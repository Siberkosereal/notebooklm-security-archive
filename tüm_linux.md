###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 21. Ders 76 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Bu bölüm içerisinde ağ hakkında çok temel düzeyde bilgi almamızı
sağlayan bazı araçlardan bahsedeceğiz. Ancak tabii ki ağ konusu başlı
başına öğrenilmesi gereken bir konu olduğu için bu bölümde ağ
temellerine değinmeyeceğiz. Eğer network konusunda temel seviye bilginiz
yoksa, mevcut platformda ağ temellerine giriş eğitimi mevcut. Bu
bölümden önce ağ temellerini öğrenmeniz, bu bölümden alacağınız verimi
kesinlikle arttıracaktır.

Bu bölümde, mevcut platformdaki "[ağ
temelleri](https://www.linuxdersleri.net/temel-network)" eğitimini
bitirdiğinizi ya da halihazırda ağ temellerini bildiğinizi varsayarak
açıklamalar yapıyor olacağım. Bu eğitim standart Linux kullanıcılarını
da kapsadığı için zaten yalnızca herkesin işine yarayabilecek bazı ağ
araçları hakkında çok kısaca bilgi ediniyor olacağız.

ping
----

`ping` komutu, ağdaki cihazların erişilebilirliğini ve tepki sürelerini
kontrol etmek için kullanılan bir araçtır. Temelde, bir cihazdan
diğerine küçük kontrol(icmp) paketleri gönderir ve bu paketlerin karşı
cihaza ne kadar sürede ulaştığını ve geri döndüğünü ölçer.

Hemen denemek için www.google.com adresine ping göndermeyi deneyelim.

**ℹ️ Not:** Biz durdurana kadar ping gönderilmeye devam edeceği için bir
noktada Ctrl + C tuşlaması ile işlemi duraklatmamız gerekiyor.

``` {.python}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ping www.google.com
PING www.google.com (216.58.212.4) 56(84) bytes of data.
64 bytes from www.google.com (216.58.212.4): icmp_seq=1 ttl=115 time=16.6 ms
64 bytes from www.google.com (216.58.212.4): icmp_seq=2 ttl=115 time=17.5 ms
64 bytes from www.google.com (216.58.212.4): icmp_seq=3 ttl=115 time=16.6 ms
64 bytes from www.google.com (216.58.212.4): icmp_seq=4 ttl=115 time=17.3 ms
64 bytes from www.google.com (216.58.212.4): icmp_seq=5 ttl=115 time=17.1 ms
^C
--- www.google.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4009ms
rtt min/avg/max/mdev = 16.638/17.020/17.450/0.330 ms
```

Çıktılara bakacak olursak, verdiğimiz www.google.com domain adresi
çözümlenip "216.58.212.4" ip adresi bulunmuş ve bu adrese küçük bir data
paketi gönderilmiş. Göndermiş olduğumuz pakete karşılık olarak da
www.google.com adresi 64 byte'lık yanıt paketleri göndermiş.

**icmp\_seq**(ICMP Sequence) kısmı, kaçıncı paket olduğunu belirtiyor.
Çıktılardan görüldüğü gibi sıralı şekilde paketler ulaştığı için paket
kaybı olmadığını anlayabiliyoruz.

**TTL**, "**t**ime **t**o **l**ive" yani "yaşam süresi" anlamına
geliyor. Hat üzerinde taşınan paket, her yönlendiriciye(router)
geldiğinde ilgili yönlendirici TTL değerini 1 azaltıp paketi bir sonraki
yönlendiriciye aktarır. Bu değer, her bir yönlendirme işleminde 1
azaltılır. Bu sayede kaç yönlendirme yapıldığı bilinebilir. Ayrıca
paketlerin döngüye girip sonsuza kadar yönlendirilerek ağ trafiği
oluşturması da önlenmiş olur. Varsayılan TTL değerleri olarak "64" "128"
"255" gibi değerlerle tanımlanabiliyor. Özellikle lokal ağdaki
yönlendirme durumlarını teşhis etmek için bu değere bakılabilir. TTL
değeri, yönlendirmeler hakkında bilgi sunuyor olsa da daha çok,
paketlerin sonsuz döngüye girmesini engelleme amacı taşıyor. Zira TTL
değeri hedef adrese ve aradaki yönlendiricilerin davranışlarına göre
değişiklik gösterebiliyor.

**time** kısmı, bu yanıtın ne kadar sürede bize ulaştığını belirtir. Bu
süre, paketin gönderilip yanıtın alınması sırasında geçen sürenin
toplamıdır. Bu sayede sunucu ile aramızdaki gecikmeyi öğrenebiliyoruz.

Sondaki çıktılarda da genel istatistikler belirtilmiş. Zaten İngilizce
olarak açıkça belirtildiği için; 5 paketin iletildiği, 5 tanesinin
hedefine ulaştığı, yüzde 0 paket kaybı olduğu ve ping işlemi sırasında
geçen süreyi çıktılarda görebiliyoruz.

Buradaki **RTT** ifadesi (**R**ound-**T**rip **T**ime), yani veri
paketlerinin gönderilip geri dönme süresini ifade ediyor. Bu satırda,
çıktılarda yer alan **time** değerlerinin en kısası, ortalaması, en
uzunu ve ortalama sapma değeri ayrıca belirtiliyor.

`ping` aracının en temel kullanımı bu şekilde. Diğer seçeneklerini
görmek için `ping —help` komutunu kullanabilirsiniz.

Örneğin kaç adet paketin gönderileceğini belirtmek için `-c` seçeneği
ile sayı belirtmemiz mümkün. Ben denemek için yalnızca **2** sayısını
belirtiyorum.

``` {.python}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ping -c 2 www.linuxdersleri.net
PING www.linuxdersleri.net (185.199.109.153) 56(84) bytes of data.
64 bytes from www.linuxdersleri.net (185.199.109.153): icmp_seq=1 ttl=56 time=16.3 ms
64 bytes from www.linuxdersleri.net (185.199.109.153): icmp_seq=2 ttl=56 time=15.6 ms

--- www.linuxdersleri.net ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 15.550/15.922/16.295/0.372 ms
```

`ping` komutu varsayılan olarak ipv4 adresleri üzerinde çalışıyor. Eğer
ipv6 adresleriyle çalışacaksanız `-6` seçeneği ile bunu özellikle
belirtmeniz gerekiyor. Elbette ipv6 adresleri üzerinde işlem yapıyorken,
internet servis sağlayıcınızın da bu adreslere destek veriyor olması
gerek.

ip Komutu
---------

`ip` komutu, ağ arayüzleri hakkında bilgi almak ve yapılandırmak için
kullanabildiğimiz çok kullanışlı bir araç. Aracımızın çok fazla seçeneği
olduğu için öncelikle sahip olduğu seçenekleri görmek için yalnızca `ip`
komutunu girelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
       ip [ -force ] -batch filename
where  OBJECT := { address | addrlabel | amt | fou | help | ila | ioam | l2tp |
                   link | macsec | maddress | monitor | mptcp | mroute | mrule |
                   neighbor | neighbour | netconf | netns | nexthop | ntable |
                   ntbl | route | rule | sr | tap | tcpmetrics |
                   token | tunnel | tuntap | vrf | xfrm }
       OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |
                    -h[uman-readable] | -iec | -j[son] | -p[retty] |
                    -f[amily] { inet | inet6 | mpls | bridge | link } |
                    -4 | -6 | -M | -B | -0 |
                    -l[oops] { maximum-addr-flush-attempts } | -br[ief] |
                    -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |
                    -rc[vbuf] [size] | -n[etns] name | -N[umeric] | -a[ll] |
                    -c[olor]}
```

Burada komutun temel kullanım şablonu açıklanmış. `ip` komutundan sonra
ilgili seçeneği ve objeyi belirtebiliyoruz. Seçeneklerin ve objelerin
yani aslında `ip` aracıyla yönetebileceğimiz nesnelerin hangileri olduğu
da bu çıktılarda gözüküyor.

Sistemimize bağlı bulunan ağ arayüzleri hakkında bilgi almak için `ip a`
ya da `ip addr` ya da uzun şekilde `ip address` şeklinde komutumuzu
girebiliriz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0
       valid_lft 83519sec preferred_lft 83519sec
    inet6 fe80::a00:27ff:fe95:bd54/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Eğer ağ arayüzleri tarafından gerçekleştirilen paket transferleri
hakkında bilgi edinmek istersek `-s a` seçeneğini ekleyebiliriz.
Buradaki `-s` seçeneği detaylı bilgi için istatistikleri(**s**tatistics)
verirken, a(**a**ddress) parametresi, ağ arayüzlerini temsil etmek için
ekleniyor. Bunun yerine `-s addr` `-s address` gibi uzun uzadıya
yazmanız da mümkün.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip -s a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
    RX:  bytes packets errors dropped  missed   mcast           
             0       0      0       0       0       0 
    TX:  bytes packets errors dropped carrier collsns           
             0       0      0       0       0       0 
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0
       valid_lft 85199sec preferred_lft 85199sec
    inet6 fe80::f856:4192:4810:8e2c/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
    RX:  bytes packets errors dropped  missed   mcast           
          3908      44      0       0       0      24 
    TX:  bytes packets errors dropped carrier collsns           
          3373      34      0       0       0       0
```

Buradaki çıktılarda yer alan "lo" ifadesi localhost ya da local loopback
olarak bilinen ağ arayüzünü temsil ediyor. Bu arayüz, sayesinde mevcut
cihazın kendi kendine ağ trafiği oluşturması ve işlemesi mümkün oluyor.
Bu sayede örneğin bir websitesi geliştirirken gerçek ağ trafiği olmadan
uygulamanın nasıl çalıştığını test edebiliyoruz. Ayrıca sistem
üzerindeki pek çok araç da lokal adrese benzer sebeplerle ihtiyaç
duyuyor.

İkinci ağ arayüzü olan "eth0" ise ethernet bağlantısını temsil eden ağ
arayüzüdür. Ben modemime, ethernet kartıma bağlı olan kablo ile bağlı
olduğum için ağ trafiğimi "eth0" olarak temsil edilen "ethernet arayüzü"
üzerinden sağlıyorum.

Eğer sistemime Wi-Fi aygıtı bağlı olsaydı "wlan0" ağ arayüzünü de bu
çıktılarda görüyor olacaktım. Bu durumu teyit etmek için sistemime Wifi
adaptörünü bağladıktan sonra tekrar `ip a` komutunu giriyorum.

``` {.sql}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ip a                                                                                                                                                 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.15/24 brd 192.168.1.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::e1f0:e5b2:f52:f244/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
3: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 5e:ba:fb:fb:58:23 brd ff:ff:ff:ff:ff:ff permaddr d4:6e:0e:02:0e:0d
```

Bakın bu kez wlan0 arayüzü de eklenmiş oldu. İsimlendirme sayesinde
hangi tür ağ arayüzü olduğunu ve kaçıncı ağ arayüzü olduğunu da
rahatlıkla görebiliyoruz. Buradaki "eth" ve "wlan" ifadeleri arayüz
tipini belirtiyorken, bitişik şekilde yazılan sayılar ise kaçıncı ağ
arayüzü olduğunu belirtiyor. Örneğin benim sistemimde 3 tane ethernet ağ
kartı(network interface card) bağlı olsaydı buradaki çıktılarda "eth0",
"eth1" ve "eth2" şeklinde sırasıyla isimlendirilmiş ethernet
arayüzlerini görecektik.

Ayrıca örneğin Red Hat tabanlı dağıtımlar üzerinde bu ağ arayüzü
isimlendirmesi biraz daha farklı. Hemen görmek için `ip a` komutunu
Rocky Linux üzerinde girelim.

``` {.sql}
[pc@linuxdersleri ~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:ce:11:be brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.12/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s3
       valid_lft 85424sec preferred_lft 85424sec
    inet6 fe80::a00:27ff:fece:11be/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
4: wlp0s11u1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000
    link/ether 8e:ef:cc:44:7f:e2 brd ff:ff:ff:ff:ff:ff permaddr d4:6e:0e:02:0e:0d
[pc@linuxdersleri ~]$
```

**Lokal adres** yine "**lo**" şeklinde belirtiliyorken, **ethernet**
arayüzü "**enp0s3**" şeklinde isimlendirilmiş ve **wi-fi** arayüzü ise
"**wlp0s11u1**" şeklinde isimlendirilmiş. Yine de çıktılara baktığımızda
"**enp**" ile başlayanın **ethernet** arayüzünü, "**wlp**" ile
başlayanın ise **wi-fi** arayüzünü temsil ettiğini ve bitişiğindeki ilk
sayının ise kaçıncı ağ arayüzü olduğunu belirttiğini rahatlıkla
anlayabiliyoruz.

Neticede `ip a` komutu sayesinde ağ arayüzleri hakkında gerekli olan
temel bilgileri öğrenebiliyoruz.

Ağ Arayüzlerini Açıp Kapatmak \| UP DOWN
----------------------------------------

Dilersek bu ağ arayüzlerini kapatıp açmamız da mümkün. Üzerinde işlem
yapmak istediğimiz arayüzü `ip link set` komutundan sonra yazıp, yapmak
istediğimiz işlemi belirtebiliriz. Ben öncelikle **ethernet** arayüzünü
kapatmak istiyorum. Bunun için `sudo ip link set eth0 down` komutunu
giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo ip link set eth0 down
[sudo] password for taylan: 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ip address                                                                                                                          
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
```

Gördüğünüz gibi **ethernet** bağlantısını temsil eden **eth0**
arayüzünün **state** yani durumu **DOWN** olarak gözüküyor.

Şimdi kapatmış olduğumuz ağ arayüzünü tekrar aktifleştirmek üzere bu kez
`up` seçeneğini kullanalım.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo ip link set eth0 up

┌──(taylan㉿linuxdersleri)-[~]
└─$ ip address                                                                                                                                
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0
       valid_lft 86398sec preferred_lft 86398sec
    inet6 fe80::a00:27ff:fe95:bd54/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Bakın `sudo ip link set eth0 up` komutu sayesinde **eth0** arayüzünü
tekrar **aktifleştirmiş** oldum.

Yönlendirici Adresini Öğrenmek \| route
---------------------------------------

Sistemin yönlendirme tablosu hakkında bilgi almak için `ip route`
komutunu kullanabiliyoruz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip route                                                                                                                                                
default via 192.168.1.1 dev eth0 proto dhcp metric 100 
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.11 metric 100
```

Bu çıktılarda, **eth0** ağ arayüzünün **192.168.1.1** adresini
**getway** olarak kullandığını belirtiyor. Ayrıca **192.168.1.0/24**
adresinin **ağ adresi** olduğunu, **eth0** arayüzünün ise **192.168.1.11
ip adresine sahip** olduğu belirtiliyor.

Yani böylelikle 192.168.1.0/24 ağında 192.168.1.11 ip adresine sahip bir
ethernet bağlantısına sahip olduğumu ve harici bir ağ ile iletişime
geçmem gerektiğinde default getway olan 192.168.1.1 ip adresine sahip
router ile iletişim kurulduğunu buradaki çıktılara bakarak
anlayabiliyorum.

Neticede `ip` aracı sayesinde ağ ve ağ arayüzleri hakkında gerekli olan
pek çok bilgiye erişmemiz mümkün oluyor. Üstelik `ip` aracını yalnızca
bilgi almak için değil, bizzat ip ve route gibi bilgileri düzenlemek
için de kullanabiliyoruz. Yani yeni ip adresleri veya
yönlendirme(routing) bilgileri ekleyip kaldırmamız mümkün. **Fakat ip
aracı ile gerçekleştirilecek olan bu değişiklikler sistem ya da ağ
arayüzü yeniden başlatıldığında sıfırlanmış oluyor**. Bu sebeple kalıcı
değişimler için alternatif araçlar tercih ediliyor.

Temelde `ip` aracının kullanımı bu şekilde.

nmcli \| nmtui
--------------

`nmcli` ifadesi "**n**etwork **m**anager **c**ommand **l**ine
**i**nterface" kısaltmasından geliyor. Ve ağ ile ilgili düzenlemeleri
komut satırı üzerinden gerçekleştirebilmemizi sağlıyor. Ayrıca `nmtui`
isimli alternatif sayesinde de yine komut satırı üzerinden ama bu kez
görsel bir arayüzü bulunan araç ile temel ağ ayarlarını düzenlememiz
mümkün oluyor. `nmtui` ifadesi "**n**etwork **m**anager **t**erminal
**u**ser **i**nterface" ifadesinin kısaltmasından geliyor. Her iki araç
da **systemd** tarafından sağlanan "**NetworkManager**" servisinin
yönetilmesini sağlıyor.

Temel ağ konfigürasyonları için son derece yeterli ve kolay
kullanılabilir olduğu için biz `nmtui` aracını ele alalım.

Aracı çalıştırmak için konsola `nmtui` komutunu girelim.

![nmtui.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui.webp)

Araç ilk açıldığında "ağ konfigürasyonlarını düzenleme", "ağ
arayüzlerini aktifleştirme" ve sistemin "hostname bilgisini tanımlama"
seçenekleri sunuyor. Öncelikle **ağ bağlantısını konfigüre etme**
seçeneği ile devam edelim.

![nmtui-connection.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection.webp)

Burada bağlı olduğum ağ arayüzü gözüküyor. Benim sistemimde şu an
yalnızca ethernet bağlı bulunduğu için yalnızca ethernet var. Eğer yeni
bir bağlantı türü eklemek istersem, klavyemdeki yön tuşlarını
kullanarak, sağ taraftaki **Add** seçeneğinin üstüne gelip enter ile
onaylayabilirim.

![nmtui-connection-add.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-add.webp)

Buradaki listeden, hangi türde bağlantı tanımlanacaksa onu seçip gerekli
konfigürasyonları gerçekleştirmemiz mümkün. Örneğin Wi-Fi bağlantısı
gerçekleştirilecekse, bu seçenek seçilip, gerekli aygıt ve ağ
bilgilerinin tanımlanması mümkün.

![nmtui-connection-add-wifi.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-add-wifi.webp)

Değişiklikleri kaydetmek için **OK** seçeneğinin üstüne gelip enter ile
onaylamanız yeterli. Eğer değişiklikleri kaydetmek istemiyorsanız
**Cancel** seçeneğini enter ile onaylayabilirsiniz. Ayrıca esc tuşu ile
de değişiklikleri iptal edip bir önceki menüye hızlıca dönmeniz mümkün.

Yeni ağ bağlantısı tanımlamak yerine mevcut olan bağlantıyı konfigüre
etmek istersek, ilgili bağlantının üstündeyken enter ile veya menüdeki
**Edit** seçeneğine enter ile tıklayabiliriz.

![nmtui-connection-edit.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-edit.webp)

Düzenleme penceresi üzerinde, ilgili bağlantının türüne göre
tanımlayabileceğimiz seçenekler gözüküyor. Örneğin ben ethernet
bağlantısındaki IPv4 ip adreslerinin otomatik olarak alınması yerine
kendim elle girmek istersem, bu seçeneği değiştirmek üzere enter ile
seçeneğe tıklayabilirim.

![nmtui-connection-edit-ipv4.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-edit-ipv4.webp)

IP adresini elle girmek istediğim için "**Manual**" seçeneğini
seçebilirim. Bu seçimin ardından konfigürasyon ayrıntıları için sağ
taraftaki "**Show**" seçeneğine de tıklamamız gerek.

![nmtui-connection-edit-ipv4-manual.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-edit-ipv4-manual.webp)

Artık buradan istediğim ip bilgilerini girmem mümkün. Bu değişimleri
onaylamak için "**OK**" seçeneğinin üstüne gelip enter ile onaylamamız
gerek. Daha sonra ağ arayüzünü kapatıp tekrar açtığımızda bu değişimler
de gerçekleşmiş olacak. Ağ arayüzünü açıp kapatmak için de menüye dönüp
buradan "**Activate a connection**" seçeneğine tıklamamız gerek.

![nmtui-connection-activate.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-activate.webp)

Buradan ilgili bağlantıya enter ile tıkladığınızda aktif ise pasif,
pasif ise aktif forma geçecektir. Yani buradan, ilgili ağ arayüzünü açıp
kapatmanız mümkün.

![nmtui-connection-activate-on-off.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-connection-activate-on-off.webp)

hostname bilgisini yani cihazın ağ üzerindeki ismini değiştirmek
isterseniz ana menüden "**Set system hostname**" seçeneğine
tıklayabilirsiniz.

![nmtui-hostname.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-hostname.webp)

Buradan dilediğiniz bir hostname bilgisi girip "**OK**" ile
onaylayabilirsiniz.

**⚠️ Dikkat:** Ben menüde yer aldığı için burada hostname değişiminden
bahsediyorum fakat sizin şu an hostname bilgisini değiştirmenizi
kesinlikle önermiyorum. Çünkü hostname değişimi için uygulanması gereken
ek konfigürasyonlar da mevcut. İleride hostname konusundan ayrıca
bahsettiğimizde daha bilinçli şekilde değişim yapabiliyor olacaksınız.
Ben burada yalnızca bir alternatif olduğu için bu değişimden
bahsediyorum fakat şimdilik siz hostname bilgisini değiştirmeyin. Aksi
halde sistem yönetimi noktasında sorun yaşamanız kaçınılmaz olur.

![nmtui-hostname-set.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-hostname-set.webp)

Hostname değişimi sırasında, yetkili olduğunuzu kanıtlamanız için parola
bilgisi istenebilir. Değişim için parolanızı girin.

![nmtui-hostname-set-passwd.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-hostname-set-passwd.webp)

Son olarak tüm işlerinizi bitirdiğinizde aracı kapatmak üzere "**Quit**"
seçeneğinin üstüne gelip enter ile aracı kapatabilirsiniz.

![nmtui-quit.png](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-quit.webp)

İhtiyaç duyabileceğiniz temel ağ konfigürasyonları için `nmtui` son
derece kullanışlı bir araç.

Eğer benzer konfigürasyonları komut satırı üzerinden gerçekleştirmek
isterseniz `nmcli` aracını da kullanabilirsiniz. Fakat temel kullanımda
`nmtui` çok daha kolay olduğu için daha çok tercih ediliyor. `nmcli`
aracını kullanmak istiyorsanız, temel seçenekler için yardım sayfasına
göz atabilirsiniz.

Burada gerçekleştirilen tüm konfigürasyonlar
***/etc/NetworkManager/system-connections/*** dizini altında, ilgili ağ
arayüzünü temsil eden konfigürasyon dosyasında tutuluyor. Ben Debian ve
Redhat tabanlı dağıtımlarda bu içeriğe göz atıp aşağıya ekledim.

**Debian:**

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]                                                                                                                             
└─$ sudo cat /etc/NetworkManager/system-connections/Ethernet\ connection\ 1.nmconnection                                                                   
[connection]                                                                                                                                               
id=Ethernet connection 1                                                                                                                                   
uuid=0ba239d3-24c0-4511-87d6-749b381231a4                                                                                                                  
type=ethernet                                                                                                                                              
permissions=                                                                                                                                               
timestamp=1693291090                                                                                                                                       
                                                                                                                                                           
[ethernet]
mac-address-blacklist=

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto

[proxy]
```

**RedHat:**

``` {.ini}
[root@linuxdersleri ~]# cat /etc/NetworkManager/system-connections/enp0s3.nmconnection 
[connection]
id=enp0s3
uuid=ebbc2f9d-0363-3da7-ab54-11479d0c8546
type=ethernet
autoconnect-priority=-999
interface-name=enp0s3
timestamp=1678973669

[ethernet]

[ipv4]
method=auto

[ipv6]
addr-gen-mode=eui64
method=auto

[proxy]
```

Bu sayede sistem başlangıcında, buradaki konfigürasyonlar dahilinde ağ
ayarları kullanıma hazır hale getiriliyor. Bu sebeple sistem üzerinde ağ
ile ilgili çeşitli özellikleri barındıran konfigürasyon dosyalarında
manuel olarak değişim yapıp, sistemi yeniden başlatacak olursak bu
değişimler silinmiş olacak. Dolayısıyla **NetworkManager** ile
gerçekleştirebileceğiniz işlerinizi `nmcli` veya `nmtui` gibi araçlar
yardımıyla gerçekleştirmeniz çok daha doğru bir yaklaşım olacaktır.

Örneğin ileride DNS bilgisinin tutulduğu ***/etc/resolv.conf***
dosyasından bahsedeceğiz. Bu dosyada elle değişim yaparsanız, sistemi
yeniden başlattığınızda yine **NetworkManager** tarafından tanımlanmış
olan konfigürasyonlar geçerli olacak. Bu sebeple, kalıcı olmasını
istediğiniz değişimler için `nmcli` veya `nmtui` araçlarını
kullanmalısınız.

SSH
---

SSH, "**s**ecure **sh**ell" ifadesinin kısaltmasından geliyor. SSH
sayesinde uzaktaki sunuculara güvenli şekilde bağlanıp sunucuları
yönetmemiz mümkün oluyor.

SSH kullanabilmek için sunucular üzerinde ssh servisinin aktif olması
gerekiyor. Aktif olma durumunu kontrol etmek için
`systemctl status ssh.service` komutunu girelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status ssh.service                                                                                                                           
○ ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)
     Active: inactive (dead)
       Docs: man:sshd(8)
             man:sshd_config(5)
```

Şu anda benim sistemimde ssh servisi aktif değil. Aktifleştirmek üzere
`systemctl start ssh.service` komutunu girip, yönetici parolası ile
işlemi onaylayalım.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status ssh.service                                                                                                                           
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)
     Active: active (running) since Tue 2023-08-22 11:56:07 EDT; 1s ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 23362 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 23363 (sshd)
      Tasks: 1 (limit: 12719)
     Memory: 2.2M
        CPU: 29ms
     CGroup: /system.slice/ssh.service
             └─23363 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"

Aug 22 11:56:07 linuxdersleri systemd[1]: Starting OpenBSD Secure Shell server...
Aug 22 11:56:07 linuxdersleri sshd[23363]: Server listening on 0.0.0.0 port 22.
Aug 22 11:56:07 linuxdersleri sshd[23363]: Server listening on :: port 22.
Aug 22 11:56:07 linuxdersleri systemd[1]: Started OpenBSD Secure Shell server.
```

SSH servisini başlatmış olduk. Artık ssh ile bu sunucuya bağlanmamız
mümkün. Ben denemek için aynı lokal ağda bulunan Windows makinesi
üzerinden, Linux sunucuma bağlantı gerçekleştireceğim. Bunun için
Windows powershell aracını çalıştırıp `ssh kullanıcı-adı@sunucu-ip`
şeklinde komutumu girmem gerek. SSH bağlantısı için "putty" gibi çeşitli
alternatif araçları da kullanabiliyoruz fakat ben Windows powershell
tercih ediyorum. Sunucuya bağlanabilmek için öncelikle sunucunun ip
adresini biliyor olmamız gerek. Ben öğrenmek için Linux makineme `ip a`
komutunu giriyorum.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip a                                                                                                                                                   
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:95:bd:54 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0
       valid_lft 83058sec preferred_lft 83058sec
    inet6 fe80::5acb:6b00:3372:dcfc/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Benim sunucumun lokal ağdaki ip adresi "**192.168.1.11**" şeklinde
gözüküyor. Bu sebeple ben de "**taylan**" kullanıcı hesabında oturum
açmak üzere `ssh taylan@192.168.1.11` komutunu powershell üzerinden
giriyorum.

``` {.vbnet}
ssh taylan@192.168.1.11
The authenticity of host '192.168.1.11 (192.168.1.11)' can't be established.
ED25519 key fingerprint is SHA256:5bgjOGZMfMpfFhTRv8jTYWq2dCdHA5dVmYb3OCeU6g4.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

Taraflar arasında ilk kez bağlantı kurulduğu için, bağlantıyı
şifrelemeyi sağlayan anahtar hakkında bilgi sunuluyor. Bu anahtar benim
Windows sistemimde kayıtlı olan bir anahtar olmadığı için bağlantıya
güvenme konusunda benden onay bekleniyor. Ben emin olduğum için "yes"
ile onaylıyorum.

``` {.vbnet}
? yes
Warning: Permanently added '192.168.1.11' (ED25519) to the list of known hosts.
taylan@192.168.1.11's password:
```

Anahtarı kabul ettikten hemen sonra "taylan" olarak oturum açabilmem
için taylan kullanıcı hesabının parolasını girmem bekleniyor. Ben taylan
kullanıcısının parolasını giriyorum.

``` {.vbnet}
taylan@192.168.1.11's password:
Linux linuxdersleri 5.15.0-kali3-amd64 #1 SMP Debian 5.15.15-2kali1 (2022-01-31) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Mon Aug 21 02:52:28 2023
┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Parolamı doğru yazdığım için Linux sunucusu üzerindeki taylan kullanıcı
hesabında, Windows powershell üzerinden oturum açmış oldum. Teyit etmek
için `whoami` komutunu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ whoami
taylan
```

Gördüğünüz gibi "taylan" çıktısını aldım yani taylan kullanıcı hesabında
oturum açtığımı bir kez daha teyit etmiş oldum.

Artık böylelikle Windows üzerinden güvenli şekilde Linux makinemi
kontrol edebilirim. Aramızdaki tüm bağlantı şifrelendiği için veri
trafiğini izleyen hiç kimse trafiği analiz etme noktasında güvenlik
riski oluşturamaz.

İşte bu yöntem sayesinde fiziksel olarak yanında olmamıza gerek
kalmadan, sunuculularımızı uzaktan herhangi bir cihaz ile
yönetebiliyoruz. Örneğin telefonunuz üzerinden de sunucunuza SSH
bağlantısı gerçekleştirebilirsiniz.

Sunucuda işiniz bittiğinde `exit` komutu ile mevcut kabuğu kapatmak
suretiyle ssh bağlantısını sonlandırabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ exit
logout
Connection to 192.168.1.11 closed.
```

SSH bağlantısının en temel kullanımı bu şekilde. SSH konusunda "anahtar
yönetimi" ve "güvenlik sıkılaştırmaları" gibi ek detaylar mevcut fakat
temel eğitim için ele aldığımız bilgiler yeterli.

Pek çok araç SSH sayesinde güvenli şekilde işlevlerini yerine
getirebiliyor. Yani ssh kullanımı yalnızca burada ele aldığımız şekilde
karşımıza çıkmıyor. Örneğin sunucular arasında güvenli şekilde dosya
kopyalamak üzere ssh protokolünden yararlanan `scp` aracını
kullanabiliyoruz.

scp
---

`scp` , "**S**ecure **C**opy **P**rotocol" ifadesinin kısaltmasından
gelen ve dosyaları güvenli bir şekilde SSH (Secure Shell) üzerinden
kopyalamak için kullanılan bir araçtır. Ben denemek için Debian tabanlı
bir dağıtım olan Kali Linux üzerinden, Redhat tabanlı Rocky Linux
dağıtımına bir dosya göndereceğim.

Bunun için öncelikle Rocky Linux dağıtımının lokal ağdaki ip adresini
öğrenmek üzere `ip a` komutunu giriyorum.

``` {.sql}
[pc@linuxdersleri ~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:ce:11:be brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.12/24 brd 192.168.1.255 scope global dynamic noprefixroute enp0s3
       valid_lft 85961sec preferred_lft 85961sec
    inet6 fe80::a00:27ff:fece:11be/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
[pc@linuxdersleri ~]$
```

IP adresini öğrendim.

SSH servisinin aktif olup olmadığını da kontrol edelim. Zira
bağlanacağımız Rocky Linux sisteminde ssh aktif olmazsa iletişim
kurmamız mümkün olmaz. ssh servisi, Redhat üzerinde "**sshd**" olarak
geçiyor.

``` {.yaml}
[pc@linuxdersleri ~]$ systemctl status sshd.service 
● sshd.service - OpenSSH server daemon
     Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
     Active: active (running) since Tue 2023-08-22 19:26:40 +03; 2min 26s ago
       Docs: man:sshd(8)
             man:sshd_config(5)
   Main PID: 864 (sshd)
      Tasks: 1 (limit: 23069)
     Memory: 3.1M
        CPU: 37ms
     CGroup: /system.slice/sshd.service
             └─864 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"
[pc@linuxdersleri ~]$
```

SSH servisi de aktif olduğuna göre son olarak göndermek istediğim
dosyayı Kali Linux üzerinde oluşturmak istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo "ben kali linux" > kali-linux.txt

┌──(taylan㉿linuxdersleri3)-[~]
└─$ cat kali-linux.txt                                                                                                                                     
ben kali linux
```

Tamamdır, şimdi
`scp gönderilecek-dosya kullanıcı-adı@ip:hedef-dosya-yolu` şeklinde
komutumuzu girebiliriz. Ben mevcut bulunduğum dizindeki
"***kali-linux.txt***" dosyasını, Rocky Linux sistemindeki
***/home/pc/Desktop/*** dizinine göndereceğim.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ scp ./kali-linux.txt pc@192.168.1.12:/home/pc/Desktop/kaliden-gelen.txt                                                                               
The authenticity of host '192.168.1.12 (192.168.1.12)' can't be established.
ED25519 key fingerprint is SHA256:wkc7gaEfQ4X72cDnzhTSg5TX/OsYaeRJCLvLx26HdyA.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

Bağlantı sağlayacağım makinenin şifreleme anahtarı, mevcut makinede
kayıtlı olmadığı için bu anahtara güvenilsin mi diye soruluyor. Ben
"yes" ile onaylıyorum.

``` {.css}
pc@192.168.1.12's password: 
kali-linux.txt             100%   15     1.3KB/s   00:00
```

Hedefteki kullanıcı hesabının parolasını doğru girdiğim için gördüğünüz
gibi ilgili dosya hedefteki makineye taşınmış oldu. Teyit etmek için
Rocky Linux üzerinden bu dosyayı okumayı deneyebiliriz.

``` {.ruby}
[pc@linuxdersleri ~]$ cat ~/Desktop/kaliden-gelen.txt 
ben kali linux
```

Bakın dosya güvenli şekilde hedefe taşınmış oldu. Bu yaklaşımı,
dilediğiniz dosya türü ve boyutunda uygulayabilirsiniz.

Ayrıca mevcut makinden hedef makineye gönderilebileceği gibi, hedefteki
makineden mevcut makineye de dosya çekilebilir.

Denemek üzere öncelikle Rocky Linux üzerinde bir dosya oluşturalım.

``` {.ruby}
[pc@linuxdersleri ~]$ echo "ben rocky linux" > rocky-linux.txt
[pc@linuxdersleri ~]$ cat rocky-linux.txt 
ben rocky linux
[pc@linuxdersleri ~]$ pwd
/home/pc
```

Tamamdır, şimdi bu dosyayı Kali Linux sistemine çekmek üzere komutumuzu
girelim. Bunun için; hedefteki kullanıcı adı ve ip adresiyle birlikte
hangi dosya alınacaksa tam olarak o dosyanın konumu belirtilir. Ve bu
dosyanın mevcut makinede hangi dizine kopyalanacağı da tam dizin yolu
olarak belirtilir.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ scp pc@192.168.1.12:/home/pc/rocky-linux.txt /home/taylan/rocky-linuxtan-gelen.txt
pc@192.168.1.12's password: 
rocky-linux.txt                                                                                                          100%   16     4.1KB/s   00:00    

┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /home/taylan/rocky-linuxtan-gelen.txt 
ben rocky linux
```

Gördüğünüz gibi mevcut makineye, hedef makineden dosya çekmeyi başarmış
olduk.

wget
----

`wget`, "**w**eb **get**" ifadesinin kısaltmasından gelen, URL üzerinden
dosya indirmeyi mümkün kılan bir araçtır. Ben örnek olması için Linux
Dersleri dokümantasyon kaynağı olan Github reposundaki ***README***
dosyasını bilgisayarıma indirmek istiyorum. Bunun için `wget` komutundan
sonra indirmek istediğim dosyayı barındıran URL adresini eklemem
yeterli.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ wget https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/README.md                                                                    
--2023-08-22 13:18:30--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/README.md
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.110.133, 185.199.109.133, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 9929 (9.7K) [text/plain]
Saving to: ‘README.md’

README.md                              100%[===========================================================================>]   9.70K  --.-KB/s    in 0.002s  

2023-08-22 13:18:30 (4.89 MB/s) - ‘README.md’ saved [9929/9929]

┌──(taylan㉿linuxdersleri)-[~]
└─$ cat README.md 
# Doküman Hakkında
<img align="left" width="250" height="140" src="https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/Ana%20Sayfa/linux-logo.webp">Buradaki doküman videolu eğitim olarak ele aldığımız [Kali Linux ile Sıfırdan Temel Linux Eğitimi](https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2)'nin komut satırı dersleri dokümantasyon kaynağıdır. Bu eğitim serisi, Linux sistemlerini nasıl yönetebileceğimizi sıfırdan başlayarak sıralı şekilde ele aldığımız temel konu anlatımlarından oluşturulmuştur. Müfredat ve daha fazla bilgi için aşağıdaki bilgileri gözden geçirebilirsiniz.
```

Herhangi bir ek seçenek kullanmadığımızda ilgili dosya, çalışmakta
olduğumuz mevcut dizine aynı isimle indiriliyor gördüğünüz gibi. Eğer
dosyayı farklı bir isimle veya farklı bir dizine kaydetmek istersek `-O`
seçeneğini kullanabiliyoruz. Zaten "**o**utput" ifadesinin
kısaltmasından geldiği için kolay hatırlanması olası. Ben denemek için
aynı dosyayı bu kez "***OKUBENI***" ismi ile
***/home/taylan/Documents/*** dizini altına indirmek istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ wget https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/README.md -O /home/taylan/Documents/OKUBENI
--2023-08-22 13:27:49--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/README.md
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.109.133, 185.199.108.133, 185.199.111.133, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.109.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 9929 (9.7K) [text/plain]
Saving to: ‘/home/taylan/Documents/OKUBENI’

/home/taylan/Documents/OKUBENI         100%[===========================================================================>]   9.70K  --.-KB/s    in 0.001s  

2023-08-22 13:27:54 (7.49 MB/s) - ‘/home/taylan/Documents/OKUBENI’ saved [9929/9929]

┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /home/taylan/Documents/OKUBENI 
# Doküman Hakkında
<img align="left" width="250" height="140" src="https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/Ana%20Sayfa/linux-logo.webp">Buradaki doküman videolu eğitim olarak ele aldığımız [Kali Linux ile Sıfırdan Temel Linux Eğitimi](https://www.udemy.com/course/kali-linux-ile-sifirdan-temel-linux-egitimi/?referralCode=04ABD09E6ED5DA93F7A2)'nin komut satırı dersleri dokümantasyon kaynağıdır. Bu eğitim serisi, Linux sistemlerini nasıl yönetebileceğimizi sıfırdan başlayarak sıralı şekilde ele aldığımız temel konu anlatımlarından oluşturulmuştur. Müfredat ve daha fazla bilgi için aşağıdaki bilgileri gözden geçirebilirsiniz.
```

Tam olarak istediğim dizine istediğim isimde kaydedilmiş oldu.

`wget —help` komutunun çıktılarına göz atarak bizzat görebileceğiniz
gibi `wget` aracının pek çok ek seçeneği mevcut. Fakat tek tek hepsine
değinmemiz gerekmiyor. Zira ihtiyaç duydukça zaten yardım sayfasına göz
atıyor olacaksınız. Örneğin toplu şekilde dosya indirmek istediğinizde
bu dosyaların linklerini bir dosya içinde toplayıp, bu dosyayı `wget`
aracına `-i` seçeneği ile "**i**nput" yani girdi olarak verebilirsiniz.
Ben denemek için alt alta birden fazla URL barındıran bir input dosyası
oluşturuyorum.

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat > indirilecekler.txt
https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/dok%C3%BCmantasyonlar/linux_nedir.md
https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/dok%C3%BCmantasyonlar/Linux_dosya_sistemi_hiyerar%C5%9Fisi.md
https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/1.webp
https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/4.gif
https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/5.webp
```

Şimdi bu dosyaları tek seferde indirmek üzere
`wget -i indirilecekler.txt` şeklinde komutumu girmem yeterli. Eğer
harici bir dizin belirtmezsem mevcut bulunduğumuz dizin altına
indirileceklerini biliyorsunuz. Ben ***Documents*** dizini altına
indirilmesini istediğim için komutuma bir de `-P` seçeneğini de
ekliyorum. `P` seçeneği hedef dizini belirtmeyi sağlayan bir seçenek.
`-O` seçeneği tek bir dosyanın ismini belirtmeyi sağlarken, `-P`
seçeneği sayesinde kaydedilecek dizini belirtebiliyoruz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ wget -i indirilecekler.txt -P ~/Documents/
--2023-08-22 13:43:37--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/dok%C3%BCmantasyonlar/linux_nedir.md
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.110.133, 185.199.111.133, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 30950 (30K) [text/plain]
Saving to: ‘/home/taylan/Documents/linux_nedir.md’

linux_nedir.md                         100%[===========================================================================>]  30.22K  --.-KB/s    in 0s      

2023-08-22 13:43:41 (124 MB/s) - ‘/home/taylan/Documents/linux_nedir.md’ saved [30950/30950]

--2023-08-22 13:43:41--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/dok%C3%BCmantasyonlar/Linux_dosya_sistemi_hiyerar%C5%9Fisi.md
Reusing existing connection to raw.githubusercontent.com:443.
HTTP request sent, awaiting response... 200 OK
Length: 20984 (20K) [text/plain]
Saving to: ‘/home/taylan/Documents/Linux_dosya_sistemi_hiyerarşisi.md’

Linux_dosya_sistemi_hiyerarşisi.md     100%[===========================================================================>]  20.49K  --.-KB/s    in 0.004s  

2023-08-22 13:43:41 (4.67 MB/s) - ‘/home/taylan/Documents/Linux_dosya_sistemi_hiyerarşisi.md’ saved [20984/20984]

--2023-08-22 13:43:41--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/1.webp
Reusing existing connection to raw.githubusercontent.com:443.
HTTP request sent, awaiting response... 200 OK
Length: 106442 (104K) [image/png]
Saving to: ‘/home/taylan/Documents/1.webp’

1.webp                                  100%[===========================================================================>] 103.95K  --.-KB/s    in 0.03s   

2023-08-22 13:43:41 (3.75 MB/s) - ‘/home/taylan/Documents/1.webp’ saved [106442/106442]

--2023-08-22 13:43:41--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/4.gif
Reusing existing connection to raw.githubusercontent.com:443.
HTTP request sent, awaiting response... 200 OK
Length: 448808 (438K) [image/gif]
Saving to: ‘/home/taylan/Documents/4.gif’

4.gif                                  100%[===========================================================================>] 438.29K  --.-KB/s    in 0.09s   

2023-08-22 13:43:42 (4.57 MB/s) - ‘/home/taylan/Documents/4.gif’ saved [448808/448808]

--2023-08-22 13:43:42--  https://raw.githubusercontent.com/taylanbildik/Linux_Dersleri/master/img/4%20-Linux%20Dosya%20Sistemi%20Hiyerar%C5%9Fisi/5.webp
Reusing existing connection to raw.githubusercontent.com:443.
HTTP request sent, awaiting response... 200 OK
Length: 56666 (55K) [image/png]
Saving to: ‘/home/taylan/Documents/5.webp’

5.webp                                  100%[===========================================================================>]  55.34K  --.-KB/s    in 0.01s   

2023-08-22 13:43:42 (5.23 MB/s) - ‘/home/taylan/Documents/5.webp’ saved [56666/56666]

FINISHED --2023-08-22 13:43:42--
Total wall clock time: 5.4s
Downloaded: 5 files, 648K in 0.1s (4.67 MB/s)

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls ~/Documents/
1.webp  4.gif  5.webp  linux-dersleri  Linux_dosya_sistemi_hiyerarşisi.md  linux_nedir.md  OKUBENI
```

İşte toplu dosya indirme işlemi de bu şekilde. Temel kullanım için
`wget` aracının bu kadarlık seçeneğini bilmek de gayet yeterli. Yine de
dilerseniz `wget` aracının diğer seçenekleri için yardım sayfasına göz
atabilirsiniz.

DNS Hakkında
------------

Biz özellikle aksini belirtmediğimiz sürece DNS sorguları için router
görevini üstelenmiş olan modem cihazının ip adresi kullanılıyor. Bu
sayede internet servis sağlayıcısının sunduğu DNS hizmeti vasıtası ile
domain adreslerinin ardındaki ip adreslerini öğrenebiliyoruz. Öncelikle
bu durumu teyit etmek üzere `nslookup` komutu ile herhangi bir domain
için adres çözümlemeyi deneyelim. `nslookup` aracı, ilgili domain
adresinin hangi ip adresine işaret ettiğinin bilgisini verirken, bu
bilginin hangi DNS sunucusu sayesine alındığını da belirtiyor. Bu sayede
mevcut sistemdeki DNS konfigürasyonunu tespit edebiliyoruz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ nslookup www.google.com
Server:         192.168.1.1
Address:        192.168.1.1#53

Non-authoritative answer:
Name:   www.google.com
Address: 142.251.140.4
Name:   www.google.com
Address: 2a00:1450:4017:80f::2004
```

Gördüğünüz gibi www.google.com adresinin ip adresi çözümlenmiş oldu.
Çıktıların başında, bu sorgunun 192.168.1.1 adresindeki DNS hizmeti
sayesinde gerçekleştirilmiş olduğunu da görebiliyoruz. Ayrıca buradaki
"\#53" tanımı da, bu sorgunun gerçekleştirildiği port numarasını
belirtiyor. DNS sunucuları varsayılan olarak 53 numaraları porttan
sorgulama istekleri aldığı için bu çıktıyı aldık. Yani DNS hizmetinin de
aslında bizim "default getway" olarak kullanılan modemimiz tarafından
sağlandığını görmüş olduk. Default getway adresinizi teyit etmek
isterseniz `ip route` komutunu girebileceğinizi biliyorsunuz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ip route
default via 192.168.1.1 dev eth0 proto dhcp metric 100 
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.11 metric 100
```

Bakın burada "**default via 192.168.1.1 dev eth0**" yazıyor. Yani benim
eth0 arayüzümün varsayılan ağ geçidi **192.168.1.1** adresi olarak
gözüküyor.

Eğer siz internet servis sağlayıcınızın veya routerınızın DNS hizmetini
kullanmak istemiyorsanız, özel DNS adresleri de belirtebilirsiniz. Ben
denemek için 8.8.8.8 adresini yeni DNS adresim olarak tanımlamak
istiyorum. DNS sorgusu ***/etc/resolv.conf*** dosyasında belirtilen
adrese göre gerçekleştiriliyor. Bu sebeple bu dosyada düzenleme yapmamız
gerek. Buradaki "**resolv**" ifadesi de zaten "**çözümleme**" anlamına
geliyor. Dolayısıyla domain adresi çözümleme işlevi için kullanıldığını
anımsamak zor değil. Öncelikle dosyamızın içeriğine bir göz atalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /etc/resolv.conf 
# Generated by NetworkManager
search Home
nameserver 192.168.1.1
```

Bakın "nameserver" yani DNS adresi olarak default getway yani router
adresim bulunuyor. Ben bunun yerine 8.8.8.8 adresini eklemek için nano
ile bu dosyayı açıp düzenleyeceğim. Elbette yetki gerektiren bir işlem
olduğu için komutumu `sudo nano /etc/resolv.conf` şeklinde girmem gerek.

``` {.bash}
GNU nano 6.0                        /etc/resolv.conf      
# Generated by NetworkManager
search Home
nameserver 8.8.8.8
```

Değişikliğin geçerli olabilmesi için bu çözümleme servisini yeniden
başlatmam gerek. Bunun için `systemctl restart systemd-resolved.service`
komutunu giriyorum. Ve test etmek için yine www.google.com adresini
`nslookup` aracına çözümletiyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ nslookup www.google.com                                                                                                                                 
Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   www.google.com
Address: 142.250.184.132
Name:   www.google.com
Address: 2a00:1450:4017:80c::2004
```

Bakın bu kez "8.8.8.8" adresine sorularak, www.google.com domain
adresinin ip adresi bulunmuş oldu. Yani DNS değiştirme işlemimiz başarı
ile sonuçlanmış oldu.

Ben örnek sırasında tek bir DNS adresi belirttim fakat, birinde
bulunamadığında diğerine sorulabilmesi için dilerseniz sırasıyla alt
alta birden fazla DNS adresini ***/etc/resolv.conf*** dosyasına
ekleyebilirsiniz.

``` {.bash}
┌──(taylan㉿kali-makinesi)-[~]
└─$ cat /etc/resolv.conf                                                                                                                                     
# Generated by NetworkManager
search linuxdersleri.net

nameserver 8.8.8.8
nameserver 8.8.4.4
```

hostname
--------

Ağ üzerinde ip alabilen cihazlara "host" denildiğini biliyorsunuzdur.
"**hostname**" ifadesi de, lokal ağımızdaki cihazların birbirinden ayırt
edilebilmesini sağlayan isimlendirmedir. Bu isimler sayesine lokal
ağdaki cihazların ip adresini hatırlamaya gerek kalmadan doğrudan
hostname bilgisi ile, ilgili cihazla iletişime geçebiliyoruz.

Öncelikle mevcut cihazımızın ağ üzerindeki ismini öğrenmek üzere
`hostnamctl` komutunu girebiliriz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ hostnamectl                                                                                                                                             
 Static hostname: linuxdersleri
       Icon name: computer-vm
         Chassis: vm 🖴
      Machine ID: 2f7f9cc088b74a54aaee8cfbc587c6ea
         Boot ID: 93aec4d830474a919b87cfa774110091
  Virtualization: oracle
Operating System: Kali GNU/Linux Rolling
          Kernel: Linux 5.15.0-kali3-amd64
    Architecture: x86-64
 Hardware Vendor: innotek GmbH
  Hardware Model: VirtualBox
```

Gördüğünüz gibi yönetmekte olduğum Kali Linux sisteminin ağ üzerindeki
ismi "linuxdersleri" olarak geçiyor. Dilersem bu ismi yeni bir hostname
ile değiştirmem mümkün. Bunun için tek yapmam gereken
`hostnamctl hostname yeni-hostname` şeklinde komutumu girmek. Ben
denemek için ismi "kali-makinesi" olarak değiştiriyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ hostnamectl hostname kali-makinesi                                                                                                                      

┌──(taylan㉿linuxdersleri)-[~]
└─$ hostnamectl 
 Static hostname: kali-makinesi
       Icon name: computer-vm
         Chassis: vm 🖴
      Machine ID: 2f7f9cc088b74a54aaee8cfbc587c6ea
         Boot ID: 93aec4d830474a919b87cfa774110091
  Virtualization: oracle
Operating System: Kali GNU/Linux Rolling
          Kernel: Linux 5.15.0-kali3-amd64
    Architecture: x86-64
 Hardware Vendor: innotek GmbH
  Hardware Model: VirtualBox
```

hostname bilgisi değişti gördüğünüz gibi fakat ek olarak
***/etc/hosts*** dosyasına da bu değişimi eklememiz gerekiyor. Çünkü
***/etc/hosts*** dosyası yerel olarak adres çözümlemesi sağlayan bir
konfigürasyon dosyası. Bu dosyada, bizim kendi makinemizi temsil eden
127.0.1.1 lokal ip adresi, bizim hostname adresimiz ile eşleştirilmiş
durumda. Bu sayede hostname üzerinden doğrudan makinemizin ip adresi
temsil edilmiş oluyor. Bu hostname bilgisini sistem üzerinde pek çok
yapı kullandığı için de ***/etc/hosts*** dosyasını düzenlemeden sistemi
sorunsuzca kullanmamız mümkün değil. Hemen dosya içeriğine göz atalım.

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /etc/hosts                                                                                                                                          
127.0.0.1       localhost
127.0.1.1       linuxdersleri

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Gördüğünüz gibi eski hostname bilgisi hala makinenin kendisini temsil
eden 127.0.1.1 adresine yönlendiriliyor. Bu adresi düzeltmek için
`sudo nano /etc/hosts` komutu ile dosyamızı açıp, yeni hostname
bilgimizi buraya ekleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo nano /etc/host
sudo: unable to resolve host kali-makinesi: Name or service not known
sudo: error initializing audit plugin sudoers_audit
```

Eklemek üzere dosyamızı açmak istedik fakat `sudo` komutu
"kali-makinesi" hostname bilgisini tanımadığını belirterek işleme onay
vermedi. İşte tam da bu sebeple ***/etc/hosts*** dosyasını düzenlememiz
gerek diyoruz. Aksi halde hostname bilgisi ile işlem yapan araçlar
çalışamaz hale gelecekler. Ben dosyayı düzenlemek için root kullanıcı
hesabına geçiş yapıp ilgili değişimi gerçekleştireceğim.

``` {.bash}
┌──(root㉿kali-makinesi)-[~]
└─# nano /etc/hosts
                                                                                                                                                            
┌──(root㉿kali-makinesi)-[~]
└─# exit
```

Normalde hostname değiştirilmeden önce ***/etc/hosts*** dosyasında bu
değişimin belirtilmesi daha doğru bir yaklaşım olacaktır. Fakat ben
önemini bizzat görmeniz için bu şekilde yanlış yoldan uygulamaya gittim.

Tamamdır artık böylelikle mevcut makinemin hostname bilgisini
değiştirmiş oldum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /etc/hosts                                                                                                                                          
127.0.0.1       localhost
127.0.1.1       kali-makinesi

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

┌──(taylan㉿linuxdersleri)-[~]
└─$ hostnamectl 
 Static hostname: kali-makinesi
       Icon name: computer-vm
         Chassis: vm 🖴
      Machine ID: 2f7f9cc088b74a54aaee8cfbc587c6ea
         Boot ID: 93aec4d830474a919b87cfa774110091
  Virtualization: oracle
Operating System: Kali GNU/Linux Rolling
          Kernel: Linux 5.15.0-kali3-amd64
    Architecture: x86-64
 Hardware Vendor: innotek GmbH
  Hardware Model: VirtualBox
```

Konsoldaki prompt alanında hala "linuxdersleri" gözüküyor fakat yeni bir
konsol ya da kabuk başlattığınızda bu da değişmiş olacak.

domainname
----------

Ağ üzerinde birden fazla sunucu mevcutsa bu sunucuları birbirinden
ayırmak için hostname bilgisi kullanılıyor. hostname bilgisine ek olarak
bu sunucuların aynı ağda olduğunun temsili için domain adresi de
tanımlanabiliyor. Örneğin [linuxdersleri.net](http://linuxdersleri.net/)
adresi için kullanılan bir web sunucusunun hostname bilgisi "web"
olabilir. Ayrıca varsa email sunucusu da "email" hostname ile
tanımlanmış olabilir. Bu sayede linuxdersleri.net domain adresi altında
hangi amaçla hangi sunucunun kullandığını, ip adreslerini hatırlamamıza
gerek kalmadan takip edebiliriz.

hostname ve domain name bilgisinin bir arada bulunduğu bu tanımlamaya da
**FQDN** (**f**ully **q**ualified **d**omain **n**ame) deniyor.
Gösterimi de **hostname.domainname** şeklinde, aralarındaki tek bir
nokta ile ayrılmış isimlerden ibaret.

Ben daha açık bir örnek olması için mevcut "kali-makinesi" hostname
adresine sahip cihazın domain adresi olarak linuxdersleri.net adresini
almasını istiyorum. Bunun için öncelikle ***/etc/hosts*** dosyasında
değişiklik yapmak üzere `sudo nano /etc/hosts` komutunu girip tam alan
adını(**FQDN)** tanımlıyorum. Değişiklikleri `cat` komutu ile teyit
edebiliriz.

``` {.makefile}
┌──(taylan㉿kali-makinesi)-[~]
└─$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali-makinesi.linuxdersleri.net

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Şimdi sistem üzerindeki hostname ve domainame bilgisini tanımlamak üzere
`hostnamectl hostname kali-makinesi.linuxdersleri.net` şeklinde komutumu
giriyorum.

``` {.yaml}
┌──(taylan㉿kali-makinesi)-[~]
└─$ hostnamectl hostname kali-makinesi.linuxdersleri.net

┌──(taylan㉿kali-makinesi)-[~]
└─$ hostnamectl 
 Static hostname: kali-makinesi.linuxdersleri.net
       Icon name: computer-vm
         Chassis: vm 🖴                                                                                                                                     
      Machine ID: 2f7f9cc088b74a54aaee8cfbc587c6ea                                                                                                         
         Boot ID: 2c2115508125496eaa8692e6325cf58a                                                                                                         
  Virtualization: oracle                                                                                                                                   
Operating System: Kali GNU/Linux Rolling                                                                                                                   
          Kernel: Linux 5.15.0-kali3-amd64                                                                                                                 
    Architecture: x86-64                                                                                                                                   
 Hardware Vendor: innotek GmbH                                                                                                                             
  Hardware Model: VirtualBox
```

Gördüğünüz gibi hostname bilgisi değiştirilmiş oldu. İlk noktadan önceki
kısım hostname, daha sonrası domain name olarak geçiyor. Dilerseniz,
`dnsdomainname` komutu ile bu durumu kendiniz de teyit edebilirsiniz.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ dnsdomainname                                                                                                                                          
linuxdersleri.net
```

Böylelikle lokal ağdaki hostname "kali-makinesi" olurken, domain bilgisi
de "linuxdersleri.net" oldu. Eğer lokal ağımda birden fazla sunucu varsa
her birine benzer şekilde aynı domain bilgisine ek olarak özel bir
hostname tanımlayabilirim. Bu sayede DNS sunucusu da bu adresleri
tanıyorsa, ilgili ip adresini bilmeme gerek kalmadan ilgili sunucuyu
bulabilirim.

![hostname-domainname.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/hostname-domainname.webp)

Yani tıpkı bizim websitelerini ziyaret etmek için DNS yardımıyla, domain
adresini ip adresine dönüştürüyor olmamız gibidir. Fakat bu işlem lokal
ağdaki cihazları birbirinden ayırt etmek ve isimleri üzerinden kolayca
onlara ulaşabilmek için kullanılıyor. Örneğin yukarıdaki gibi bir ağda,
"kali-makinem" isimli host, "mail" hostu ile iletişime geçmek
istediğinde **mail.linuxdersleri.net** adresinin ip adresini ağdaki DNS
sunucusuna sorar.

![DNS-request.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/DNS-request.webp)

DNS sunucusu ise, eğer bu adres kendi tablosunda kayıtlı ise ilgili ip
adresini yanıt olarak gönderir.

![DNS-response.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/DNS-response.webp)

Bu sayede doğrudan ip adresini bilmemize gerek kalmadan lokal ağdaki tüm
hostlar ile, hostname bilgisi üzerinden iletişim kurabiliriz.

Bu yaklaşımın kullanılabilmesi için elbette lokal ağdaki cihazların
ortak olarak aynı DNS hizmetini kullanıyor olması ve bu DNS hizmetinin
de bu hostname ve ip adreslerini biliyor olması gerek. Bunun için
dilerseniz routerınız üzerinden konfigürasyon tanımlayabilir ya da DNS
için harici olarak bir sunucu kurabilirsiniz. Bu sayede bu DNS hizmetine
sorgu yollayan tüm lokal ağdaki cihazlar, birbirilerinin ip ve hostname
bilgilerine de kolayca erişmiş olur. Hatta eğer birbirine bağlı birden
fazla ağ bulunuyorsa bu ağlardaki cihazlar ile iletişime geçmek üzere de
benzer yaklaşım kullanılır.

![DNS-multi-network.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/DNS-multi-network.webp)

İşte hostname sayesinde ağ içindeki cihazları birbirinden ayırmak mümkün
iken, domain sayesinde de gerektiğinde ağları birbirinden ayırt etmemiz
mümkün oluyor. Bu sayede ip adreslerini doğrudan bilmeye gerek kalmadan
kısayoldan ilgili cihaza ulaşabiliyoruz.

Biz bu temel eğitimde DNS sunucusunun nasıl kurulacağını ele
almayacağız. Çünkü bu eğitimin amacı herkes için temel Linux bilgisi
sağlamak. Fakat merak ediyorsanız kısa bir araştırma ile
öğrenebilirsiniz. Burada önemli olan hostname ve domain bilgisinin neden
kullanıldığını anlayabilmek.

/etc/hosts
----------

***/etc/hosts*** , sistemimizdeki lokal DNS görevini üstlenen bir
konfigürasyon dosyasıdır. hostname değişimi sırasında bu dosyadan
bahsetmiştik. Şimdi ayrıca ele alarak biraz daha anlamlı hale
getirebiliriz.

***/etc/hosts*** dosyasının temel amacı, IP adreslerini doğrudan host
isimleriyle eşleştirmektir. Bu sayede harici bir DNS sorgusuna gerek
kalmadan yerel olarak IP çözümlemesi sağlanabilir. Bu yaklaşım,
özellikle ağdaki cihazlar arasındaki iletişimde veya belirli servislere
erişimde IP adreslerini belirlemek amacıyla kullanılabiliyor. Örneğin
lokal ağımızdaki hostların isimleri ile ip adreslerini bu listeleye
ekleyerek, yalnızca hostname bilgileri sayesinde ilgili hostlar ile
kolayca iletişim kurabiliriz.

Ben denemek için lokal ağımdaki Windows ve Rocky Linux sistemlerinin ip
adreslerinin hostname bilgisini, `nano` yardımıyla ***/etc/hosts***
dosyasına ekliyorum.

``` {.makefile}
GNU nano 6.0                                           /etc/hosts *                                                  
127.0.0.1       localhost
127.0.1.1       kali-makinesi.linuxdersleri.net
192.168.1.2     windows
192.168.1.12    rocky-linux

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Şimdi değişimi test etmek için örneğin hostname bilgisi üzerinden ilgili
hostlara `ping` ile kontrol paketleri gönderebiliriz.

``` {.python}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ping windows                                                                                                       
PING windows (192.168.1.2) 56(84) bytes of data.
64 bytes from windows (192.168.1.2): icmp_seq=1 ttl=128 time=0.478 ms
64 bytes from windows (192.168.1.2): icmp_seq=2 ttl=128 time=0.518 ms
64 bytes from windows (192.168.1.2): icmp_seq=3 ttl=128 time=0.486 ms
^C
--- windows ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2054ms
rtt min/avg/max/mdev = 0.478/0.494/0.518/0.017 ms

┌──(taylan㉿kali-makinesi)-[~]
└─$ ping rocky-linux                                                                                                   
PING rocky-linux (192.168.1.12) 56(84) bytes of data.
64 bytes from rocky-linux (192.168.1.12): icmp_seq=1 ttl=64 time=2.72 ms
64 bytes from rocky-linux (192.168.1.12): icmp_seq=2 ttl=64 time=0.967 ms
64 bytes from rocky-linux (192.168.1.12): icmp_seq=3 ttl=64 time=0.831 ms
^C
--- rocky-linux ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2026ms
rtt min/avg/max/mdev = 0.831/1.506/2.722/0.861 ms
```

Gördüğünüz gibi ***/etc/hosts*** dosyasına eklemiş olduğum "hostname ip"
eşleşmesi sayesinde, ben hostname yazdığımda bu hostname ip adresine
çözümlenip ilgili ip adresi üzerinden işlem gerçekleştiriliyor.

Yani harici olarak DNS hizmetine sorulmadan önce sistem kendi içinde bu
sorguyu gerçekleştirdiği için, lokal olarak dilediğim ip için dilediğim
hostname veya domain bilgisi ekleyebiliyorum.

Örneğin spesifik domain veya hostname adresini engellemek istersem bu
dosya üzerinden geçersiz bir ip adresi ile tanımlayabilirim. Ben denemek
için google.com adresini 127.0.0.1 adresi ile eşleştiriyorum.

``` {.bash}
┌──(taylan㉿kali-makinesi)-[~]
└─$ cat /etc/hosts                                                                                                     
127.0.0.1       localhost
127.0.1.1       kali-makinesi.linuxdersleri.net
192.168.1.2     windows
192.168.1.12    rocky-linux
127.0.0.1       google.com
```

Bu sayede ben google.com domain bilgisini talep ettiğimde bana 127.0.0.1
adresi döndürüleceği için bu domainin arkasındaki gerçek ip ile
iletişime geçemeyeceğim. Dolayısıyla ilgili domain adresinin
çözümlenmesini de engellemiş olacağım. Bu noktada, kullanıcı yalnızca
doğrudan ilgili domain arkasındaki ip adresini tam olarak girerek
iletişim kurabilir.

Denemek için google.com adresine ping gönderelim.

``` {.python}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ping google.com
PING google.com (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.018 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.031 ms
^C
--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1012ms
rtt min/avg/max/mdev = 0.018/0.024/0.031/0.006 ms
```

Gördüğünüz gibi google.com adresi, localhost adresi olan 127.0.0.1
adresine işaret ediyor. Dolayısıyla gerçek adres ile iletişim
kuramıyorum.

Yani neticede ***/etc/hosts*** dosyası lokal DNS görevi gören bir
konfigürasyon dosyasıdır. Harici DNS hizmetine gidilmeden önce her
seferinde işletim sistemi tarafından ilk olarak bu dosya kontrol
edildiği için işletim sistemi bazında domain veya hostname çözümlemeleri
tanımlamak için bu dosya kullanılabiliyor.

DHCP Hakkında
-------------

DHCP hizmetinin, ağdaki tüm cihazlara gerekli olan "ip", "subnet",
"getway", "dns" bilgisini otomatik olarak sunduğunu biliyorsunuz. Bu
sayede client cihazlara tek tek tanımlamakla uğraşmadan ağ içindeki
iletişimi sorunsuz hale getirebiliyoruz. Fakat her zaman otomatik
tanımlama yapılmasını istemeyeceğimiz durumlar olabilir. Örneğin
sunucuların sabit ip adreslerine sahip olmasını da isteyebiliriz. Biz
aksini belirtmediğimiz sürece "default getway" yani "varsayılan ağ
geçidi" olarak kullanılan router aslında **DHCP** görevini üstelenerek
ağdaki cihazlara benzersiz ip tanımlamaları yapıyor. Bu durumu teyit
etmek için `ip route` komutunu girebiliriz.

![DHCP.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/DHCP.webp)

Gördüğünüz gibi **eth0** arayüzü için "**default getway**" olarak
tanımlı olan "**192.168.1.1**" adresi aynı zamanda "**dhcp**" olarak
kullanılıyormuş. Yani eth0 arayüzünün, dhcp üzerinden dinamik(dynamic)
olarak değişken ip adresleri aldığını öğrenmiş olduk.

Eğer ip adresinin değişken olmasını istemiyorsak, `nmtui` üzerinden
"automatic" seçeneğini devredışı bırakıp manuel olarak kendimiz sabit
bir ip adresi tanımlayabiliriz. Tek yapmanız gereken, statik ip adresi
tanımlamak istediğiniz ağ arayüzünü seçip, dhcp yerine elle ip
tanımlaması yapmak. Daha önce ele aldığımız için ben hızlıca gif resmi
üzerinden adımları gösteriyorum.

![static-ip.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/static-ip.gif)

![static-ip.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/static-ip.webp)

Gördüğünüz gibi `ip r` komutunu çıktısında da ip adresinin "static" yani
"sabit" olarak eklenmiş olduğu açıkça belirtiliyor. Bu şekilde statik ip
tanımlamasını kolayca gerçekleştirebiliyoruz.

Fakat tabii ki dhcp yerine elle tanımlama yaptığınızda ip çakışması gibi
yanlış konfigürasyonların sebep olabileceği sorunlar ile karşılaşmanız
da olası. Bu sebeple static yani sabit ip adresini yalnızca gerekli
durumlarda uygulamanız tavsiye edilir. Örneğin client yerine genellikle
ip adresinin sabit olması gereken server cihazlarında ip sabitlemesi
yapılır. Bu sayede bu server ile iletişime geçmek isteyen tüm yapılar
değişmeyen tek bir ip adresi sayesine zahmetsizce iletişim kurabilir.

Bunun dışında default getway üzerinden dhcp hizmeti almak
istemiyorsanız, harici olarak dhcp sunucusu kurup bu sunucunun ağdaki
tüm cihazlara ip tanımlaması yapmasını da sağlayabilirsiniz. Bu sayede
geniş ağlarda merkezi bir dhcp yönetimi mümkün oluyor. DHCP sunucusu
üzerinden, hostların MAC adresi ile ip sabitlemesi gibi çeşitli işlemler
de yapılabildiği için karmaşık ağlarda ağ yönetimini kolaylaştırmak
adına harici DHCP sunucusu tercih edilebiliyor.

arp
---

Ağ üzerindeki hostların, iletişime geçtiği hostların IP-MAC bilgisini
kendi arp tablolarında tuttuğunu biliyorsunuzdur. Linux üzerinde, mevcut
makinenin arp tablosunu görmek için `arp` komutunu girmemiz yeterli
oluyor.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ arp

┌──(taylan㉿kali-makinesi)-[~]
└─$
```

Eğer daha önce herhangi bir host ile iletişim kurmamış bir cihaz
üzerinden bu komutu girecek olursanız, bende olduğu şekilde arp tablosu
boş olacaktır. Bu tablonun, hostlar ile iletişim kurdukça dolduğunu
teyit etmek için ağımızdaki bir hosta `ping` ile icmp paketi
yollayabiliriz. Ben "192.168.1.2" ip adresine sahip olduğunu bildiğim
Windows makinesine `ping -c 3 192.168.1.2` komutu ile 3 paket
gönderiyorum.

``` {.python}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ping -c 3 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=128 time=1.41 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=128 time=0.858 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=128 time=0.606 ms

--- 192.168.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2012ms
rtt min/avg/max/mdev = 0.606/0.956/1.406/0.333 ms

┌──(taylan㉿kali-makinesi)-[~]
└─$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.1.2              ether   4c:cc:6a:4a:58:f6   C                     eth0
```

Gördüğünüz gibi Windows makinesi ile aramda sorunuzca paket alışverişi
gerçekleştirildiği için Windows hostunun IP ve MAC bilgisi de alınıp ARP
tablosuna eklenmiş. Zaten arp tablosu da bu amaçla kullanılıyor. Zaman
içinde biz iletişim kurdukça ARP protokolü sayesinde taraflar arasında
IP-MAC adresi paylaşımı yapılıyor ve taraflar da kendi ARP tablolarında
bu bilgileri tutuyorlar.

Bu çıktılara dikkat edecek olursanız router cihazının ip adresi arp
tablosunda bulunmuyor. Çünkü biz lokal ağda iletişim kurarken,
modemimizin switch özelliği sayesinde bu paketleri hedeflerine
ulaştırıyoruz. Router özelliği, harici ağlara paket yönlendirmek
istediğimizde kullanılıyor. Bu durumu teyit etmek için "1.1.1.1"
adresine yani lokal ağımız dışındaki internet üzerinde yer alan public
bir ip adresine ping gönderelim ve arp tablosunu tekrar kontrol edelim.

``` {.python}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ping 1.1.1.1
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.
64 bytes from 1.1.1.1: icmp_seq=1 ttl=56 time=9.64 ms
64 bytes from 1.1.1.1: icmp_seq=2 ttl=56 time=7.69 ms
64 bytes from 1.1.1.1: icmp_seq=3 ttl=56 time=8.25 ms
64 bytes from 1.1.1.1: icmp_seq=4 ttl=56 time=8.50 ms
^C
--- 1.1.1.1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3131ms
rtt min/avg/max/mdev = 7.687/8.519/9.640/0.710 ms

┌──(taylan㉿kali-makinesi)-[~]
└─$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.1.1              ether   c8:3a:35:7d:46:18   C                     eth0
192.168.1.2              ether   4c:cc:6a:4a:58:f6   C                     eth0
```

Bakın bu kez hedef dış ağdaki bir adres olduğu için, router ile bu
paketin bu ağa yönlendirilmesi gerekiyor. Bu sebeple bu paket router
cihazına teslim ediliyor. Bu teslim sırasında router cihazı ile benim
aramda ARP protokolü ile IP-MAC adresi paylaşımı gerçekleşiyor. Bu
sebeple benim arp tabloma router cihazının ip adresi ve MAC adresi
ekleniyor.

Lokal ağdayken modemimizin switch özelliği sayesinde paketler "fiziksel
port-MAC"adresi bilgisiyle iletiliyor. Dolayısıyla router ile işimiz
olmuyor. Fakat söz konusu harici bir ağa paket iletmek olduğunda, router
"yönlendirici" görevinde olduğu için router cihazının IP ve MAC
bilgisine ihtiyacımız oluyor.

Eğer buradaki anlatımlar yeterince açık değilse, ağ temellerini ele
aldığımız eğitimi tamamlayıp tekrar döndüğünüzde daha anlamlı hale
gelebilir.

Ayrıca arp tablosu mevcut ağ arayüzüne(network interface) özel olarak
tutuluyor. Dolayısıyla bir ağ arayüzü kapatıldığında veya farklı bir ağ
arayüzü kullanıldığında bu arp tablosu da sıfırlanmış oluyor. Ben
denemek için eth0 arayüzünü kapatıp tekrar açacağım ve arp tablosunu
tekrar kontrol edeceğim.

``` {.bash}
┌──(taylan㉿kali-makinesi)-[~]
└─$ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.1.1              ether   c8:3a:35:7d:46:18   C                     eth0
192.168.1.2              ether   4c:cc:6a:4a:58:f6   C                     eth0
┌──(taylan㉿kali-makinesi)-[~]
└─$ sudo ip link set eth0 down
┌──(taylan㉿kali-makinesi)-[~]
└─$ sudo ip link set eth0 up
┌──(taylan㉿kali-makinesi)-[~]
└─$ arp
┌──(taylan㉿kali-makinesi)-[~]
└─$
```

Gördüğünüz gibi eth0 arayüzünü kapatıp tekrar açtığımda arp tablosu da
sıfırlanmış oldu. Benzer şekilde örneğin ben Wi-Fi bağlantısı
gerçekleştirecek olursam, bu kez Wi-Fi arayüzü için ayrı bir arp tablosu
tutuluyor olacak.

route
-----

Mevcut ağ arayüzünün, dış ağlar ile iletişim kurmak üzere kullandığı
routerın bilgisini "default getway" adresi üzerinden öğrenebiliyoruz.
Bunun için `ip r` komutunu girmemiz yeterli.

``` {.sql}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ip r                                                                                                               
default via 192.168.1.1 dev eth0 proto static metric 100 
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.15 metric 100
```

Doğrudan yönlendirme tablosunu görmek istersek `route` komutunu da
kullanabiliyoruz.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ route                                                                                                                                                
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

Burada varsayılan ağ geçici(default getway) 192.168.1.1 olarak
gözüküyor. Yani bir paket harici bir ağa gönderilecekse bu adrese teslim
ediliyor. İsim çözümlemesi yapmadan yalnızca sayısal verileri görmek
için `route -n` komutunu girelim.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

Bakın bu kez ilk satırda "Destination" yani hedef olarak "**0.0.0.0**"
adresi yazıyor. Genmask değeri de ağın büyüklüğünün herhangi bir değer
olabileceğini belirten "**0.0.0.0**" subnetmask değeri aslında. Bunun
anlamı; hedefi herhangi bir ağ olan tüm isteklerin, default getway olan
"192.168.1.1" adresine yönlendirilecek olduğu. Bu sayede internet
üzerindeki herhangi bir ip adresi ile iletişim kurmak istediğimizde
ilgili paket, "default getway" adresindeki cihaza teslim ediliyor. Bu
cihaz da router aygıtımız olduğu için bu aygıt, ilgili paketin hedefe
ulaşabilmesi için gerekli yönlendirmenin yapılmasını sağlıyor.

İkinci satırda ise "Destination" yani hedef olarak "192.168.1.0" adresi
yazıyor. Genmask adresi ise "255.255.255.0" yani bu bilgiler ışığında
**tam olarak "192.168.1.0"** ağı içindeki ip adreslerinin hedeflendiği
durumlar kapsanmış oluyor. Gateway adresindeki "**0.0.0.0**" değeri ise
bu ağa erişim için bir ağ geçidi kullanılmasına gerek olmadığını
belirtiyor. Dolayısıyla 192.168.1.0 ağı içindeki ip adresleri, birbiri
ile iletişim kurarlarken default getway adresindeki router cihazına veri
göndermeleri gerekmiyor. Bu sebeple biz lokal ağımızdaki bir hosta veri
gönderirken, bu veri paketi router cihazına uğramadan-switch vasıtası
ile-ilgili host cihazına teslim ediliyor.

Eğer temel ağ eğitimine katıldıysanız, orada benzeri durumdan
bahsetmiştik. İnternet gibi geniş bir ip aralığını temsil etmek üzere
"**0.0.0.0/0**" adresi tanımlanıyordu. Ayrıca lokal ağdaki iletişim için
de ayrıca lokal ağ adresi belirtiliyordu. Bu sayede ip adresi lokal
ağdaki bir adres ise, ilgili paket doğrudan lokal ağdaki hosta
iletiliyorken, lokal ağında dışındaki adreslerin hepsi default getway
olarak bilinen yönlendirici router cihazına iletiliyordu.

Mevcut cihazımızdaki routing table bilgisini `route` aracı üzerinden
düzenlememiz mümkün. Fakat günümüzde yönlendirme tablosunu düzenlemek
için `ip` aracı daha sık kullanılıyor. Örneğin ben 10.0.0.0/24 ağındaki
ip adresleri hedeflendiğinde, verilerin 192.168.1.2 adresine
yönlendirilmesini istiyorum. Bunun için
`sudo ip route add 10.0.0.0/24 via 192.168.1.2` komutunu girmem yeterli.

``` {.sql}
┌──(taylan㉿kali-makinesi)-[~]
└─$ sudo ip route add 10.0.0.0/24 via 192.168.1.2                                                                                                          
[sudo] password for taylan: 

┌──(taylan㉿kali-makinesi)-[~]
└─$ route -n                                                                                                                                               
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
10.0.0.0        192.168.1.2     255.255.255.0   UG    0      0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

Gördüğünüz gibi "10.0.0.0" ağındaki herhangi bir ip adresinin
hedeflendiği durumda, bu veriler "192.168.1.2" adresine yönlendiriliyor
olacak. Bu adreste de muhtemelen bir router olacağı için bu router
konfigüre edildiği şekilde bu paketlerin uygun yerlere ulaşmasını
sağlayacak. Bu yaklaşım sayesinde özellikle birden fazla şirket ağının
olduğu işletmelerde, hangi ağdaki cihazların hangi ağlara veya hostlara
erişebileceğini yönetmek mümkün oluyor.

Eğer bu tanımlamayı silmek isterseniz "`add`" yerine "`del`" seçeneğini
aynı şekilde belirtmeniz yeterli.

``` {.ruby}
┌──(taylan㉿kali-makinesi)-[~]
└─$ sudo ip route del 10.0.0.0/24 via 192.168.1.2                                                                                                          

┌──(taylan㉿kali-makinesi)-[~]
└─$ route -n                                                                                                                                               
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

Elbette bu değişimleri ip aracı üzerinden gerçekleştirdiğimiz için
kalıcı değiller. Kalıcı olmasını istiyorsanız, sistem başlangıcında
çalışacak bir servis tanımlayabilir ya da `nmtui` aracı üzerinden
yönlendirme ekleyebilirsiniz. `nmtui` üzerinden yönlendirmeye dair örnek
için aşağıdaki görsellere bakabilirsiniz.

![nmtui-routing-table.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-routing-table.webp)

![nmtui-routing-table-add.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/nmtui-routing-table-add.webp)

Anlatım sırasında bahsetmiş olduğumuz lokal ve harici ağlardaki
yönlendirme durumu bizzat teyit etmek üzere `traceroute` aracı
yardımıyla yönlendirme adımlarını takip edebiliriz.

traceroute
----------

Paketlerin ağdaki yönlendirilme yolculuğunu takip etmek için
`traceroute` aracı ile icmp paketi yollayabiliyoruz. Ben denemek için
dış ağdaki "**8.8.8.8**" adresine giden yönlendirme yolcuğunu test etmek
istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ traceroute 8.8.8.8                                                                                                                                      
traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
 1  Tenda.Home (192.168.1.1)  8.050 ms  7.560 ms  7.497 ms
 2  172.17.1.81 (172.17.1.81)  7.485 ms  12.420 ms  12.383 ms
 3  69.125.223.31.srv.turk.net (31.223.125.69)  12.289 ms  12.231 ms  12.149 ms
 4  70.125.223.31.srv.turk.net (31.223.125.70)  12.124 ms  12.116 ms  12.081 ms
 5  73.125.223.31.srv.turk.net (31.223.125.73)  12.163 ms  12.126 ms  12.046 ms
 6  77.100.146.159.srv.turk.net (159.146.100.77)  22.134 ms  18.165 ms  17.565 ms
 7  72.14.210.191 (72.14.210.191)  16.364 ms  16.167 ms  17.343 ms
 8  72.14.210.190 (72.14.210.190)  17.182 ms  16.920 ms  16.747 ms
 9  * * *
10  dns.google (8.8.8.8)  16.045 ms  16.473 ms  16.853 ms
```

Gördüğünüz gibi adım adım yönlendirmeler hakkında bilgi sunulmuş oldu.
Çıktılarda yer alan "`* * *`" çıktısı bu yönlendiricinin icmp
paketlerine yanıt vermeyecek şekilde konfigüre edildiği veya bu
yönlendiricinin hizmet vermediği anlamına geliyor olabilir.

Çıktılara dikkat edecek olursanız ben dış ağdaki bir hedefe paket
gönderdiğim için, paket ilk olarak varsayılan ağ geçidim olan
192.168.1.1 adresine uğrayıp oradan internet servis sağlayıcımın
yönlendiricilerine uğrayıp hedefe doğru yönlendiriliyor. Çünkü
bilgisayarımdaki routing table üzerinde dış ip adreslerine gönderilen
verilerin "192.168.1.1" adresine yönlendirilmesi gerektiği belirtiliyor.

Paket lokal ağdaki bir ip adresine gönderilecek olsaydı, 192.168.1.1
adresindeki default getway görevini gerçekleştiren routera
uğramayacaktı.

Bu durumu teyit etmek için lokal ağımızdaki bir hosta gönderdiğimiz
paketi de takip edebiliriz.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ traceroute 192.168.1.12                                                                                                                                
traceroute to 192.168.1.12 (192.168.1.12), 30 hops max, 60 byte packets
 1  rocky-linux (192.168.1.12)  3.128 ms !X  2.008 ms !X  1.989 ms !X
```

Bakın hedef IP, lokal ağımdaki bir host olduğu için router ile
yönlendirme ihtiyaç duymadığından default getway adresine uğramadan
doğrudan ilgili hedefe yönlendirilmiş gözüküyor.

Neticede böylelikle routing table kullanım amacını ve önemini bizzat
teyit etmiş olduk.

`traceroute` aracını tıpkı burada olduğu şekilde kullanarak, olası ağ
sorunlarını tespit etmemiz de mümkün olabilir. Örneğin konfigüre
ettiğiniz router cihazlarının beklendiği şekilde çalışıp çalışmadığının
teyit etmek için kullanabilirsiniz. Ya da birden fazla yönlendirici
olduğu durumda, tam olarak hangi noktada sorun yaşandığının tespiti için
de kullanışlı olabilir.

Portlar Hakkında
----------------

IP adreslerine ek olarak, sistem üzerindeki tüm araçların sorunsuz
şekilde veri alışverişinde bulunabilmesi için portların kullandığını
biliyorsunuz.

![transport-port.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/transport-port.webp)

Dolayısıyla sistemimizdeki portlar hakkında temel düzeyde bilgi almak ve
gerektiğinde portları kontrol edebilmek önemli bir yetkinlik. Bu
doğrultuda, öncelikle sistemimizdeki aktif portları sorgulayarak
başlayabiliriz.

ss
--

`ss`, "**s**ocket **s**tatistic" ifadesinin kısaltmasından gelen, Linux
sistemindeki "soketler" hakkında bilgi sunan bir araçtır. Soketler,
işlemler arasındaki haberleşme için kullanılan özel dosyalardır. Aynı
cihaz üzerindeki işlemler veya ağ bağlantısı bulunan farklı hostlardaki
işlemler arasındaki haberleşmede kullanılıyorlar. Soketler yardımıyla
karşılıklı olarak veri iletimi mümkün oluyor.

Öncelikle sistem üzerindeki tüm soket bilgilerin görmek üzere yalnızca
`ss` komutunu girebiliriz.

``` {.swift}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ss
Netid             State              Recv-Q             Send-Q                                                Local Address:Port                              Peer Address:Port             Process             
u_dgr             ESTAB              0                  0                                               /run/systemd/notify 13634                                        * 0                                    
u_dgr             ESTAB              0                  0                                      /run/systemd/journal/dev-log 13658                                        * 0                                    
u_dgr             ESTAB              0                  0                                       /run/systemd/journal/socket 13660                                        * 0                                    
u_str             ESTAB              0                  0                                                /run/user/1000/bus 20625                                        * 19893                                
u_str             ESTAB              0                  0                                                                 * 19912                                        * 20664                                
u_str             ESTAB              0                  0                                                                 * 15515                                        * 15516                                
u_str             ESTAB              0                  0                                              /tmp/dbus-lEUb2kgW9Z 16324                                        * 18943                                
u_str             ESTAB              0                  0                                                                 * 18039                                        * 18040                                
u_str             ESTAB              0                  0                                       /run/systemd/journal/stdout 56040                                        * 55074                                
u_str             ESTAB              0                  0                                       /run/dbus/system_bus_socket 19232                                        * 18410                                
u_str             ESTAB              0                  0                                       /run/systemd/journal/stdout 17133                                        * 17439                                
u_str             ESTAB              0                  0                                       /run/systemd/journal/stdout 15456                                        * 14946                                
u_str             ESTAB              0                  0                                                                 * 19090                                        * 19502                                
u_str             ESTAB              0                  0                                                @/tmp/.X11-unix/X0 19048                                        * 18176                                
u_str             ESTAB              0                  0                                                                 * 18985                                        * 18986                                
u_str             ESTAB              0                  0                                                /run/user/1000/bus 18969                                        * 16327                                
u_str             ESTAB              0                  0                                              /tmp/dbus-lEUb2kgW9Z 16279                                        * 18825
..
..
.
```

Sistem üzerindeki tüm soketleri kapsadığı için çıktı çok uzun, ben
kısaltarak ekledim. Bu çıktılar bizim için çok fazla. Genellikle
yalnızca açık olan TCP ve UDP portlarına bakmak için `ss` aracına
ihtiyacımız oluyor. Açık portları listelemek için `ss -tuln` komutunu
girebiliriz. Buradaki `t` seçeneği **TCP**, `u` seçeneği **UDP**, `l`
seçeneği "listening" yani "dinlenen" portları listeler, `n` seçeneği
port numaralarını verir.

``` {.ruby}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ss -tuln
Netid             State              Recv-Q             Send-Q                         Local Address:Port                         Peer Address:Port            Process            
tcp               LISTEN             0                  128                                  0.0.0.0:22                                0.0.0.0:*                                  
tcp               LISTEN             0                  128                                     [::]:22                                   [::]:*
```

Şu anda ssh servisi aktif olduğu için 22 portu dinleniyor. Ayrıca
yalnızca "dinlenen" portlar yerine tüm port bilgisini almak için `l`
seçeneği yerine "**all**" ifadesinden gelen `a` seçeneğini
kullanabiliriz.

``` {.ruby}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ss -tuna
Netid             State              Recv-Q             Send-Q                         Local Address:Port                         Peer Address:Port            Process            
tcp               LISTEN             0                  128                                  0.0.0.0:22                                0.0.0.0:*                                  
tcp               LISTEN             0                  128                                     [::]:22                                   [::]:*
```

Şu anda yalnızca dinlendiği için harici bir port bilgisi bastırılmadı.
Ben test etmek için yeni bir konsol açıp, Rocky Linux sistemine ssh ile
bağlanacağım.

``` {.swift}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ssh pc@rocky-linux 
pc@rocky-linux's password: 
Last login: Sat Aug 26 15:13:21 2023 from 192.168.1.15
[pc@linuxdersleri ~]$ whoami
pc
[pc@linuxdersleri ~]$
```

Şimdi kendi konsolumuza dönüp tekrar `ss -tuna` komutunu girelim.

``` {.ruby}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ss -tuna
Netid            State              Recv-Q             Send-Q                         Local Address:Port                          Peer Address:Port            Process            
tcp              LISTEN             0                  128                                  0.0.0.0:22                                 0.0.0.0:*                                  
tcp              ESTAB              0                  0                               192.168.1.15:44370                         192.168.1.12:22                                 
tcp              LISTEN             0                  128                                     [::]:22                                    [::]:*
```

Bakın bu kez "**LISTEN**" durumuna ek olarak "**ESTAB**" yani
"**estab**lished" ifadesinden gelen "bağlantı kuruldu" tanımı da
görüyoruz. SSH ile hedef sunucuya bağlandığım için aramızda bağlantı
kuruldu. Burada hangi port üzerinden hangi ip adresi ile bağlantı
kurulduğu da açıkça yazıyor.

İşte `ss` aracının en temel kullanımı bu şekilde. Tabii ki `ss —help`
komutu ile bizzat teyit edebileceğiniz gibi esasen çok fazla ek seçenek
mevcut fakat temel kullanım için bu kadarlık bilgi bize yeterli olacak.

netcat \| nc
------------

netcat aracı, kısaca `nc` komutu ile kullanılan temel ağ araçlarından
biridir. `nc` sayesinde TCP ve UDP üzerinden hedefteki sunucu ile veri
alışverişinde bulunarak bağlantı testleri gerçekleştirebiliyoruz. En
temel kullanımı, hedef ip ve port sayesinde bağlantı kurulmasıdır. Ben
denemek için Kali Linux üzerinde `python3 -m http.server 8080` komutu
ile 8080 portunda çalışan bir http server oluşturuyorum.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```

Şimdi aynı lokal ağdaki Rocky Linux üzerinden bu adrese bağlanmak için
hedef sunucu ve ip adresini girmem yeterli.

``` {.csharp}
[root@linuxdersleri ~]# nc 192.168.1.15 8080
```

Şu anda Rocky Linux, Kali Linux makinesindeki yani 192.168.1.15
adresindeki 8080 portu üzerinden sunulan http sunucusuna bağlı durumda.
Bu durumu teyit etmek için `ss -tuna` komutunu girebiliriz.

``` {.ruby}
┌──(taylan㉿kali-makinesi)-[~]
└─$ ss -tuna                                                                                                                                                                      
Netid            State              Recv-Q             Send-Q                         Local Address:Port                         Peer Address:Port             Process            
tcp              LISTEN             0                  128                                  0.0.0.0:22                                0.0.0.0:*                                   
tcp              LISTEN             0                  5                                    0.0.0.0:8080                              0.0.0.0:*                                   
tcp              ESTAB              0                  0                               192.168.1.15:8080                         192.168.1.12:37440                               
tcp              LISTEN             0                  128                                     [::]:22                                   [::]:*
```

Bağlantı durumu burada ip ve port detaylarıyla birlikte açıkla
gözüküyor.

Ek olarak aramızdaki bağlantı ve veri iletişimini test etmek için burada
"hello" yazıp enter ile sunucuya isteğimizi iletelim.

``` {.php-template}
[root@linuxdersleri ~]# nc 192.168.1.15 8080
hello
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>Error response</title>
    </head>
    <body>
        <h1>Error response</h1>
        <p>Error code: 400</p>
        <p>Message: Bad request syntax ('hello').</p>
        <p>Error code explanation: HTTPStatus.BAD_REQUEST - Bad request syntax or unsupported method.</p>
    </body>
</html>
```

Hedefteki sunucunun "hello" ifadesine yanıtı, bir hata mesajı oldu.
Neticede böylelikle http sunucusu ile iletişim kurabildiğimizi bizzat
teyit etmiş olduk. Hatta emin olmak istersek Kali Linux üzerindeki
çıktılara da bakabiliriz.

``` {.scss}
┌──(taylan㉿kali-makinesi)-[~]
└─$ python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
192.168.1.12 - - [26/Aug/2023 08:33:41] code 400, message Bad request syntax ('hello')
192.168.1.12 - - [26/Aug/2023 08:33:41] "hello" 400 -
```

Bakın python ile başlatılan http sunucusunun "hello" mesajına yanıtı,
400 hata kodu olarak gözüküyor. Böylelikle Rocky Linux ile Kali Linux
arasında `nc` aracı yardımıyla bağlantı kurulabildiğini tekrar teyit
etmiş olduk.

`nc` aracı genellikle bağlantı kontrolü için kullanılan bir araç fakat
benzer yaklaşım kullanılarak alternatif kullanım amaçları da
karşılanabiliyor. Örneğin genellikle güvenlik testleri sırasında
kullanılan "reverse shell" yaklaşımı için netcat aracı kullanılabiliyor.
Bunun için bağlanılmak istenilen hedef sunucuda
`nc -l -p 9999 -e /bin/bash` komutu giriliyor. Bu komut `nc` aracının
"**9999**" portunu dinlemesini, bağlantı olması halinde ***/bin/bash***
aracını yani bash kabuğunu bu bağlantıdan gelen tarafa sunmasını ifade
ediyor.

``` {.bash}
┌──(taylan㉿kali-makinesi)-[~]
└─$ nc -l -p 9999 -e /bin/bash
```

Ben Rocky Linux sisteminden, Kali Linux sistemine reverse shell almak
üzere Kali Linux tarafından dinlenmekte olan bu porta, Kali Linux
makinesinin ip adresi ile bağlanabilirim.

``` {.bash}
[pc@linuxdersleri ~]$ nc 192.168.1.15 9999
whoami
taylan
uname -a
Linux kali-makinesi.linuxdersleri.net 5.15.0-kali3-amd64 #1 SMP Debian 5.15.15-2kali1 (2022-01-31) x86_64 GNU/Linux
```

Gördüğünüz gibi Rocky Linux sisteminden, Kali Linux sisteminde bir
kabuğa erişim sağlamış oldum. Girdiğim komutların çıktılarından, bu
bağlantının başarılı olduğunu teyit edebiliyoruz.

Bu yaklaşım genelde, güvenlik testi sırasında sızılan sisteme dışarıdan
erişilebileceğini kanıtlamak üzere kullanılıyor.

Benzer şekilde bağlantı kurulmak istenilen ağ ile aramızdaki sorunun
hangi taraftan kaynaklandığını tespit etmek için de kullanabiliyoruz.
Bunun için bağlanılmak istenilen adreste `nc -l PORT-NUMARASI` komutu
ile belirli bir port üzerinden dinleme moduna geçiyoruz. Daha sonra
dinleme modundaki hedefe, yine `nc` ile bağlanmaya çalışıyoruz. Eğer
bağlanabiliyorsak hedefteki ağa erişmede sorun yoktur. Ama
bağlanamıyorsak aramızdaki bağlantı problemlidir. Bu gibi kontroller
için `nc` aracı sıklıkla kullanılıyor.

Ayrıca `nc` aracı ile hedef ip adresindeki portları taramamız ya da
dosya gönderme gibi işlemler yapmamız da mümkün. Aracın temelde nasıl
çalıştığını öğrendiğinize göre kısa bir araştırma ile bu işlemleri nasıl
gerçekleştirebileceğinizi de öğrenebilirsiniz.

iptables \| firewalld Hakkında
------------------------------

IP ve portlar için kural tanımlamamıza olanak sağlayan **iptables** ve
**firewalld** yapıları mevcuttur. Her ne kadar biz bu eğitimde
değinmeyecek olsak da, sistem yönetimi alanında ilerlemek isteyenler
için bu yapıların varlığından haberdar olup araştırabilmeleri adına
burada bu açıklamayı eklemek istedim.

Sisteme gelen ve sistemden çıkan tüm paketlerin istenilen koşullara göre
filtrelenebilmesi için iptables ve firewalld çözümleri kullanılabiliyor.
Dolayısıyla sistem güvenliği konusunda ek araştırma yapmak istiyorsanız
bu kavramları araştırarak başlayabilirsiniz.

Tıpkı iptables ve firewalld gibi elbette bu bölüm içerisinde
değinmediğimiz pek çok farklı ağ aracı bulunmasına karşın, temel düzeyde
ağ ile ilgili işlerimizi halletmek için yeteri kadar araçtan bahsetmiş
olduk. Bizim değinmediğimiz diğer araçlar ve detaylar, ağ üzerinde
gerçekleştirmek istediğiniz işlemler özelinde kullanmanız gereken
spesifik çözümlerdir. Bu eğitim herkese yönelik temel Linux eğitimi
sunmayı amaçladığı için profesyonel Linux sistem yönetimi detay
seviyesinde bilgilere değinmedik. Ama bahsetmiş olduğumuz temel
bilgiler, hangi yöne doğru gitmek isterseniz kullanabileceğiniz
temellerdir. Örneğin ileride sistem yöneticiliği özelinde bir eğitim
serisi hazırlayacak olursam, buradaki temelleri bildiğinizi varsayarak
bu temeller üzerinden yeni detaylara değiniyor olurum. Dolayısıyla
gereken temele sahip olduğunuz için bundan sonrası ihtiyaçlarına göre
kendi araştırmanıza kalıyor.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 13. Ders 83 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Bu bölümde dosya arşivleme, sıkıştırma ve sıkıştırılmış olan dosya
arşivlerini açma gibi işlemleri ele alacağız. Zaten bu kavramlar sizlere
yabancı gelmemeli zira daha önce hangi işletim sistemini kullanmış
olursanız olun öyle ya da böyle mutlaka arşiv dosyaları karşınıza
çıkmıştır. Genellikle yüksek boyutlu dosyaların sıkıştırılmasında veya
veri kaybı olmadan güvenli transfer yapabilmek için ve bunlar gibi pek
çok avantaj dolayasıyla arşiv dosyaları ile sıklıkla karşılaşıyoruz,
karşılaşmaya da devam edeceğiz. Bu sebeple biz de bu bölüm içerisinde
öncelikle dosyaları nasıl arşivleyebileceğimizden daha sonra ise
sıkıştırma işlemlerinin nasıl gerçekleştirildiğinden bahsedeceğiz.

Arşivlemek
----------

Bir grup dosya veya klasörü tek bir arşiv dosyası içerisinde toparlamaya
"arşivleme" diyoruz. Dosya transferlerinde veri kayıplarını önlemek yani
veri bütünlüğünü sağlamak ve dosyaları daha düzenli depolamak için
arşivlere sıklıkla ihtiyacımız oluyor. Linux üzerinde arşiv işlemleri
için grafiksel arayüze sahip araçlar olmasına karşın, biz daha verimli
olacağı için arşivlemeyi de komut satırı üzerinden gerçekleştireceğiz.
Grafiksel arayüzlü arşiv araçlarının hangileri olduğu ve nasıl
kullanılabileceğini kendiniz de kolayca keşfedebilirsiniz. Biz komut
satırından arşivleme işlemi için `tar` aracını kullanıyor olacağız.

`tar` Komutu
------------

Komut satırı üzerinden arşivler üzerinde çalışmak için kullandığımız
`tar` aracının ismi "**T**ape **AR**chive" ifadesinden geliyor. İsmi şu
an size garip gelmiş olabilir ancak bu araç manyetik bantlar için arşiv
oluşturmak üzere geliştirildiği için bu isim verilmiş. Bu ifadeyi arama
motorunun görseller bölümünde arattığınızda manyetik bantların
depolandığı pek çok arşiv odası resmi karşınıza çıkacaktır.

![tape
archive](https://www.linuxdersleri.net/egitim/temel-linux/arsiv/tape_archive.webp)
[Resim
Kaynağı](https://commons.wikimedia.org/wiki/File:Video_tape_archive_%286498650083%29.webp)

Zaten aracımızın ismi de buradan geliyor. Akılda kalıcı olması için
isminden bahsetmek istedim ancak isminin nerden geldiği çok da önemli
değil. Neticede `tar` aracını kullanarak arşivler oluşturabiliyoruz.

`tar` komutunu kullanarak arşiv oluşturmak için aracın `c` ve `f`
seçeneklerini birlikte kullanmamız gerekiyor. `c` seçeneği "**c**reate"
yani "oluşturmak" ifadesinin kısaltmasıyken, `f` seçeneği ise "**f**ile"
ifadesinin kısaltmasından geliyor. `c` seçeneği sayesinde arşiv dosyası
oluşturmak istediğimizi belirtiyorken, `f` seçeneği sayesinde de
oluşturulacak arşiv dosyasının ismini belirleyebiliyoruz.

Ben basit örnek olması için çeşitli metin dosyalarını ve resimleri
arşive almak istiyorum. Örnek için boş dosyaları da kullanabiliriz,
fakat ileride sıkıştırma işlemi de uygulayacağımız için kullanacağımız
dosyaların içi dolu olursa sıkıştırma işleminden sonraki boyut farkını
gözlemeyebiliriz.

Ben arşivleme örnekleri sırasında mevcut platformun Github üzerindeki
dosyalarını kullanmak istiyorum ancak elbette siz arşivlemek için
istediğiniz türde dosyaları kullanabilirsiniz.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls linux-dersleri/                                                                                                                                      
 404.html                                   'hakk'$'\302\215''nda.markdown'                   _plugins
'al'$'\302\215''st'$'\302\215''rmalar.webp'   _includes                                        _posts
 assets                                      index.markdown                                   public
 _authors                                   ''$'\302\200''izimler'                            questions.json
 bildirim.html                               kitap.webp                                        README.md
 blog                                        _komut                                           sistem-yonetim.webp
 _config.yml                                 komutlar                                         site
 _egitim                                     kurs.markdown                                   's'$'\302\215''kca-sorulan-sorular.markdown'
 egitim.markdown                             _layouts                                         telefon.webp
 etiketler.markdown                          linux-doc.webp                                    temel-linux.markdown
 feedback.webp                                linux-sistem-yonetimine-giris-egitimi.markdown   temel-linux.webp
 feedback-sended.webp                         logo.svg                                         test.markdown
 Gemfile                                     pagefind                                         video-egitim.webp
 Gemfile.lock                                pagefind.yml
 gizlilik.markdown                           panic.webp
```

Bakın websitesinin tüm dosyaları burada bulunuyor. Ben alt
klasörlerdekiler de dahil tüm dosya ve klasörleri tek bir arşiv dosyası
içine almak istiyorum. Normalde arşivleme işlemi sonrası arşivlenen
dosyaların boyutlarında bir değişiklik olmuyor. Çünkü biz özellikle
belirtmediğimiz sürece arşivleme işlemi sırasında sıkıştırma yapılmıyor.
Arşivleme işlemi, ilgili dosya ve klasörlerin tek bir arşiv dosyası
altında toparlanmasını sağlıyor.

Söylediğim bu durumu teyit etmek için arşivleme işleminden önce klasörün
kapladığı disk boyutunu öğrenmek üzere `du -hs linux-dersleri` şeklinde
komutumu girmek istiyorum. Buradaki `du` aracı hedef gösterdiğim
klasörün alt dizinleri de dahil toplam boyutunu okunaklı şekilde
öğrenmemizi sağlayacak.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ du -hs linux-dersleri/                                                                                                                                  
142M    linux-dersleri/
```

Bakın çıktının sonunda toplam boyut belirtiliyor. Dizin içeriğinin
orijinal boyutunu öğrendiğimize göre artık arşivleme işleminden sonra
arşiv dosyasının boyutu ile orijinal klasörün boyutunu kıyaslayabiliriz.
Şu an yalnızca arşivleme işlemi yapacağımız için zaten herhangi bir
sıkıştırma işlemi uygulanmayacak ve arşiv dosyasının boyutu mevcut
klasör ile aynı olacak. Hemen arşivleyip bizzat görelim.

Arşivlemek için `tar -cf` komutundan sonra, oluşturulacak arşiv
dosyasının ismini ve hedef dosyaları yazmamız gerekiyor.

    tar -cf linux-dersleri.tar linux-dersleri/

Ekranda herhangi bir çıktı belirmese de bu dizindeki tüm dosyalar
arkaplanda arşivlendi. Komut girerken, oluşturulacak arşiv dosyasını
ismini önce giriyoruz çünkü arşiv dosyasına birden fazla dosyayı dahil
edebileceğimiz için `tar` aracı hangi dosyanın arşive eklenip hangisinin
arşiv dosyası ismi olarak kullanılacağı konusunda emin olmak istiyor. Bu
sebeple her zaman dosya ismi belirtmemizi sağlayan `f` seçeneğinin hemen
ardından arşiv dosyasının ismini girmemiz gerekiyor. Yani komutumuzu
`tar -c linux-dersleri/ -f linux-dersleri.tar` şeklinde de girebilirdik.
Burada önemli olan `f` seçeneğinin hemen ardından oluşturulacak olan
arşiv dosyasının ismini belirtmek. Buradaki `c` seçeneği de zaten yeni
arşiv oluşturacağımızı belirten bir seçenek. Yeni arşiv dosyası
oluşturduğumuz için bu seçeneğin de bulunması gerekiyor. Neticede bu
komut sayesinde belirtmiş olduğumuz bu klasörün içindeki tüm dosya ve
klasörler mevcut dizinde "***linux-dersleri.tar***" isimli bir arşiv
dosyasına alınmış oldu.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls
linux-dersleri  linux-dersleri.tar
```

Belki burada arşiv dosyasının isminin sonuna eklediğim "**.tar**"
uzantısının şart olup olmadığı kafanıza takılmıştır. Dosya isminin
sonuna eklemiş olduğum "**.tar**" uzantısı, `tar` aracının standart
arşiv uzantısı. Bu uzantıyı kullanmak zorunda değilsiniz ancak sistem
üzerinde arşiv dosyalarınızı ayırt edici kılmak için mutlaka bu dosya
uzantısını da ismine eklemenizi tavsiye ederim. Dosya uzantısını
eklemesiniz de arşiv dosyası olarak kullanabilirsiniz ancak daha sonra
dosyaları listelediğinizde "**.tar**" uzantısı sayesinde arşiv dosyasını
ayırt etmeniz daha kolay olur. Zaten benzeri durumdan, kabuk
genişletmeleri bölümünde bahsetmiştik. Düzenli sistem yönetimi için bu
tip detaylar önemli. Örneğin sonu "**.tar**" ile biten dosyaları listele
diyerek, tüm `tar` arşivlerini bir çırpıda listeleyebileceğinizi
düşünün. Tamamdır bence girdiğimiz komutu yeterince açıkladık.

Şimdi orijinal klasör ile bu arşivin boyutunu kıyaslayabilmek adına
`du -hs linux-dersler*` şeklinde komutumuzu girelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ du -hs linux-dersleri*                                                                                                                                  
142M    linux-dersleri
141M    linux-dersleri.tar
```

Bakın dosya ismi genişletmesi sayesinde bu dizinin ve arşiv dosyasının
boyutlarını `du` aracı yardımıyla öğrendik. Buradaki çıktıda arşiv
dosyası ile orijinal klasörün boyutlarının **neredeyse aynı** olduğuna
dikkatinizi çekmek istiyorum.

Eğer sizin oluşturduğunuz arşiv dosyası tıpkı bende olduğu gibi orijinal
dizin veya dosyalardan biraz daha küçükse, bu durumun nedeni arşivleme
yapılırken verilerin standart dosya sisteminde olduğu gibi bloklar
halinde değil bir arada saklanıyor olmasındır. Örneğin mevcut dosya
sisteminde verileri saklamak için kullanılan bloklar 4 kb'lık bloklarsa,
biz 1 kb'lık bir dosya oluşturduğumuzda bu dosyayı temsil eden veriler
bir bloğa kaydoluyor ve 3 kb'ın boşta durmasına sebep oluyor.

![disk-block.webp](https://www.linuxdersleri.net/egitim/temel-linux/arsiv/disk-block.webp)

Özellikle çok fazla bu gibi dosya olduğunda da bloklarda boşta kalan
alan miktarı artabiliyor. İşte `tar` aracı, bu blok yaklaşımı yerine tüm
verileri peşi sıra birleştirdiği için arşiv dosyası orijinalinden biraz
daha küçük olabiliyor.

![disk-archived-block.webp](https://www.linuxdersleri.net/egitim/temel-linux/arsiv/disk-archived-block.webp)

Mevcut konu bağlamından uzaklaşacağımız için ben şimdi bu konunun
ayrıntısına girmek istemiyorum, ancak çok kısa bir araştırma ile bu konu
hakkında yeterli bilgiye ulaşabilirsiniz. Ayrıca eğitimin devamında,
"Disk Yönetimi" başlığı altında da bu konuya tekrar değineceğiz.

Özetleyecek olursak; burada dikkat etmeniz gereken detay, arşivleme
yapılırken aslında sıkıştırma yapılmadığı. Arşivleme işleminde mevcut
veriler yalnızca bir araya getirilip saklanıyor. Bu sebeple disk
blokları üzerinde küçük tasarruf sağlanmış oluyor.

Biz özellikle belirtmediğimiz sürece arşiv dosyalarında sıkıştırma
yapılmıyor.

Neticede gördüğünüz gibi arşivleme işlemi yani komut satırı üzerinden
yeni arşiv oluşturmak çok kolay. En temel kullanımı ele aldığımıza göre
şimdi arşivler hakkında bilmemiz gereken diğer bilgilerden bahsederek
devam edebiliriz.

Ayrıntılı Çıktı Almak
---------------------

Arşiv oluştururken arşivleme işlemini konsol üzerinden takip etmek
istemediğim için "**v**erbose" seçeneğini komutumla birlikte
belirtmemiştim. Eğer tüm arşivleme işlemini konsol üzerinden adım adım
takip etmek istiyorsak pek çok komutta olduğu gibi "verbose" özelliği
ile detaylı şekilde çıktı almak istediğimizi belirtebiliriz. Ayrıca ben
bir önceki örnekte tek bir klasörü arşiv içine ekledim fakat dilerseniz
istediğiniz kadar dosyayı arşive alabilirsiniz. Örnek olması için
öncelikle `touch {a..z}` komutu ile **a** dan **z** ye kadar
isimlendirilmiş dosyalar oluşturalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ touch {a..z}

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls
a  b  c  d  e  f  g  h  i  j  k  l  linux-dersleri  linux-dersleri.tar  m  n  o  p  q  r  s  t  u  v  w  x  y  z
```

Şimdi bu dosyaları arşive almak istersek arşive alınacak dosyaların
isimlerini belirtmemiz yeterli. Belirtirken de yine kabuk genişletmesini
kullanabiliriz. Yani örneğin `tar -cvf alfabe.tar {a..z}` şeklinde komut
girecek olursak, a'dan z'ye kadar isimlendirilmiş tüm içeriklerin
"***alfabe.tar***" isimli arşiv dosyasın alınması mümkün. Buradaki
"verbose" seçeneğinin kısaltması olan `v` seçeneği sayesinde de zaten
tüm arşivleme adımlarını konsol üzerinden takip edebileceğiz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -cvf alfabe.tar {a..z}
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls
a  alfabe.tar  b  c  d  e  f  g  h  i  j  k  l  linux-dersleri  linux-dersleri.tar  m  n  o  p  q  r  s  t  u  v  w  x  y  z
```

Bakın tüm arşivleme işlemi yani arşive eklenen tüm dosyalar konsola
çıktı olarak adım adım bastırıldı. Benzer şekilde klasörü arşive alırken
de "verbose" seçeneği ile çıktıları takip edebiliriz. Bunun için
`tar -cvf arsiv2.tar linux-dersleri` şeklinde komutumuzu girmemiz
yeterli.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -cvf arsiv2.tar linux-dersleri
linux-dersleri/
linux-dersleri/_layouts/
...
linux-dersleri/_layouts/komut.html
..
linux-dersleri/assets/fonts/fontawesome-webfont.woff
.
linux-dersleri/assets/js/search.js
linux-dersleri/logo.svg
linux-dersleri/index.markdown
```

**ℹ️ Not:** Çıktılar kısaltılmıştır.

Aldığımız çıktıların en başına gelecek olursak, en başta arşivlemek için
hedef gösterdiğimiz dizin olmak üzere sırasıyla tüm alt dizinlerin adım
adım arşive eklendiğini buradaki çıktıların görebiliyoruz. Yani
arşivleme işleminde klasör düzeni aynen korunuyor. Belki benim örnek
için kullandığım klasör gibi olan küçük boyutlu dosyalar için ayrıntılı
çıktı özelliği pek önemli olmasa da özellikle büyük boyutlu dosyaların
arşivlenmesi sırasında işlemi konsol üzerinden takip edebilmek adına
"verbose" seçeneği kolaylık sunabiliyor. Yoksa uzun süren arşivleme
işlemlerinde, işlemin duraksadığı yanılgısı oluşabiliyor.

Arşiv İçeriğini Görüntülemek
----------------------------

Arşiv dosyasının içeriğini, arşiv dosyasını dışarı çıkarmadan
görüntülemek için `tar` komutunun `t` seçeneğini kullanabiliriz. Arşiv
dosyasının ismini yazacağımız için ayrıca `f` seçeneğini de kullanmamız
gerekiyor yoksa komut başarısız olacak. Hemen denemek için ilk
oluşturduğum "***linux-dersler.tar**"* arşiv dosyasını okumak üzere
`tar -t linux-dersleri.tar` şeklinde komutumu giriyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -t linux-dersleri.tar
tar: Refusing to read archive contents from terminal (missing -f option?)
tar: Error is not recoverable: exiting now
```

Bakın `-f` seçeneğini komutuma eklemediğim için arşiv dosyasının içeriği
okunamadı. Şimdi komutumuza `t` seçeneğine ek olarak `f` seçeneğini de
ekleyip tekrar girelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tf linux-dersleri.tar
linux-dersleri/
linux-dersleri/_layouts/
...
linux-dersleri/_layouts/komut.html
..
linux-dersleri/assets/fonts/fontawesome-webfont.woff
.
linux-dersleri/assets/js/search.js
linux-dersleri/logo.svg
linux-dersleri/index.markdown
```

**ℹ️ Not:** Çıktılar kısaltılmıştır.

Bu kez sorunsuzca arşiv dosyasının tüm içeriği sırasıyla hiyerarşik
düzende konsola bastırıldı.

Yani bizzat teyit ettiğimiz gibi, `tar` aracının `t` seçeneği sayesinde
arşiv dosyasının içeriğini, arşiv dosyasını dışarı çıkarmadan da
rahatlıkla listeleyebiliyoruz. Eğer listeleme işlevi için `t` seçeneği
benim aklımda kalmaz diyorsanız `t` yerine uzun şekilde `—list`
seçeneğini de kullanabilirsiniz. Denemek için
`tar —list -f linux-dersleri.tar` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tf linux-dersleri.tar
linux-dersleri/
linux-dersleri/_layouts/
...
linux-dersleri/_layouts/komut.html
..
linux-dersleri/assets/fonts/fontawesome-webfont.woff
.
linux-dersleri/assets/js/search.js
linux-dersleri/logo.svg
linux-dersleri/index.markdown
```

Standart şekilde listelemenin yanında ayrıca daha ayrıntılı bir
listeleme yapmak istersek `t` veya `—list` seçeneğine yani listeleme
seçeneğine ek olarak "verbose" seçeneğinin kısaltması olan `v` seçeneği
de komutumuza ekleyebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tvf linux-dersleri.tar                                                                                                                             
drwxr-xr-x taylan/taylan     0 2023-07-03 10:29 linux-dersleri/
drwx------ taylan/taylan     0 2023-07-03 10:29 linux-dersleri/_layouts/
-rw-r--r-- taylan/taylan  5103 2023-07-01 14:11 linux-dersleri/_layouts/tutorial.html
..
-rw-r--r-- taylan/taylan     3202 2023-06-08 14:51 linux-dersleri/assets/js/temel-linux.js
-rw-r--r-- taylan/taylan     4505 2023-07-01 14:12 linux-dersleri/assets/js/read.js
-rw-r--r-- taylan/taylan    10814 2023-06-30 12:08 linux-dersleri/assets/js/zooming.min.js
-rw-r--r-- taylan/taylan    36913 2023-06-29 12:28 linux-dersleri/logo.svg
-rw-r--r-- taylan/taylan     1919 2023-06-25 20:16 linux-dersleri/index.markdown
```

Bakın bu kez tıpkı `ls` komutunun `-l` seçeneğini kullandığımızda olduğu
gibi, arşiv dosyasının içindeki dosyaların yetkileri, sahibi, grubu ve
benzeri diğer tüm özellikleri yani ayrıntılı listesini aldık. Üstelik
içeriği görüntülemek için arşiv dosyasını dışarı çıkarmamız da
gerekmedi.

Bu yaklaşım sayesinde spesifik olarak aradığımız bir dosya varsa arşivi
dışarı çıkarmadan da konsol üzerinden rahatlıkla kontrol edebiliyoruz.
Ben örnek olarak "***index***" isimli bir dosya var mı diye kontrol
etmek üzere komutunun sonuna `| grep index` şeklinde eklemek istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tvf linux-dersleri.tar | grep index                                                                                                                
-rw-r--r-- taylan/taylan  1891 2023-06-16 14:53 linux-dersleri/komutlar/index.markdown
-rw-r--r-- taylan/taylan    2265 2023-06-25 18:49 linux-dersleri/blog/index.md
-rw-r--r-- taylan/taylan    84320 2022-02-23 20:24 linux-dersleri/assets/js/searchindex.js
-rw-r--r-- taylan/taylan     1919 2023-06-25 20:16 linux-dersleri/index.markdown
```

Bakın arşiv içindeki "***index***" dosyaları karşımıza geldi. Yani
ihtiyacımıza yönelik olarak `grep` aracını `tar` aracı ile birleştirip
istediğimiz sonucu elde edebildik. Neticede konsol üzerinden aldığımız
çıktılar akış halindeki verilerden ibaret. Bu metinsel verileri daha
önce öğrendiğiniz manipülasyon ve filtreleme yöntemleri ile istediğiniz
şekilde biçimlendirmek yani ihtiyaçlarınıza yönelik çözümleri bulmak
tamamen bizim elimizde.

Arşivi Dışarı Çıkarmak
----------------------

Arşivden çıkarma yaparken temelde iki farklı seçeneğe sahibiz. Birincisi
arşiv içeriğinin tamamını dışarı çıkarmak, diğer ise spesifik olarak
belirttiğimiz bazı dosya ve klasörleri dışarı çıkarmak. Öncelikle tüm
dosya içeriğini dışarı çıkarmayı deneyelim.

### Tüm Dosya İçeriğini Çıkarmak

Çıkarma işlemi için çıkarmak-ayıklamak anlamına gelen "e**x**tract"
seçeneğinin kısalması olan `x` seçeneğini kullanıyoruz. Eğer çıkarma
işlemi için `tar` aracına yalnızca bu seçeneği verirsek, arşiv
dosyasının içeriği mevcut bulunduğumuz dizine çıkarılır. Bu sebeple ben
öncelikle arşivi çıkaracağım "***linux***" isminde yeni bir klasör
oluşturmak istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ mkdir linux
```

Tamamdır şimdi arşiv içeriğini buraya çıkarmak için
`tar -xf linux-dersleri.tar -C linux/` şeklinde komutumuzu girelim. Eğer
buradaki büyük `-C` ile hedef arşiv içeriğinin çıkarılacağı hedef dizin
belirtmezsek, arşiv dosyası mevcut dizine çıkarılacak. Bu sebeple
spesifik dizin belirtirken `-C` seçeneğini mutlaka kullanmamız
gerekiyor. Ayrıca ben mevcut dizin altında oluşturduğum "***linux***"
klasörüne çıkardığım için yalnızca klasörün ismini girdim. Yani göreli
yol belirttim. Ancak siz eğer farklı bir dizine çıkaracaksanız, örneğin
diyelim ki "***/usr/share/doc***" dizini altında çıkarmak isterseniz
doğrudan bu dizinin adresin tam olarak buraya yazabilirsiniz. Zaten
buradaki `-C` seçeneği arşivin çıkarılacağı tam konumu belirtmemiz için
var. Hedef adresi doğru şekilde yazdığınız sürece ister göreli
isterseniz de kesin yolu belirtmeniz fark etmiyor.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf linux-dersleri.tar -C linux
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$
```

"verbose" yani ayrıntılı çıktı seçeneğini kullanmadığımız için işleme
dair konsolumuza herhangi bir çıktı bastırılmadı ama arşivin çıkarılmış
olması lazım. Teyit etmek için tüm alt dizinleri de görmek üzere `ls -R`
komutu ile özyinelemeli şekilde "***linux***" klasörünün içeriğini
kontrol edebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -R linux                                                                                                                                               
linux:
linux-dersleri

linux/linux-dersleri:
 404.html                                   'hakk'$'\302\215''nda.markdown'                   _plugins
'al'$'\302\215''st'$'\302\215''rmalar.webp'   _includes                                        _posts
 assets                                      index.markdown                                   public
 _authors                                   ''$'\302\200''izimler'                            questions.json
 bildirim.html                               kitap.webp                                        README.md
 blog                                        _komut                                           sistem-yonetim.webp
 _config.yml                                 komutlar                                         site
 _egitim                                     kurs.markdown                                   's'$'\302\215''kca-sorulan-sorular.markdown'
 egitim.markdown                             _layouts                                         telefon.webp
 etiketler.markdown                          linux-doc.webp                                    temel-linux.markdown
 feedback.webp                                linux-sistem-yonetimine-giris-egitimi.markdown   temel-linux.webp
 feedback-sended.webp                         logo.svg                                         test.markdown
 Gemfile                                     pagefind                                         video-egitim.webp
 Gemfile.lock                                pagefind.yml
 gizlilik.markdown                           panic.webp

linux/linux-dersleri/assets:
css  fonts  img  js
...
..
.
```

Bakın tüm arşiv içeriğinin hedef dizine yani "***linux***" klasörüne
sorunsuzca çıkarıldığını buradan görebiliyoruz.

İşte arşiv dosyasının tüm içeriğini dışarı çıkarmak bu kadar kolay.
Şimdi birkaç ayrıntıdan daha bahsetmek istiyorum. Örneğin arşiv
dosyasını spesifik bir hedef dizine çıkarmak için `-C` seçeneğini
kullanmak size pek akılda kalıcı ve pratik gelmediyse iki farklı
alternatif yaklaşımla da arşiv içeriğini istediğiniz bir dizine
çıkarabilirsiniz.

İlk yaklaşım, arşiv dosyasının içeriğini çıkarmak istediğimiz dizine
geçiş yapıp çıkarma işlemini bu dizin içinden gerçekleştirmek. `tar`
aracı, arşiv içeriğini varsayılan olarak komutun girildiği mevcut dosya
konumuna çıkardığı için biz hangi dizin içindeysek arşiv içeriği de bu
dizine çıkarılabiliyor. Örneğin ben "***Documents***" klasörü içine
çıkarmak istediğim için `cd Documents` komutu ile öncelikle bu dizine
geçiş yapıyorum. Şimdi tek yapmam gereken çıkarmak istediğim arşiv
dosyasını belirtmek.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cd ~/Documents/

┌──(taylan㉿linuxdersleri)-[~/Documents]
└─$ tar -xf ~/Downloads/linux-dersleri.tar

┌──(taylan㉿linuxdersleri)-[~/Documents]
└─$ ls -R linux-dersleri/                                                                                                                                     
linux-dersleri/:
 404.html                                   'hakk'$'\302\215''nda.markdown'                   _plugins
'al'$'\302\215''st'$'\302\215''rmalar.webp'   _includes                                        _posts
 assets                                      index.markdown                                   public
 _authors                                   ''$'\302\200''izimler'                            questions.json
 bildirim.html                               kitap.webp                                        README.md
 blog                                        _komut                                           sistem-yonetim.webp
 _config.yml                                 komutlar                                         site
 _egitim                                     kurs.markdown                                   's'$'\302\215''kca-sorulan-sorular.markdown'
 egitim.markdown                             _layouts                                         telefon.webp
 etiketler.markdown                          linux-doc.webp                                    temel-linux.markdown
 feedback.webp                                linux-sistem-yonetimine-giris-egitimi.markdown   temel-linux.webp
 feedback-sended.webp                         logo.svg                                         test.markdown
 Gemfile                                     pagefind                                         video-egitim.webp
 Gemfile.lock                                pagefind.yml
 gizlilik.markdown                           panic.webp

linux-dersleri/assets:
css  fonts  img  js
...
..
.
```

Bakın arşiv dosyasının tüm içeriği mevcut bulunduğu dizine sorunsuzca
çıkarılmış. Burada tek yaptığım, çıkarılacak arşiv dosyasının tam dizin
adresini eksiksiz şekilde belirtmek. Bunu yaptığımda zaten `tar` aracı
`-x` seçeneğinin varsayılan davranışı olarak mevcut bulunduğum dizin
altına bu arşiv içeriğini çıkarıyor.

### Spesifik Dosya ve Klasörleri Çıkarmak

Şimdiye kadar örneklerimizde hep arşiv dosyasının tüm içeriğini dışarı
çıkarmayı ele aldık. Fakat her zaman tüm içeriği çıkarmak
istemeyebiliriz. Yani spesifik olarak istediğimiz bazı dosya veya
klasörleri seçip, yalnızca bunların dışarı çıkarılmasını da
isteyebiliriz.

Fakat örneğimizden önce, karıştırmamak için "linux-dersleri" isimli
klasörü silelim ki, hangi dosyaları arşivden çıkardığımızı görebilelim.
Çünkü spesifik olarak belirteceğimiz dosyalar da yine
"***linux-dersleri***" isimli klasör altına çıkartılmış olacak.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rm -rd linux-dersleri
```

Hangi dosyaları çıkarmak istediğinize karar vermek için öncelikle `t`
seçeneği ile arşiv dosyasının içeriğini listeleyebilirsiniz. Ben örnek
olması için yalnızca "***index.markdown***" dosyasını, "***css***"
dizini altındaki "***style.css***" dosyasını ve "***js***" klasörünün
tamamını dışarı çıkarmak istiyorum. Bunun için bu dosyaların arşiv
dosyası içerisindeki tam konumunu belirtmem yeterli. Yani örneğin
"***index.markdown***" dosyasını çıkarmak için "***linux-dersleri***"
klasörünü de belirtmem gerekiyor çünkü dışarı çıkarmak istediğim bu
dosya, arşiv içinde tam olarak bu dizin atlında tutuluyor. Benzer
şekilde diğer tüm dosyalar da benim arşivimde alt klasörlerde
tutuluyorlar.

Örneğin tam dizin adresi belirtmeden
`tar -xf linux-dersler.tar index.markdown /js /css/style.css` şeklinde
komut girersek başarısız olacağız. Emin olmak için hemen deneyelim.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf linux-dersleri.tar index.markdown /js /css/style.css
tar: index.markdown: Not found in archive
tar: /js: Not found in archive
tar: /css/style.css: Not found in archive
tar: Exiting with failure status due to previous errors
```

Bakın belirttiğim dosya ve dizinlerin arşiv içinde bulunamadığına dair
uyarı aldım çünkü gerçekten de burada yazdığım şekilde tutulmuyorlar.
Tıpkı dizinlerde gezinirken dikkat ettiğimiz gibi bu dosyaların arşiv
içindeki dizin adreslerini tam olarak belirtmemiz gerekiyor. İstediğimiz
dosyaları çıkarmak için tek tek tüm dosya yollarını her bir dosya için
belirtebilir ya da daha önce öğrendiğimiz dosya ismi genişletme
karakteri olan yıldız karakterinden de faydalanabiliriz. Çok daha kolay
olduğu için ben genişletmeleri kullanmak istiyorum. Denemek için bu kez
komutumu `tar -xf linux-dersleri.tar *index.markdown */js *style.css`
şeklinde giriyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf linux-dersleri.tar *index.markdown */js */css/style.css                                                                                         
tar: Pattern matching characters used in file names
tar: Use --wildcards to enable pattern matching, or --no-wildcards to suppress this warning
tar: *index.markdown: Not found in archive
tar: Pattern matching characters used in file names
tar: Use --wildcards to enable pattern matching, or --no-wildcards to suppress this warning
tar: */js: Not found in archive
tar: Pattern matching characters used in file names
tar: Use --wildcards to enable pattern matching, or --no-wildcards to suppress this warning
tar: */css/style.css: Not found in archive
tar: Exiting with failure status due to previous errors
```

Bakın bu kez de burada argüman olarak yazdığımız dosya isimlerinde
örüntü işleme karakteri kullandığımızı ama `—wildcards` seçeneği ile bu
karakterlerin geçerli olmasını sağlayacak **wildcards** özelliğini
aktifleştirmediğimizi belirten bir çıktı aldık. Yani dosya ismi
genişletmesi için yıldız joker karakterini kullanacaksak komutumuza
`—wildcards` seçeneğini de eklememiz gerekiyormuş. Hatırlıyorsanız dosya
ismi genişletmesi için kullandığımız bu karakterlere "**wildcards**"
denildiğinden de özellikle bahsetmiştik. Şimdi birlikte deneyimlediğimiz
gibi hata çıktısında geçen **wildcards** ifadesinin ne demek olduğunu
bildiğimiz için sorunu çözebiliyoruz. Ben bu sebeple eğitimdeki tüm
anlatımların birbiri ile bağlantılı olduğu ve çok dikkatlice takip
etmeniz gerektiğini söylüyorum.

Her neyse şimdi komutumuzu tekrar çağırıp bu seçeneğini de ekleyelim.

``` {.bash}
tar --wildcards -xf linux-dersleri.tar *index.html */js *style.css
```

Bakın herhangi bir hata almadık. Yani komutumuz sorunsuzca çalışmış
olmalı.

Komutumun ardından tam olarak istediğim dosya ve klasörlerin çıktığını
teyit edebilmek için klasör içeriğini özyinelemeli olarak bastırmak
üzere ls -R linux-dersleri şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -R linux-dersleri                                                                                                                                    
linux-dersleri:
assets  index.markdown  komutlar

linux-dersleri/assets:
css  js

linux-dersleri/assets/css:
style.css

linux-dersleri/assets/js:
bootstrap.min.js            jquery1.min.js            read.js    searchindex.js  temel-linux.js
form-submission-handler.js  jquery-3.3.1.slim.min.js  script.js  search.js       zooming.min.js

linux-dersleri/komutlar:
index.markdown
```

Bakın tüm arşiv dosyasının içeriği değil, yalnızca benim belirtmiş
olduğum dosya ve klasörler dışarı çıkarılmış.

Eğitimi buraya kadar atlamadan adım adım takip eden herkesin buraya
girmiş olduğum komutu tam olarak anladığını düşünüyorum. Ama yine de çok
kısaca açıklamam gerekirse; "***index.markdown***" ve "***style.css***"
dosyalarının birer tane olduğunu bildiğim için başlarında yalnızca
yıldız dosya genişletme karakteri ile hangi alt dizinde olduklarını
belirtmeden bu dosyaların bulunmasını sağladım. Yani buradaki yıldız
joker karakteri bu dosyaların dizin adreslerine otomatik olarak
genişletildi. Bunun dışında "***js***" klasörünün tamamını dışarı
çıkarmak istediğim için `*/js` komutu ile bu klasör ismiyle eşleşen
dizinin de otomatik olarak bulunup çıkarılmasını sağlamış oldum.

Sizler de bu şekilde spesifik olarak dışarı çıkarılmasını istediğiniz
içerikleri belirtebilirsiniz. Dışarı çıkarma işleminde dikkat etmeniz
gereken tek husus, çıkarmak istediğiniz dosyanın veya dizinin arşiv
içindeki tam adresini belirtmeniz.

Arşivleme konusunda son olarak mevcut arşiv içeriğine nasıl yeni dosya
ekleyip çıkarabileceğimizden bahsetmek istiyorum. Daha sonra sıkıştırma
işlemlerinden bahsedebiliriz.

Arşive Yeni Dosya Eklemek
-------------------------

Arşive yeni dosya eklemek için öncelikle yeni bir dosya oluşturalım.
Basit şekilde içeriği dolu bir dosya oluşturmak için
`echo “deneme” > metin.txt` şeklinde komutumu girebilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ echo "deneme" > metin.txt
```

Dosyamı oluşturdum. Şimdi bu dosyayı mevcut arşive eklemek için `r`
seçeneğini ya da uzun haliyle `—append` seçeneğini kullanabiliriz. Ben
daha akılda kalıcı olduğu için `—append` yani "ekleme" seçeneğini tercih
ediyorum. Dosyamı eklemek için komutumu
`tar —append -f linux-dersleri.tar metin.txt` şeklinde giriyorum.

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar --append -f linux-dersleri.tar metin.txt 

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tf linux-dersleri.tar | grep metin.txt
metin.txt
```

`grep` ile filtreleyerek bizzat teyit ettiğimiz gibi yeni eklediğim
dosya burada, yani yeni dosya eklemeyi başardık. Dilerseniz benzer
şekilde klasör de ekleyebilirsiniz.

Bu şekilde bir veya birden fazla dosya ve klasörü mevcut bir arşiv
içerisine istediğiniz zaman ekleyebiliyoruz. Tek yapmamız gereken,
eklemek istediğimi dosya veya dizinin tam adresini belirtmek.

Arşivden Dosya Silmek
---------------------

`tar` aracıyla mevcut arşivdeki bir dosya veya klasörü silmek için
`—delete` seçeneğini kullanıyoruz. Bu seçeneğin kısaltması yok, zaten bu
şekilde daha akılda kalıcı bir seçenek.

Ben arşive en son eklemiş olduğum "***metin.txt***" dosyasını silmek
istediğim için komutumu `tar -f linux-dersleri.tar —delete metin.txt`
şeklinde yazıyorum. Eğer istersek
`tar —delete -f linux-dersleri.tar metin.txt` komutuyla da silebiliriz.
Silme işlemi için de tam olarak silinecek içeriğin konumunu belirtmemiz
gerekiyor. Ben yalnızca üst dizindeki "***metin.txt***" dosyasını silmek
istediğim için buraya yalnızca `metin.txt` şeklinde yazıyorum ve
komutumu onaylıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -f linux-dersleri.tar --delete metin.txt
```

Tamamdır, bu dosyanın arşivden silinmiş olması gerekiyor. Şimdi tekrar
`tar -tf linux-dersleri.tar | grep “metin.txt”` komutu ile arşiv
dosyasının içeriğini `grep` ile filtreleyelim.

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -tf linux-dersleri.tar | grep metin.txt

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$
```

Gördüğünüz gibi `grep` aracı "**metin.txt**" ile eşleşme bulamadı yani
bu çıktılardan "***metin.txt***" dosyasının silindiğini görebiliyoruz.
Normalde burada listeleniyordu. Ben yalnızca dosya silmeyi ele aldım ama
aynı şekilde istediğiniz dosya ve klasörleri silmekte özgürsünüz.

Bence tüm işlemler son derece kolay.

Neticede arşivleme hakkında bilmemiz gereken tüm temel pratiklerden
bahsetmiş olduk. Yani artık konsol üzerinden kendi arşivlerinizi
oluşturup içeriğini dilediğiniz gibi düzenleyerek gerektiğinde arşiv
içeriğini dışarı aktarabilecek bilgiye sahipsiniz. Tek ihtiyacınız biraz
pratik yapmak. Pratik yaptıkça zaten ne kadar kolay olduğunu bizzat
deneyimleyeceksiniz.

Arşivleme işlemi tek başına son derece kullanışlı olsa da, sıkıştırma
işleminin sağladığı avantajlar dolayısıyla çoğu zaman arşivleri
sıkıştırmaya da ihtiyacımız oluyor. Bu sebeple anlatımlarımıza
sıkıştırma işlemlerinden bahsederek devam etsek hiç fena olmaz.

Sıkıştırma
----------

Çeşitli teknikler uygulanarak verilerin geri döndürülebilir ve depolama
alanından tasarruf sağlayacak biçimce sıkıştırılması işlemine genel
olarak "sıkıştırma" deniyor. Tabii ki sıkıştırma işlemi sonrasında
mevcut depolama alanından tasarruf edebilmenin yanı sıra, sıkıştırılmış
dosyalar taşınırken bellek ve ağ trafiğinde daha az yük oluşturuyor.
Dolayısıyla sıkıştırma işlemi söz konusu sistem yönetimi olduğunda pek
çok yönden oldukça yararlı bir çözüm. Üstelik sıkıştırmadan yararlanmak
için, sıkıştırma işleminin teknik olarak nasıl çalıştığını bilmemiz
gerekmiyor. Zaten burada tek bir sıkıştırma algoritmasından da
bahsetmeyeceğimiz için teknik ayrıntıların içinden çıkamayız.

Pek çok alternatif var dedik, tabii ki her birinin de kendi içinde
avantaj ve dezavantajları olduğu için hangi sıkıştırma yönetimini
kullanacağınız tamamen ihtiyaçlarınızın ne olduğuyla ilgili. Biz
sıkıştırma işlemini anlayabilmek ve tanıyabilmek için öncelikle Linux
üzerinde en yaygın kullanıma sahip olan gzip ve bzip2 sıkıştırma
algoritmalarından bahsederek başlayabiliriz.

Sıkıştırma algoritmalarını dosyalarımız üzerinde kullanabilmemiz için
algoritmaların isimleriyle temsil edilen çeşitli araçlar bulunuyor.
Örneğin `gzip` algoritmasını kullanmak için `gzip` isimli aracı
kullanıyorken `bzip2` algoritması için de `bzip2` isimli aracı
kullanabiliyoruz.

`gzip`
------

`gzip` aracı nerdeyse hemen her Linux dağıtımında **gzip** sıkıştırma
algoritmasından faydalanabilmemiz için varsayılan olarak yüklü geliyor.
Araç sayesinde mevcut verileri sıkıştırıp, sıkıştırılmış verilerimizi de
orijinal boyutlarına geri dönüştürebiliyoruz.

Ben hemen basit bir örnek olması için daha önce oluşturduğum
"***linux-dersleri.tar***" isimli arşiv dosyamı **gzip** ile sıkıştırmak
istiyorum.

Öncelikle arşiv dosyasının sıkıştırılmadan önceki boyutunu öğrenmek için
`ls -sh linux-dersleri.tar` komutunu girelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh linux-dersleri.tar 
141M linux-dersleri.tar
```

Şimdi sıkıştırıp dosya boyutundaki değişimi kıyaslayalım. Dosyaları
sıkıştırmak için tek yapmamız gereken `gzip` komutundan sonra
sıkıştırılmasını istediğimiz dosyaları argüman olarak belirtmek.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip linux-dersleri.tar 

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$
```

Tamamdır sıkıştırma işleminin tamamlanmış olması gerekiyor. Hemen
`ls -sh` komutu ile mevcut dizini listeleyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh
total 266M
   0 a              0 b     0 e     0 h     0 k      4.0K linux-dersleri         4.0K metin.txt     0 p     0 s     0 v     0 y
 20K alfabe.tar     0 c     0 f     0 i     0 l      125M linux-dersleri.tar.gz     0 n             0 q     0 t     0 w     0 z
141M arsiv2.tar     0 d     0 g     0 j  4.0K linux     0 m                         0 o             0 r     0 u     0 x
```

Bakın buradaki çıktılardan, "***linux-dersleri.tar***" isimli arşiv
dosyamın "***linux-dersleri.tar.gz***" olarak değiştiğini ve önceki
boyutu ile kıyasladığımda bir miktar sıkıştırıldığını da teyit
edebiliyorum. Önceki boyutu 141M, sıkıştırıldıktan sonraki boyutu ise
125M. Neticede gördüğünüz gibi arşiv dosyamı `gzip` aracı ile
sıkıştırmış oldum.

Bu arada yanlış anlaşılma olmasın yalnızca arşiv dosyası sıkıştırmak
zorunda değiliz. İstediğimiz türdeki bir veya birden fazla dosyayı
sıkıştırmamız da mümkün. Mesela örnek olarak ben markdown dosyasını
sıkıştırmak istiyorum. Daha önce dışarı çıkardığım
"***linux-dersleri***" klasörü içinde "***index.markdown***" dosyası
vardı. Bu dizine geçiş yapıp dosya boyutunu öğrenmek için `ls -sh`
şeklinde komut girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/linux-dersleri]
└─$ ls -sh
total 12K
4.0K assets  32K index.markdown  4.0K komutlar
```

Bakın "***index.markdown***" dosyası 32K gözüküyor. Bu dosyanın
sıkıştırılmadan önceki boyutu. Şimdi dosyayı sıkıştırmak üzere
`gzip index.markdown` komutunu girebiliriz. Fakat komutumu bu şekilde
girmeden önce, sıkıştırma işleminden sonra orijinal dosyayı nasıl
koruyabileceğimize de çok kısaca değinmek istiyorum.

Orijinal Dosyayı Korumak
------------------------

Bir önceki örneğimizde arşiv dosyasını sıkıştırırken sizin de bizzat
şahit olduğunu gibi sıkıştırma işlemi doğrudan orijinal dosyanın
üzerinde uygulanmıştı. Bu sebeple sıkıştırma işlemi sonucunda geriye
yalnızca sıkıştırılmış dosya kalıyor. Ancak `gzip` aracının dosyayı
sıkıştırırken orijinal dosyayı kullanıyor olmasını kimi zaman
istemeyebiliriz. Ben hem orijinal dosya korunsun hem de sıkıştırılmış
bir versiyonu oluşturulsun istediğim için `-k` seçeneği ile `keep` yani
orijinal dosyanın "korunması" özelliğini de aktifleştirmek istiyorum.

Bunun için komutumu `gzip -k index.markdown` şeklinde giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/linux-dersleri]
└─$ ls -sh                                                                                                                                                  
total 44K
4.0K assets   32K index.markdown  4.0K index.markdown.gz  4.0K komutlar
```

Bakın orijinal dosya ve sıkıştırılmış versiyonu listelenmiş oldu. Yani
`keep` seçeneği sayesinde orijinal dosyanın korunurken, sıkıştırılmış
dosyanın sonuna da **.gz** uzantısı getirildiğiniz görebiliyoruz. Ayrıca
bakın dosyamın boyutu 32 K'dan 4 K'a kadar sıkıştırılarak düşürülmüş.
İşte sizler de tıpkı bu iki örneğimizde olduğu şekilde istediğiniz
türdeki dosyaları sıkıştırabilirsiniz.

Ayrıca ben örnekleri hep tek bir dosya üzerinden gösterdim ancak sizler
aynı anda birden fazla dosya ismini belirterek ayrı ayrı her birinin
sıkıştırılmalarını da sağlayabilirsiniz. Sıkıştırma işlemi bu şekilde.

Sıkıştırılmış gzip Dosyaların Açılması
--------------------------------------

Sıkıştırmış olduğumuz dosyaları orijinal boyutuna geri çevirmek için de
tek yapmamız gereken "**d**ecompress" ifadesinin kısalması olan `-d`
seçeneğini kullanmak.

Örnek olması için ben daha önce sıkıştırmış olduğum arşiv dosyasını eski
haline getirmek istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                                                                                  
total 266M
   0 a              0 b     0 e     0 h     0 k      4.0K linux-dersleri         4.0K metin.txt     0 p     0 s     0 v     0 y
 20K alfabe.tar     0 c     0 f     0 i     0 l      125M linux-dersleri.tar.gz     0 n             0 q     0 t     0 w     0 z
141M arsiv2.tar     0 d     0 g     0 j  4.0K linux     0 m                         0 o             0 r     0 u     0 x
```

Bakın isminin sonunda **.gz** uzantısı bulunan arşiv dosyam burada
bulunuyor ve sıkıştırılmış boyutu da burada açıkça yazıyor. Bu dosyayı
orijinal boyutuna dönüştürmek için `gzip -d linux-dersleri.tar.gz`
şeklinde komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip -d linux-dersleri.tar.gz
```

Sıkıştırılmış olan verilerin açılması yani orijinal haline
dönüştürülmesi sıkıştırma işleminden çok daha kısa sürdüğü için işlem
anında tamamlanacaktır. Şimdi teyit etmek için `ls -sh` ile dizinimizi
bir daha listeleyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                                                                                  
total 281M
   0 a              0 b     0 e     0 h     0 k      4.0K linux-dersleri      4.0K metin.txt     0 p     0 s     0 v     0 y
 20K alfabe.tar     0 c     0 f     0 i     0 l      141M linux-dersleri.tar     0 n             0 q     0 t     0 w     0 z
141M arsiv2.tar     0 d     0 g     0 j  4.0K linux     0 m                      0 o             0 r     0 u     0 x
```

Bakın sıkıştırmış olduğum arşiv dosyası orijinal boyutuna geri dönmüş ve
gördüğünüz gibi **gzip** algoritması ile sıkıştırıldığını temsil eden
**.gz** uzantısı da kaldırılmış. Yani aslında sıkıştırmış olduğumuz
dosyayı `-d` seçeneği sayesinde sorunsuzca eski haline getirmiş olduk.

Ben örneklerimde kullanmadım ancak `gzip` aracını kullanırken tüm
işlemler sırsında işlemlerin detaylarını takip etmek için isterseniz
**verbose** seçeneğinin kısalması olan `v` seçeneğini de komutunuza
ekleyebilirsiniz. Bir sonraki örneğimizde verbose seçeneğini de
kullanabiliriz.

Bir sonraki örneğimizi de özyinele özelliğinden bahsetmek için
uygulayabiliriz mesela. Fakat özyineleme yaklaşımından önce sıkıştırma
işlemlerinin her bir dosyada ayrı ayrı uygulandığına vurgu yapmamız
gerekiyor. Biz `gzip` aracına sıkıştırması için aynı anda birden fazla
dosyayı argüman olarak verdiğimizde her bir dosya ayrı ayrı
sıkıştırılıyor.

Denemek için mevcut bulunduğum dizindeki a'dan z'ye kadar olan tüm
dosyaları sıkıştırabiliriz. Öncelikle klasör içeriğini listeleyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                                                                                  
total 281M
   0 a              0 b     0 e     0 h     0 k      4.0K linux-dersleri      4.0K metin.txt     0 p     0 s     0 v     0 y
 20K alfabe.tar     0 c     0 f     0 i     0 l      141M linux-dersleri.tar     0 n             0 q     0 t     0 w     0 z
141M arsiv2.tar     0 d     0 g     0 j  4.0K linux     0 m                      0 o             0 r     0 u     0 x
```

Şimdi bu dosyaların hepsini arşivlemek üzere `gzip {a..z}` şeklinde
komut girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip {a..z}                                                                                                                                             

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                                                                                  
total 282M
4.0K a.gz        4.0K b.gz  4.0K e.gz  4.0K h.gz  4.0K k.gz   4.0K linux-dersleri      4.0K m.gz  4.0K p.gz  4.0K s.gz  4.0K v.gz  4.0K y.gz
 20K alfabe.tar  4.0K c.gz  4.0K f.gz  4.0K i.gz  4.0K l.gz   141M linux-dersleri.tar  4.0K n.gz  4.0K q.gz  4.0K t.gz  4.0K w.gz  4.0K z.gz
141M arsiv2.tar  4.0K d.gz  4.0K g.gz  4.0K j.gz  4.0K linux  4.0K metin.txt           4.0K o.gz  4.0K r.gz  4.0K u.gz  4.0K x.gz
```

Bakın her dosya ayrı ayrı sıkıştırılmış. Bu ayrı ayrı sıkıştırma işlemi
dolayısıyla zaten bizler doğrudan bir klasörü sıkıştırmak üzere komut
giremiyoruz. Çünkü klasörler kendi içlerinde birden fazla dosya ve alt
klasörü barındırdığı için tek bir klasörün sıkıştırılması mümkün
olmuyor. Klasörleri sıkıştırmak istiyorsak öncelikle ilgili klasörü
arşiv dosyası formuna getirip, bu tekil dosyayı **gzip** gibi bir
algoritma ile sıkıştırmamız mümkün oluyor.

Klasörlerin doğrudan sıkıştırılamadığını teyit etmek için `mkdir test`
komutu ile yeni bir klasör oluşturup `mv {a..z}.gz test` komutu ile
dosyaları bu klasör altına taşıyalım ve `gzip test` komutu ile klasörü
sıkıştırmayı deneyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ mkdir test                                                                                                                                              

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ mv {a..z}.gz test                                                                                                                                       

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip test                                                                                                                                               
gzip: test is a directory -- ignored
```

Bakın `gzip` aracı argüman olarak verdiğimiz ifadenin dizin olması
sebebiyle bize hata döndürdü. Yani bizzat teyit ettiğimiz gibi klasörler
üzerinde doğrudan sıkıştırma işlemi yapamıyoruz. Eğer bir klasörü
sıkıştırmak istiyorsanız öncelikle o klasörü bir arşiv dosyasına
dönüştürmeniz gerekiyor.

Özyineleme
----------

Fakat amacınız doğrudan bir klasörü sıkıştırmak yerine, klasör içindeki
alt dizinler de dahil tüm dosyası ayrı ayrı sıkıştırmaksa bunu
"recursive" yani "özyineleme" seçeneği ile gerçekleştirebilirsiniz.

Özyineleme ifadesinin ne anlama geldiğiniz zaten birçok kez
deneyimledik. Şimdi bir klasör içeriğini özyinelemeli olarak
sıkıştırmayı deneyebiliriz. `gzip` aracı özyineleme özelliği için
"**r**ecursive" ifadesinin kısaltmasından gelen `r` seçeneğini
kullanmamızı istiyor. Ben daha önce birkaç dosya ve klasörünü dışarı
çıkardığım "***linux-dersleri***" klasörü içindeki tüm dosyaları
özyinelemeli olarak sıkıştırmak istiyorum. Sıkıştırma işleminden önce
dizin içeriğini özyinelemeli olarak bastırmak üzere
`ls -R linux-dersleri` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -R linux-dersleri                                                                                                                                    
linux-dersleri:
assets  index.markdown  index.markdown.gz  komutlar

linux-dersleri/assets:
css  js

linux-dersleri/assets/css:
style.css

linux-dersleri/assets/js:
bootstrap.min.js            jquery1.min.js            read.js    searchindex.js  temel-linux.js
form-submission-handler.js  jquery-3.3.1.slim.min.js  script.js  search.js       zooming.min.js

linux-dersleri/komutlar:
index.markdown
```

Bakın alt dizinlerde de dahil birden çok dosya bulunuyor. Şimdi bunları
ayrı ayrı sıkıştırmak için `gzip -r linux-dersleri/` şeklinde komutumuzu
girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip -r linux-dersleri                                                                                                                                  

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -R linux-dersleri                                                                                                                                    
linux-dersleri:
assets  index.markdown.gz  komutlar

linux-dersleri/assets:
css  js

linux-dersleri/assets/css:
style.css.gz

linux-dersleri/assets/js:
bootstrap.min.js.gz            jquery1.min.js.gz            read.js.gz    searchindex.js.gz  temel-linux.js.gz
form-submission-handler.js.gz  jquery-3.3.1.slim.min.js.gz  script.js.gz  search.js.gz       zooming.min.js.gz

linux-dersleri/komutlar:
index.markdown.gz
```

Bakın alt dizindekiler de dahil tüm dosyalar ayrı ayrı sıkıştırılmışlar.

Bu sıkıştırılan dosyaları tekrar orijinal hallerine çevirmek için de
yine özyineleme seçeneğiyle "decompress" seçeneğini birlikte
kullanabiliriz. Hatta işlemlerin detaylarını görmek için `v` seçeneğini
de ekleyebiliriz. Ben `gzip -vdr linux-dersleri/` şeklinde komutumu
giriyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip -vdr linux-dersleri/
linux-dersleri/komutlar/index.markdown.gz:       49.6% -- replaced with linux-dersleri/komutlar/index.markdown
linux-dersleri/index.markdown.gz:        96.5% -- replaced with linux-dersleri/index.markdown
linux-dersleri/assets/css/style.css.gz:  76.2% -- replaced with linux-dersleri/assets/css/style.css
linux-dersleri/assets/js/bootstrap.min.js.gz:    73.5% -- replaced with linux-dersleri/assets/js/bootstrap.min.js
linux-dersleri/assets/js/read.js.gz:     74.2% -- replaced with linux-dersleri/assets/js/read.js
linux-dersleri/assets/js/search.js.gz:   77.0% -- replaced with linux-dersleri/assets/js/search.js
linux-dersleri/assets/js/script.js.gz:   67.9% -- replaced with linux-dersleri/assets/js/script.js
linux-dersleri/assets/js/zooming.min.js.gz:      68.5% -- replaced with linux-dersleri/assets/js/zooming.min.js
linux-dersleri/assets/js/temel-linux.js.gz:      58.7% -- replaced with linux-dersleri/assets/js/temel-linux.js
linux-dersleri/assets/js/jquery-3.3.1.slim.min.js.gz:    65.7% -- replaced with linux-dersleri/assets/js/jquery-3.3.1.slim.min.js
linux-dersleri/assets/js/jquery1.min.js.gz:      66.0% -- replaced with linux-dersleri/assets/js/jquery1.min.js
linux-dersleri/assets/js/searchindex.js.gz:      65.1% -- replaced with linux-dersleri/assets/js/searchindex.js
linux-dersleri/assets/js/form-submission-handler.js.gz:  64.4% -- replaced with linux-dersleri/assets/js/form-submission-handler.js
```

Bakın sıkıştırılma oranlarından orijinal boyuta dönüşümlerine dair
ayrıntılı çıktımızı almış olduk. Bu ayrıntılar komutumuza eklediğimiz
"verbose" seçeneği sayesinde bastırıldı. Sıkıştırma işlemi sırasında da
aynı şekilde sıkıştırma oranlarını takip etmek için verbose seçeneğini
komutunuza ekleyebilirsiniz.

Dosyalarımın sorunsuzca eski hallerine çevrildiklerini buradaki
çıktılardan görebiliyorum ama yine de emin olmak için tekrar
`ls -R linux-dersleri` komutunu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -R linux-dersleri                                                                                                                                    
linux-dersleri:
assets  index.markdown  komutlar

linux-dersleri/assets:
css  js

linux-dersleri/assets/css:
style.css

linux-dersleri/assets/js:
bootstrap.min.js            jquery1.min.js            read.js    searchindex.js  temel-linux.js
form-submission-handler.js  jquery-3.3.1.slim.min.js  script.js  search.js       zooming.min.js

linux-dersleri/komutlar:
index.markdown
```

Bakın tüm dosyalar sıkıştırılmadan önceki hallerine geri dönmüşler.

Benim temel sıkıştırma ve sıkıştırılmış içerikleri orijinal boyutuna
geri çevirmeyle yani "dekompres" işlemiyle ilgili bahsetmek istediklerim
bu kadar. Buradan öğrendiklerinizle dosyalarınızı **gzip**
algoritmasıyla kolayca sıkıştırabilirsiniz.

Yine de temel kullanım dışında sıkıştırma işlemiyle ilgili bahsetmek
istediğim birkaç ek kullanım detayı daha bulunuyor. Örneğin sıkıştırma
seviyesini özellikle belirtebiliriz.

Sıkıştırma Seviyeleri
---------------------

Sıkıştırma ve eski haline getirmeyi öğrendik. Ancak sıkıştırma seviyesi
kavramından henüz bahsetmedik. Biz aksini belirtmediğimiz için şimdiye
kadar ele aldığımız örneklerde hep standart olan 6. kademe sıkıştırma
uygulandı. Normalde **gzip** üzerinde 1'den 9'a kadar sıkıştırma
seviyeleri bulunuyor. İlk kademe en az sıkıştırmayı uygulayıp işlemi
hızlıca bitiyorken, seviye yükseldikçe sıkıştırma oranı artarken işlem
süresi de uzuyor. Sıkıştırılmış dosyalar açılırken ise tersi şekilde,
çok sıkıştırılan daha çabuk, az sıkıştırılan daha yavaş olacak şekilde
açılıyor.

Peki bu sıkıştırma seviyelerini nasıl belirtebiliriz ?

Çok basit, tek yapmamız gereken `gzip` komutunun ardından tire
işaretinin peşine istediğimiz sıkıştırma seviyesini belirtmek.

Örneğin standart bir sıkıştırma yerine maksimum sıkıştırma oranını
istiyorsanız `gzip -9 sıkıştırılacak_dosya` şeklinde komut girmeniz
gerekiyor. Tersi şekilde yani örneğin hızlı ama az sıkıştırılmasını
istiyorsak `gzip -1 sıkıştırılacak_dosya` şeklinde komutumuzu
girebiliriz.

Ben şimdi sıfırdan standart, düşük ve en yüksek sıkıştırma seviyelerin
hepsini deneyip süre ve sıkıştırma oranlarını test etmek istiyorum.
Ancak baştan belirteyim, sıkıştıracağım dosyanın boyutu çok büyük
olmadığı için süre ve sıkıştırma oranı bakımından çok büyük farklılıklar
görmeyeceğiz. Anlatımın devamında daha kapsamlı bir testten bahsedeceğim
biz yine de kendimiz için ufak bir test gerçekleştirelim.

Süreyi ölçmek için `time` komutunu kullanacağım. `time` komutu sayesine,
`time` komutunun ardından belirtilmiş olan komutun çalışma süresi
hakkında bilgi edinebiliyoruz. Bu sayede işlemlerin ne kadar sürdüğünü
konsol üzerinden öğrenebileceğiz. Ayrıca diskin okuma yazma hızından
etkilenmemesi için bu sıkıştırılmış dosyaları geçici dizin olan
***/tmp*** dizinine yönlendiriyor olacağım. Bu sayede daha şeffaf bir
zaman testi sağlayabiliriz. Öncelikle sıkıştırmak istediğim
***linux-dersleri.tar*** dosyasını ***/tmp*** dizinine kopyalamak
istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cp linux-dersleri.tar /tmp/

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cd /tmp/
```

Sıkıştırılmış dosyaların bizim istediğimiz bir isimde kaydolması için
`gzip` aracının `c` seçeneğini kullanabiliriz. Buradaki `c` seçeneği,
sıkıştırılmış verilerin standart çıktıya yönlendirilmesi sağlıyor. Biz
de standart çıktıyı istediğimiz bir dosya ismiyle kaydedebiliriz.

Ayrıca işlem süresini öğrenmek için `time` aracını kullanacağım fakat
kafanız karışmasın, bu araç `gzip` aracını bir parçası değil. Yalnızca
zamanı ölçebilmemiz konusunda bize yardımcı olacak.

Ben olarak standart seviye olan 6. seviyeyi test etmek üzere:

`time gzip -c linux-dersleri.tar > standart.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -c linux-dersleri.tar > standart.tar.gz

real    0m5.570s
user    0m4.867s
sys     0m0.699s
```

Bakın işlemin ne kadar sürdüğü burada yazıyor.

Şimdi en hızlı ama en az sıkıştırmayı uygulayan 1. seviyeyi test etmek
üzere:

`time gzip -1 -c linux-dersleri.tar > en-az.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -1 -c linux-dersleri.tar > en-az.tar.gz

real    0m5.210s
user    0m4.245s
sys     0m0.962s
```

Son olarak da **gzip** algoritması için en yüksek sıkıştırmayı uygulayan
ama yavaş olan -9 seviyeyi deneyelim.

`time gzip -9 -c linux-dersleri.tar.gz > en-cok.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -9 -c linux-dersleri.tar > en-cok.tar.gz

real    0m5.884s
user    0m5.886s
sys     0m0.000s
```

Evet bakın en nihayetinde işlemlerin sonunda hangisinin ne kadar süre
tuttuğunu görebiliyoruz. Buradaki rakamlar sıkıştırılan dosyaya ve
sistemin özelliklerine göre değişkenlik gösterse de bize çok kabaca
fikir veriyor. Dosya boyutu çok küçük olduğu için istatistikler net
değil ancak kıyaslayabilmek için "user" olarak geçen buradaki zamana
yani işlemin gerçekleşmesi için harcanan "cpu" zamanına bakabiliriz. En
yüksek sıkıştırma seviyesi yani en fazla sıkıştırma uygulayan seviye en
uzun sürede oluşturulmuşken, en düşük seviye en hızlı tamamlanan işlem
olmuş. Buradaki standart seviye olan 6 seviye **gzip** algoritmasının en
optimum seviyesi olduğu için hem sıkıştırma hem de zaman bakımından
ortama olarak gayet ideal bir oran gösteriyor. Özellikle dosyanın boyutu
küçük olduğu için standart sıkıştırma oranı da süre bakımından en düşük
sıkıştırma yapan 1 oranı ile de yarışır düzeyde hızlı. Yani buradaki
çıktılar kafanızı karıştırmasın. Az sıkıştırma işlemi normalde daha kısa
sürerken, sıkıştırma oranı arttıkça işlem süresi de uzuyor. Elbette bu
rakamlar sıkıştırılan dosyaların boyutları ve türlerine ve testin
yapıldığı sistem özelliklerine göre değişkenlik gösterebilir ancak sizde
de aşağı yukarı tıpkı bende olduğu gibi bir fark oluşacaktır.

Süreler hakkında konuştuk. Şimdi bir de sıkıştırma oranlarına göz atmak
için `gzip` aracının sıkıştırma oran istatistiklerini sunan `l`
seçeneğini kullanalım. Ben tüm dosyaları tek seferde kontrol etmek üzere
`gzip -l *.gz` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ gzip -l *.gz
         compressed        uncompressed  ratio uncompressed_name
          131630297           147271680  10.6% en-az.tar
          130785192           147271680  11.2% en-cok.tar
          130837086           147271680  11.2% standart.tar
          393252575           441815040  11.0% (totals)
```

Evet bakın hem ayrı ayrı hem de toplam sıkıştırılma istatistiklerini
aldık. Tabloya bakacak olursak hızlı olan seviyede en az sıkıştırma
yapılmışken, yavaş olan 9 seviyede en yüksek sıkıştırma miktarı
uygulanmış olduğunu görebiliyoruz. Standart seviye ile en çok
sıkıştırmayı uygulayan seviye oran bakımından aynı gözükse de buradaki
ayrıntılı boyuttan en çok sıkıştırma sunan seviyenin biraz daha küçük
olduğunu görebiliyoruz.

Başta da belirttiğim gibi aslında uyguladığımız bu test çok basit ve
yetersiz bir test ancak yine de sıkıştırma oranları ve süresi hakkında
aşağı yukarı bize fikir verebilir. Örneğin süre testini sıkıştırılmış
dosyaları açma işlemleri için de gözlemleyebiliriz ancak dosya boyutu
küçük olduğu için dikkate değer bir fark oluşturmayacaktır. Yine de
dosyaları açıp daha önce belirttiğim ters orantıyı gözlemeye çalışalım.
`time gzip -d` komutundan sonra dosyanın ismini girmemiz yeterli. Ben
ayrı ayrı zaman istatistiklerini öğrenmek için sırasıyla tüm dosyalar
için komutumu ayrı ayrı girmek istiyorum.

`time gzip -d en-az.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -d en-az.tar.gz 

real    0m2.073s
user    0m0.890s
sys     0m1.182s
```

`time gzip -d standart.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -d standart.tar.gz                                                                                                                            

real    0m1.156s
user    0m0.857s
sys     0m0.298s
```

`time gzip -d en-cok.tar.gz`

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ time gzip -d en-cok.tar.gz 

real    0m1.095s
user    0m0.825s
sys     0m0.266s
```

**ℹ️ Not:** Tüm işlemleri `c` seçeneği ile standart çıktıdan farklı bir
dosya ismi olarak kaydettiğimiz için "keep" `k` seçeneğini kullanmadan
orijinal dosyanın içeriğinin korunmasını sağladık.

Tüm dosyası açtık. Buradaki "user" zamanına bakacak olursak, bakın en
çok sıkıştırılan dosyanın çok daha çabuk açıldığını görebiliyoruz. Dosya
boyutu ve test ortamı çok sağlıklı olmasa da neticede bu çıktıyla
birlikte daha önce belirtmiş olduğumuz sıkıştırma ve açma sürelerinin
seviyelere göre değişimini bizzat test etmiş olduk. Gerçekleştirdiğimiz
test her ne kadar basit bir gözlem imkanı sağlasa da elbette bu
sıkıştırma oranları ve süresi özellikle büyük veya çok sayıdaki dosyanın
üzerinde uygulanırken önem kazanıyor. Neyse anlatımın sonlarında bu
konunun üzerinde ayrıca duracağım. Şimdi **gzip** kadar popüler olan
**bzip2** sıkıştırma algoritmasından bahsederek devam edelim.

`bzip2`
-------

`bzip2` aracı **bzip2** sıkıştırma algoritmasını kullanabilmemizi
sağlayan bir araç.

Aslında `bzip2` aracının kullanımını özellikle ele almamız gerek yok
çünkü `gzip` ile neredeyse tamamen aynı. `gzip` aracında bahsettiğimiz
temel işlemler için kullanılan seçenekleri `bzip2` üzerinde de aynen
uygulayabiliyoruz.

Örneğin `bzip2 dosya adı` şeklinde komut girdiğimizde ilgili dosya
sıkıştırılıp dosya isminin sonuna da **.bz2** uzantısı ekleniyor.

Benim şu an çalıştığım dizinde ***linux-dersleri.tar*** isimli arşiv
dosyam mevcut.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls -sh
total 562M
141M en-az.tar  141M en-cok.tar  141M linux-dersleri.tar  141M standart.tar
```

Ben bu arşiv dosyasını **bzip2** ile sıkıştırmak için
`bzip2 linux-dersleri.tar` şeklinde dosyamın ismini giriyorum.
Sıkıştırılması için biraz beklememiz gerekecek.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ bzip2 linux-dersleri.tar
```

Sıkıştırma tamamlandı, `ls -sh` komutu ile listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls -sh                                                                                                                                                  
total 547M
141M en-az.tar  141M en-cok.tar  125M linux-dersleri.tar.bz2  141M standart.tar
```

Bakın dosyanın isminin sonuna **.bz** uzantısı eklenmiş ve dosya
sıkıştırılmış.

Sıkıştırılmış bzip2 Dosyaların Açılması
---------------------------------------

Şimdi sıkıştırılmış olan dosyayı eski haline getirelim. Bunun için
"decompress" ifadesinin kısalmasından gelen `d` seçeneğini
kullanabiliriz. `bzip2 -d linux-dersleri.tar.bz2` şeklinde komutu
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ bzip2 -d linux-dersleri.tar.bz2                                                                                                                         

┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls -sh                                                                                                                                                  
total 562M
141M en-az.tar  141M en-cok.tar  141M linux-dersleri.tar  141M standart.tar
```

Bakın dosyam eski haline geri döndü.

Eğer orijinal dosya korunsun harici olarak sıkıştırılmış versiyonu
oluşturulsun istiyorsak **gzip** aracında da kullandığımız "**k**eep"
seçeneğinin kısalması olan `k` seçeneğini kullanabiliriz.

Ben test etmek için bu kez komutumu `bzip2 -k linux-dersleri.tar`
şeklinde yazıyorum. Hatta istersek, verbose seçeneğini ekleyip işlem
hakkında ayrıntılı bilginin konsola bastırılmasını sağlayabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ bzip2 -kv linux-dersleri.tar                                                                                                                            
  linux-dersleri.tar:  1.125:1,  7.113 bits/byte, 11.09% saved, 147271680 in, 130937266 out.
```

Bakın işlem sonunda `v` seçeneği sayesinde, sıkıştırma işlemi hakkında
tasarruf edilen alan, önceki sonraki boyutu gibi çeşitli bilgileri de
aldık. Şimdi ls komutu ile mevcut dizinimizi de listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls
en-az.tar  en-cok.tar  linux-dersleri.tar  linux-dersleri.tar.bz2  standart.tar
```

Bakın `k` seçeneği sayesinde orijinal dosya korunurken, sıkıştırılmış
versiyonu da oluşturulmuş.

Ben bu örnekte orijinal dosyayı koruyarak orijinal dosya ile aynı isimde
sıkıştırılmış versiyonunu oluşturdum. Ancak istersem `c` seçeneği ile
spesifik olarak istediğim isimde dosya oluşturulmasını da
sağlayabilirim. Buradaki `c` seçeneği sıkıştırılmış verilerin standart
çıktı ile bastırılmasını sağlıyor. Biz de bu standart çıktıları
yönlendirme operatörlerini kullanarak istediğimiz isimde bir dosyaya
yönlendirebiliyoruz.

Örnek olması için arşiv dosyasını sıkıştırıp masaüstü dizinimde
***yeni-arsiv.tar.bz2*** ismiyle kaydetmek istiyorum. Bunun için
`bzip2 -c linux-dersleri.tar > ~/Desktop/yeni-arsiv.tar.bz2` şeklinde
komutumu yazıyorum. Aslında burada dosya isminin sonuna ***.tar.bz2***
eklentisini eklemesem de sıkıştırma işlemi başarılı olacak ancak daha
önce de bahsettiğim düzenli çalışma adına bu gibi eklenti detaylarına
dikkat etmemiz gerekiyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ bzip2 -c linux-dersleri.tar > ~/Desktop/yeni-arsiv.tar.bz2

┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls ~/Desktop/                                                                                                                                           
yeni-arsiv.tar.bz2
```

Bakın dosyanın sıkıştırılmış versiyonu tam olarak istediğim dizine ve
tam olarak istediğim isimle kaydedilmiş bulunuyor. Üstelik `c` seçeneği
ile standart çıktıları farklı bir isimle kaydettiğimiz için orijinal
dosyamız da silinmemiş oldu.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ ls /tmp/                                                                                                                                                
en-az.tar  en-cok.tar  linux-dersleri.tar  linux-dersleri.tar.bz2  standart.tar
```

Söylediğim gibi `bzip2` aracının kullanımı `gzip` ile son derece benzer.
Ufak tefek farkların dışında her iki aracı da hemen hemen aynı şekilde
kullanabiliyoruz. Şimdiye kadar bahsettiğimiz tüm işlemleri `gzip` ile
de aynı seçenekleri kullanarak yerine getirdik zaten.

Sıkıştırma Seviyeleri
---------------------

`gzip` üzerinde bahsetmiş olduğum sıkıştırma seviyeleri aynen `bzip2`
üzerinde de mevcut fakat varsayılan olarak kullanılan seviyeler farklı.
**gzip** algoritmasındaki **varsayılan seviye 6** iken, **bzip2**'nin
varsayılan sıkıştırma seviyesi ise **9**'dur. Algoritmaların farklı
seviyeleri varsayılan olarak kullanma nedeni, ilgili algoritmanın en
verimli şekilde çalıştığı seviyenin farklı olmasıdır. Yani sıkıştırma ve
işlem zamanı ortalamasındaki en verimli seviye **bzip2** algoritması
için **9** iken **gzip** için **6**'dır. Tabii ki **bzip2**
algoritmasında da tıpkı **gzip** de olduğu gibi her zaman varsayılan
sıkıştırma seviyesini kullanmak zorunda değiliz. Dilediğimiz bir
sıkıştırma seviyesini bzip2 komutunun ardından `-1` veya `-9` şeklinde
belirtebiliyoruz.

Eğer az ama hızlı sıkıştırma istiyorsanız 1 seviye, çok ama daha yavaş
olmasını kabul ediyorsanız da 9. yani varsayılan seviyeyi
kullanabilirsiniz. Ayrıca bu seviyelerin arasındaki diğer seviyeleri de
kullanmakta özgürsünüz tabi. Örneğin 2 3 4 5 7 8 gibi rakamları da
kullanarak farklı seviyelerde sıkıştırma uygulayabilirsiniz. Ben
yalnızca iki uç seviyeden bahsederek aralarındaki farka değinmek
istedim.

Tüm özelliklerinden tek tek bahsetmemiş olsa da gördüğünüz gibi `gzip`
ile `bzip2` araçların temel kullanımları hemen hemen aynı. Zaten daha
fazla özellik ve kıyaslama için yardım sayfalarını açıp kontrol
edebilirsiniz.

Örneğin `gzip` aracında geçerli olan klasörleri sıkıştıramama durumu
`bzip2` için de aynen geçerli. Ama mesela `bzip2` aracını dahili olarak
özyineleme özelliğini sağlamıyor. Farklı araçları kullanarak dosyaların
isimlerini özyinelemeli şekilde `bzip2` aracına aktarıp yine hepsinin
sıkıştırılmasını sağlayabiliriz fakat bu özellik `gzip` aracında olduğu
gibi `bzip2` aracında dahili bir özellik değil. Neticede temel
kullanımları aynı olsa da gerekiyorsa yardım sayfalarından yararlanarak
ihtiyacınıza yönelik çözüm için gereken bilgiyi edinebilirsiniz.

Ayrıca biz sadece **gzip** ve **bzip2** algoritmalarını ele aldık ancak
aslında sıkıştırma işlemi için kullanabileceğimiz pek çok algoritma
mevcut. Ben yalnızca temel sistem yönetimi sırasında en sık
karışacağımız iki algoritmadan bahsetmek istedim. Diğer sıkıştırma
algoritmaları için kısa bir araştırma ile detaylı pek çok bilgiye
ulaşabilirsiniz. Örneğin algoritmaların birbiri ile kıyaslandığı
[buradaki](https://linuxreviews.org/Comparison_of_Compression_Algorithms)
gibi pek çok blog yazısına da rahatlıkla ulaşabilirsiniz.

Sıkıştırılmış Arşiv Dosyası Oluşturmak
--------------------------------------

`tar` aracı sayesinde sıkıştırma algoritmalarını uygulamamızı sağlayan
araçları bir arada kullanarak dosyalardan tek seferde sıkıştırılmış
arşiv dosyaları oluşturabiliriz.

Bunun için `tar` aracına hangi algoritmayı kullanarak sıkıştırma yapmak
istediğimizi belirtmemiz yeterli. Normalde bildiğiniz gibi `tar` aracı
yalnızca dosyaları arşivleme işlevinde. Eğer biz `tar` aracına arşivleme
işleminden sonra bir sıkıştırma algoritması aracını kullanmasını
söylersek tek seferde sıkıştırılmış arşiv dosyaları oluşturabiliyoruz.

Ben **gzip** ve **bzip2** için sıkıştırılmış arşiv dosyaları oluşturmayı
ele alacağım. Bu sıkıştırma algoritmaları yaygın kullanımda olduğu için
zaten tar aracında bu algoritmaları temsil eden kısayollar tanımlı.
Bunları görmek için `tar —help` komutu ile kısa yardım bilgisini
sorgulayabiliriz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[/tmp]
└─$ tar --help                                                                                                                                              
Usage: tar [OPTION...] [FILE]...
GNU 'tar' saves many files together into a single tape or disk archive, and can
restore individual files from the archive.

...

 Compression options:

  -a, --auto-compress        use archive suffix to determine the compression
                             program
  -I, --use-compress-program=PROG
                             filter through PROG (must accept -d)
  -j, --bzip2                filter the archive through bzip2
  -J, --xz                   filter the archive through xz
      --lzip                 filter the archive through lzip
      --lzma                 filter the archive through xz
      --lzop                 filter the archive through lzop
      --no-auto-compress     do not use archive suffix to determine the
                             compression program
      --zstd                 filter the archive through zstd
  -z, --gzip, --gunzip, --ungzip   filter the archive through gzip
  -Z, --compress, --uncompress   filter the archive through compress
..
```

Çok fazla seçeneği olduğu için ben çıktıyı yalnızca "sıkıştırma"
bölümüne kadar kısaltarak buraya ekledim. Buradaki seçeneklere bakacak
olursak, bakın burada farklı sıkıştırma algoritmaları için çeşitli kısa
ve uzun seçenekler var. Eğer sistemde bu algoritmaların araçları
yüklüyse bu seçenekleri kullanarak `tar` aracılığı ile sıkıştırılmış
arşiv dosyaları oluşturabiliyoruz. Örneğin **bzip2** ile sıkıştırılması
için `j` seçeneğini ya da uzun şekilde `—bzip2` seçeneğini
kullanabiliyoruz.

Ya da bakın **gzip** ile sıkıştırmak için de `z` seçeneğini veya `—gzip`
seçeneğini kullanabileceğimiz yazıyor. Hemen örnekler üzerinden ele
alalım.

Örneğin ben daha önce websitesinin dosyalarını `tar` komutu ile yalnızca
arşivlemiştim. Eğer hem arşivleyip hem de sıkıştırılmasını istersem
bunun için `tar` komutuna ilgili sıkıştırma algoritmasının seçeneğini
eklemem gerekiyor. Ben denemek için öncelikle **gzip** ile sıkıştırılmış
bir arşiv oluşturmak istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls
alfabe.tar  arsiv2.tar  linux-dersleri  metin.txt  test
```

Bakın şu an bulunduğum dizinde web sitesinin dosyaları bulunuyor.

Ben arşiv dosyası oluşturacağım için tar komutunun `c` seçeneğini ve
gzip algoritması ile sıkıştırılmasını için de `z` seçeneğini ekliyorum.
Son olarak arşiv dosyasının isminin ne olacağını belirtebilmek için de
`f` seçeneğini eklememiz gerekiyor. Ben isim olarak
***linux-dersleri.tar.gz*** olarak yazıyorum ve arşivlenip
sıkıştırılacak klasörün ismini de yazıyorum. .

`tar -czf linux-dersleri.tar.gz linux-dersleri`

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -czf linux-dersleri.tar.gz linux-dersleri/

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$
```

Şimdi kontrol etmek için `du -sh` komutu ile listeleyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ du -sh linux-dersleri linux-dersleri.tar.gz                                                                                                             
142M    linux-dersleri
125M    linux-dersleri.tar.gz
```

Bakın oluşturduğumuz arşiv dosyası normal dosyadan daha küçük çünkü biz
aynı zamanda sıkıştırmıştık. Bu arşivimiz **gzip** ile sıkıştırıldı.
Hatta teyit etmek için dosyaların türü hakkında bilgi sunan `file`
aracından faydalanabiliriz. Ben `file linux-dersleri.tar.gz` komutu ile
oluşturduğum arşiv dosyasını sorguluyorum.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ file linux-dersleri.tar.gz                                                                                                                              
linux-dersleri.tar.gz: gzip compressed data, from Unix, original size modulo 2^32 147271680
```

Bakın **gzip** ile sıkıştırılmış veri olduğu burada açıkça yazıyor. Yani
arşiv dosyamızın **gzip** algoritmasıyla sıkıştırıldığını teyit etmiş
olduk.

Şimdi **bzip2** ile sıkıştırılmış arşiv oluşturmak için **bzip2**
algoritmasını temsil eden `j` seçeneğini kullanmayı da deneyebiliriz.
Ben bu kez `tar -cjf linux-dersleri.tar.bz2 linux-dersleri` şeklinde
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -cjf linux-dersleri.tar.bz2 linux-dersleri                                                                                                                                                    

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ du -sh linux-dersleri*                                                                                                                                  
142M    linux-dersleri
125M    linux-dersleri.tar.bz2
125M    linux-dersleri.tar.gz
```

Bakın **bzip2** ile sıkıştırılmış arşiv dosyası da orijinal dosyadan
daha az yer kaplıyor. İşte `tar` aracıyla **sıkıştırılmış arşiv**
dosyası oluşturmak bu kadar kolay. Seçenekleri hatırlamanız bile önemli
değil. Önemli olan `tar` aracıyla sıkıştırılmış arşivler
oluşturabileceğinizden haberdar olmanız. Neticede hangi algoritmanın
hangi seçenek ile belirtildiğini hatırlamadığınızda `tar —help` komutu
ile hemen öğrenebilirsiniz.

Son olarak sıkıştırılmış bu arşiv dosyasını dışarı çıkarma işlemini ele
alacak olursak.

Sıkıştırılmış Arşiv Dosyasını Dışarı Çıkarmak
---------------------------------------------

Sıkıştırılmış arşivleri açmak için ortak olarak yalnızca `x` seçeneğini
kullanabiliyoruz. Çünkü otomatik olarak ilgili algoritmanın açılımı
gerçekleştiriliyor. Teyit etmek için sıkıştırmış olduğumuz arşivleri tek
tek açmayı deneyebiliriz. Ama aynı klasörü farklı algoritmalar ile
sıkıştırdığım için çıkardığımda hepsi aynı klasörünün üzerine yazılacak.
Bu sebeple ben çıkarma işleminden sonra dizinimi listeleyip daha sonra
klasörü sileceğim. İlk olarak buradaki mevcut klasörü
`rm -r linux-dersleri` komutu ile silelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rm -r linux-dersleri
```

Tamamdır. Şimdi örneğin **gzip** ile sıkıştırılmış olan arşivi açmayı
deneyebiliriz. Bunun için `tar -xf linux-dersleri.tar.gz` şeklinde
komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf linux-dersleri.tar.gz                                                                                                                           

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls                                                                                                                                                      
alfabe.tar  arsiv2.tar  linux-dersleri  linux-dersleri.tar.bz2  linux-dersleri.tar.gz  metin.txt  test
```

Bakın klasör sorunsuzca dışarı çıkarılmış. Şimdi teste devam edebilmek
için `rm -r linux-dersleri` komutu ile bu klasörümüzü de silelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rm -r linux-dersleri
```

Ben **bzip** ile oluşturduğum sıkıştırılmış arşivi çıkarmak için de
tekrar aynı komutumu çağırıyorum ve yalnızca arşiv dosyasının isminiz
değiştiriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf linux-dersleri.tar.bz2 

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls                                                                                                                                                      
alfabe.tar  arsiv2.tar  linux-dersleri  linux-dersleri.tar.bz2  linux-dersleri.tar.gz  metin.txt  test
```

Bakın bzip2 arşivinin içeriği de sorunsuzca dışarı çıkarılmış. İşte
`tar` aracını kullanarak sıkıştırılmış arşiv oluşturmak istediğimizde
ilgili sıkıştırma algoritmasını temsil eden seçeneği özellikle
belirtmemiz gerekiyorken, sıkıştırılmış arşiv dosyalarının hepsini `x`
seçeneği ile dışarı çıkarabiliyoruz.

Arşivleme ve sıkıştırmayla ilgili daha pek çok ayrıntıdan ve detaydan
söz etmek mümkün ancak temel eğitimi aşacağı için bu detaylar biraz
fazla. Zaten artık arşivleme ve sıkıştırmayla ilgili temel kavramları
bildiğiniz için gerekiyorsa geri kalanını bizzat kendinizin araştırıp
daha fazla detaya kolaylıkla ulaşabilirsiniz. Örneğin paralel olarak
sıkıştırma veya farklı sıkıştırma algoritmalarının performansları gibi
ek araştırmalar yapma konusunda özgürsünüz.

Ben bir sonradaki derste çok kısaca sıkıştırılmış dosyalar üzerinde
çeşitli işlemler yapabilmemizi sağlayan tanıdık bazı araçlardan
bahsetmek istiyorum.

`zcat` `zgrep` `bzcat` `bzgrep` `zless` `zmore`
-----------------------------------------------

Daha önce dosyalar üzerinde kullandığımız `cat` `grep` `less` `more`
gibi araçları biliyorsunuz. Normalde sıkıştırılmış bir dosya üzerinde bu
gibi araçları doğrudan kullanamıyoruz çünkü veriler sıkıştırılmış
oluyor. Fakat çözümsüz değiliz çünkü standart dosyalarda olduğu gibi bu
işlevlerin benzerlerini arşiv dosyaları için sunan çeşitli araçlar
mevcut. Örneğin **gzip** algoritması için `zcat` `zgrep` `zless` `zmore`
ve benzeri araçlar kullanılıyor. Diğer algoritmalar için de benzeri
şekilde farklı isimlendirilmiş araçlar var. Pek çok farklı sıkıştırma
algoritması olduğu için elbette benzer görev için pek çok farklı
yardımcı araç var. Ben örnek olarak **gzip** algoritmasında kullanılan
`zcat` ve `zgrep` araçlarından bahsedeceğim ancak sizler diğer tüm
algoritmaların harici yardımcı araçlarına manuel sayfasından göz
atabilirsiniz. Daha önce ele aldığımız için zaten `cat` ve `grep`
araçlarının temel işlevlerini biliyorsunuz. Sıkıştırılmış dosyalar
üzerinde kullandığımız bu araçlar da aynı şekilde çalıştığı için
üzerlerinde çok fazla durmak istemiyorum. Basit örnekler verip
anlatımımıza devam edebiliriz.

`zcat`
------

Öncelikle `zcat` aracı ile sıkıştırılmış bir metin dosyasının içeriğini
okumayı deneyebiliriz. Ben test edebilmek için `echo “deneme” > test1`
komutu ile içerisinde deneme yazan "test1" isimli bir dosya oluşturmak
istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ echo "deneme" > test1

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cat test1
deneme
```

Bakın bu dosyayı `cat` komutu ile sorunsuzca okuyabiliyoruz. Şimdi
`gzip test` komutu ile dosyayı sıkıştırıp `cat test.gz` komutu ile
okumayı deneyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ gzip test1                                                                                                                                              

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cat test1.gz 
��dtest1KI�K�M���(
```

Bakın dosya içeriği bozuk şekilde konsola bastırıldı. Şimdi `zcat` ile
aynı dosyayı okumak için `zcat test.gz` komutunu deneyebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zcat test1.gz                                                                                                                                           
deneme
```

Bakın bu kez sıkıştırılmış dosyanın içeriğini `zcat` aracıyla sorunsuzca
görüntüleyebiliyoruz.

`zgrep`
-------

Benzer şekilde `grep` aracının sunduğu çözümü **gzip** ile sıkıştırılmış
dosyalar üzerinde kullanabilmek için `zgrep` aracını kullanabiliyoruz.

Biliyorum çok çok basit bir örnek olacak fakat ben daha önce sıkıştırmış
olduğum test dosyası içinde "**de**" ifadesi geçiyor mu diye kontrol
etmek için `zgrep` aracını kullanmak istiyorum. Çıktıların
renklendirilmesi için de komutumu `zgrep —color “de” test1.gz` şeklinde
giriyorum.

![zgrep.webp](https://www.linuxdersleri.net/egitim/temel-linux/arsiv/zgrep.webp)

Bakın tam olarak "**de**" ifadesi ile eşleşen kısım renkli şekilde
`zgrep` aracı yardımıyla filtrelenmiş oldu.

Aynı testi `zgrep` yerine `grep` aracını kullanarak da deneyebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ grep --color "de" test1.gz 

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$
```

Bakın herhangi bir çıktı almadık çünkü `grep` aracı sıkıştırılmış olan
dosyanın içeriğini doğru şekilde tarayıp filtreleyemedi. `cat` ve `grep`
araçlarının **gzip** ile sıkıştırılmış dosyalar üzerindeki en temel
çalışma biçimi işte bu şekilde.

Ayrıca tıpkı **gzip** algoritmasında olduğu gibi diğer algoritmalar
içinde benzer şekilde çözümler sağlayan alternatif araçlar mevcut
olduğuna dikkatinizi çekmek istiyorum. Örneğin **bzip2** algoritması
için `bzcat` veya `bzgrep` araçlarını kullanabiliyoruz. Ben tüm bu
araçlardan tek tek bahsetmeyeceğim çünkü `cat` `less` `more` `grep` ve
benzeri araçların kullanımlarını daha önce ele aldık sizin tek yapmanız
gereken sıkıştırma algoritmasına uygun olan aracı bulup kullanmak.
Örneğin **bzip2** için mevcut sistemde yüklü olan araçları öğrenmek için
"bz" yazdıktan sonra iki kez tab tuşuna basıp olası araçları
listeleyebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ bz                                                               
bzcat         bzegrep       bzgrep        bzless
bzcmp         bzexe         bzip2         bzmore
bzdiff        bzfgrep       bzip2recover  
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ bz
```

Bakın bunlar hep **bzip2** için kullanabildiğimiz araçlar. Tabii sizin
sisteminizde yüklü olmayabilir ya da "bz" ile başlayan başka alakasız
araçlar da listelenmiş olabilir fakat aşağı yukarı buradaki çıktılardan
araçların işlevlerini zaten anlayabilirsiniz. Örneğin bakın `less`
aracının bzip2 için olan versiyonu `bzless` olarak geçiyor.

`zip` ve `rar`
--------------

Normalde Linux üzerinde çok sık karşılaşmayacak olsak da ihtiyacımız
olabileceği için **zip** ve **rar** arşivlerinden de çok bahsetmek
istiyorum.

zip ve rar algoritmalarını diğer algoritmalardan ayrı olarak ele alıyor
olma nedenim lisans ve dosya özelliklerinin korunmamasıyla ilgili olan
farklılıklardır.

rar iyi sıkıştırma oranı sunuyor olsa da tescilli olan rar algoritması
özgür lisansa sahip değil. Sıkıştırılmış dosyaların açılması konusunda
lisans sorun olmuyorken, yeni dosyaların sıkıştırılması rar
algoritmasının tescilli olması dolayısıyla bir handikap. Üstelik özgür
lisansa sahip pek çok açık kaynaklı alternatif olduğu için rar
kullanımına Linux üzerinde pek sık rastlamıyoruz.

Biz yine de ihtiyaç duyduğumuz arşiv oluşturma ve mevcut arşivleri
çıkarmak hakkında bilgi sahibi olalım. Zaten en temel işlevler olan
arşiv oluşturma ve mevcut arşivleri çıkarmayı ele alacağız sadece.

`zip`
-----

zip özellikle pek çok işletim sistemi ortamında ortak olarak
kullanılabildiği için sistemler arası ortak bir arşivleme ve sıkıştırma
yöntemi olarak tercih ediliyor. Eğer kullanmakta olduğunuz sistemde
`zip` aracı varsayılan olarak yüklü gelmiyorsa kullandığınız sisteme
göre `sudo apt install zip -y` veya `sudo dnf install zip -y` komutu ile
kolayca kurabilirsiniz.

Aracımızın kullanımı hakkında bilgi almak için yardım bilgisine göz
atabiliriz. `zip —help` komutunu girelim.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zip --help                                                                                  
Copyright (c) 1990-2008 Info-ZIP - Type 'zip "-L"' for software license.
Zip 3.0 (July 5th 2008). Usage:
zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]
  The default action is to add or replace zipfile entries from list, which
  can include the special name - to compress standard input.
  If zipfile and list are omitted, zip compresses stdin to stdout.
  -f   freshen: only changed files  -u   update: only changed or new files
  -d   delete entries in zipfile    -m   move into zipfile (delete OS files)
  -r   recurse into directories     -j   junk (don't record) directory names
  -0   store only                   -l   convert LF to CR LF (-ll CR LF to LF)
  -1   compress faster              -9   compress better
  -q   quiet operation              -v   verbose operation/print version info
  -c   add one-line comments        -z   add zipfile comment
  -@   read names from stdin        -o   make zipfile as old as latest entry
  -x   exclude the following names  -i   include only the following names
  -F   fix zipfile (-FF try harder) -D   do not add directory entries
  -A   adjust self-extracting exe   -J   junk zipfile prefix (unzipsfx)
  -T   test zipfile integrity       -X   eXclude eXtra file attributes
  -y   store symbolic links as the link instead of the referenced file
  -e   encrypt                      -n   don't compress these suffixes
  -h2  show more help
```

Bakın kullanılabilir seçenekler listelendi. Örneğin dizinleri arşivlemek
için "**r**ecursive" yani "özyineleme" seçeneğini temsil eden `r`
seçeneğini kullanmamız gerekiyor. `-r` seçeneği sayesinde ilgili
klasörün altındaki dizinlere de ulaşılmış oluyor. Ayrıca sıkıştırma
seviyesi gibi seçeneklere de sahip olduğunu buradaki yardım bilgisinden
görebiliyoruz.

zip Arşivi Oluşturmak
---------------------

Ben websitesinin dosyalarını zip ile sıkıştırmak istediğim için komutumu
`zip -r linux.zip linux-dersleri` şeklinde giriyorum. Buradaki `r`
seçeneğini eklemezsek alt dizinlerdeki dosyalar sıkıştırılmayacak.
Klasörleri sıkıştırırken `r` seçeneği önemli yani. Zaten şimdiye kadar
klasörler üzerinde çalışırken bu durumdan tekrar tekrar bahsettik. Hatta
test etmek için `-r` seçeneği olmadan komutumuzu girelim.

``` {.python}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zip linux.zip linux-dersleri
  adding: linux-dersleri/ (stored 0%)
```

İşlem anında tamamlandı çünkü ama aslında alt dosya ve klasörler bu
sıkıştırılmaya dahil edilmedi. Bu durumu teyit etmek için `ls -sh`
komutunu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh 
total 391M
 20K alfabe.tar      125M linux-dersleri.tar.bz2  4.0K metin.txt  4.0K test1.gz
141M arsiv2.tar      125M linux-dersleri.tar.gz   4.0K metin.zip
4.0K linux-dersleri  4.0K linux.zip               4.0K test
```

Bakın oluşturulan dosyanın boyutu çok çok küçük. Yani aslında klasörün
tüm içeriğinin sıkıştırılmadığını buradan da teyit edebiliyoruz. Şimdi
aynı komutu bu kez `-r` seçeneğini de ekleyerek girelim.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zip -r linux.zip linux-dersleri                                                             
  adding: linux-dersleri/ (stored 0%)
  adding: linux-dersleri/_layouts/ (stored 0%)
  adding: linux-dersleri/_layouts/tutorial.html (deflated 56%)
  adding: linux-dersleri/_layouts/home.html (deflated 64%)
  adding: linux-dersleri/_layouts/komut.html (deflated 54%)
  adding: linux-dersleri/_layouts/author.html (deflated 59%)
  adding: linux-dersleri/_layouts/about.html (deflated 42%)
  adding: linux-dersleri/_layouts/post.html (deflated 49%)
  adding: linux-dersleri/_layouts/simple.html (deflated 43%)
  adding: linux-dersleri/_layouts/b-post.html (deflated 54%)
  adding: linux-dersleri/linux-sistem-yonetimine-giris-egitimi.markdown (deflated 65%)
  adding: linux-dersleri/egitim.markdown (deflated 66%)
  adding: linux-dersleri/komutlar/ (stored 0%)
  adding: linux-dersleri/komutlar/index.markdown (deflated 50%)
  adding: linux-dersleri/etiketler.markdown (deflated 65%)
  adding: linux-dersleri/pagefind/ (stored 0%)
...
..
.
adding: linux-dersleri/index.markdown (deflated 58%)
```

Bakın adım adım tüm sıkıştırma işlemlerini konsoldan takip edebiliyoruz.
Bir önceki komutta sıkıştırma olmadığı için herhangi bir çıktı yoktu.
Şimdi tekrar `ls -sh` komutu ile dosyanın boyutunu kontrol edelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                      
total 516M
 20K alfabe.tar      125M linux-dersleri.tar.bz2  4.0K metin.txt  4.0K test1.gz
141M arsiv2.tar      125M linux-dersleri.tar.gz   4.0K metin.zip
4.0K linux-dersleri  126M linux.zip               4.0K test
```

Bakın bu kez dosyanın boyutu daha gerçekçi bir oranda küçülmüş. Yani
klasörün alt dizinlerindeki tüm dosya ve klasörlerin dahil edildiğini
tahmin edebiliyoruz. Hatta teyit etmek için sıkıştırılmış dosya
içeriğini dışarı çıkarabiliriz.

zip Arşivini Dışarı Çıkarmak
----------------------------

zip ile sıkıştırılmış olan dosyaları dışarı çıkarmak için `unzip`
aracını kullanmamız gerekiyor. Mevcut dizine çıkardığımızda aynı
klasörün yerini alacağı için ben öncelikle sıkıştırmak için kullandığım
klasörü silmek istiyorum. `rm -r linux-dersleri` komutu ile klasörümüzü
silip, `unzip linux.zip` komutunu girelim.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rm -r linux-dersleri                                                                        

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ unzip linux.zip                                                                             
Archive:  linux.zip
   creating: linux-dersleri/
   creating: linux-dersleri/_layouts/
  inflating: linux-dersleri/_layouts/tutorial.html  
  inflating: linux-dersleri/_layouts/home.html  
  inflating: linux-dersleri/_layouts/komut.html  
  inflating: linux-dersleri/_layouts/author.html  
  inflating: linux-dersleri/_layouts/about.html  
  inflating: linux-dersleri/_layouts/post.html  
  inflating: linux-dersleri/_layouts/simple.html  
  inflating: linux-dersleri/_layouts/b-post.html  
  inflating: linux-dersleri/linux-sistem-yonetimine-giris-egitimi.markdown
...
..
.
inflating: linux-dersleri/logo.svg  
  inflating: linux-dersleri/index.markdown
```

Bakın tek tek tüm dosyalar çıkarıldı. Görebildiğiniz gibi sıkıştırılmış
dosya içeriğinin tamamı sorunsuzca dışarı çıkarılmış. `zip` aracının en
temel kullanımı bu şekilde.

rar
---

Normalde `rar` aracı pek çok dağıtımda varsayılan olarak yüklü gelmiyor.
Dolayısıyla kullanabilmek için öncelikle kurmamız gerekiyor. Kurmak için
debian tabanlı sistemlerde `sudo apt install rar -y` komutunu
girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ rar
Command 'rar' not found, but can be installed with:
sudo apt install rar
Do you want to install it? (N/y)y
sudo apt install rar
[sudo] password for taylan: 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  rar
0 upgraded, 1 newly installed, 0 to remove and 1844 not upgraded.
Need to get 358 kB of archives.
After this operation, 1,397 kB of additional disk space will be used.
Get:1 http://kali.download/kali kali-rolling/non-free amd64 rar amd64 2:6.20-0.1 [358 kB]
Fetched 358 kB in 11s (31.3 kB/s)
Selecting previously unselected package rar.
(Reading database ... 291479 files and directories currently installed.)
Preparing to unpack .../rar_2%3a6.20-0.1_amd64.deb ...
Unpacking rar (2:6.20-0.1) ...
Setting up rar (2:6.20-0.1) ...
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for man-db (2.9.4-4) ...
```

Yardım bilgisini görüntülemek için yalnızca `rar` yazıp komutumuzu
onaylayalım.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ rar

RAR 6.20   Copyright (c) 1993-2023 Alexander Roshal   17 Jan 2023
Trial version             Type 'rar -?' for help

Usage:     rar <command> -<switch 1> -<switch N> <archive> <files...>
               <@listfiles...> <path_to_extract/>

<Commands>
  a             Add files to archive
  c             Add archive comment
  ch            Change archive parameters
  cw            Write archive comment to file
  d             Delete files from archive
  e             Extract files without archived paths
  f             Freshen files in archive
  i[par]=<str>  Find string in archives
  k             Lock archive
  l[t[a],b]     List archive contents [technical[all], bare]
  m[f]          Move to archive [files only]
  p             Print file to stdout
  r             Repair archive
  rc            Reconstruct missing volumes
  rn            Rename archived files
  rr[N]         Add data recovery record
  rv[N]         Create recovery volumes
  s[name|-]     Convert archive to or from SFX
  t             Test archive files
  u             Update files in archive
  v[t[a],b]     Verbosely list archive contents [technical[all],bare]
  x             Extract files with full path

<Switches>
  -             Stop switches scanning
  @[+]          Disable [enable] file lists
  ad[1,2]       Alternate destination path
  ag[format]    Generate archive name using the current date
  ai            Ignore file attributes
  am[s,r]       Archive name and time [save, restore]
  ap<path>      Set path inside archive
  as            Synchronize archive contents
  c-            Disable comments show
  cfg-          Disable read configuration
  cl            Convert names to lower case
  cu            Convert names to upper case
  df            Delete files after archiving
  dh            Open shared files
  ds            Disable name sort for solid archive
  dw            Wipe files after archiving
  e[+]<attr>    Set file exclude and include attributes
  ed            Do not add empty directories
  ep            Exclude paths from names
  ep1           Exclude base directory from names
  ep3           Expand paths to full including the drive letter
  ep4<path>     Exclude the path prefix from names
  f             Freshen files
  hp[password]  Encrypt both file data and headers
  ht[b|c]       Select hash type [BLAKE2,CRC32] for file checksum
  id[c,d,n,p,q] Display or disable messages
  ierr          Send all messages to stderr
  ilog[name]    Log errors to file
  inul          Disable all messages
  isnd[-]       Control notification sounds
  iver          Display the version number
  k             Lock archive
  kb            Keep broken extracted files
  log[f][=name] Write names to log file
  m<0..5>       Set compression level (0-store...3-default...5-maximal)
  ma[4|5]       Specify a version of archiving format
  mc<par>       Set advanced compression parameters
  md<n>[k,m,g]  Dictionary size in KB, MB or GB
  me[par]       Set encryption parameters
  ms[ext;ext]   Specify file types to store
  mt<threads>   Set the number of threads
  n<file>       Additionally filter included files
  n@            Read additional filter masks from stdin
  n@<list>      Read additional filter masks from list file
  o[+|-]        Set the overwrite mode
  oh            Save hard links as the link instead of the file
  oi[0-4][:min] Save identical files as references
  ol[a]         Process symbolic links as the link [absolute paths]
  op<path>      Set the output path for extracted files
  or            Rename files automatically
  ow            Save or restore file owner and group
  p[password]   Set password
  qo[-|+]       Add quick open information [none|force]
  r             Recurse subdirectories
  r-            Disable recursion
  r0            Recurse subdirectories for wildcard names only
  rr[N]         Add data recovery record
  rv[N]         Create recovery volumes
  s[<N>,v[-],e] Create solid archive
  s-            Disable solid archiving
  sc<chr>[obj]  Specify the character set
  sfx[name]     Create SFX archive
  si[name]      Read data from standard input (stdin)
  sl<size>      Process files with size less than specified
  sm<size>      Process files with size more than specified
  t             Test files after archiving
  ta[mcao]<d>   Process files modified after <d> YYYYMMDDHHMMSS date
  tb[mcao]<d>   Process files modified before <d> YYYYMMDDHHMMSS date
  tk            Keep original archive time
  tl            Set archive time to latest file
  tn[mcao]<t>   Process files newer than <t> time
  to[mcao]<t>   Process files older than <t> time
  ts[m,c,a,p]   Save or restore time (modification, creation, access, preserve)
  u             Update files
  v<size>[k,b]  Create volumes with size=<size>*1000 [*1024, *1]
  ver[n]        File version control
  vn            Use the old style volume naming scheme
  vp            Pause before each volume
  w<path>       Assign work directory
  x<file>       Exclude specified file
  x@            Read file names to exclude from stdin
  x@<list>      Exclude files listed in specified list file
  y             Assume Yes on all queries
  z[file]       Read archive comment from file

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Daha önce **rar** algoritmasının tescilli olduğunu belirtmiştim. Bu
durumu teyit etmek için aldığımız yardım çıktılarının en başına bakacak
olursak, burada kurmuş olduğumuz rar aracının deneme sürümü olduğunu
"Trial version" ifadesi ile belirtilmiş. Rar tescilli olduğundan, şu
anlık yalnızca bireysel kullanım için deneme sürümüne sahibiz.

Tamamdır, rar algoritmasının tescilli olduğunu artık biliyoruz. Şimdi
buradaki yardım çıktılarına göz atarak nasıl yeni arşiv
oluşturabileceğimize göz atalım.

Rar Arşivi Oluşturmak
---------------------

Arşive dosya eklemek için `a` parametresini kullanmamız gerekiyormuş. Bu
seçenek sayesinde eğer hiç yoksa yeni arşiv oluşturabilir, eğer varsa da
yeni dosya ekleyebiliriz. Mevcut arşivi çıkarmak için de `x`
parametresini kullanıyoruz.

Ben denemek için yine websitesinin dosyalarını sıkıştırmak istiyorum.
Bunun için komutumu `rar a linux.rar linux-dersleri` şeklinde giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rar a linux.rar linux-dersleri

RAR 6.20   Copyright (c) 1993-2023 Alexander Roshal   17 Jan 2023
Trial version             Type 'rar -?' for help

Evaluation copy. Please register.

Creating archive linux.rar

Adding    linux-dersleri/_layouts/tutorial.html                       OK 
Adding    linux-dersleri/_layouts/home.html                           OK 
Adding    linux-dersleri/_layouts/komut.html                          OK 
Adding    linux-dersleri/_layouts/author.html                         OK 
Adding    linux-dersleri/_layouts/about.html                          OK 
Adding    linux-dersleri/_layouts/post.html                           OK 
Adding    linux-dersleri/_layouts/simple.html                         OK 
Adding    linux-dersleri/_layouts/b-post.html                         OK 
..
. 
Adding    linux-dersleri/assets                                       OK 
Adding    linux-dersleri                                              OK 
Done
```

Belirttiğim dizindeki tüm dosyaların arşivle eklendiğini konsol
üzerinden de takip edebiliyoruz. Şimdi `ls -sh` komutu ile listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls -sh                                                                                                                                                 
total 639M
 20K alfabe.tar  4.0K linux-dersleri          125M linux-dersleri.tar.gz  126M linux.zip  4.0K metin.zip  4.0K test1.gz
141M arsiv2.tar  125M linux-dersleri.tar.bz2  124M linux.rar              4.0K metin.txt  4.0K test
```

Bakın **rar** arşivi oluşturulmuş üstelik gayet iyi sıkıştırma
sağladığını, arşiv dosyasının boyutundan da anlayabiliyoruz.

Rar Arşivini Dışarı Çıkarmak
----------------------------

Şimdi oluşturduğumuz bu arşiv dosyasını dışarı çıkaralım. Çıkarmak için
de `x` seçeneğini kullanabiliyoruz. Mevcut bulunduğumuz dizine çıkarmak
istersek doğrudan `rar x linux.rar` şeklinde komutumuzu girebiliriz.
Fakat halihazırda bu isimde klasör ve içinde aynı dosyalar bulunduğu
için bizden onay istenecek. Hemen deneyelim.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rar x linux.rar 

RAR 6.20   Copyright (c) 1993-2023 Alexander Roshal   17 Jan 2023
Trial version             Type 'rar -?' for help

Extracting from linux.rar

Would you like to replace the existing file linux-dersleri/_layouts/tutorial.html
  5103 bytes, modified on 2023-07-01 14:11
with a new one
  5103 bytes, modified on 2023-07-01 14:11

[Y]es, [N]o, [A]ll, n[E]ver, [R]ename, [Q]uit y

Extracting  linux-dersleri/_layouts/tutorial.html                     OK 

Would you like to replace the existing file linux-dersleri/_layouts/home.html
  2950 bytes, modified on 2023-05-10 17:59
with a new one
  2950 bytes, modified on 2023-05-10 17:59

[Y]es, [N]o, [A]ll, n[E]ver, [R]ename, [Q]uit y
```

Ben tek tek uğraşmak istemediğim için hepsini temsil eden **All** yani
`a` yazıp onaylıyorum.

``` {.bash}
Extracting  linux-dersleri/_layouts/home.html                         OK 

Would you like to replace the existing file linux-dersleri/_layouts/komut.html
  3958 bytes, modified on 2023-06-08 21:22
with a new one
  3958 bytes, modified on 2023-06-08 21:22

[Y]es, [N]o, [A]ll, n[E]ver, [R]ename, [Q]uit a

Extracting  linux-dersleri/_layouts/komut.html                        OK 
Extracting  linux-dersleri/_layouts/author.html                       OK 
Extracting  linux-dersleri/_layouts/about.html                        OK 
Extracting  linux-dersleri/_layouts/post.html                         OK 
Extracting  linux-dersleri/_layouts/simple.html                       OK 
Extracting  linux-dersleri/_layouts/b-post.html                       OK 
..
.
Extracting  linux-dersleri/logo.svg                                   OK 
Extracting  linux-dersleri/index.markdown                             OK 
All OK
```

Böylelikle rar ile sıkıştırmış olduğumuz dizin içeriğini `x` seçeneği
sayesinde dışarı çıkarmayı başardık. Dilerseniz mevcut dizin yerine
spesifik olarak çıkarılmasını istediğiniz dizini komutun sonunda
belirtebilirsiniz. Yani örneğin benim durumda
`rar x linux.rar çıkarılacağı konum` şeklinde komut girebilirdim.

Neticede `rar` ve `zip` aracı hakkında bahsetmek istediklerim bu kadar.
Aslında tıpkı `rar` komutunun çıktılarında da gördüğümüz gibi pek çok
özellik mevcut fakat ben lisans gereği pek sık kullanmaya ihtiyaç
duymayacağımız için ek detaylardan bahsetmek istemiyorum. Nitekim ben de
her seferinde yardım bilgisine bakıp hatırlıyorum. Zaten genelde mevcut
**rar** dosyalarını yalnızca açmaya ihtiyaç duyuyoruz.

`rar` ve `zip` araçlarının kullanımı ile ilgili merak ettiğiniz tüm ek
bilgileri yardım sayfasından öğrenebilirsiniz. Zaten çok Linux üzerinde
çok sıklıkla ihtiyaç duymayacağınız için yardım sayfaları üzerinden
dilediğiniz zaman gerekli bilgileri edinebilirsiniz.

Evet böylelikle arşivleme ve sıkıştırma işlemleri hakkında bilmemiz
gereken temel bilgilerden bahsetmiş olduk. Ben bahsetmedim ancak
arşivleri parçalara bölmek veya şifrelemek ve çok daha fazla özellik
için ihtiyaç duyduğunuz bilgileri hem manuel sayfalarından hem de
internet araştırmalarından kolaylıkla öğrenebilirsiniz. Sadece şimdiye
kadar kısaca bahsettiğimiz arşivleme ve sıkıştırma alternatiflerini
düşündüğünüzde, hepsinden bahsetmemiz veya hepsini biliyor olmamız pek
olası olmadığı bence gayet açık. Bizim bu bölümdeki amacımız temel
arşivleme ve sıkıştırma yaklaşımlarından haberdar olabilmemizdi. İhtiyaç
duyduğunuz çözümler için her zaman ekstra araştırma yaparak çözümlere
ulaşma imkanına internet sayesinde sahipsiniz zaten. Sık kullandığınız
bilgiler de zamanla zihninizde yer etmiş olacak.

Bir sonraki bölümde komut satırı üzerinden çeşitli bilgiler edinmemizi
sağlayan komutlardan bahsederek devam ediyor olacağız.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 14. Ders 45 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Genel olarak sistemdeki tarih takvim araçlar dosyalar ayarlar kayıtlar
ve benzeri pek çok yapı hakkında konsol üzerinden kolayca bilgi
edinebilmek için kullandığımız komutları, bilgi alma komutları başlığı
altında inceleyebiliriz. Dolayısıyla aslında tüm eğitim boyunca
kullandığımız ve kullanmaya da devam edeceğimiz pek çok komutu bilgi
alma komutları sınıfında değerlendirmemiz mümkün. Çünkü hepsi, kendi
görevleri özelinde pek çok bilgi sunma kabiliyetine sahip araçlar. En
basit örnek olarak, `ls` komutu bile tek başına kullanıldığında mevcut
dizinimizdeki içerikler hakkında bilgi almamızı sağlıyor.

Yine de eğitimin geri kalanında değinmek için uygun bölümleri bulunmayan
ama haberdar olmamızın faydalı olacağı bazı araçlardan "bilgi alma
bölümü" altında çok kısaca bahsetmek istiyorum.

Anlatımlarımıza öncelikle takvim ve saat gibi temel bilgileri nasıl
edinebileceğimizle başlayabiliriz.

Tarih ve Saat Hakkında Bilgi Edinme
-----------------------------------

`date` Komutu
-------------

Eğer grafiksel arayüz kullanıyorsanız zaten mutlaka tarih ve saati
kolayca öğrenebileceğiniz bir ortama sahipsinizdir.

Tarih bilgisini komut satırından edinmek istediğimizdeyse `date`
komutunu kullanabiliyoruz. Zaten "date" ifadesi "tarih" anlamına geldiği
için hatırlaması kolay bir komut. Hemen komutumuzu girelim.

``` {.bash}
└─$ date
Mon Jun 26 02:40:38 PM EDT 2023
```

Bakın `date` komutu tek başına kullanıldığında gördüğünüz gibi
sırasıyla, haftanın gününü, ayı, ayın gününü, saati, saat dilimini ve
yılı içeriyor. Yani mevcut bulunduğumuz günün tüm tarihi temel
bilgilerini `date` aracıyla öğrenebiliyoruz. Tabii ki aracımızın
sağladığı tek bilgi mevcut günümüz de değil. Diğer seçenekleri görmek
için `date —help` komutu ile yardım sayfasına bakacak olursanız ne kadar
çok seçeneğin bulunduğunu görebilirsiniz. Ancak bu kadar çok seçenek
olması gözünüzü korkutmasın, çünkü temelde `date` aracının yalnızca
sistem tarihini öğrenmek için kullanıyoruz. Mesela tüm tarih bilgisini
değil de yalnızca saat bilgisini almak istersek yardım bilgisinde
gözüken `%r` parametresini kullanabiliriz.

Bakın yalnızca saat bastırıldı. Benzer şekilde diğer parametreleri
kullanarak `date` aracından dilediğiniz formda çıktı alabilirsiniz. Bu
özelliğe genellikle kabuk programlamada ihtiyaç duyuyor olsak da artık
bildiğinize göre ihtiyaç duyduğunuzda yardım sayfasını açıp tekrar
hatırlayıp rahatlıkla kullanabilirsiniz..

Ayrıca `date` aracı ile tarihi değiştirmemiz de mümkün fakat tarihi
değiştirmek için sistem servislerini kullanmak çok daha sağlıklı bir
yaklaşım. Lütfen şimdilik buradaki "servis" kavramına çok takılmayın.
İleride servisleri ayrıca ele alacağız. O zaman servisten kastımın ne
olduğunu net biçimde anlamış olacaksınız. Şimdilik `date` komutunun bize
mevcut tarih bilgisini sunduğunu bilmemiz yeterli.

`cal` Komutu
------------

`cal` aracı komut satırımız üzerinden takvim bilgisi sunan basit bir
araç. Kimi sistemlerde varsayılan olarak yüklü bulunmasa da aslında çoğu
dağıtımda mevcut oluyor.

Aracın yüklü olup olmadığınız öğrenmek için tek yapmamız gereken
konsolumuza `cal` komutunu girmek.

``` {.bash}
└─$ cal
Command 'cal' not found, but can be installed with:
sudo apt install ncal
Do you want to install it? (N/y)
```

Bakın böyle bir komut olmadığı, eğer istersek bu araçla ilişkili olan
`ncal` paketinin kurulabileceği belirtiliyor. Buradaki komutu "y" ile
onaylayarak ya da kendimiz de buradaki `sudo apt install ncal` komutunu
girerek kurulumu yapabiliriz. Eğer size bu şekilde sorulmadıysa ve
sisteminizde yüklü değilse, debian tabanlı dağıtımınıza kurmak için siz
de buradaki komutu kullanabilirsiniz. Ben "y" ile aracın kurulumunu
onaylıyorum ve kullanıcı hesabımın parolasını girip kurulumu
başlatılıyorum.

``` {.bash}
└─$ cal
Command 'cal' not found, but can be installed with:
sudo apt install ncal
Do you want to install it? (N/y)y
sudo apt install ncal
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  ncal
0 upgraded, 1 newly installed, 0 to remove and 1830 not upgraded.
Need to get 19.7 kB of archives.
After this operation, 59.4 kB of additional disk space will be used.
Get:1 http://kali.download/kali kali-rolling/main amd64 ncal amd64 12.1.8 [19.7 kB]
Fetched 19.7 kB in 11s (1,828 B/s)
Selecting previously unselected package ncal.
(Reading database ... 291346 files and directories currently installed.)
Preparing to unpack .../archives/ncal_12.1.8_amd64.deb ...
Unpacking ncal (12.1.8) ...
Setting up ncal (12.1.8) ...
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for man-db (2.9.4-4) ...
```

Şimdi aracımızı çalıştırmak için `cal` komutunu tekrar girelim.

``` {.ruby}
└─$ cal
     June 2023        
Su Mo Tu We Th Fr Sa  
             1  2  3  
 4  5  6  7  8  9 10  
11 12 13 14 15 16 17  
18 19 20 21 22 23 24  
25 26 27 28 29 30
```

Bakın mevcut ayın takvim bilgisini sorunsuzca konsola bastırmış olduk.
Bu komutun dışında eğer takvimde gün isimlerinin bastırılmasını ve bizim
hangi günde olduğumuzun belirtilmesini istersek `ncal` komutunu da
kullanabiliriz.

``` {.ruby}
└─$ ncal
    June 2023         
Su     4 11 18 25   
Mo     5 12 19 26   
Tu     6 13 20 27   
We     7 14 21 28   
Th  1  8 15 22 29   
Fr  2  9 16 23 30   
Sa  3 10 17 24
```

Bakın sol tarafta gün isimleri sırasıyla yazıyor. Takvim de bu günlerin
sıralamasına uygun şekilde basılmış oldu.

Eğer mevcut ayı değil de geçmiş ya da gelecek bir tarihten takvim
bilgisine bakmak istersek `cal` ya da `ncal` komutunun ardından ay ve
yılı belirterek tam istediğimiz tarihteki takvim bilgisine de
ulaşabiliriz. Ben örnek olarak **2000** yılının **ocak** ayının
takvimini bastırmak üzere `ncal 1 2000` şeklinde komutumu giriyorum.

``` {.yaml}
└─$ ncal 1 2000
    January 2000      
Su     2  9 16 23 30
Mo     3 10 17 24 31
Tu     4 11 18 25   
We     5 12 19 26   
Th     6 13 20 27   
Fr     7 14 21 28   
Sa  1  8 15 22 29
```

Bakın 2000 yılının ocak ayı takvimi getirildi. Benzer şekilde ileri
tarih de belirtebiliriz. Ben 2025 yılının 6 ayı için takvim bilgisini
istiyorum.

``` {.yaml}
└─$ ncal 6 2025                                                  
    June 2025         
Su  1  8 15 22 29   
Mo  2  9 16 23 30   
Tu  3 10 17 24      
We  4 11 18 25      
Th  5 12 19 26      
Fr  6 13 20 27      
Sa  7 14 21 28
```

Bakın bu takvim de bastırıldı. İşte ihtiyacınız olduğunda sizler de
konsol üzerinden takvim bilgisine bu şekilde kolayca ulaşabilirsiniz.
Komutun ismi "**cal**endar" yani "takvim" ifadesinden geldiği için
hatırlaması da kolay aslında. Yine de unutursanız örneğin yardım
sayfalarını `apropos calendar` komutu ile kurcalayabilirsiniz mesela.

``` {.java}
└─$ apropos calendar
cal (1)              - displays a calendar and the date of Easter
ncal (1)             - displays a calendar and the date of Easter
zshcalsys (1)        - zsh calendar system
```

Bakın takvimle ilgili olan komutlar ve açıklamaları listelendi.

Neticede takvimi öğrenebileceğimiz bir komut olduğunu bildiğimiz sürece,
ilgili komutun ismini bulmak için yardım sayfalarını kolayca
kullanabiliyoruz gördüğünüz gibi.

Dosyalar Hakkında Bilgi Edinmek
-------------------------------

`which` Komutu
--------------

`which` komutunu, çalıştırdığımız araçların dosya konumlarını öğrenmek
için kullanabiliyoruz.

Örneğin sizler de biliyorsunuz ki; ben konsola `ls` yazdığımda kabuk
öncelikle `ls` isminde bir yerleşik komutu var mı diye bakıyor, eğer
yoksa PATH yolu üzerinde bu isimde bir dosya var mı diye araştırmaya
giriyor ve eğer bulabilirse bu dosyayı çalıştırıyor. Zaten bu durumdan
eğitimin en başında bahsettik. İşte bash komutunun bulup çalıştırmasına
benzer şekilde, `which` komutu da kendisine argüman olarak belirtilmiş
olan isimdeki aracın tam dosya konumunu bize bildiriyor. Yani aslında
`which` komutu da PATH yoluna bakarak argüman olarak verdiğim aracı
araştırıyor. Dolayısıyla PATH yolunda olmayan araçların dosya konumları
`which` komutu tarafından bastırılamıyor.

Hemen `ls` komutunun tam dizin adresine bakalım.

Bakın `ls` aracı tam olarak ***/usr/bin/ls*** dizini içindeymiş. hatta
istersek `which` aracının kendi dosya adresine de bakabiliriz.

``` {.bash}
└─$ which which
/usr/bin/which
```

Bakın `which` aracı da ***/usr/bin/which*** dizini içindeymiş. İşte bu
şekilde PATH yolu üzerindeki araçların tam dizin adreslerini
öğrenebilirsiniz. Bu komut özellikle bir aracın çalıştırılabilmesi için
tam dizin adresinin girilmesi gereken durumlarda bize dizin bilgisini
sunması bakımından önemli. Örneğin eğer hatırlıyorsanız, varsayılan
kabuğumuzu bash olarak değiştirme işleminden bahsederken, bash kabuğunun
dosya konumunu da `which` komutu sayesinde bulmuştuk. `which` komutu,
özellikle bash kabuk programlamada sıklıkla kullanıldığı için, ileride
karşılaşmanız ve ihtiyaç duymanız olası. Yani hemen şimdi aktif olarak
kullanmayacak olsanız bile bu komutu gördüğünüzde hangi amaca hizmet
ettiğini artık biliyorsunuz.

`type` Komutu \| `command` & `builtin` Komutları
------------------------------------------------

`type` komutu, isminden de anlaşılabileceği gibi kabuğa girdiğimiz
komutların tipiyle türleriyle ilgili bilgileri görüntülemek için
kullandığımız bir araçtır. Diğer bir deyişle kabuğa verdiğiniz
komutların kabuk tarafından nasıl algılandığını görmenizi sağlıyor. Bu
komut özellikle sistemde yüklü bulunan araçların isimleri ile aynı
isimde takma isimler yani **alias** tanımlandığında, kabuğun bizim
girdiğimiz komutu nasıl gördüğünü anlamak için kullanışlı bir bilgi
edinme aracıdır.

Ben denemek için konsola `type ls` yazıyorum.

``` {.bash}
└─$ type ls
ls is aliased to `ls --color=auto'
```

Bakın kabuğa `ls` komutunu verdiğimde aslında kabuğun `ls` komutunu bir
takma isim olarak kabul edip buradaki komutu çalıştırdığını öğrendik.
Normalde standart `ls` aracı yani biz `ls` komutunu girdiğimizde
çalıştırılan dosya ***/usr/bin/ls*** dosyası. Ama `ls` komutu ile aynı
isimde yeni bir takma isim tanımlandığı için kabuk bizim girdiğimiz `ls`
komutunu öncelikli olarak takma isim olarak dikkate alıyor ve buradaki
takma isim tanımlamasından dolayı `ls —color=auto` komutunu
çalıştırıyor.

Takma isim dışında kabuğun yerleşik komutlarını da sorgulayabiliriz.

``` {.bash}
└─$ type cd
cd is a shell builtin
```

Bakın `cd` aracı bash kabuğunun yerleşik aracı olduğu için bu çıktıyı
almış olduk.

Ayrıca mesela `type bash` komutunu da girebiliriz.

``` {.python}
└─$ type bash
bash is /usr/bin/bash
```

Bakın bu kez bash kabuğunun dosya konumunu aldık çünkü biz `bash`
komutunu girdiğimizde mevcut kabuk bu dizindeki dosyayı çalıştırıyormuş.
Bash kabuğu yerleşik bir araç olmadığı için veya bu isimde bir takma
isim tanımlanmadığı için bu şekilde doğrudan çalıştırılan dosyanın
konumu kabuk tarafından kullanılıyor.

Özetle bakın `type` komutu sayesinde bizim girdiğimiz komutlardaki araç
isimlerinin kabuk tarafından nasıl algılandığını öğrenebiliyoruz.

Peki bizim girdiğimiz komutların kabuk tarafından nasıl algılandığının
neden bilmemiz gerekiyor ?

Bu bilgi önemli çünkü, tıpkı `ls` komutunda olduğu gibi yerleşik ve PATH
yolundaki harici komutlarla aynı isimde takma isimler tanımlı
olabiliyor. Takma isimler yerleşik ve harici komutlardan daha öncelikli
değerlendirildiği için de, girdiğimiz komutlar bizim normalde
beklediğimizden daha farklı sonuçlar verebiliyor.

Örneğin ben `alias ls="echo ben takma isimim"` şeklinde yani var olan
bir komutla aynı isimde bir takma isim tanımlarsam ne olur ? Hemen
deneyelim.

``` {.ruby}
└─$ alias ls="echo ben takma isimim"

┌──(taylan@linuxdersleri)-[~]
└─$ ls                                                           
ben takma isimim
```

Gördüğünüz gibi `ls` komutunun neticesinde dizin içeriğini listelemek
yerine "ben takma isimim" çıktısını aldık. Çünkü kabuğa girdiğimiz
komutlarda ilk olarak eğer komutla eşleşen bir takma isim varsa kabuk
bunu dikkate alıyor. Nitekim çıktıdan da bu durumu teyit ettik. İşte
girdiğimiz komutun beklediğimizden farklı sonuçlar verdiği durumlarda
`type` komutu ile kabuğun bakış açısından girdiğimiz komutu
sorgulayabiliyoruz. Bu sayede girdiğimiz komutun neden beklenmedik
şekilde çalıştığına dair çözüm için fikir sahibi olmamız mümkün oluyor.

Örneğin benim `ls` takma ismi örneğinde komutumu `command ls` şeklinde
girmem gerekiyor.

``` {.bash}
└─$ command ls                                                   
 abc         harf.txt           liste3            sehir
```

Bakın bu şekilde girdiğimde, `ls` ifadesinin bir komut olduğunu
belirtmiş oluyorum. Benim burada kullandığım `command` komutu sayesinde
kabuk takma ismi görmezden gelip normla şekilde önce yerleşik komutlara
daha sonra `ls` isminin geçtiği PATH yolundaki dizinlere bakıyor ve
***/usr/bin/ls*** dosyasını bulup çalıştırabiliyor. Yani buradaki
`command` komutu `ls` komutunun doğrudan çalıştırılacak komut olarak
kabul edilmesini sağlıyor.

Aynı durum yerleşik komutlar için de geçerli. Örneğin `cd` yerleşik
komutu ile aynı isimde bir `alias` tanımlarsak `cd` komutunu
kullandığımızda takma ismin karşılığındaki komut çalıştırılıyor olacak.
Denemek için `alias cd=”echo ben cd komutuyum”` şeklinde yazıp
onaylayalım.

``` {.bash}
└─$ alias cd="echo ben cd komutuyum"                             

┌──(taylan@linuxdersleri)-[~]
└─$ cd                                                           
ben cd komutuyum

┌──(taylan@linuxdersleri)-[~]
└─$ cd /                                                         
ben cd komutuyum /
```

Bakın `cd` komutu asıl işlevi olan dizin geçişi işlemi yerine bizim
tanımladığımız takma ismi kullanılıp konsol çıktı bastırılıyor. Hatta
`type cd` komutu ile de teyit edebiliriz.

``` {.bash}
└─$ type cd
cd is aliased to `echo ben cd komutuyum'
```

Bakın `cd` komutu kabuk tarafından artık bir takma isim olarak
algılanıyormuş.

Eğer biz bu takma isim yerine `command cd /` veya `builtin cd /`
şeklinde yazarsak, kabuk buradaki `cd` ifadesini ile tanımlı olan takma
ismi görmezden gelip `cd` komutunun asıl işlevini yerine getiriyor
olacak.

``` {.bash}
└─$ command cd /                                                 

┌──(taylan@linuxdersleri)-[/]
└─$ builtin cd ~

┌──(taylan@linuxdersleri)-[~]
└─$ pwd                                                          
/home/taylan
```

Bakın bu kez `cd` aracı yerleşik komutlar içinde bulunduğu için kök
dizine sorunsuzca geçiş yaptık. Girdiğimiz komutun bir yerleşik komut
olduğunu özellikle belirtmek için `builtin` komutunu da
kullanabileceğimizi görmüş olduk.

Fakat dikkat edin `builtin` komutu yalnızca yerleşik komutları
niteliyorken, `command` komutu tüm komut türlerinde takma isimlerin
görmezden gelinmesini sağlıyor.

Bu durumu test etmek için yerleşik komut olmayan `ls` komutunu
`builtin ls` komutu ile doğrudan çalıştırmayı deneyebiliriz.

``` {.bash}
└─$ builtin ls                                                   
bash: builtin: ls: not a shell builtin
```

Bakın `ls` aracının bash kabuğunun yerleşik aracı olmadığı konusunda
hata çıktısı bastırıldı.

Takma ismin görmezden gelinmesi için `command ls` şeklinde girebiliriz.

``` {.bash}
└─$ command ls                                                   
 abc         harf.txt           liste3            sehir
```

Bakın bu kez `ls` aracı için takma isim görmezden gelinip bu isim
doğrudan PATH yolundaki ilgili dosyayı çalıştırmış oldu.

Sanırım bu örneklerle birlikte, neden `type` komutunu kullanma ihtiyacı
duyabileceğimiz ve kabuğun bizim girdiğimiz komutlara bakış açısı
hakkında temel düzeyde de olsa fikir sahibi olabildik.

`type` komutu hakkında dikkat etmeniz gereken detay, `type` aracının
bütüncül olarak girdiğiniz çok argümanlı komutları değerlendirmek için
kullanılmadığı. Yalnızca çalıştırılacak olan araçları temsil eden
komutların kabuk tarafından nasıl ele alındığını görmemizi sağlıyor.

Yani örneğin `ls` komutunun `-l` seçeneğiyle birlikte bu komutun tipini
sorgulamaya çalışabiliriz.

``` {.bash}
└─$ command ls                                                   
 abc         harf.txt           liste3            sehir
```

Bakın `ls` komutunun takma isim olduğu ama `-l` ifadesinin bulunamadığı
belirtilmiş. Tırnak içinde yazmayı da deneyebiliriz.

``` {.bash}
└─$ type "ls -l"                                                 
bash: type: ls -l: not found

└─$ type 'ls -l'
bash: type: ls -l: not found
```

Bakın bu kez de `ls -l` komutunun bulunamadığı hatasını aldık.

Yani bizzat buradaki örnekler üzerinden de teyit ettiğimiz gibi buradaki
`type` aracı yalnızca ona verdiğimiz argümanlardaki araç isimlerin kabuk
tarafından nasıl ele alınıp çalıştırılacağı konusunda bilgi sunuyor.
Mesela `type ls echo cd nano` şeklinde birden fazla argüman verip,
birden fazla aracı temsil eden komutların kabuk tarafından nasıl ele
alındığını görebiliriz.

``` {.bash}
└─$ type ls echo cd nano                                         
ls is aliased to `echo ben takma isimim'
echo is a shell builtin
cd is aliased to `echo ben cd komutuyum'
nano is /usr/bin/nano
```

Bakın bu komutlar kabuk tarafından çalıştırılırken buradaki tipleri
dahilinde ele alınıp çalıştırılıyorlarmış.

En nihayetinde `type` komutunun bizlere kabuğun bakış açısından
komutları görebilme imkanı tanıdığı görmüş olduk. Artık ihtiyacınız
olduğunda komutların kabuktaki tip karşılığını nasıl öğrenebileceğinizi
biliyorsunuz.

`file` Komutu
-------------

`file` aracını dosyaların türleri hakkında bilgi almak için
kullanabiliyoruz.

Özellikle dosya uzantısı bulunmayan ve türünü bilmediğimiz dosyalar
hakkında hızlıca bilgi edinmek için file aracı iyi bir tercih. Daha önce
sıkıştırmış olduğumuz arşiv dosyasının türünden emin olmak için
kullanmıştık hatırlıyorsanız. Tekrar hatırlayacak olursak örneğin
`file ~/.bashrc` komutu ile ***.bashrc*** dosyasının türünü
sorgulayabiliriz.

``` {.vbnet}
└─$ file ~/.bashrc
/home/taylan/.bashrc: Unicode text, UTF-8 text
```

Bakın bu dosya aslında "text" dosyasıymış.

Başka bir örnek olarak arşiv dosyasını sorgulayabilirim.

``` {.csharp}
└─$ file /var/log/user.log.4.gz 
/var/log/user.log.4.gz: gzip compressed data, last modified: Sat Jun  3 07:27:18 2023, from Unix, original size modulo 2^32 113312
```

Bakın bu arşiv dosyasının, hangi tür arşiv olduğu burada kısaca
belirtiliyor. Bu şekilde istediğiniz dosyaları sorgulayıp türleri
hakkında bilgi alabilirsiniz. Tek tek tüm dosyalar üzerinde denememize
gerek yok. `file` aracına argüman olarak belirttiğiniz dosyalar hakkında
bu şekilde kısa bilgi alabiliyoruz. Eğer aldığınız çıktıdaki dosya
türünü bilmiyorsanız internet üzerinde araştırıp gerekli bilgiye
ulaşabilirsiniz.

Son bir örnek olarak sistemde yüklü bulunan araçların dosyalarını da
sorgulayabiliriz. Ben `file /usr/bin/ls` komutu ile `ls` aracının dosya
türünü sorguluyorum.

``` {.bash}
└─$ file /usr/bin/ls                                             
/usr/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6e3da6f0bc36b6398b8651bbc2e08831a21a90da, for GNU/Linux 3.2.0, stripped
```

Gördüğünüz gibi tür olarak "**ELF"** basıldı. Bu kısaltma
"**E**xecutable and **L**inkable **F**ormat" ifadesinin kısalmasıdır. En
genel hali ile yürütülebilir dosyaları temsil ediyor. İşte tıpkı
sorguladıklarımız gibi, sistem üzerinde pek çok farklı türde dosya
bulunuyor. `file` komutu sayesinde de gerektiğinde dosyaların türleri
hakkında bilgi edinebiliyoruz.

`stat` Komutu
-------------

Şimdiye kadar `ls` komutu ile boyut tarih ve isim gibi kriterlere göre
filtreleme yaparken bizzat gördüğümüz gibi sistemimizdeki dosya ve
klasörlerin kendine ait "isim" "boyut" "dizin adresi" "erişim yetkileri"
ve "türü" gibi pek çok öznitelik detayını temsil eden metaverileri
bulunuyor. `stat` komutu da dosya veya klasörlerin sahip olduğu
öznitelikler yani metaveriler hakkında detaylı bilgi sunan bir komuttur.

Ben denemek için `touch yeni-dosya` komutuyla yeni bir dosya oluşturup
stat komutu ile bu dosyanın metaverilerini kontrol etmek istiyorum.

``` {.yaml}
└─$ touch yeni-dosya

└─$ stat yeni-dosya
  File: yeni-dosya
  Size: 0               Blocks: 0          IO Block: 4096   regular empty file
Device: 801h/2049d      Inode: 2893118     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-27 02:05:22.675485267 -0400
Modify: 2023-06-27 02:05:22.675485267 -0400
Change: 2023-06-27 02:05:22.675485267 -0400
 Birth: 2023-06-27 02:05:22.675485267 -0400
```

Bakın dosyayla ilgili pek çok detay konsolumuza bastırıldı.

Dosyanın tam ismi, boyutu ve dosya tipi gibi detaylar burada gözüküyor.
Örneğin bu dosya içerisi boş standart bir dosya olduğu için "regular
empty file" şeklinde çıktı aldık.

Bunun dışında daha önceki anlatımlarımızda kısaca ele aldığımız "inode"
ve "link" bilgisi de burada açıkça belirtiliyor. Buradaki **links**, bu
dosyanın **sahip olduğu katı linkleri** temsil ederken, **inode** değeri
**diskteki veriye ulaşmayı sağlayan benzersiz index numarasını**
belirtiyor.

Dosyanın erişim izinlerini ve sahiplik bilgilerini de buradan
görebiliyoruz. Burası dosyanın yetkilerini, sahibini ve grubunu bize
bildiriyor. Erişim yetkilerinden ileride ayrıca bahsediyor olacağız.

Ayrıca bakın burada dosyanın en son "erişim", "düzenleme" ve "değişim"
tarihleri detaylı şekilde basılmış. Biz dosyayı yeni oluşturduğumuz için
hepsi aynı oldu ama aslında:

**Erişim tarihi;** dosyanın en son erişilen tarihi belirtiyor. Örneğin
dosyanın okunması veya çalıştırılması gibi bir erişim.

**Düzenleme tarihi;** dosya içeriğinin en son ne zaman değiştirildiğini
belirtiyor.

**Değişim tarihi;** dosyanın meta verilerinin en son ne zaman
değiştirildiğini belirtiyor. Örneğin dosyanın ismi değiştirildiyse bu
tarih de değişecektir.

Ayrıca "birth" yani dosyanın ilk oluşturulduğu tarihle ilgili bir satır
daha bulunuyor.

Neticede gördüğünüz gibi `stat` komutu sayesinde dosyaların meta
verilerini detaylı şekilde görüntüleyebiliyoruz.

Sistem Hakkında Genel Bilgi Edinmek
-----------------------------------

`lsb_release` Komutu
--------------------

`lsb_release` komutu sayesinde mevcut dağıtım hakkında çeşitli bilgiler
edinebiliyoruz. Komutumuzda yer alan "**lsb**" ifadesi "**L**inux
**S**tandard **B**ase" ifadesinin kısalmasından geliyor. Linux Standard
Base kısaca (LSB), Linux sistem yapısını standartlaştırmak için Linux
Vakfı'nın organizasyon yapısı altında yürütülen bir projedir. LSB'
projesinin en temel amacı, Linux dağıtımları arasındaki uyumluluğu
sağlamak için bir dizi açık standart geliştirmek ve bunların kullanımını
teşvik etmektir. İşte biz de `lsb_release` komutu ile mevcut
dağıtımımızın bu standartlar dahilindeki ismi ve sürümü gibi detayları
öğrenebiliyoruz. Tüm bilgileri listelemek için `lsb_release -a` komutunu
kullanabiliriz.

``` {.yaml}
└─$ lsb_release -a                                               
No LSB modules are available.
Distributor ID: Kali
Description:    Kali GNU/Linux Rolling
Release:        2022.1
Codename:       kali-rolling
```

Bakın çıktılarda, dağıtıcı kimliği, kullandığım dağıtım, sürümü, kodadı
gibi detaylar bastırıldı. Bu bilgiler mevcut dağıtım hakkında standart
düzende bilgiler sunuyor. Buradaki bilgiler sayesinde mevcut dağıtımın
tam olarak hangi sürüm olduğunu anlayabiliyorum.

Aldığımız çıktının başındaki "lsb modülü bulunamadı" hatasına
takılmayın. Bu hata `lsb_release` aracının kurulu olduğu ama çekirdek
modülünün kurulu olmadığını söylüyor. Şart değil ama dilerseniz lsb
çekirdek modülünü nasıl kurabileceğinizi araştırıp kolayca kurulum
yapabilirsiniz.

Ayrıca `lsb_release —help` komutu ile yardım bilgilerinde de
görebileceğiniz gibi aslında yalnızca -a seçeneği yok. Çeşitli bilgileri
ayrı ayrı bastırmamızı sağlayan farklı seçenekler de var. Eğer kabuk
programlama sırasında bu bilgilere ayrı ayrı ihtiyacınız olan bir
durumla karşılaşırsanız kullanabilirsiniz. Bunun dışında ben yalnızca
gerektiğinde mevcut dağıtım bilgisini edinmek için `lsb_release -a`
komutunu kullanıyorum.

`uname` Komutu
--------------

`uname` komutu mevcut işletim sistemi ve donanımı hakkında temel
bilgiler sağlayan komuttur. Tüm temel bilgilerin hepsini tek seferde
öğrenmek için `-a` seçeneğiyle birlikte kullanabiliyoruz.

``` {.bash}
└─$ uname -a
Linux kali 5.15.0-kali3-amd64 #1 SMP Debian 5.15.15-2kali1 (2022-01-31) x86_64 GNU/Linux
```

Buradaki çıktılara bakarak sırasıyla; çekirdek adını, hostname bilgisini
yani mevcut cihazımızın ağ üzerinden iletişim kurarken kullandığı adı,
sistemin çekirdek sürümünü, tam çekirdek versiyonunu, makinenin donanım
mimarisini ve son olarak da işletim sisteminin adını öğrenebiliyoruz.

Mevcut bulunduğumuz sistemi tanımak için yeteri kadar bilgi burada
sunuluyor.

Ayrıca isterseniz tek seferde bastırdığımız tüm bu bilgileri ayrı ayrı
da bastırabilirsiniz. Seçenekleri görmek için `uname —help` komutunu
kullanabilirsiniz. Neticede gördüğünüz gibi `uname` komutu üzerinden
mevcut sistemimiz hakkında kolayca bilgi edinebiliyoruz.

`uptime` Komutu
---------------

`uptime` ifadesi Türkçe olarak "çalışma süresi" anlamına geliyor.

Adından da anlaşılabileceği gibi `uptime` aracı, sistemin ne kadar
süredir çalıştığı konusunda bilgi almamızı sağlayan bir araç. Hemen
komutumuzu girip sonuçları üzerinden konuşalım.

``` {.lua}
└─$ uptime
 02:16:40 up 19 min,  1 user,  load average: 0.06, 0.07, 0.09
```

`uptime` komutunu tek başına seçenek belirtilmeden kullandığımızda
sırasıyla;

mevcut sistem saatini ,

sistemin ne kadar süredir açık olduğunu,

mevcut sistemde açık olan kullanıcı oturumu sayısı

ve son 1, 5 ve 15 dakikanın sistem yük ortalamalarını veriyor.

Buradaki yük ortalaması, sistemin 1 5 ve 15 dakikalık son periyottaki
meşguliyetini ifade ediyor. Bu çıktılarda sizin sisteminizde yakın
zamanda yani son 15 dakikadan son 1 dakikaya doğru yük miktarın arttığı
görülüyorsa sistem yükünün artmakta olduğunu düşünebilirsiniz.

Şu anda benim sistemin yük altında olmadığı için yani çoğunlukla bekleme
modunda olduğu için buradaki değerler sıfıra yakın gözüküyor. Örneğin
yük durumunu gözlemlemek `echo {1..999999}` şeklinde komutumuzu girip
sistemi suni olarak biraz daha yük altında bırakabiliriz.

``` {.bash}
└─$ echo {1..9999999}
1 2 3 4 5 5 ....
...
..

└─$ uptime                                                       
 02:19:35 up 22 min,  1 user,  load average: 0.13, 0.09, 0.09
```

Bakın yakın zamandaki yük oranı uzak zamana göre artış gösteriyor. Bu
çıktı bize, yakın zamanda sistemin daha fazla yük altına girdiğini haber
veriyor.

Burada dikkat etmeniz gereken detay Linux'ta yük ortalamaları yalnızca
CPU'lara değil, disk kaynaklarına olan talebi de yansıtıyor olması. Yani
disk üzerindeki okuma yazma da sistem yükü ortalamasını etkiliyor.
Elbette bu konu çok daha detayı barındırıyor ancak temel seviye için bu
detaylar gerekli değil. Yine de daha fazla detay için
[buradaki](https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html)
blog yazısını okuyabilirsiniz.

Özetleyecek olursak, eğer sizdeki çıktılarda sistem yükü benim ilk
aldığım çıktıda olduğu gibi düşük veya 0 olarak gözüküyorsa, bu durum
sisteminizin bu kısa periyotta genellikle beklemede olduğunun bilgisini
veriyordur. Eğer yakın zaman aralığında artış görülüyorsa da bu
sisteminizin gittikçe daha fazla yük altında kaldığına işaret ediyordur.

Eğer `uptime` komutundaki bu gibi detayları görmek istemezsek yani bu
çıktı yerine yalnızca sistemin ne kadar süredir açık olduğunu daha
okunaklı şekilde görmek istersek "**p**retty" ifadesinin kısalması olan
`p` seçeneğini de kullanabiliriz.

``` {.bash}
└─$ uptime -p                                                    
up 31 minutes
```

Bakın yalnızca sistemin ne kadar süredir açık olduğunu daha güzel yani
okunaklı şekilde bastırmış olduk.

Eğer tarih olarak sistemin ne zaman başlatıldığını yani ilk açılış
zamanı görmek istersek "**s**ince" ifadesinin kısaltması olan `s`
seçeneğini kullanabiliyoruz.

``` {.bash}
└─$ uptime -s
2023-06-27 01:56:41
```

Bakın sistemin ne zaman başlatıldığı tam tarih ve saat olarak
bastırılmış oldu.

`uptime` komutu sistemin çalışma durumunu kontrol etmek için
kullandığımız basit ama bilgi verici güzel bir araç. `uptime` hakkında
bahsetmemiz gereken ekstra bir detay da bulunmuyor. Zaten yalnızca `-p`
ve `-s` olmak üzere iki işlevsel seçeneği var. Unutmanız halinde yardım
sayfasından seçeneklerin işlevlerini saniyeler içinde tekrar
hatırlayabilirsiniz. Önemli olan `uptime` yani çalışma süresi komutunu
biliyor olmanız. Zaten ismi de tam olarak işlevini tanımladığı için
kolay kolay da unutmazsınız.

`free` Komutu
-------------

`free` aracı, mevcut bellek kullanımı hakkında bilgi almak için
kullandığımız bir araç. Herhangi bir seçenek olmadan doğrudan `free`
komutunu kullandığımızda, mevcut bellek ve takas ile ilgili bilgileri
kilobayt olarak konsola bastırıyor.

``` {.vbnet}
└─$ free
               total        used        free      shared  buff/cache   available
Mem:        10945140      803840     9596448        6652      544852     9884496
Swap:         998396           0      998396
```

Bakın fiziksel ve takas alanı için sütunlar halinde pek çok detay
bastırıldı. Zaten sütun başlıklarında buradaki miktarların tam olarak
neyi temsil ettiği de açıkça belirtiliyor. Buradaki büyüklük birimleri
kilobayt cinsinden. Eğer kilobayt yerine daha okunaklı şekilde çıktıları
bastırmak istersek "**h**uman readable" ifadesinden gelen "**h**"
seçeneğini kullanabiliriz.

``` {.vbnet}
└─$ free -h
               total        used        free      shared  buff/cache   available
Mem:            10Gi       783Mi       9.2Gi       6.0Mi       532Mi       9.4Gi
Swap:          974Mi          0B       974Mi
```

Tüm çıktılar çok daha okunaklı büyüklük birimleriyle bastırılmış oldu.

Neticede gördüğünüz gibi `free` komutu sayesinde toplam bellek ve takas
alanı hakkında ve ayrıca anlık olarak kullanılan ve boştaki bellek
miktarları hakkında kolayca bilgi alabiliyoruz.

Eğer tek seferliğine değil de belirli bir aralık belirterek bu
istatistikleri görmek istersek `-s` seçeneği ile kaç saniyede bir bu
değerlerin bastırılacağını da özel olarak belirtebiliriz. Ben denemek
için `free -s 3` komutu ile 3 saniyelik aralık belirtiyorum. Biz
durduruncaya kadar bu bilgiler 3 saniyede bir konsola bastırılacak.
Durdurmak için Ctrl + c kısayolunu kullanabiliriz.

``` {.vbnet}
└─$ free -s 3
               total        used        free      shared  buff/cache   available
Mem:        10945140      798048     9602124        6652      544968     9890288
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797536     9602628        6652      544976     9890800
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797276     9602880        6652      544984     9891060
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797524     9602628        6652      544988     9890812
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797508     9602628        6652      545004     9890828
Swap:         998396           0      998396

^C
```

Gördüğünüz gibi ben durduruncaya kadar 3 saniyede bir ilgili bilgileri
konsona bastırmış oldu.

Eğer istersek buradaki gibi yalnızca saniye aralığı belirtmek yerine
basılma sayısını da tam olarak belirtebiliriz. Yani biz durdurana kadar
değil bizim önceden belirttiğimiz sayı kadar çıktı basılır. Bunun için
"**c**ount" yani "sayma" anlamındaki ifadenin kısaltmasından gelen `c`
seçeneği kullanabiliriz. Ben `free -s 2 -c 4` komutu ile 2 saniye
aralıkla 4 kez çıktıların bastırılmasını istiyorum.

``` {.vbnet}
└─$ free -s 2 -c 4                                               
               total        used        free      shared  buff/cache   available
Mem:        10945140      796648     9603428        6652      545064     9891684
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      796896     9603176        6652      545068     9891436
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797144     9602924        6652      545072     9891188
Swap:         998396           0      998396

               total        used        free      shared  buff/cache   available
Mem:        10945140      797136     9602924        6652      545080     9891196
Swap:         998396           0      998396
```

2 saniye aralıkla yalnızca 4 kez bellek kullanımı hakkındaki son durum
bastırılmış oldu.

Bu seçenekler dışında `free` komutunun yardım sayfasında yer alan
seçenekler de zaten standart kullanımdaki çıktıları sınırlamak veya
genişletmek için kullanılan ek özelliklerdir. Dilerseniz buradaki
seçenekler ile çıktıları istediğiniz formda bastırabilirsiniz.

Ayrıca aldığımıza çıktılarda yer alan "shared" sütunu eskiye dönük
uyumluluk için mevcut olan ve günümüzde geçerli kullanımı olmayan bir
sütun. Buffer ve cache kavramlarının ne ifade ettiğini bilmiyorsanız
ayrıca araştırıp öğrenebilirsiniz. En özet haliyle, tekrar kullanılacak
verilerin bellekte tutularak hızlı erişimi mümkün kılan bir mekanizma.
Buradaki buff/cache bilgisi de bu amaçla bellekte tutulan veri miktarını
belirtiyor. Daha fazla detayı öğrenmek isterseniz ek araştırma
yapabilirsiniz zira, tam anlaşılmaları bu bölümde açıklanamayacak kadar
uzun sürebilir. Eğer profesyonel anlamda sistem yönetimiyle ilgili
değilseniz bu detay sizin için zaten önemli değil. Diğer sütunlardaki
veriler de oldukça açık şekilde "toplam", "kullanılan" ve "boştaki"
bellek miktarları hakkında bilgi sunuyor.

`du` Komutu
-----------

`du` komutu "**d**isk **u**sage" yani "disk kullanımı" ifadesinin
kısaltmasından geliyor. Bu araç sayesinde dosyalar veya dizinler
tarafından kullanılan tahmini disk alanını öğrenebiliyoruz. Büyük
miktarda disk alanı kaplayan dosya ve dizinleri bulmak için
kullandığımız pratik bir araç.

`du` komutu herhangi bir seçenek veya argüman olmadan çalıştırıldığında,
mevcut dizindeki ve alt dizinlerdeki tüm dosya ve klasörlerin disk
kullanımını bayt cinsinden konsola bastırıyor. Ben şu an kendi ev
dizinimdeyim. Denemek için yalnızca `du` yazıp komutumu onaylıyorum.

``` {.bash}
└─$ du
4       ./.gnupg/private-keys-v1.d
8       ./.gnupg
8       ./.java/.userPrefs/burp
12      ./.java/.userPrefs
16      ./.java
4       ./Templates
4       ./linkler
4       ./Music
4       ./Videos
4       ./yeni klasor
4       ./yeni/y
12      ./yeni
..
..
..
36      ./.cache/pip/wheels
100     ./.cache/pip
436     ./.cache/samba
4       ./.cache/mesa_shader_cache
8       ./.cache/sessions/thumbs-kali:0
20      ./.cache/sessions
4       ./.cache/obexd
185048  ./.cache
4       ./Documents/belgeler
12      ./Documents
8       ./Desktop/yeni-dizin
12      ./Desktop
175436  ./Downloads
8       ./calısma
4       ./ada
4       ./Pictures/bulbeni
20      ./Pictures/Yeni Klasor/yeni-isim
24      ./Pictures/Yeni Klasor
3020    ./Pictures
389344  .
```

Çıktılar çok uzun olduğu için buraya kısaltarak ekledim fakat alt
dizinler de dahil tüm dizinlerdeki klasörlerin bastırıldığı ve en altta
toplam disk boyutunun verdiğini görebiliyoruz.

Fark ettiyseniz klasörler içerisinde yer alan dosyaların isimleri
bastırılmadı ama tabii ki bu dosyaların boyutları bulundukları klasörler
aracılığıyla burada belirtiliyor. Bu sayede çıktılar çok uzamadan mevcut
dizin altındaki tüm klasörlerin büyüklüklerini listeleyebiliyoruz.

Yine de ev dizinimde çalıştırdığım için aldığımız bu çıktılar uzun
olduğu için size karmaşık gelmiş olabilir. Daha yalın bir çıktılar
üzerinden konuşsak daha iyi olacak.

Örneğin ben "***isimler.txt***" dosyasının boyutunu öğrenmek üzere
`du isimler.txt` komutunu giriyorum.

``` {.bash}
└─$ du isimler.txt                                               
8       isimler.txt
```

Bakın dosyanın kaç kilobayt disk alanı kapladığı bastırıldı. Dilersek
birden fazla dosyanın boyutuna da kolayca bakabiliriz. Hatta `-h`
seçeneğini eklersek büyüklüklerin gösterimi bakımından daha okunaklı
çıktılar da elde edebiliriz.

``` {.bash}
└─$ du -h isimler.txt liste1 ~/Downloads/linux.zip 
8.0K    isimler.txt
4.0K    liste1
58M     /home/taylan/Downloads/linux.zip
```

Bakın dosyanın tam dizin adresini belirttiğimiz sürece sorunsuzca
istediğimiz dosyaların boyutlarını öğrenebiliyoruz. Dosya üzerinde
kullanımı gayet basit ve yalın. Birde klasörler üzerinde gözlemleyelim.
Ben gözlemleyebilmek için içerisinde web sitesinin dosyalarını ve iç içe
klasörler barındıran Downloads dizini atlındaki "linux-dersleri"
klasörünün disk üzerinde kapladığı alanı
`du -h ~/Downloads/linux-dersleri` komutu ile sorguluyorum.

``` {.swift}
└─$ du -h ~/Downloads/linux-dersleri                             
736K    /home/taylan/Downloads/linux-dersleri/docs/temel-linux
748K    /home/taylan/Downloads/linux-dersleri/docs
208K    /home/taylan/Downloads/linux-dersleri/css
1.3M    /home/taylan/Downloads/linux-dersleri/img/10- Süreç İşlemleri
3.1M    /home/taylan/Downloads/linux-dersleri/img/1- Komut Satırı
1.5M    /home/taylan/Downloads/linux-dersleri/img/9- Kullanıcı İşlemleri
120K    /home/taylan/Downloads/linux-dersleri/img/0- Gerekli Ortamın Kurulması
764K    /home/taylan/Downloads/linux-dersleri/img/5- Dizin İşlemleri
420K    /home/taylan/Downloads/linux-dersleri/img/20- Log Dosyaları
512K    /home/taylan/Downloads/linux-dersleri/img/2- Yardım Alma Komutları
5.6M    /home/taylan/Downloads/linux-dersleri/img/Linux Nedir
344K    /home/taylan/Downloads/linux-dersleri/img/12- Çalışma Seviyeleri(Runlevels)
320K    /home/taylan/Downloads/linux-dersleri/img/15- Joker Karakterler
1.5M    /home/taylan/Downloads/linux-dersleri/img/11-Disk İşlemleri
2.5M    /home/taylan/Downloads/linux-dersleri/img/14- Güncelleme Kurma Kaldırma İşlemleri
1.3M    /home/taylan/Downloads/linux-dersleri/img/3- Bilgi Alma Komutları
396K    /home/taylan/Downloads/linux-dersleri/img/19- Zamanlanmış Görevler
1.4M    /home/taylan/Downloads/linux-dersleri/img/18- Konsol Üzerinden Dosya İndirmek
1.2M    /home/taylan/Downloads/linux-dersleri/img/6- Dosya İşlemleri
11M     /home/taylan/Downloads/linux-dersleri/img/menu
2.6M    /home/taylan/Downloads/linux-dersleri/img/17- Vim Editörü
424K    /home/taylan/Downloads/linux-dersleri/img/7- Dosya Arşivleme
3.1M    /home/taylan/Downloads/linux-dersleri/img/4 -Linux Dosya Sistemi Hiyerarşisi
508K    /home/taylan/Downloads/linux-dersleri/img/8- Erişim Yetkileri
324K    /home/taylan/Downloads/linux-dersleri/img/13- Sembolik Link Ve Katı Link
21M     /home/taylan/Downloads/linux-dersleri/img/21-Sistem Görünümünü Özelleştirme
836K    /home/taylan/Downloads/linux-dersleri/img/16- Ağ Komutları
61M     /home/taylan/Downloads/linux-dersleri/img
1.1M    /home/taylan/Downloads/linux-dersleri/fonts
240K    /home/taylan/Downloads/linux-dersleri/js
63M     /home/taylan/Downloads/linux-dersleri
```

Şimdi çıktılara bakalım. Bakın en altta klasörün içindeki tüm dosya ve
klasörlerle birlikte diskte kapladığı toplam disk alanı basılmış. Sonda
başa doğru da alt klasörlerin disk üzerindeki boyutları yer alıyor. Her
dizin yalnızca kendi içindeki dosya ve klasörlerin toplam boyutunu
veriyor, bu şekilde içe içe olan tüm dizinlerin boyut bilgisi sırasıyla
bastırılmış oluyor. Neticede gördüğünüz gibi `du` komutu sayesinde bir
klasör içinde tüm dizinlerin disk üzerinde toplam kapladıkları alan
hakkında kolayca bilgi alabildik. Fakat dikkatinizi çektiyse dosyaların
diskte kapladığı alan toplam alana ekleniyor olsa da dosya isimleri yine
bastırılmadı.

Eğer klasörler ile birlikte dosyaların da bastırılmasını istersek `a`
seçeneği ile tüm içeriğin bastırılmasını söyleyebiliriz. Ben komutumu
çağırıp, `a` seçeneği ekleyip tekrar giriyorum.

``` {.swift}
└─$ du -ha ~/Downloads/linux-dersleri                            
4.0K    /home/taylan/Downloads/linux-dersleri/menu.html
4.0K    /home/taylan/Downloads/linux-dersleri/bildirim.html
20K     /home/taylan/Downloads/linux-dersleri/hakkinda.html
..
4.0K    /home/taylan/Downloads/linux-dersleri/js/main.js
4.0K    /home/taylan/Downloads/linux-dersleri/js/fluidtextresizer.js
4.0K    /home/taylan/Downloads/linux-dersleri/js/script.js
240K    /home/taylan/Downloads/linux-dersleri/js
24K     /home/taylan/Downloads/linux-dersleri/sw_sayfa.js
44K     /home/taylan/Downloads/linux-dersleri/liste.html
63M     /home/taylan/Downloads/linux-dersleri
```

Çıtılar uzun olduğu için ben kısaltarak buraya ekledim fakat gördüğünüz
gibi `a` seçeneği sayesinde klasörün içindeki tüm dosya ve dizinlerin
disk üzerinde kapladıkları alanın bilgisini kolayca bu çıktıdan
öğrenebiliyoruz.

İlgili dizindeki tüm içeriği bastırmak dışında ayrıca dilersek yalnızca
belirttiğimiz klasörün boyutunu öğrenmek için "**s**ummarize" yani
"özetlemek" ifadesinin kısalmasından gelen `s` seçeneğini de
kullanabiliriz. Ben yine "***linux-dersleri***" klasörü üzerinde denemek
istiyorum. Bakın yalnızca bu klasörün toplam boyutunu bastırdım.

``` {.bash}
└─$ du -hs ~/Downloads/linux-dersleri                           
63M     /home/taylan/Downloads/linux-dersleri
```

Bunlar dışında eğer istersek spesifik olarak belirttiğimiz birden fazla
dosya ve klasörün toplam disk boyutunu da öğrenebiliriz. Normalde
örneğin ben ev dizinimde ismi büyük "**D**" ile başlayan tüm içeriklerin
`du` aracı ile boyut bilgisini sorgularsam hepsinin ayrı ayrı
büyüklükleri bastırılacak. Hemen denemek için özet ve okunaklı çıktı
almak üzere `du -sh ~/D*` şeklinde komutumuzu girelim.

``` {.bash}
└─$ du -sh ~/D*                                                  
12K     /home/taylan/Desktop
12K     /home/taylan/Documents
234M    /home/taylan/Downloads
```

Bakın büyük "**D**" karakteri ile başlayan içeriklerin hepsinin ayrı
ayrı büyüklükleri konsola bastırıldı. Eğer bu içeriklerin toplam
boyutlarının da bastırılmasını istiyorsak komutumuza `c` seçeneğini de
ekleyebiliriz.

``` {.bash}
└─$ du -shc ~/D*                                                 
12K     /home/taylan/Desktop
12K     /home/taylan/Documents
234M    /home/taylan/Downloads
234M    total
```

Bakın bu kez en alt satırda, tüm içeriklerin toplam boyutu da özellikle
bastırılmış oldu.

Neticede farklı örnekler üzerinden de bizzat teyit ettiğimiz gibi dosya
ve klasörlerimizin disk üzerinde kapladıkları alan bilgisini öğrenmek
için `du` komutunu çok kolay şekilde kullanabiliyoruz. Ayrıca tabii ki
ben `du` aracının tüm özelliklerinden yani tüm seçeneklerinden
bahsetmedim. Eğer yardım sayfasına bakacak olursanız daha fazla kullanım
seçeneği olduğunu da görebilirsiniz. Ancak benim ele aldıklarım
dışındaki diğer seçenekler pek sık tercih edilmediği için ve artık `du`
aracının temel çalışma yapısını öğrendiğiniz için ben tüm seçenekleri
tek tek açıklama gereği duymuyorum tabii ki. Dilerseniz zaten temelde
nasıl çalıştığını bildiğiniz için buradaki ek seçenekleri
keşfedebilirsiniz. Sizin de bildiğiniz gibi yardım sayfaları hep bir
komut uzağınızda.

Ben son olarak sistemimize bağlı bulunan bazı aygıtları listelememizi
sağlayan birkaç bilgi alma komutundan da bahsedip bu bölümü sonlandırmak
istiyorum.

`lsusb` & `lspci` & `lshw`
--------------------------

Sistemimize bağlı bulunan USB aygıtları listelemek istersek, `lsusb`
komutun kullanabiliyoruz. Zaten komutun ismi, işlevini gayet iyi biçimde
açıklıyor. Hemen `lsusb` şeklinde komutumuzu girelim.

``` {.yaml}
└─$ lsusb
Bus 001 Device 002: ID 80ee:0021 VirtualBox USB Tablet
Bus 001 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
```

Bakın benim sisteminde şu anda bu aygıtlar USB ile bağlı gözüküyor. Ben
sanal makine üzerinden çalıştığım için çok aygıt listelenmedi ancak
normalde USB ile bağlı olan aygıtlar burada listeleniyor. Örneğin USB
üzerinden harici bir wifi kartı taktığınızda aygıt hakkında buradan
bilgi alabilirsiniz. USB wifi aygıtınız sistem tarafından tanınmıyorsa,
aygıtınızı takıp `lsusb` komutu ile bu liste üzerinden aygıtın buradaki
ID sine bakabilirsiniz. Bu id üzerinden internette araştırma yaparak
uygun aygıt sürücüsü olup olmadığını sorgulayabilirsiniz. Kullanmakta
olduğunu dağıtıma kurmak için forumlarda mutlaka daha önce pek çok kişi
soru sorup yanıt almıştır. Eğer sorulmadıysa siz de sorabilirsiniz.
Ayrıca github gibi harici kaynaklardan da aygıt sürücülerini
araştırabilirsiniz.

Neticede `lsusb` komutu sayesinde gerektiğinde sistemimize bağlı olan
USB aygıtları hakkında bilgi almamız mümkün oluyor.

Benzer şekilde **pci veriyolu** üzerinden sistemimize bağlı aygıtları
görüntülemek için de `lspci` komutunu kullanabiliyoruz.

``` {.makefile}
└─$ lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)
00:02.0 VGA compatible controller: VMware SVGA II Adapter
00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 02)
00:04.0 System peripheral: InnoTek Systemberatung GmbH VirtualBox Guest Service
00:05.0 Multimedia audio controller: Intel Corporation 82801AA AC'97 Audio Controller (rev 01)
00:06.0 USB controller: Apple Inc. KeyLargo/Intrepid USB
00:07.0 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)
00:0d.0 SATA controller: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [AHCI mode] (rev 02)
```

Bakın `lsusb` komutuna benzer şekilde bu kez **pci** bağlantısı olan
aygıtlar listelenmiş oldu.

Eğer sisteme bağlı bulunan bütün aygıtları listelemek istersek de `lshw`
komutunu kullanabiliyoruz. Buradaki "**hw"** ifadesi "**h**ard**w**are"
yani "donanım" ifadesinin kısaltmasından geliyor. Komutumuzu girip
sonuçlar üzerine tekrar konuşalım.

``` {.python}
└─$ lshw
bash: /usr/bin/lshw: No such file or directory
```

Benim sistemimde bu araç yüklü değişmiş. Kurmak için
`sudo apt install lshw -y` komutunu girelim.

``` {.java}
└─$ sudo apt install lshw
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  lshw
0 upgraded, 1 newly installed, 0 to remove and 1829 not upgraded.
Need to get 300 kB of archives.
After this operation, 941 kB of additional disk space will be used.
Get:1 http://http.kali.org/kali kali-rolling/main amd64 lshw amd64 02.19.git.2021.06.19.996aaad9c7-2+b1 [300 kB]
Fetched 300 kB in 11s (26.7 kB/s)
Selecting previously unselected package lshw.
(Reading database ... 291347 files and directories currently installed.)
Preparing to unpack .../lshw_02.19.git.2021.06.19.996aaad9c7-2+b1_amd64.deb ...
Unpacking lshw (02.19.git.2021.06.19.996aaad9c7-2+b1) ...
Setting up lshw (02.19.git.2021.06.19.996aaad9c7-2+b1) ...
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for man-db (2.9.4-4) ...
```

Tamamdır aracım kuruldu. Şimdi tekrar `lshw` komutu ile tüm donanımları
listelemeyi deneyelim.

``` {.yaml}
└─$ lshw
WARNING: you should run this program as super-user.
kali                        
    description: Computer
    width: 64 bits
    capabilities: smp vsyscall32
  *-core
       description: Motherboard
       physical id: 0
     *-memory
          description: System memory
          physical id: 0
          size: 10GiB
     *-cpu
          product: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz
          vendor: Intel Corp.
          physical id: 1
          bus info: cpu@0
          version: 6.94.3
          width: 64 bits
          capabilities: fpu fpu_exception wp vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp x86-64 constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 movbe popcnt aes rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase bmi1 bmi2 invpcid rdseed clflushopt md_clear flush_l1d arch_capabilities
          configuration: microcode=4294967295
     *-pci
          description: Host bridge
          product: 440FX - 82441FX PMC [Natoma]
          vendor: Intel Corporation
          physical id: 100
          bus info: pci@0000:00:00.0
          version: 02
          width: 32 bits
          clock: 33MHz
        *-usb
             description: USB controller
             product: KeyLargo/Intrepid USB
             vendor: Apple Inc.
             physical id: 6
             bus info: pci@0000:00:06.0
             version: 00
             width: 32 bits
             clock: 33MHz
             capabilities: ohci bus_master cap_list
             configuration: driver=ohci-pci latency=64
             resources: irq:22 memory:f0804000-f0804fff
        *-bridge
             description: Bridge
             product: 82371AB/EB/MB PIIX4 ACPI
             vendor: Intel Corporation
             physical id: 7
             bus info: pci@0000:00:07.0
             version: 08
             width: 32 bits
             clock: 33MHz
             capabilities: bridge
             configuration: driver=piix4_smbus latency=0
             resources: irq:9
  *-input:0
       product: AT Translated Set 2 keyboard
       physical id: 1
       logical name: input0
       logical name: /dev/input/event0
       logical name: input0::capslock
       logical name: input0::numlock
       logical name: input0::scrolllock
       capabilities: i8042
WARNING: output may be incomplete or inaccurate, you should run this program as super-user.
```

Çıktıları kısaltarak vermiş olmama karşın farlı kategoriler altında
bilgisayara bağlı bulunan aygıtların listelendiğini görebiliyoruz.

Ayrıca benim kısaltmış olmam dışında eğer sizin aldığınız çıktılarda
aygıtlar eksikse, aracınızı `sudo lshw` komutuyla yetkili şekilde
çalıştırmayı deneyebilirsiniz. Tabii ki bu bilgiler sürekli olarak
ihtiyacımız olacak türden bilgiler de değil. Yalnızca aygıtınızla ilgili
sorun çözmeniz gerektiğinde size bilgi vermesi için veya belki
forumlarda destek isterken kullanabileceğiniz basit işlevsel bir araç
yalnızca.

En nihayetinde bence komut satırı üzerinden mevcut sistemin aygıtları
hakkında bilgi almak için bu bahsetmiş olduğumuz komutlar çoğu durumda
yeterli.

Ben özellikler değinmeyeceğim ama hem bu bahsetmiş olduğumuz komutların
ek seçenekleri hem de ayrıca bir çok aygıt hakkında bilgi sunan ek
komutlar da mevcut. Merak ediyorsanız biraz araştırma ile diğer
komutları ve seçeneklere kolayca ulaşabilirsiniz. Örneğin bizim
bahsetmiş olduğumuz komutların yardım sayfalarına bakarak diğer
seçenekler hakkında bilgi sahibi olup, sonuçlarını bizzat test ederek
gözlemleyebilirsiniz.

Bu bölümde ele aldığımız komutlar genel bilgi alma komutları olduğu için
çok fazla üzerine düşüp uzun açıklamalar yapmak istemedim çünkü pek çok
farklı türde bilgi sunan komutları ele aldığımız için detaylıca
bahsetmeye kalksaydık bu bölüm çok uzun sürebilirdi. Üstelik çoğu ek
araç temel sistem yönetimi için bilmenizin şart olmadığı ek bilgi
araçları. Ben sadece en temel bilgi alma komutlarının en temel
işlevlerini odaklandım. Bu sayede daha fazlası için gerektiğinde yardım
sayfaları ve internet araştırması ile tüm sorularınıza yanıt
bulabilirsiniz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 17. Ders 102 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Söz konusu sistemi yönetmek olduğunda disk yönetimi önemli konuların
başında geliyor. Tüm disk işlemlerini bilinçli şekilde
gerçekleştirebilmemiz için de neyi neden yaptığımızın farkında olmamız
gerekiyor. Bu sebeple öncelikle uygulamalar sırasında bahsi geçecek olan
bazı kavramları temel düzeyde açıklamak istiyorum. Mevcut eğitimin
hedefi temel düzey olduğu için elbette çok teknik detaylara
giremeyeceğiz.

En temelden başlayacak olursak verilerin nasıl ele alındığıyla
başlayabiliriz.

Veri Nedir ve Nasıl Ölçülür ?
-----------------------------

Bilgisayarların yalnızca 0 ve 1'lerden anladığını mutlaka
duymuşsunuzdur. Düşük akım "0" iken yüksek akım "1" olarak kabul
ediliyor. Bu elektrik sinyallerinin uygun şekilde sıralanması ile
bilgisayar, verileri işleyip sonuçlarını sunabiliyor. Tüm veri aktarımı
bu ikili sayı sistemi üzerinden yapılıyor. Bu ikili sayı sistemine yani
0 ve 1'lerden oluşan veri kümesine de "ikili kod" yani "binary code"
deniyor.

Bu 0 ve 1 sinyalleri de bilgisayarlar üzerindeki en küçük veri birimi
olan **bit** kelimesi ile ifade ediliyor. **Bit** ifadesi küçük **b**
ile temsil ediliyor.

**8 tane bit** yan yana getirilerek de bir **bayt** oluşturuluyor.
Baytlar da büyük **B** ile ifade ediliyor. Bir bayt 2\^8 den tam 256
farklı değeri temsil edebiliyor. Bu baytlar da **ascii** gibi
standartlarca belirlenmiş olan özel karaktere karşılık geliyor. Örneğin
büyük **A** harfinin ikili sayı sistemindeki karşılığı **0 1 0 0 0 0 0
1** olup **ascii** kodu **65'**tir. Bizi şu an doğrudan ilgilendirmediği
için **ascii** kodunun nasıl hesaplandığına değinmek istemiyorum. Kısa
bir ek araştırma ile ulaşabilirsiniz.

![aschii.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/aschii.webp)

Neticede burada esas vurgulamak istediğim, biz tek bir karakteri
kullandığımızda örneğin klavyemizden "a" tuşuna bastığımızda bu karakter
toplam 8 bitten 1 bayta karşılık geliyor ve bilgisayar bu "a"
karakterini ikili kod olarak ele alıp işliyor. Elbette sizlerin de
bildiği gibi büyüklük birimleri bitlerden ve baytlardan ibaret değil.
Aşağıdaki tabloya bakarak diğer büyüklük birimlerini de görebiliriz.
Normalde bizler hep ondalık sayı sistemine göre karşılıklarını telaffuz
ediyoruz ancak bazı komut çıktılarında da karşılaşabileceğimiz gibi
büyüklük birimlerinin ikili gösterimi de bulunuyor.

![decimal-binary-table](https://www.linuxdersleri.net/egitim/temel-linux/disk/decimal-binary.webp)
[Tablo Kaynağı](https://en.wikipedia.org/wiki/Byte#Multiple-byte_units)

**Ondalık(Decimal) Gösterim:**

1000 bayt = 1 kilobayt,

1000 kilobayt = 1 megabayt,

1000 megabayt = 1 gigabayt ediyor.

**İkili(Binary) Gösterim:**

1024 bayt = 1 kibibyte,

1024 kibibayt = 1 mebibyte,

1024 mebibyte = 1 gibibyte ediyor.

Bu sebeple özellikle disk yönetimiyle ilgili kullandığımız komutların
sonucunda, ikili gösterimin kısaltması olan **KiB MiB GiB** gibi
kısaltmalarla karşılaşıyor olacağız. Disklerle ilgili uygulamalar
yaparken zaten bu gösterimlerle karşılaşacağımız için şimdiden açıklamak
istedim. Bizler yaygın olarak ondalık gösterimi kullanıyor olsak da
aslında bilgisayarların ikili sayı sisteminden anladığını biraz önce
belirttik. Yani aslında bilgisayarlar için ikili sayı sistemini temsil
eden büyüklük değerleri(Kib, MiB, GiB) geçerlidir.

Yine de ikili sayı sistemine oranla ticari olarak, ondalık gösterim daha
büyük alan vaat ediyor gibi göründüğü için depolama birimlerinin
büyüklüklerini tanımlamada çok daha yaygın kullanılıyor. Zaten bu
sebeple bizler de yaygın olarak ondalık(MB, KB, GB) gösterimin büyüklük
karşılığına aşina oluyoruz.

Normalde karıştırılanın aksine örneğin 1 gigabayt 1024 megabayt
değildir. Hatta teyit etmek için Google'a "**1 gb to mb**" şeklinde
yazıp aratabiliriz.

![gb-to-mb.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/gb-to-mb.webp)

Bakın **1 gigabyte**'ın **1000 megabyte** olduğu belirtiliyor. Zaten bu
sebeple satın aldığımız diskler sisteme bağladığımızda bizim
beklediğimizden daha az depolama alanına sahip gözüküyor.

Örneğin **1 terabayt**lık disk, sistem üzerinde yaklaşık **931
gibibyte** olarak gözüküyor. Çünkü depolama alanının büyüklük birimi
**terabayttan gibibyte** dönüştürülüyor. Yine Google üzerinden de bu
durumu teyit edebiliriz.

![tb-to-gib.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/tb-to-gib.webp)

Bakın **1 terabayt** aslında yaklaşık olarak **931 gibibayt**.
Bilgisayar, ikili sayı sistemi üzerinden hesaplama yaptığı için onluktan
ikili düzene geçişte bu farklar ortaya çıkıyor. Bizler de işletim
sistemleri üzerinde bu büyüklük farklarını görebiliyoruz.

En genel haliyle büyüklük birimleri hakkında bilmemiz gerekenler bunlar.

Veriler Diskte Nasıl Depolanır ?
--------------------------------

Büyüklük birimlerinden bahsettiğimize göre verilerin diskte nasıl
depolandığından da kısaca bahsedebiliriz. Elbette fiziksel olarak
disklerin nasıl çalıştığına değinmeyeceğiz. Ama merak ediyorsanız
Youtube üzerinde animasyonlu şekilde diske nasıl veriler yazıldığı ve
verilerin nasıl okunduğunu açıklayan pek çok video var. Bunları
izleyerek tam olarak nasıl çalıştığını kavrayabilirsiniz. Biz şimdi
diskteki verilerin, birimlerinden bahsedelim.

Sektör
------

**8 bit'**in **1 byte** ettiğini öğrendik. Baytlar da disk üzerindeki en
küçük birim olan **sektörler** üzerinde barındırılıyor. Sektör dediğimiz
kavram, diskteki verileri tutan fiziksel bir noktadır. Standart bir
sabit diskte de her bir sektör 512 bayt veri tutabiliyor.

![sector.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/sector.webp)

Blok
----

Sektör birimi dışında bir de blok olarak isimlendirilen işletim
sistemleri için gruplanmış birimler vardır. Bloklar, en genel tanımıyla
işletim sisteminin adresleyebileceği yani işaret edebileceği bir sektör
grubudur. Bir blok yalnızca tek bir sektörden ibaret olabilir, ya da
2'li 4'lü 8'li 16'lı gibi birden çok sektörün bir araya gelmesiyle de
oluşturulabilir.

![block.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/block.webp)

Blok olarak ifade ettiğimiz birim, aslında dosya sisteminin
adresleyebileceği en küçük depolama birimini temsil eden bir
soyutlamadır. Hatırlıyorsanız inode kavramından bahsederken, inode'un
aslında disk üzerindeki verilerin hangi bloklarda olduğunu söyleyen yapı
olduğunu öğrenmiştik. Yani aslında verilerin disk üzerinde bloklar
halinde tutulduğunu daha önce de üstü kapalı şekilde görmüştük.
Verilerin disk üzerinde bloklar halinde tutulmasının nedeni, diskin en
verimli şekilde işletim sistemi tarafından yönetilebilmesini
sağlamaktır. Ama şu an bu konunun detaylarına girmek istemiyorum.
Anlatımın devamında neden blok yaklaşımın kullanıldığından zaten
bahsedeceğiz. Şimdi blok kavramının tam olarak neyi ifade ettiği
üzerinde biraz daha duralım.

İşletim sisteminin ana yapısı olan çekirdek, tüm dosya sistemi
işlemlerini blok birimleri üzerinden ele alınır. Burada depolama
bağlamında kullandığımız "blok" ifadesi, disk donanımı ile sistemin
kaynaklarını yönetmekten sorumlu olan çekirdek arasında arabirim
oluşturabilen en küçük boyuttur. Yani fiziksel olarak böyle bir gruplama
söz konusu değil. Yalnızca soyut olarak sektörlerin gruplanmış haline
blok diyoruz. Dolayısıyla işletim sisteminin emirleri doğrultusunda bir
diskten veri okunurken veya bir diske veri yazılırken, veriler bloklar
halinde okunur veya yazılır. Örneğin Linux sisteminin varsayılan dosya
sistemi formatı olan **ext4**'ün, standart blok boyutu **4096 byte**dir.
Disk üzerindeki en küçük birim olan tek bir sektör **512 byte** veri
tutabildiği için bize soyutlama katmanı sunan ext4'ün varsayılan olarak
ele aldığı en küçük disk birimi **8 sektörden meydana gelmiş tek bir
bloktur**. Yani **ext4** dosya sistemine sahip disk bölümlerine veriler
yazılırken veya okunurken disk üzerinde **4096 byte** karşılık gelen
8'er sektörlük birimler kullanılır. Bu da her veri kümesi için 4096
baytlık veri bloklarının kullanılacağı anlamına geliyor.

![ext4-sector.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/ext4-sector.webp)

Belki buradaki açıklamalarım yeterince anlaşılır gelmemiş olabilir.
Hemen somut bir örnek üzerinden açıklamalarımızı pekiştirelim.

Örneğin bir metin belgesi oluşturup içerisine tek bir karakter girersek,
bu karakter 1 byte veriye karşılık gelecektir. Zaten tek bir karakterin
1 byte karşılık(\~çoğunlukla) geldiğinden anlatımın başında
bahsetmiştik. Bu karakter 1 byte karşılık geliyor ancak, bizim
kullandığımız dosya sisteminin en küçük birimi olan blok boyutu 4096
byte olduğu için dosya içerisine yazdığımız 1 baytlık veri de olsa, disk
üzerinde bu veri 4096 baytlık disk bölümü işgal edecek. Çünkü mevcut
dosya sisteminin ele alabileceği yani kontrol edebileceği en küçük birim
bu 4096 baytlık bloktur. Hemen uygulamalı şekilde bu durumu
gözlemleyelim.

Ben `cat > test` komutunu girip "**1**" yazıyorum ve alt satıra geçmeden
Ctrl + d ile veri girişini sonlandırıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat > test                                                                                                                                              
1
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat test                                                                                                                                                
1
```

Gördüğünüz gibi içerisinde yalnızca 1 rakamı bulunuyor. Şimdi dosya
hakkında daha detaylı bilgi almak için `stat test` komutunu girebiliriz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ stat test                                                                                                                                               
  File: test
  Size: 1               Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2891462     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/  taylan)   Gid: ( 1000/  taylan)
Access: 2023-07-09 05:09:17.715076334 -0400
Modify: 2023-07-09 05:09:15.184342332 -0400
Change: 2023-07-09 05:09:15.184342332 -0400
 Birth: 2023-07-09 05:08:20.403746381 -0400
```

Tüm bu çıktılardan biz şimdilik yalnızca büyüklükler hakkında bilgi
sunan bu satıra odaklanacağız.

``` {.yaml}
Size: 1               Blocks: 8          IO Block: 4096   regular file
```

Bakın dosyanın gerçek boyutu(Size:) **1** bayt olarak gözüküyor. Blocks
ifadesinin karşısında da kaç tane sektörü işgal ettiği yazıyor. Hemen
yanında da bloğun boyutu yazıyor. Buradaki "io" ifadesi "**i**nput
**o**utput" ifadesinden geliyor. Bu bilgi de mevcut dosya sisteminin tek
bir blok boyutunu belirtiyor. Neticede 1 baytlık bu dosyanın 4096
baytlık bir blok üzerinde 8 sektörlük disk alanını işgal ettiğini bu
çıktılara bakarak teyit edebiliyoruz. Bizim örneğimizdeki tek bir
karakterin diskte barındırılması için; bir sektör 512 bayt olduğu için
tek bir blok için 8 sektör yani 4096 baytlık alan kullanılmış oldu.

![1byte.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/1byte.webp)

Emin olmak için dosya boyutunu bir blok boyutunu aşacak şekilde revize
edebiliriz. Ben örnek olarak `echo {1..1045} > test2` şeklinde komutumu
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo {1..1045} > test2
```

Bu sayede 1'den 1045'e kadar olan tüm sayılar dosyaya yazılmış oldu.
Şimdi `stat` komutu ile tekrar dosyanın özelliklerini görüntüleyelim.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ stat test2
  File: test2
  Size: 4118            Blocks: 16         IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2891462     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/  taylan)   Gid: ( 1000/  taylan)
Access: 2023-07-09 05:09:17.715076334 -0400
Modify: 2023-07-09 05:12:35.272248119 -0400
Change: 2023-07-09 05:12:35.272248119 -0400
 Birth: 2023-07-09 05:08:20.403746381 -0400
```

Bakın dosyanın boyutu 4096 byte'ı sadece biraz geçmiş olmasına rağmen 16
sektörü yani toplam iki blokluk 8192 byte alanı işgal ediyor.

![4118byte.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/4118byte.webp)

İşte bizzat teyit edebildiğimiz gibi dosya sisteminin sahip olduğu blok
boyutuna göre veriler, bloklar halinde diskte depolanıyor ve tekrar bu
bloklar üzerinden okunuyor. Tam da bu noktada muhtemelen, bu yaklaşımla
depolama biriminin tam olarak verimli kullanılamadığını yani bloklardaki
boş disk alanlarının kullanılması gerektiğini düşünmüş olabilirsiniz.
Ancak bu tam olarak doğru bir yaklaşım sayılmaz.

İşletim sistemi çekirdeğinin kontrolündeki dosya sistemine göre en küçük
birim blok olduğu için bir bloğun kısmi bir bölümünü kullanamayız. Çünkü
dosya sistemi bloktan daha küçük bir alana adresleme yapamaz. Yani ilk
örneğimizde olduğu gibi 1 baytlık dosya için 4096 baytlık blok
kullanılmak zorunda. Eğer bu dosyaya yeni veri eklenmezse başka bir
dosyayla ilişkili olan herhangi bir veri bu bloğa yazılamaz. Çünkü dosya
sistemi bloğun bir kısmına adresleme yapamaz. Yalnızca bloğun bütününe
adresleme yapabilir. Zaten inode kavramını ele alırken bu durumdan da
bahsetmiştik hatırlarsanız. Yani örneğin bir bloğun bir kısmında X
dosyasının verileri bir kısmında da Y dosyasının verileri
barındırılamaz. Çünkü barındırılsa bile dosya sistemi, bloktan daha
küçük birimleri kontrol edemediği için X ve Y dosyası gibi bir ayrım
gözetmeden yalnızca tüm bloğu işaret edebilir. Zaten hatırlarsanız inode
değeri de dosyanın içindeki verilerin hangi bloklarda olduğunu
söylüyordu. İlgili verilerin, bloğun tam olarak neresinde olduğuna
bakılmıyor, komple bloğun kendisi ele alınıyor. Yani özetle veriler
dosya sistemi tarafından blok blok ele alınıyor. Bu nedenle bir dosya
aslında tüm bloğu tüketmese bile yani tüm bloğu doldurmasa bile, disk
üzerindeki bloğa ayrılmış olan sektörlerin bir kısmı boş kalabilir.
Dolayısıyla sistemde barındırılacak dosyaların genel boyutlarına göre
blok boyutlarının belirlenmesi önemlidir. Eğer çoğunlukla büyük boyutlu
dosyalar barındırılacaksa blok boyutları büyük olabilir. Ya da küçük
boyutlu dosyalar bulunacaksa da blok boyutları küçük şekilde konfigüre
edilebilir.

Ne kadar çok blok olursa, ilgili verilere ulaşması o kadar zaman
alırken, disk alanı daha tasarruflu kullanılmış olur. Tersi şekilde blok
sayısı az olduğunda da verileri ulaşım hızlıyken, alan tasarrufu mümkün
olmayabilir. Bu sebeple aksini gerektiren özel bir durum olmadığı sürece
kullanılan dosya sisteminin varsayılan blok boyutu tercih edilmedir. Bu
varsayılan değer, ilgili dosya sistemi üzerindeki optimum değer olduğu
için çoğunlukla en doğru tercihtir.

Şimdilik daha fazla detaya gerek yok. Temel büyüklük ve blok gibi
kavramları ele aldığımıza göre artık disk bölümleri hakkında da
konuşabiliriz.

Disk Bölümleri ve Bölümlendirme Tablosu
---------------------------------------

Fiziksel diskimizi yazılımsal olarak bölümlere ayırıp farklı amaçlar
için kullanabiliyoruz. Hangi disk bölümünün nerede başlayıp nerede
bittiğinin bilgisi de "bölümlendirme tablosu" olarak isimlendirilen MBR
ya da GPT tablolarında tutuluyor. Aslında alternatif tablolar da var
ancak şu an için bizi yalnızca MBR ve GPT ilgilendiriyor.

MBR
---

MBR, artık eskimiş olan ancak hala çok sık karşılaştığımız ve
karşılaşmaya devam edeceğimiz disk bölümleme tablosudur. MBR disk
bölümleme tablosu maksimum 2 TB'a kadar olan disk boyutlarını
destekliyor. Ve MBR disk bölümleme tablosu kullanılarak disk yalnızca 4
birincil bölüme ayrılabiliyor. Yine de birincil bölüm sınırlamasını
aşmak için, birincil bölümlerden birini mantıksal bölümlere ayrılan
genişletilmiş bölüm olarak da kullanabiliyoruz. Yani MBR bölümleme
tablosunda maksimum 3 birincil ve 1 genişletilmiş bölüm üzerinden 12
mantıksal olmak üzere toplam 15 tane bölüm oluşturabiliyoruz.

![mbr-max.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/mbr-max.webp)

GPT
---

**GPT**, zaman içinde disk kapasitelerinin artması ve diskleri daha
fazla alana bölümlenebilmesi ihtiyaçları doğrultusunda **MBR**'ın
yetersiz kaldığı noktada geliştirilmiş olan yeni nesil disk bölümleme
tablosudur. GPT maksimum 8 [ZiB](https://en.wikipedia.org/wiki/ZiB)'a
kadar olan disk boyutlarını destekliyor. Yani eski nesil bölümleme
tablosu olan MBR'a oranla günümüz şartları için gereken büyüklükleri
destekliyor. Ayrıca GPT sayesinde diski 128 bölüme ayırmamız da
mümkündür. Hatta bu sayı bölümleme tablosunda daha fazla alan ayrılarak
genişletilebilir ancak bizim için 128 bölüm bile son derece yeterli.
Üstelik GPT disk bölümleme tablosunda "**primary**" ve "**extended**"
yani "**birincil**" ve "**genişletilmiş**" diye bir ayrım da bulunmuyor.
Tüm bölümler birincil olarak ayrılıyor. MBR üzerinde ise mantıksal
bölümlerle birlikte maksimum 15 bölüm oluşturulabiliyor.

Yani özetle MBR'a oranla GPT hem maksimum boyut hem de bölüm sayısı ile
çok daha kullanışlı bir bölümleme tablosudur.

Aslında MBR ve GPT hakkında bahsedilebilecek pek çok ek detay daha
bulunuyor ancak konuyu çok dağıtmak istemiyorum. Merak ediyorsanız tüm
detaylarına kısa bir araştırma ile ulaşabilirsiniz. Neticede her iki
bölümleme tablosu hakkında genel bilgi sahibi olduk. Şimdi bu bölümleme
tablolarının nerede nasıl kullanıldığından bahsederek devam edelim.

BIOS ve UEFI
------------

Daha önce herhangi bir işletim sisteminin kurulumunu
gerçekleştirdiyseniz, mutlaka BIOS ve UEFI kavramları ile
karşılaşmışsınızdır. En genel haliyle bu kavramlar, bilgisayarın
başlangıç aşamasından sorumlu olan yapıları ifade ediyor. BIOS daha eski
bir yaklaşımken, UEFI yeni dönemin ihtiyaçlarına yanıt vermek üzere
geliştirilmiş yeni bir çözümdür.

En temel sorumlulukları, bilgisayar açılırken donanımların kontrolü
gerçekleştirip, uygun olan diski başlatmaktır. Bu sayede disk
içerisindeki işletim sistemi başlatılmış oluyor.

Yani aslında biz cihazımızı başlattığımızda BIOS veya UEFI (modern
sistemlerde), öncelikle sistem donanımlarını kontrol ediyor. Eğer
donanımlar sorunsuzsa, belirlenen öncelik sırasına göre ilk diski
başlatıyor. Zaten daha önce işletim sistemi kurulumu yaptıysanız mutlaka
BIOS veya UEFI ayarlarında, başlatmak istediğiniz diski ilk sıraya
getirmişsinizdir. İlk sıradaki disk BIOS veya UEFI sayesinde
başlatıldıktan sonra bu diskteki bölümlendirme tablosu kontrol ediliyor.
Bölümlendirme tablosunda hangi bölüm "boot" edilecek yani "önyüklenecek"
bölüm olarak işaretlendi ise o bölümün önyüklenmesi sağlanıyor. Zaten bu
bölümde de genellikle "boot loader" olarak geçen, işletim sisteminin
başlatılmasını için gerekli olan(çekirdek gibi) yapıları yükleyen bir
araç vardır. Bu sayede boot loader üzerinden ilgili işletim sistemi
başlatılmış olur. Örneğin diskinizde birden fazla işletim sistemi kurulu
ise, boot loader yazılımı üzerinden istediğiniz işletim sisteminin
başlatılmasını da sağlayabilirsiniz. Linux üzerinde boot loader olarak
genellikle GRUB kullanılıyor fakat biz bu eğitimde bu konudan
bahsetmeyeceğiz.

Özetle, eğer sizin cihazınızda BIOS kullanılıyorsa MBR disk bölümleme
tablosunu kullanabiliyorsunuz. UEFI varsa, GPT bölümleme tablosunu
kullanmanız mümkün oluyor.

BIOS genel işlem akışı.

![bios.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/bios.webp)

UEFI genel işlem akışı.

![uefi.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/uefi.webp)

Esasen bu konu pek çok detayı barındırıyor, fakat temel seviye için bu
başlangıç yeterli. Netleştirmek için mutlaka ek olarak araştırmanızı
öneririm. Yine de bu bölümdeki anlatımları takip etmek için şimdilik bu
kadarlık bilgi yeterli.

Dosya Sistemi Nedir ?
---------------------

Dosya sistemi, en genel haliyle disk bölümündeki verilerin nasıl ele
alınacağını belirleyen yapıdır. Dosya sistemi ifadesi, isminde de yer
aldığı şekilde dosyaların diskteki veri karşılıklarının nasıl depolanıp
ne şekilde ele alınacağını belirleyen sistematik bir metodolojiyi temsil
eder. Dosya sistemi olmadan diskteki veriler yalnızca yığınlardan
ibarettir. Dosya sistemi olmadan diskteki verilere erişip onları
yönetemeyiz.

![file-systemd-vs.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/file-systemd-vs.webp)

Tek bir diski birden fazla bölüme ayırabildiğimiz için de esasen aynı
fiziksel diskteki farklı bölümlerde birbirinden farklı dosya
sistemlerini kullanmamız da mümkündür.

![multi-filesystem](https://www.linuxdersleri.net/egitim/temel-linux/disk/multi-filesystem.webp)

Bu sayede aynı disk aygıtı üzerinden, ihtiyaca yönelik farklı dosya
sistemleri kullanılabilir. Yani diski bölümledikten sonra işiniz
bitmiyor aslında. Bu disk bölümü için bir de dosya sistemi tanımlaması
yapmanız gerekiyor. Aksi halde işletim sistemi üzerinden disk
bölümündeki verilere ulaşılması mümkün olmuyor. Çünkü dosya sistemleri,
verilerin diskte nasıl depolandığı ve tekrar nasıl erişilebileceğini
işletim sistemine izah ediyor.

Dizinlerde gezintiyi ele aldığımız bölümde Linux sisteminin "**dosya
sistemi hiyerarşisini**" de kısaca açıklamıştık. Linux sisteminde tüm
dosyalar "**kök dizin**" olarak ifade edilen "**/**" dizininden başlayıp
alt klasörlerde hiyerarşik düzende tutuluyor. Linux, farklı dizinlere
farklı disk bölümlerini bağlamayı da mümkün kıldığı için kök dizin
altında gözüken ancak birbirinden farklı disk bölümlerinde birbirinden
farklı dosya sistemlerine sahip klasörler tek bir dizin hiyerarşisi
içerisinde gözükebiliyor.

![file-systemd-hierarchy](https://www.linuxdersleri.net/egitim/temel-linux/disk/file-systemd-hierarchy.webp)

Normalde Windows sisteminden bildiğimiz üzere işletim sisteminin kurulu
olduğu disk "**C:**" olarak isimlendirilir ve ek disk aygıtları ya da
bölümleri de **D:** **E:** **F:** gibi isimler ile ayrı olarak bağlanıp
kullanılır. Linux'ta ise tüm disk aygıtları kök dizin altındaki uygun
klasöre bağlanarak kullanılıyor. Yani ayrı olarak ele alınmıyor, tekil
hiyerarşi olduğu için bu hiyerarşiye dahil ediliyor.

Linux sistemi pek çok farklı dosya sistemini destekliyor. Bunları görmek
için `cat /proc/filesystem` komutunu girebiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /proc/filesystems 
nodev   sysfs
nodev   tmpfs
nodev   bdev
nodev   proc
nodev   cgroup
nodev   cgroup2
nodev   cpuset
nodev   devtmpfs
nodev   debugfs
nodev   tracefs
nodev   securityfs
nodev   sockfs
nodev   bpf
nodev   pipefs
nodev   ramfs
nodev   hugetlbfs
nodev   devpts
nodev   mqueue
nodev   pstore
        ext3
        ext2
        ext4
nodev   autofs
nodev   configfs
        fuseblk
nodev   fuse
nodev   fusectl
nodev   rpc_pipefs
nodev   vboxsf
```

Linux çekirdeğin desteklediği dosya sistemleri konsola bastırıldı.
Aslında hepsi burada yazmıyor fakat bu noktada tüm detaylara hakim
olmamız şart değil. Birden fazla dosya sistemi olduğunu bilmemiz
yeterli. Elbette her bir dosya sisteminin avantajları ve dezavantajları
birbirinden farklı. Dolayısıyla farklı amaçlar için farklı dosya
sistemleri kullanılabiliyor. Bunların detayları için ekstra araştırma
yapabilirsiniz. Ben anlatımlar sırasında Linux üzerinde yaygın kullanıma
sahip olan **ext4** dosya sistemini kullanıyor olacağım.

Hazırlık
--------

Diskler üzerinde uygulamalar yapabilmek için öncelikle uygun ortamı
hazırlamamız gerekiyor. Merak etmeyin disk işlemleri için birden fazla
diske veya büyük disk kapasitelerine sahip olmanız gerekmiyor. Sanal
makine üzerinden de istediğimiz biçimde sanal disk oluşturup bunlar
üzerinden uygulama yapabiliriz. Üstelik sanal ortamda çalıştığımız için,
mevcut disklerimizdeki verileri kaybetmekten korkmadan disk yönetimi
konusunda pratik yapabiliriz.

Disk üzerinde yapılan işlemler normal şartlarda çok risklidir. Eğer
yedeği yoksa yaptığınız hataları telafi etmeniz mümkün olmayabilir. Bu
sebeple öğrenme aşaması için sanal sistem üzerinde kurcalamaktan
korkmadan tüm işlemleri ve sonuçlarını deneyimlemek en mantıklı yaklaşım
olacaktır. Yani eğer eğitimi sanal makine üzerinden takip etmiyorsanız
size önerim en azından disk yönetimi bölümünü yani bu bölümdeki
uygulamaları sanal makineniz üzerinden takip etmenizdir.

Ben kurulum rehberini herkes için ulaşılabilir olması açısından ücretsiz
virtualbox sanallaştırma yazılımı üzerinden ele alacağım. Siz
dilediğiniz bir sanallaştırma çözümünü kullanabilirsiniz elbette.

Ayrıca zaman içinde arayüz değişiminden dolayı, buradaki sanal disk
ekleme rehberi eskimiş olabilir. Bu durumda sezgisel olarak ya da kısa
internet araştırması ile nasıl sanal disk ekleyebileceğinizi
keşfedebilirsiniz.

Virtualbox Üzerinden Sanal Disk Eklemek
---------------------------------------

Öncelikle sanal makinenizi kapatmanız gerekiyor. Çünkü makine açıkken
ayarlarını değiştirmemiz mümkün değil.

![close-virtualbox.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/close-virtualbox.webp)

Sanal makinenizin üzerine sağ tıklayıp ayarları açın.

![virtualbox-settings.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-settings.webp)

Ayar penceresindeki "**Depolama**" sekmesine tıklayın.

![virtualbox-settings-storage.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-settings-storage.webp)

Denetleyici üzerindeki disk ekleme ikonuna tıklayın.

![virtualbox-controller.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-controller.webp)

Yeni disk oluşturmak üzere "**Oluştur**" butonuna basın.

![virtualbox-add-disk.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk.webp)

Bu pencerede bize oluşturmak istediğimiz sanal diskin türü soruluyor.
Standart olan seçenekle devam edebiliriz. Merak ediyorsanız diğer
seçenekleri araştırabilirsiniz.

![virtualbox-add-disk2.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk2.webp)

İlgili disk bölümü sanal makinede doldurulmadığı sürece gerçek diskteki
alan dolmayacağı için varsayılan seçenekle devam edebilirsiniz. Eğer
burada "Tam boyutu önceden ayır" seçeneğini seçerseniz, ilgili disk
sanal sistemde kullanılsa da kullanılmasa da mevcut diskinizden sizin
belirlediğiniz disk boyutu kadar alan ayrılacaktır. Bu yöntem sanal
diskin hızlı çalışmasını sağlasa da eğer diskinizde çok alan yoksa bu
seçeneği seçmenizi önermem. Bırakın, sanal disk kullanıldıkça fiziksel
diskinizden alan ayrılsın.

![virtualbox-add-disk3.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk3.webp)

Sanal diskin boyutunu ve nerede barındırılması gerektiğini belirlememiz
gerekiyor. Ben açıklamalar sırasında vereceğim örnekler için yeterli
olacağından, yalnızca 2GB boyutunda disk oluşturuyorum.

![virtualbox-add-disk4.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk4.webp)

Son olarak oluşturduğunuz yeni sanal diski makineye eklemek için buradan
seçmemiz gerek.

![virtualbox-add-disk5.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk5.webp)

Gördüğünüz gibi disk bölümü sanal makineye eklenmiş bulunuyor.

![virtualbox-add-disk-final.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk-final.webp)

Bu şekilde sanal makinenize sanal diskler ekleyebilirsiniz. Ben tıpkı
burada ele aldığım şekilde örnekler sırasında kullanmak üzere 2 tane
daha 1GB'lık disk ekleyeceğim.

![virtualbox-add-disk-final2.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-disk-final2.webp)

Sanal SATA disklerini oluşturdum.

Örnek için yalnızca SATA denetleyicisi üzerinden disk oluşturdum ama
farklı disk biçimlerini de kullanabiliriz. Pratikler sırasında farklı
disk biçimlerini de görebilmek adına oluşturduğumuz sanal disklere ek
olarak bir de sanal `NVMe` disk de eklesek iyi olabilir. Bunun için
öncelikle uygun denetleyiciyi eklememiz gerekiyor.

![virtualbox-add-controller.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-add-controller.webp)

![virtualbox-controller-nvme.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-controller-nvme.webp)

Tıpkı daha önce SATA denetleyicisi üzerinden yaptığımız gibi, şimdi de
bu denetleyici üzerinden aynı şekilde yeni disk ekleyebiliriz.

![virtualbox-controller-nvme2.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-controller-nvme2.webp)

Ben 10GB ve 1GB olmak üzere iki tane NVMe disk eklemek istiyorum.

![virtualbox-controller-nvme3.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/virtualbox-controller-nvme3.webp)

Ben örnek olarak anlatım sırasında bu diskleri kullanıyor olacağım.
Sizler bu kadar disk oluşturmak zorunda değilsiniz. Ben sadece birden
fazla diskin nasıl görüneceği hakkında fikir sahibi olabilmemiz için
birden fazla ve farklı türde disk ekledim sadece. Hepsini doğrudan
kullanmayacağım. Sizler dilediğiniz boyutta dilediğiniz kadar disk
oluşturabilirsiniz. Yani fiziksel diskinizde uygun alan yoksa benimle
aynı şekilde ve sayıda disk oluşturmak zorunda değilsiniz. 1 veya 2 disk
oluşturabiliyorsanız da beni rahatlıkla takip edebilirsiniz. Yalnızca
açıklamalarımı dikkatlice takip etmeniz yeterli. Şimdi sanal makinemizi
çalıştırıp diskler üzerinde pratik yapmaya başlayabiliriz.

Blok Aygıtlarını Listelemek \| `lsblk`
--------------------------------------

Diskler, Linux üzerinde blok aygıtları olarak anıldıkları için
"**l**i**s**t **bl**oc**k** devices" ifadesinin kısaltmasından gelen
`lsblk` komutu ile disk aygıtlarının ve bölümlerinin sistem üzerindeki
isimlerini öğrenebiliyoruz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0   80G  0 disk 
├─sda1    8:1    0   79G  0 part /
├─sda2    8:2    0    1K  0 part 
└─sda5    8:5    0  975M  0 part [SWAP]
sdb       8:16   0    2G  0 disk 
sdc       8:32   0    1G  0 disk 
sdd       8:48   0    1G  0 disk 
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Aldığımız çıktıda **sda** diski bu diskin altında **sda1** **sda2**
**sda5** şeklinde birden fazla disk bölümü yer alıyor. Çıktılara
dikkatlice bakacak olursak **sda** aslında mevcut sistemimizin kurulu
olduğu diski temsil eden sanal dosyadır. Sistemin kurulu olduğu disk,
bağlanan ilk disk olduğu için **sda** şeklinde isimlendirilmiş.

Sisteme birden fazla disk takılı olduğunda, görebildiğiniz gibi **sdb
sdc sdd** gibi sıralı şekilde isimlendiriliyor. Elbette **sd** ifadesi
de olmak zorunda değil. Örneğin benzer şekilde **nvme** diskleri
**nvme0n1** ve **nvme0n2** olarak isimlendiriliyor. Ayrıca ben sanal
makineme misafir eklentisini kurarken sanal optik disk kullandığım için
burada **sr0** olarak gözüküyor. Birden fazla optik disk olsaydı, **sr1
sr2** şeklinde sıralı olarak isimlendirileceklerdi. Yani aygıtların
dosya karşılıklarının isimlendirilmesi çekirdek tarafından, kullanılan
disk türüne göre belirleniyor. Ayrıca sisteme bağlanma sıralarına göre
"**a b c**" veya "**1 2 3**" şeklinde isimlerinin sonuna, sırayı
belirten kısaltmalar da ekleniyor.

Bu noktada tekrar dikkatinizi çekmek istediğim nokta, bir diski birden
fazla bölüme ayırılabiliyor olmamızdır. Buradaki çıktılardan da **sda**
diski altında sıralı şekilde disk bölümlerini görebiliyoruz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0   80G  0 disk 
├─sda1    8:1    0   79G  0 part /
├─sda2    8:2    0    1K  0 part 
└─sda5    8:5    0  975M  0 part [SWAP]
sdb       8:16   0    2G  0 disk 
sdc       8:32   0    1G  0 disk 
sdd       8:48   0    1G  0 disk 
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Zaten altığımız çıktıdaki sütunların başlıklarına baktığımızda
"**type**" yani "tip" kısmında da hangisinin "**disk**" hangisinin
"**disk bölümü(part)**" olduğu açıkça belirtiliyor. İşte disk bölümleri
de ilgili diskin aygıt isminin sonuna numaralar getirilerek bu şekilde
otomatik olarak isimlendiriliyor.

Ayrıca "**mountpoint**" yani bağlanma noktası sütunundan, disk
bölümlerinin **dosya sistemi hiyerarşisinde hangi klasöre bağlı
olduğunu** da görebiliyoruz. Buradaki bağlamaktan kasıt, bu disk
bölümüne hangi konumdan erişebileceğimizin belirtilmesidir. Örneğin
Windows üzerinde yeni disk bölümü oluşturduğumuzda bu disk **D** veya
**E** gibi bir isme sahip olur ve diskler bölümünden üzerine tıklayarak
ilgili disk bölümündeki verilere erişebiliriz. İşte Linux üzerinde de
disk bölümlerini bir klasöre bağlamamız ve bu klasör üzerinden disk
bölümündeki verilere erişmemiz gerekiyor. Disk bölümlerinin dosya
sistemi hiyerarşisindeki uygun bir klasöre bağlanmasına da
"**mounting**" deniyor. Örneğin kök dizin(**/**) **sda1**'e bağlı iken
**sda5** bölümü de **SWAP** olarak bağlı.

Bu durumda ben kök dizin(**/**) altında işlem yapıyorken aslında kök
dizini aracılığı ile bu disk bölümünde(**sda1**) işlem yapıyorum.

Ayrıca aldığımız çıktılardaki diğer detayları merak ettiyseniz burada
bizi ilgilendiren detay "**rm**" ve "**ro**" olarak geçen sütunlar.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME    MAJ:MIN RM  SIZE RO <span TYPE MOUNTPOINTS
sda       8:0    0   80G  0 <span disk
├─sda1    8:1    0   79G  0 <span part /
├─sda2    8:2    0    1K  0 <span part
└─sda5    8:5    0  975M  0 <span part [SWAP]
sdb       8:16   0    2G  0 <span disk 
sdc       8:32   0    1G  0 <span disk 
sdd       8:48   0    1G  0 <span disk 
sr0      11:0    1 1024M  0 <span rom  
nvme0n1 259:0    0    1G  0 <span disk 
nvme0n2 259:1    0   10G  0 <span disk
```

**rm** sütunu blok aygıtının çıkarılabilir olup olmadığını belirtiyor.
Zaten "**r**e**m**ovable" yani Türkçe "çıkarılabilir" ifadesinin
kısalmasından geliyor. Aldığımız tabloda, blok aygıtına karşılık gelen
bu sütun **0** ise o aygıt **çıkarılabilir biçimde değildir**. Eğer
**1** rakamı varsa o **aygıt çıkabilir biçimdedir**. Örneğin tabloya
dönüp bakın, optik disk(sr0) çıkarılabilir biçimde olduğu için **1**
olarak gözüküyor. Ayrıca sisteme takılı ise USB flash disk olsaydı bu da
çıkarılabilir biçimde olduğu için 1 olarak gözükecekti. **Çıkarılabilir
olmayanlar** tabloda da gördüğünüz gibi **0** değerine sahip.

**ro** olarak geçen sütun ise ilgili blok aygıtının "**r**ead **o**nly"
yani "yalnızca okuma" modunda olup olmadığını gösteriyor. Eğer buradaki
değer **1** ise ilgili blok aygıtı **yalnızca okunabilir** biçimdedir.
Eğer **0** ise ilgili blok aygıtının içine **veri de eklenebilir**.

Hazır `lsblk` komutunu ele almışken son olarak `-f` seçeneğinden de
kısaca bahsetmek istiyorum. Eğer aygıt dosyalarının sahip olduğu "dosya
sistemleri" hakkında bilgi almak istersek `lsblk -f` komutunu
kullanabiliyoruz.

    ┌──(taylan㉿linuxdersleri)-[~]
    └─$ lsblk -f
    NAME    FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
    sda                                                                            
    ├─sda1  ext4   1.0         491d3534-b3d9-47af-ad63-66b0e72fe8dd   61.6G    15% /
    ├─sda2                                                                         
    └─sda5  swap   1           00253fba-ff78-4f04-b189-fbc974082345                [SWAP]
    sdb                                                                            
    sdc                                                                            
    sdd                                                                            
    sr0                                                                            
    nvme0n1                                                                        
    nvme0n2

Kurulum aşamasında oluşturulan diskler **ext4** ve **swap** dosya
sistemlerine sahipler, bu bilgiyi **FSTYPE** sütununa bakarak teyit
edebiliyoruz. Buradaki **LABEL** sütunu da bu disk bölümlerine
tanımlanan **etiketlerin** gözüktüğü bölüm. Ben herhangi bir etiket
tanımlamadığım için şu an boş gözüküyor. **UUID** ise ilgili disk
aygıtının **benzersiz kimlik** numarasıdır. Ayrıca dosya sistemlerinin
sahip olduğu toplam boyut ve ne kadarının kullanıldığı da buradaki
sütunlarda belirtiliyor. Ve elbette ilgili dosya sisteminin hangi dizine
bağlı olduğu da "**MOUNTPOINTS**" sütunu altında tam dizin adresi olacak
şekilde yazıyor.

Şimdi burada benim dikkatimi çeken detay, yeni eklediğimiz disklerle
ilgili hiç bir çıktının bastırılmamış olması. Aslında bu çok normal
çünkü bu diskler üzerinde hiç bir ayarlama yapmadık tamamen tanımsız
haldeler. `lsblk` komutunun `f` seçeneği yalnızca blok aygıtlarının
dosya sistemleri hakkında bilgi almak için kullanılıyor. Bu yeni disk
aygıtlarında da henüz dosya sistemi tanımlı olmadığı için doğal olarak
hiç bir çıktı bastırılamadı. Anlatımın devamında disklerimize dosya
sistemi eklediğimizde burada görebiliyor olacağız. Diskler üzerinde
yönetim gerçekleştirmeye, öncelikle diskleri nasıl
bölümleyebileceğimizden bahsederek başlayabiliriz.

Bölümleme işlemine geçmeden önce komut satırı üzerinden
gerçekleştireceğimiz işlemleri aslında grafiksel arayüzlü çeşitli
yazılımlar ile yerine getirebileceğimizi de belirtmek istiyorum. Yine de
her zaman grafiksel arayüze erişimimiz olmayabileceği veya kabuk
programlama gibi otomatik çözümler için komut satırı araçlarını
kullanmamız gerekeceği için öncelikle temel disk yönetim işlerimizi
komut satırı üzerinden nasıl gerçekleştirebileceğimizi öğrenmemiz
önemli. Zaten temel kavramları komut satırı üzerinden öğrendikten sonra
grafiksel arayüze sahip araçları ekstra bir eğitime ihtiyaç duymadan
kendi başınıza öğrenip rahatlıkla kullanabilirsiniz.

Gelin diskleri nasıl bölümleyebileceğimizi ele alarak devam edelim.

Diskleri Bölümlemek \| `fdisk`
------------------------------

Disk bölümleme için alternatif pek çok araç olsa da ben `fdisk` aracını
kullanıyor olacağım. `fdisk` aracının kullanımı son derece basit.
`fdisk` komutunun ardından, üzerinde işlem yapmak istediğimiz diskin
adını belirtmemiz yeterli. Eğer diskin sistem üzerindeki ismini
bilmiyorsak `fdisk -l` komutu ile mevcut tüm diskleri özellikleriyle
birlikte detaylıca listeleyebiliriz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ fdisk -l
fdisk: cannot open /dev/nvme0n1: Permission denied
fdisk: cannot open /dev/nvme0n2: Permission denied
fdisk: cannot open /dev/sdd: Permission denied
fdisk: cannot open /dev/sdb: Permission denied
fdisk: cannot open /dev/sdc: Permission denied
fdisk: cannot open /dev/sda: Permission denied
```

Elbette diskler üzerinde işlem yapacağımız için `fdisk` aracını `sudo`
komutu ile root yetkileri dahilinde çalıştırmamız gerekiyor. Eğer `sudo`
komutu olmadan kullanırsak görebildiğiniz gibi erişim yetkisi hatası
alıyoruz. Ben diskleri listelemek için komutumu `sudo fdisk -l` şeklinde
giriyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo fdisk -l
[sudo] password for taylan: 
Disk /dev/nvme0n1: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/nvme0n2: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors                      
Disk model: VBOX HARDDISK                                                    
Units: sectors of 1 * 512 = 512 bytes                                        
Sector size (logical/physical): 512 bytes / 512 bytes                        
I/O size (minimum/optimal): 512 bytes / 512 bytes                            
                                                                             
                                                                             
Disk /dev/sdb: 1 GiB, 1073741824 bytes, 2097152 sectors                      
Disk model: VBOX HARDDISK                                                    
Units: sectors of 1 * 512 = 512 bytes                                        
Sector size (logical/physical): 512 bytes / 512 bytes                        
I/O size (minimum/optimal): 512 bytes / 512 bytes                            
                                                                             

Disk /dev/sdc: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xd562e290

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sda1  *         2048 165771263 165769216   79G 83 Linux
/dev/sda2       165773310 167770111   1996802  975M  5 Extended
/dev/sda5       165773312 167770111   1996800  975M 82 Linux swap / Solaris
```

Bakın tüm diskler ve disk bölümleri listelenmiş oldu. Örneğin mevcut
sistemin kurulu olduğu disk ve diskin bölümleri **/dev/sda** adı altında
yer alıyor. Burada diskin ismi, boyutu, toplam byte kapasitesi, toplam
sektör sayısı yazıyor. Diskin modeli ve bir sektörün kaç byte olduğu
gibi çeşitli bilgiler de burada yazıyor.

``` {.python}
Disk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xd562e290

Device     Boot     Start       End   Sectors  Size Id Type 
/dev/sda1  *         2048 165771263 165769216   79G 83 Linux 
/dev/sda2       165773310 167770111   1996802  975M  5 Extended 
/dev/sda5       165773312 167770111   1996800  975M 82 Linux swap / Solaris
```

Eğer disk bölümlerine bakacak olursak, ilk sütunda ilgili bölümlerin
sistemdeki aygıt isimlerini görebiliyoruz. Boot sütununda ise ilgili
bölümün boot edilebilir olup olmadığı belirtiliyor. Yıldız işareti, bu
bölümün önyükleme sırasında kullanılabileceğini belirtiyor. Sistemin
önyüklenemesi için gereken çekirdek dosyaları gibi dosyaları barındıran
***boot*** dizini, kök dizin altında olduğu için kök dizini boot
edilebilir gözüküyor. Bu "boot" edilebilir işareti sayesinde sistem
başlangıcında bu diskin "önyükleme" işlemi için kullanılması gerektiğini
belirtmiş oluyoruz. Eğer boot dizinini farklı bir disk bölümüne bağlamış
olsaydım, o dizin "boot" edilebilir olarak gözükecekti.

Start, ve end sütunları ilgili bölümün diskin kaçıncı sektöründe
başlayıp kaçıncı sektöründe sonlandığını yani diskin ne kadarlık
bölümünü kapladığını belirleyen sınırdır. Diskleri bölümlerken başlangıç
ve bitiş sektörlerini tanımlayarak birden fazla bölüme ayırıyoruz.
Buradaki **Start** ve **End** de bunu belirtiyor. **Sectors** sütunu da
bu bölümdeki toplam sektör sayısını belirtiyor. Başlangıç ve son sektör
sayılarını çıkardığımızda zaten buradaki sayıyı elde ediyoruz. **Size**
sütunu da diskin toplam boyutunu okunaklı şekilde belirtiyor. **Id**
sütunu da dosya sistemini temsil eden kimliktir. Bu disk bölümleri
**ext4** dosya sistemini kullandığı için **83** numaralı id ye karşılık
geliyor. **Type** kısmından da dosya sisteminin türü hakkında bilgi
alabiliyoruz.

Tamamdır `fdisk` aracının çıktılarını açıklığa kavuşturduğumuza göre
artık bir diski istediğimiz şekilde bölümlemeyi deneyebiliriz. Ben
bölümlemek için 2 GB'lık alana sahip olan **sdd** diskimi kullanmak
istiyorum.

``` {.python}
Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors                      
Disk model: VBOX HARDDISK                                                    
Units: sectors of 1 * 512 = 512 bytes                                        
Sector size (logical/physical): 512 bytes / 512 bytes                        
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

Zaten içerisi bomboş yani ne bir dosya sistemi tanımlı ne de bir dosya
mevcut. Eğer bu diski bölümlemeden dosya sistemi tanımlarsam daha sonra
diskteki mevcut verileri kaybetmeden diski tekrar bölümleyemem. Bu
sebeple ben dosya sistemi tanımlamadan önce 1 GB'lık yeni bir disk
bölümü oluşturmak istiyorum. Bu disk üzerinde işlem yapabilmem için
diskin aygıt adını `fdisk /dev/sdd` şeklinde girmem gerek. Elbette disk
ile ilgili işlem yaparken yetki gerektiği için tüm komutlarımızı `sudo`
ile yetkili şekilde girmemiz gerekiyor.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo fdisk /dev/sdd

Welcome to fdisk (util-linux 2.37.3).                                                                                                                       
Changes will remain in memory only, until you decide to write them.                                                                                         
Be careful before using the write command.

Device does not contain a recognized partition table.
Created a new DOS disklabel with disk identifier 0xbaecfcb8.

Command (m for help):
```

Bakın `fdisk` aracım açıldı ve şu an benden emir bekliyor. Eğer hangi
işlemi nasıl yapacağımızı bilmiyorsak **m** tuşuna basarak yardım
bilgisine ulaşabiliriz.

``` {.sql}
Command (m for help): m

Help:

  DOS (MBR)
   a   toggle a bootable flag
   b   edit nested BSD disklabel
   c   toggle the dos compatibility flag

  Generic
   d   delete a partition
   F   list free unpartitioned space
   l   list known partition types
   n   add a new partition
   p   print the partition table
   t   change a partition type
   v   verify the partition table
   i   print information about a partition

  Misc
   m   print this menu
   u   change display/entry units
   x   extra functionality (experts only)

  Script
   I   load disk layout from sfdisk script file
   O   dump disk layout to sfdisk script file

  Save & Exit
   w   write table to disk and exit
   q   quit without saving changes

  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty DOS partition table
   s   create a new empty Sun partition table

Command (m for help):
```

Burada yapabileceğimiz tüm işlemlerin kısaltmaları ve açıklamaları yer
alıyor.

Disk Bilgisini Bastırmak
------------------------

Ben öncelikle mevcut disk hakkında bilgi almak istiyorum. Bunun için
burada belirtildiği şekilde `p` seçeneğini kullanmam gerekiyor.

``` {.python}
Command (m for help): p
Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xbaecfcb8

Command (m for help):
```

Bakın mevcut disk hakkında pek çok detay bastırıldı. Boyutu ve bu diskin
kullandığı bölümleme tablosu tipi de burada yazıyor. Hatta dikkatlice
bakacak olursak, disk boyutu olarak **gib** yani **gibibyte** olarak
büyüklüğün yazıldığını da görebiliyoruz. İşte daha önce de bahsetmiş
olduğumuz şekilde, çeşitli disk yönetim araçlarında bu büyüklükler ile
karşılaşıyor ve kullanıyor olacağız.

Bölümlendirme Tablosunu Değiştirmek
-----------------------------------

Aldığımız çıktılara dikkatlice bakacak olursak "**Disklabel type: dos**"
satırında, disk bölümleme tablosunun türü de belirtiliyor. Buradaki
"**dos**" ifadesi "**MBR**" bölümleme tablosunu temsil ediyor. Yani bu
diskimiz "MBR" bölümleme tablosunu kullanıyormuş. Eğer ben bu diskin
bölümleme tablosunu değiştirmek istersem `fdisk` aracının yardım
bilgisinde yer alan "**create a new label**" başlığı altındaki
kısaltmalardan uygun bir tanesini kullanabilirim. Örneğin ben "MBR"
yerine "GPT" disk bölümleme tablosunu kullanmak istersem `g` yazıp
onaylamam yeterli.

``` {.less}
Command (m for help): g
Created a new GPT disklabel (GUID: B512C410-CD72-ED44-94A7-1D6328C959B6).

Command (m for help):
```

Şu an disk içeriği tamamen boş olduğu için yani henüz disk üzerinde hiç
bölümleme veya veri aktarımı yapmadığım için disk tablosunu değiştirmem
sorun olmayacak. **Ancak `fdisk` aracı ile bölümleme tablosunu
değiştirirken dikkat edin çünkü içerisinde veri bulunan disklerin
bölümleme tablosunu değiştirmek disk içerisindeki tüm bölümlerin tahrip
olması yani disk verilerinin kaybedilmesiyle sonuçlanır.** Eğer
bölümlendirme tablosunu değiştirmeniz gerekiyorsa bunun için alternatif
yazılımlar ve yaklaşımlar mevcut fakat genellikle önerilen bir durum
değil. Değişim için öncelikle yedek alınması her zaman tavsiye edilir.
Bu sebeple diskte hangi tür bölümleme tablosunun kullanılacağını en
başında belirlememiz gerekiyor. Yani bölümleme işleminden de önce, ne
tür bir bölümleme tablosu kullanılacağını belirlememiz gerekiyor.

Tekrar `p` yazıp disk özelliklerini listelediğimde bölümleme türünün GPT
olarak değişmiş olduğunu görebiliyorum.

``` {.python}
Command (m for help): p
Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: B512C410-CD72-ED44-94A7-1D6328C959B6

Command (m for help):
```

Eğer "gpt" olarak kullanmaktan vazgeçersek "mbr" için de "`o`"
kısaltmasını kullanabiliriz.

``` {.python}
Command (m for help): o
Created a new DOS disklabel with disk identifier 0x0b09a6c1.

Command (m for help): p
Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x0b09a6c1
```

Tekrar `p` seçeneği ile kontrol ettiğimde tekrar "dos" yani "mbr"
bölümleme tablosuna geçiş yapıldığını görebiliyorum.

İşte bu şekilde disk üzerinde istediğimiz konfigürasyonu gerçekleştirene
kadar tekrar tekrar ayarlamalarda bulunabiliyoruz. **Çünkü biz nihai
olarak onaylamadan, bu değişikler disk üzerinde geçerli olmuyor.**
Anlatımın devamında, yaptığımız değişiklerin nasıl geçerli olacağından
ayrıca bahsedeceğiz. Disk bölümleme tablosunu değiştirebileceğimizi
söyledim ancak ben yine de sizlere MBR bölümleme tablosunu göstermek
istediğim için yine MBR ile devam etmek istiyorum. Siz isterseniz `g`
seçeneğini kullanarak diskinizde GPT bölümleme tablosunu da
kullanabilirsiniz.

Disk için bölümleme tablosu tanımladıktan sonra, diski bölümlemeniz de
artık mümkün.

Yeni Disk Bölümü Oluşturmak
---------------------------

Diskin bölümleme tablosunu karar verdiğimize göre artık istediğimiz
biçimde disk bölümü oluşturabiliriz. Yeni disk bölümü oluşturmak için
yardım listesinden de görebildiğimiz üzere `n` seçeneğini
kullanabiliyoruz.

``` {.sql}
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p):
```

Bu diskte "MBR" disk bölümleme tablosunu kullandığım için, oluşturulacak
disk bölümünün "primary" yani "birincil" mi yoksa "extended" yani
"genişletilmiş" mi olması gerektiği soruluyor. Eğer "GPT" kullanıyor
olsaydık bu ayrım olmadığı için bu soru sorulmayacaktı. Bu kavramlardan
zaten bahsetmiştik hatırlarsanız. Aldığımız çıktılarda, birincil bölümde
4 tane sınır olduğu için kaç tane birincil disk bölümünün ve
genişletilmiş disk bölümünün bulunduğu ve kaç bölümün birincil olarak
kullanılabileceği de açıkça belirtiliyor. Ben birincil bölüm oluşturmak
istediğim için `p` yazıp onaylıyorum.

``` {.sql}
Select (default p): p
Partition number (1-4, default 1):
```

Kaçıncı sıradaki birincil bölüm olması gerektiğini soruyor. Ben ilk
sırada olmasını istediğim için enter ile varsayılan değer olan 1'i
onaylıyorum.

``` {.sql}
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-4194303, default 2048):
```

Bakın şimdi de disk bölümünün hangi sektörden başlayacağını soruyor.
Zaten ilk disk olduğu için burada belirtilen değer minimum başlangıç
sektörüdür. Ben de varsayılan değer olan 2048'i seçmek için enter ile
devam ediyorum. Eğer siz diskinizde boşta kullanılmayan bir alan
bırakmak istiyorsanız başlangıç sektörünü daha yüksek belirtebilirsiniz.
Ancak bunun yerine bitiş sektörünü daha küçük tutarak alan ayırmanız
daha mantıklı olabilir.

``` {.java}
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-4194303, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-4194303, default 4194303):
```

Şimdi bizden en son sektörü girmemizi istiyor. Bu sayede başlangıç ve en
son sektör arasındaki tüm sektörler bu disk bölümü için ayrılmış olacak.
Yani burada disk bölümünün kapasitesini belirliyoruz aslında. Biraz önce
de söylediğim şekilde sektör numarasını küçük tutarsak, bu bölümün
ardından diskte kullanılmayan sektörler kalacağı için daha sonra
kullanılmak üzere diskte boş alan bırakmış oluyoruz. Ayrıca burada son
sektör deniyor ancak son sektörü sayısal olarak girmek zorunda da
değiliz. Dilersek daha kolay şekilde disk bölümünün boyutunu doğrudan
buradaki büyüklük(**K**,**M**,**G**,**T**,**P**) ifadeleri ile de
belirtebiliriz. Bu sayede belirttiğimiz büyüklüğe göre `fdisk` aracı
otomatik olarak son sektörü hesaplayıp kullanabilir. Yani biz zaten
başlangıç sektörünü biraz önce girdiğimiz için istediğimiz boyuta uygun
son sektör de otomatik olarak tanımlanacak.

Eğer `+` işaretinden sonra bir büyüklük değeri yazarsak, örneğin `+512M`
şeklinde yazarsak başlangıç sektörünün üstüne **512 mebibyte** kadar
eklenip, en son sektör otomatik olarak hesaplanacak. Yani biz bu
kullanımla ilk sektörden itibaren **512 mebibyte**'lık sektörü ayır
demiş oluyoruz.

Eğer eksi `-` işaretini kullanırsak da bu kez son sektörden geriye doğru
gidilerek hesaplanır. Örneğin ben `-512 M` yazarsam son sektörden **512
mebibyte** kadar sektör geriye gidilerek, bizim oluşturmak istediğimiz
disk bölümünün en son sektörü belirlenir. Yani toplam iki gibibayt'lık
boyutu olan bu diskte **+512M** yazarsak yeni disk bölümü **512
mebibyte** alana sahip olur. Eğer **-512** yazarsak da son sektörden
**512 mebibyte** kadar alan geri gidileceği için, oluşturulan yeni bölüm
**1.5 gibibyte** kadarlık disk alanına sahip olur. Hazır yeri gelmişken
buradaki artı ve eksi işaretlerinin işlevlerini paylaşmak istedim.
Genelde artı işareti kullanılıyor ancak bizler artık eksi işaretinin
işlevini de biliyoruz.

Ben 1 GiB bölüm oluşturmak istediğim için `+1G` şeklinde yazılıyorum.
Ayrıca buradaki büyüklük birimlerine de değinmemiz gerekirse, kolayca
tahmin edebileceğiz gibi buradaki **K kibibyte**, **M mebibyte,** **G
gibibyte,** **T tebibyte,** **P** ise **pebibyte** anlamına geliyor.
İstediğiniz büyüklüğü, bu karakterlerden uygun olanı kullanarak kolayca
belirtebilirsiniz.

``` {.java}
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-4194303, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-4194303, default 4194303): +1G

Created a new partition 1 of type 'Linux' and of size 1 GiB.

Command (m for help):
```

İlgili değeri belirtip enter ile onayladığımızda, yeni bölüm
oluşturulmuş oluyor. Ancak işimiz burada bitmedi. Çünkü değişikliklerin
geçerli olabilmesi değişiklikleri kaydetmemiz gerekiyor.

Değişiklikleri Kaydetmek
------------------------

Şu ana kadar `fdisk` aracını kullanarak, yalnızca yapılması gereken
değişiklikleri belirtmiş olduk. Eğer şimdiye kadar gerçekleştirmiş
olduğumuz değişikliklerin disk üzerinde uygulanmasını istiyorsak `w`
karakterini girip enter ile işlemi onaylamamız gerekiyor. Tersi şekilde,
eğer değişiklikleri kaydetmek istemezsek `q` karakterini girip enter ile
onaylayarak diskte hiç bir değişim olmadan `fdisk` aracından
çıkabiliriz. Yani şimdiye kadar yaptığımız hiç bir işlem aslında disk
üzerinde henüz uygulanmadı. Eğer yaptığınız işlemlerden vazgeçtiyseniz
`q` yazıp enter ile `fdisk` aracını kapatabilirsiniz.

Tersi şekilde yaptığınız değişiklikleri onaylamak isterseniz de `w`
yazıp enter ile onaylayabilirsiniz.

``` {.lua}
Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

Bakın diskin bölümleme tablosunun değiştirildiğini bildiren çıktıyı
aldık. Yeni oluşturduğumuz disk bölümü, bölümleme tablosuna eklendiği
için bu çıktı bastırıldı. Yani yeni disk bölümü oluşturma işlemimiz
başarıyla tamamlanmış oldu.

Şimdi teyit etmek için tekrar `sudo fdisk -l` komutu ile diskleri
listeleyebiliriz.

``` {.python}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo fdisk -l
.
..
...

Disk /dev/sdd: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x0b09a6c1

Device     Boot Start     End Sectors Size Id Type
/dev/sdd1        2048 2099199 2097152   1G  0 Empty

...
..
.
```

**ℹ️ Not:** Çıktıları kısaltarak ekledim. Ayrıca yalnızca ilgili disk
aygıtı hakkında bilgi almak istiyorsanız `sudo fdisk -l /dev/aygıt-adı`
şeklinde disk aygıtını argüman olarak da belirtebilirsiniz.

Bakın yeni oluşturduğum disk bölümü burada yer alıyor. Yani `fdisk`
aracını kullanarak diskimizi bölümlendirmeyi başarmış olduk. `fdisk`
aracı her aşamada bizi yönlendirdiği ve `m` komutu ile her zaman yardım
alabildiğimiz için kullanımı son derece kolay.

Şimdi bu disk bölümünü kullanabilmek için öncelikle bu disk bölümüne bir
dosya sistemi tanımlamamız gerekiyor. Bu sayede işletim sistemimiz bu
disk bölümünü tanıyıp veri alışverişi için kullanabiliyor olacak. Daha
önce de dosya sisteminin hangi görevde olduğundan ve öneminden zaten
bahsettik. Yani dosya sistemi olmadan işletim sistemi üzerinden disk
bölümündeki verilere ulaşamayacağımızı biliyorsunuz. Bu sebeple mevcut
bir disk bölümüne, istediğimiz bir dosya sistemini nasıl
tanımlayabileceğimizi ele alalım.

Dosya Sistemi Tanımlamak \| `mkfs`
----------------------------------

Dosya sistemi tanımlamak için, tanımlamak istediğimiz dosya sisteminin
türüne göre kullanmamız gereken araç değişiyor. Fakat bu durum gözünüzü
korkutmasın, çünkü `mkfs` yani "**m**a**k**e **f**ile**s**ystem" yazıp
iki kez Tab tuşuna bastığımızda tanımlayabileceğimiz dosya sistemleri
zaten listeleniyor.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkfs
mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext4    mkfs.jffs2   mkfs.msdos   mkfs.ubifs   
mkfs.bfs     mkfs.exfat   mkfs.ext3    mkfs.fat     mkfs.minix   mkfs.ntfs    mkfs.vfat
```

Çıktılardan görebildiğiniz gibi, noktadan sonra kullanmak istediğimiz
dosya sisteminin adını girmemiz yeterli. Örneğin ben **ext4** dosya
sistemini tanımlamak istediğim için `mkfs.ext4` komutunu kullanacağım.
Bu komuta da argüman olarak hangi disk bölümü için bu dosya sistemini
tanımlayacaksam onun aygıt adını girmem yeterli. Biz zaten `fdisk -l`
komutu ile aygıtları listelemiştik. Yani ben dosya sistemi eklemek
istediğim bölümün adının ***/dev/sdd1*** olduğunu bildiğim için
`mkfs.ext4 /dev/sdd1` komutunu gireceğim. Elbette `sudo` komutu ile
işlemi yetkili olarak gerçekleştirmemiz gerekiyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mkfs.ext4 /dev/sdd1
mke2fs 1.46.5 (30-Dec-2021)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: e0b3196f-8180-476b-8041-081a3d016d0f
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
```

Komutumu girdikten çok kısa bir süre sonra, dosya sistemi tanımladı ve
dosya sisteminin çeşitli özellikleri de konsola bastırıldı. Dosya
sisteminde toplam kaç blok olduğu, her bir bloğun boyutu ve toplam inode
sayıları çıktıda görülebiliyor. Ayrıca diskin benzersiz UUID'si yani
kimliği de bu çıktıda gözüküyor. Daha önce disk ve disk bölümlerinin
isimlendirilmesinin çekirdek tarafından, sisteme bağlanma sıralarına
göre sırasıyla belirlendiğinden bahsetmiştik. Dolayısıyla aslında
disklerin bağlanma sıralaması değişirse bu "**/dev/sdd1**" gibi olan
aygıt ismi de örneğin "**/dev/sdc1**" şeklinde değişebileceği için,
benzersiz UUID değerini kullanmak çok daha doğru bir yaklaşım. İleride
disklerimizi sistemimize bağlarken bu UUID konusundan tekrar
bahsedeceğiz zaten.

İşte dosya sistemi tanımlamak bu kadar kolay. Tek yapmanız gereken hangi
dosya sistemini kullanacaksanız ona uygun aracı ve doğru disk bölümünü
belirtmeniz.

Diskimizi nasıl bölümlere ayırabileceğimizden ve ayrıca disk bölümlerine
istediğimiz dosya sistemini nasıl tanımlayabileceğimizden bahsettiğimize
göre artık, disk bölümünü nasıl sistemimize bağlayabileceğimizden
bahsederek devam edebiliriz.

Disklerin Bağlanması \| `mount`
-------------------------------

Daha önce kısaca bahsettiğimiz "sisteme bağlama" kavramını tekrar
tanımlayacak olursak. İngilizce "**mounting**" olarak geçen "bağlama"
işlemi; mevcut sistem tarafından desteklenen dosya sistemine sahip olan
disk bölümlerinin, işletim sistemine bağlanarak erişilebilir hale
getirilmesidir.

Bir "dosya sistemini" mevcut sistemimize bağlamak için "bağlama"
anlamına gelen `mount` komutunun ardından, sisteme bağlamak istediğimiz
disk bölümünün aygıt ismini ve bu bölümün dosya sistemi hiyerarşisinde
hangi dizin altına bağlanacağını belirtmemiz gerekiyor.

Normalde USB Flash diskler gibi çıkarılabilir aygıtlar ***/media***
dizini altındaki bir klasöre bağlanırken, sabit disk gibi aygıtlar
***/mnt*** dizini altındaki klasörlere bağlanıyor. Bu şart olmamakla
birlikte, Linux'un hiyerarşik yaklaşımı gereği bu şekilde bir
sınıflandırma var. Ancak elbette yalnızca ***/mnt*** veya ***/media***
dizinlerine bağlamak zorunda da değiliz. İstediğimiz herhangi bir
klasöre bağlayabiliriz. Örneğin ben istersem masaüstünde bir klasör
oluşturup, disk bölümünü bu klasöre bağlayabilirim. Hatta hemen bizzat
deneyelim.

Öncelikle bağlanacak dizini oluşturmak üzere `mkdir ~/Desktop/disk`
komutu ile masaüstünde "***disk***" isminde bir klasör oluşturuyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir ~/Desktop/disk
```

Tamamdır, artık yeni oluşturduğum disk bölümünü buraya bağlayıp disk
bölümüne buradan erişebilirim.

Disk bölümünü bağlamak için ilgili disk aygıtının ismini biliyor olmamız
gerek. Ben `sudo fdisk -l` komutu ile teyit ediyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo fdisk -l                                                                                                                                
Disk /dev/nvme0n1: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/nvme0n2: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdd: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdc: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sda: 80 GiB, 85899345920 bytes, 167772160 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xd562e290

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sda1  *         2048 165771263 165769216   79G 83 Linux
/dev/sda2       165773310 167770111   1996802  975M  5 Extended
/dev/sda5       165773312 167770111   1996800  975M 82 Linux swap / Solaris

Disk /dev/sdb: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xb2de8f5b

Device     Boot Start     End Sectors Size Id Type
/dev/sdb1        2048 2099199 2097152   1G 83 Linu
```

Bakın ben bu dokümanı yazarken kısa bir ara verip sistemi yeniden
başlattığım için, daha önce üzerinde işlem yaptığım ***/dev/sdd***
olarak geçen disk artık ***/dev/sdb*** olarak isimlendirilmiş gözüküyor.
Zaten bu sebeple işlem yapmadan önce disk isimlerini teyit etmek önemli.

Şimdi disk bölümünü bu klasöre bağlamak için sırasıyla hangi disk
aygıtının hangi dizine bağlanacağını
`sudo mount /dev/sdb1 ~/Desktop/disk` şeklinde belirtmemiz gerekiyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount /dev/sdb1 ~/Desktop/disk/

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Tamamdır artık ilgili disk bloğuna bu dizin altından erişebiliyor
olacağım. Yani bu dizin içine bir dosya eklediğimde ya da buradaki bir
dosyayı sildiğimde aslında o disk bölümündeki veriler üzerinde işlem
yapmış olacağım. `mount` işleminin aslında disk bölümlerine bir nevi
giriş kapısı görevi gördüğünü düşünebilirsiniz. Bağlama işlemi sayesinde
bu disk bölümünün dosya sistemi hiyerarşisindeki karşılığı benim
oluşturduğum bu dizin oldu. Ben bu dizin üzerinden disk bölümündeki
verileri yönetiyor olacağım. `lsblk` komutu ile blok aygıtlarını tekrar
listeleyip bağlı oldukları dizinlere de bakalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0   80G  0 disk 
├─sda1    8:1    0   79G  0 part /
├─sda2    8:2    0    1K  0 part 
└─sda5    8:5    0  975M  0 part [SWAP]
sdb       8:16   0    2G  0 disk 
└─sdb1    8:17   0    1G  0 part /home/taylan/Desktop/disk
sdc       8:32   0    1G  0 disk 
sdd       8:48   0    1G  0 disk 
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Bakın yeni oluşturduğum disk bölümü, masaüstündeki ***disk*** isimli
dizine bağlı gözüküyor. Artık disk bölümünü bağladığımıza göre artık bu
bölümü kullanabiliriz.

Basit bir test için bu disk bölümüne bir klasör eklemeyi deneyelim. Ben
örnek olması için `mkdir ~/Desktop/disk/deneme` şeklinde yazıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir ~/Desktop/disk/deneme
mkdir: cannot create directory ‘/home/taylan/Desktop/disk/deneme’: Permission denied
```

Bakın yetki hatası aldım. Çünkü bu aygıtı sisteme root yetkileri ile
bağladığımız için şu an bu aygıt üzerinde yalnızca root kullanıcısının
tüm yetkileri bulunuyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld ~/Desktop/disk/
drwxr-xr-x 3 root root 4096 Jul 10 01:21 /home/taylan/Desktop/disk/
```

Diğer kullanıcıların yalnızca okuma ve çalıştırma yetkisi var.

Eğer bu disk bölümüne erişim yetkilerini değiştirmek istiyorsak,
bağladığımız dizin üzerinden erişim yetkilerini düzenleyebiliriz. Şu
anda dizinin sahibi ve grubu root olarak gözüküyor. Ben kendi hesabımdan
sorunsuzca erişmek istediğim için daha önce de öğrendiğimiz şekilde bu
klasörün sahipliğini değiştirmek istiyorum. Bunun için
`sudo chown taylan:taylan ~/Desktop/disk` şeklinde komutumu giriyorum.
Bu komut sayesinde masaüstündeki ***disk*** dosyasının sahibi ve grubu
**taylan** olarak değişmiş olacak.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown taylan:taylan ~/Desktop/disk

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld ~/Desktop/disk                                                                                                                                   
drwxr-xr-x 3 taylan taylan 4096 Jul 10 01:21 /home/taylan/Desktop/disk
```

Bakın artık dizinin sahibi şu an kullanmakta olduğum "taylan"
kullanıcısı. Yani artık bu dizin üzerinde, dolayısıyla da bu dizine
bağlı olan disk bölümü üzerinde burada belirtilen yetkilere sahibim. Ben
bu durumu teyit etmek için tekrar klasör oluşturmayı denemek istiyorum.
Bunun için `mkdir ~/Desktop/disk/yeni-klasor` şeklinde komutumu
giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir ~/Desktop/disk/yeni-klasor                                                                                                                        

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l ~/Desktop/disk/
total 20
drwx------ 2 root   root   16384 Jul 10 01:21 lost+found
drwxr-xr-x 2 taylan taylan  4096 Jul 10 01:28 yeni-klasor
```

Bakın herhangi bir erişim yetkisi hatası almadım. `ls` komutu ile
listelediğimizde de zaten ilgili klasörün disk bölümünde oluşturulduğunu
teyit edebiliyoruz.

Oluşturduğumuz klasör dışında disk bölümü içinde listelenmiş olan
**lost+found** dizinin neden bulunduğunu muhtemelen merak ediyorsunuz.
Bu klasör, elektrik kesintisi gibi ani kesinti durumlarında diskteki
adreslenemeyen verilerin tutulduğu dizindir. Ani kesinti sonrası, diski
tekrar sistem bağladığımızda bu dizin içinde bazı dosya ve klasörler
olabilir. Bunlar otomatik disk onarım aşamasından(modern dosya
sistemleri başlangıçta disk onarımı yapmayı dener) sonra da nerede
bulunmaları gerektiği belirlenmeyen verilerdi. Bunları kendiniz manuel
olarak gerekli konumlarına taşıyabilirsiniz. Yine de her zaman mükemmel
çalışmıyor elbette. Yani ani kesinti durumunda bazı verilerinizi kalıcı
olarak kaybetme ihtimaliniz her zaman bulunuyor.

Birden Fazla Klasöre Bağlama
----------------------------

Dilersek tek bir disk bölümünü birden fazla klasöre de bağlayabiliriz.
Ancak baştan belirteyim bu genelde karmaşaya sebep olabileceği için pek
önerilen bir yaklaşım değildir. Yine örnek olarak göstermek için ben
`mkdir ~/Desktop/disk2` komutu ile yeni bir klasör oluşturuyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir ~/Desktop/disk2
```

Şimdi bu klasöre aynı diski bağlayalım. Bunun için
`sudo mount /dev/sdb1 ~/Desktop/disk2` şeklide komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount /dev/sdb1 ~/Desktop/disk2
```

Artık disk bölümü iki farklı dizine bağlı bulunuyor. Disk bölümünün
bağlı olduğu dizin adreslerini öğrenmek için `lsblk` komutunu
kullanabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0   80G  0 disk 
├─sda1    8:1    0   79G  0 part /
├─sda2    8:2    0    1K  0 part 
└─sda5    8:5    0  975M  0 part [SWAP]
sdb       8:16   0    2G  0 disk 
└─sdb1    8:17   0    1G  0 part /home/taylan/Desktop/disk2
                                 /home/taylan/Desktop/disk
sdc       8:32   0    1G  0 disk 
sdd       8:48   0    1G  0 disk 
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Ayrıca `lsblk` komutu yerine tüm dizinleri listelemek için `mount`
komutunu da tek başına kullanabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mount                                                                                                                                                   
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=5429020k,nr_inodes=1357255,mode=755,inode64)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,noexec,relatime,size=1094516k,mode=755,inode64)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,inode64)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k,inode64)
cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
none on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=29,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=12283)
mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime)
tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime)
fusectl on /sys/fs/fuse/connections type fusectl (rw,nosuid,nodev,noexec,relatime)
configfs on /sys/kernel/config type configfs (rw,nosuid,nodev,noexec,relatime)
none on /run/credentials/systemd-sysusers.service type ramfs (ro,nosuid,nodev,noexec,relatime,mode=700)
sunrpc on /run/rpc_pipefs type rpc_pipefs (rw,relatime)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=1094512k,nr_inodes=273628,mode=700,uid=1000,gid=1000,inode64)
gvfsd-fuse on /run/user/1000/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_id=1000,group_id=1000)
/dev/sdb1 on /home/taylan/Desktop/disk type ext4 (rw,relatime)
/dev/sdb1 on /home/taylan/Desktop/disk2 type ext4 (rw,relatime)
```

Bakın pek çok disk için bilgiler bastırıldı. Sondaki satırlarda yeni
bağladığımız disk bölümleri de açıkça görülebiliyor.

Neticede birden fazla dizine bağlanmış olma durumunu da teyit ettik.
Hatta her iki dizinin izinlerini kontrol ettiğimizde her ikisinin de
aynı izinlere sahip olduğunu görebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld ~/Desktop/disk*
drwxr-xr-x 4 taylan taylan 4096 Jul 10 01:28 /home/taylan/Desktop/disk
drwxr-xr-x 4 taylan taylan 4096 Jul 10 01:28 /home/taylan/Desktop/disk2
```

Disk bölümünün ilk bağlandığı dizinin ayarları diğer tüm dizinlere de
otomatik olarak geçerli oluyor. Çünkü aslında bu dizinler disk bölümüne
bağlandığında, sıradan bir dizinden ziyade bu disk bölümüne giriş kapısı
görevi görüyor. Dolayısıyla aslında disk bölümünün sahip olduğu
yetkilere göre daha sonra bağlandığı dizinlerin yetkileri de aynı
oluyor. Bağı kopardığımızda bu klasörler eski normal haline dönüyor.
Ayrıca ben `mount` komutunun detaylarından bahsetmedim ancak yardım
sayfasından da bizzat görebileceğiniz gibi pek çok seçeneği bulunuyor
aslında. Örneğin henüz diski bağlarken yetkisini belirtmemiz de
mümkündür. Ancak yetkilendirme gibi temel işlemleri zaten daha önceden
sahip olduğumuz bilgilerle yerine getirebildiğimiz için `mount`
komutunun diğer seçeneklerini tek tek ele alarak ekstra bilgi karmaşası
yaşamayalım. Örneğin bağladığınız disk bölümü için erişim kısıtlaması mı
getirmek istiyorsunuz, bağlı olduğu klasörün yetkilerini değiştirmeniz
yeterli.

Tamamdır, artık "**mounting**" işleminin temellerini öğrendik. Ancak
öğrendiğimiz temel bilgiler dışında bir de dikkat etmemiz gereken birkaç
ek detay bulunuyor.

Birincisi; eğer diski bağladığınız klasör içinde halihazırda dosya ve
klasör gibi içerikler varsa, disk bölümünü bağladığınızda ilgili
klasördeki önceki içerikler gizlenir. Çünkü aslında bu dizine yeni bir
disk bölümü bağladığınızda, eski disk bölümü ile olan bağını geçici
olarak kesmiş oluyorsunuz. Dolayısıyla son bağladığınız disk bölümünü,
bu bağlandığı dizinden çıkarmadığınız sürece de diğer disk bölümündeki
içeriklere bu dizin üzerinden erişemezsiniz.

Ayrıca bizim şimdiye kadar ele aldığımız `mount` aracı ile disk bağlama
işlemi kalıcı değildir. Yani sistemi yeniden başlattığımızda ilgili disk
bölümüne, bağladığımız dizinden tekrar erişemeyeceğiz. Hemen bu
durumları deneyimlemek için basit bir test gerçekleştirelim.

Ben denemek için yine masaüstü dizinime bir klasör oluşturmak ve içine
de test etmek için bir klasör eklemek istiyorum. Bunun için
`mkdir -p ~/Desktop/disk3/test` şeklinde komutumu giriyorum.
Hatırlıyorsanız buradaki `p` seçeneği iç içe dizinler oluşturmamızı
sağlıyor. Bu olmadan tek seferde iç içe yeni dizinler oluşturamayız.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir -p ~/Desktop/disk3/test                                                                                                                           

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -Rl ~/Desktop/disk3
/home/taylan/Desktop/disk3:
total 4
drwxr-xr-x 2 taylan taylan 4096 Jul 10 01:38 test

/home/taylan/Desktop/disk3/test:
total 0
```

`ls` komutu ile listelediğimde görebildiğiniz gibi ***disk3*** dizini
altında ***test*** klasörü yer alıyor. Şimdi bu ***disk3*** dizinine
disk bölümünü bağlayalım. Bağlamak için
`sudo mount /dev/sdb1 ~/Desktop/disk3` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount /dev/sdb1 ~/Desktop/disk3/
```

Şimdi tekrar aynı dizinin içeriğini `ls` komutu ile listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -Rl ~/Desktop/disk3                                                                                                                               
/home/taylan/Desktop/disk3:
total 20
drwx------ 2 root   root   16384 Jul 10 01:21 lost+found
drwxr-xr-x 2 taylan taylan  4096 Jul 10 01:28 yeni-klasor
ls: cannot open directory '/home/taylan/Desktop/disk3/lost+found': Permission denied

/home/taylan/Desktop/disk3/yeni-klasor:
total 0
```

Bakın, yalnızca bağladığımız disk bölümü içerisinde yer alan
***yeni-klasor*** bulunuyor. Önceki ***test*** klasörü hakkında bilgi
edinemedik. Yani bizzat teyit ettiğimiz şekilde, eğer bağlanılan dizinde
daha önceden dosya ve klasörler varsa bağlama işleminden sonra bunlara
erişemiyoruz. İşte bu sebeple mümkünse disk bölümünü bağladığınız
klasörün içinde başka içerikler olmadığından emin olun. Aksi halde disk
bölümünü sistemden çıkarana kadar bu içeriklere erişemezsiniz.

Zaten bu gibi sebeplerle sabit diskleri ***/mnt*** dizini altında yeni
klasör oluşturup saklamanız ve usb disk gibi çıkarılabilir aygıtları da
***/media*** dizini altında bir dizine bağlamanız önerilir. Ama bunun
bir zorunluluk olmadığını da tekrar hatırlatıyorum. İlgili diske hangi
dizinden ulaşmak istiyorsanız o dizine bağlayabilirsiniz.

Ayrıca yeniden başlatma aşamasında bu bağlantıların sıfırlandığından da
bahsetmiştik. Şimdi bu durumu da gözlemleyebilmek için sistemimizi
yeniden başlatalım. `reboot` komutu ile yeniden başlatabiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ reboot
```

Evet sistemim açıldı. Şimdi konsolu açıp disk bölümünün bağlı olduğu tüm
dizinleri bastırmayı deneyelim. Bunun için `lsblk` komutunu girebiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0   80G  0 disk 
├─sda1    8:1    0   79G  0 part /
├─sda2    8:2    0    1K  0 part 
└─sda5    8:5    0  975M  0 part [SWAP]
sdb       8:16   0    2G  0 disk 
└─sdb1    8:17   0    1G  0 part 
sdc       8:32   0    1G  0 disk 
sdd       8:48   0    1G  0 disk 
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Bakın **sdb1** disk bölümü herhangi bir dizin adresine bağlı gözükmüyor.
Şimdi ***disk3*** klasörünün içini `ls` komutu ile listeleyip bir
bakalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -lR ~/Desktop/disk3
/home/taylan/Desktop/disk3:
total 4
drwxr-xr-x 2 taylan taylan 4096 Jul 10  2023 test

/home/taylan/Desktop/disk3/test:
total 0
```

Disk bölümü bağlıyken bu klasör gözükmüyordu, artık bağlı olmadığı için
klasörün önceki içeriğine de tekrar ulaşabiliyoruz.

Böylelikle bağlamış olduğumuz disk bölümlerinin sistem başlangıcında
tekrar otomatik olarak bağlanmadığını ve bağlı oldukları klasör
içeriklerini gizlediklerini bizzat teyit etmiş olduk.

Eğer bağlantıların kalıcı olmasını istersek, bağlama emrini
***/etc/fstab*** dosyasına eklemiz gerekiyor.

Dosya Sistemini Kalıcı Olarak Bağlamak \| ***/etc/fstab***
----------------------------------------------------------

Standart şekilde `mount` komutu ile bağladığımız disk bölümlerinin
sistem yeniden başlatılırken otomatik olarak bağlanmadığını bizzat
deneyimledik. Eğer her sistem başlangıcında otomatik olarak bağlanmasını
istediğimiz diskler veya disk bölümleri varsa bunları ***/etc/fstab***
dosyası içerisinde uygun şekilde tanımlamamız gerekiyor. ***fstab***
dosyasının içeriğine göz atmak ve disk bölümünü kalıcı olarak eklemek
için `sudo nano /etc/fstab` komutunu giriyorum.

``` {.makefile}
# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# systemd generates mount units based on this file, see systemd.mount(5).
# Please run 'systemctl daemon-reload' after making changes here.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda1 during installation
UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=00253fba-ff78-4f04-b189-fbc974082345 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0
```

Zaten halihazırda burada sistemin standart disk bölümleri bulunuyor.
Burada kimlik numaraları(UUID) ile tanımlanmış olan disk bölümleri
sistem başlangıcında otomatik olarak bağlanıyor. Bizler de tıpkı
buradaki diskler gibi uygun şekilde tanımlama yaparak, istediğimiz disk
bölümünün istediğimiz biçimde sistem başlangıcında bağlanmasını
sağlayabiliriz.

Konfigürasyon dosyası içerisinde, bağlanacak diski nasıl belirtmemiz
gerektiği zaten sütun sütun açıklanmış.

``` {.php-template}
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
```

Sırasıyla aygıt adını, bağlanacağı noktayı, dosya sistemi türünü,
bağlanma seçeneklerini ve dump pass değerlerini belirtmemiz gerektiği
yazılmış. Ben örnek olarak yeni oluşturduğum disk bölümünün sistem
başlangıcında otomatik olarak bağlanması için tanımlamada bulunacağım.

Disk bölümü tanımlamak için öncelikle ilgili disk bölümünün aygıt adını
ya da benzersiz kimlik numarasını buraya girmemiz gerekiyor. Bu sayede
hangi disk aygıtını kaydettiğimiz anlaşılabilecek. Dosyadaki mevcut
tanımlamalarda da ilgili disklerin benzersiz kimlik numaraları
kullanılmış. Bunun yerine istersek doğrudan disklerin sistemdeki sanal
dosya karşılığı olan aygıt adını da yani örneğin ***/dev/sdb1***
şeklinde de tanımlamada bulunabiliriz. Fakat daha önce deneyimlediğimiz
gibi çeşitli sebeplerle aygıtların sanal dosya sisteminde isimleri
değişebileceği için en doğru yol, benzersiz kimlik numaraları olan UUID
değeri ile tanımlama yapmaktır. Bu değeri öğrenmek için de `lsblk -f`
komutunu kullanabiliyoruz.

    ┌──(taylan㉿linuxdersleri)-[~]
    └─$ lsblk -f
    NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
    sda                                                                         
    ├─sda1
    │    ext4   1.0         491d3534-b3d9-47af-ad63-66b0e72fe8dd   61.6G    15% /
    ├─sda2
    │                                                                           
    └─sda5
         swap   1           00253fba-ff78-4f04-b189-fbc974082345                [SWAP]
    sdb                                                                         
    └─sdb1
         ext4   1.0         e0b3196f-8180-476b-8041-081a3d016d0f                
    sdc                                                                         
    sdd                                                                         
    sr0                                                                         
    nvme0n1
                                                                                
    nvme0n2

Benim bağlamak istediğim aygıtın UUID değeri
"e0b3196f-8180-476b-8041-081a3d016d0f" olarak geçiyor. Ben bu
tanımlamayı kullanacağım.

``` {.ini}
UUID=e0b3196f-8180-476b-8041-081a3d016d0f
```

Bağlanma noktası olarak da yine kendi masaüstü dizinimdeki ***disk***
isimli klasörü belirtmek istiyorum. Bunun için
***/home/taylan/Desktop/disk*** şekline yazıyorum.

``` {.bash}
UUID=e0b3196f-8180-476b-8041-081a3d016d0f /home/taylan/Desktop/disk/
```

Burada tam dizini adresini girmeniz önemli. Örneğin ben kendi ev
dizinimi **tilde \~** işareti ile belirtemem çünkü bu dosya sistem
başlangıcında okunurken, tilde işareti benim ev dizinime
genişletilmeyecek. Dolayısıyla tilde kullanırsam doğru bir dizin adresi
belirtmiş olmam.

Dosya sistemi ext4 olduğu için, ext4 şeklinde yazıyorum.

``` {.bash}
UUID=e0b3196f-8180-476b-8041-081a3d016d0f /home/taylan/Desktop/disk/ ext4
```

**options** yani seçenekler kısmından ise ilgili bölümün nasıl
bağlanacağını belirtmemiz gerekiyor. Burada pek çok seçeneğimiz
bulunuyor. Örneğin mevcut tanımlamaya bakacak olursak, ana dizin
bağlanırken hata alınması durumunda tekrar "ro" "readonly" yani
"okunabilir" biçimde bağlanması seçeneğine sahip. Mevcut seçenekleri ve
açıklamalarını görmek için `man mount` komutu ile manuel sayfalarına göz
atabiliriz. Burada bizim aradığımız bilgi, bağlama seçeneklerinin
açıklamaları olduğu için `/` işareti ile örneğin dosyada da gördüğümüz
"**errors**" ifadesini araştırabiliriz. Bu açıklamalar
"FILESYSTEM-INDEPENDENT MOUNT OPTIONS" başlığı altındaki ele alınmış.

``` {.vbnet}
FILESYSTEM-INDEPENDENT MOUNT OPTIONS
       Some of these options are only useful when they appear in the
       /etc/fstab file.

       Some of these options could be enabled or disabled by default in the
       system kernel. To check the current setting see the options in
       /proc/mounts. Note that filesystems also have per-filesystem
       specific default mount options (see for example tune2fs -l output
       for ext_N_ filesystems).

       The following options apply to any filesystem that is being mounted
       (but not every filesystem actually honors them - e.g., the sync
       option today has an effect only for ext2, ext3, ext4, fat, vfat, ufs
       and xfs):

       async
           All I/O to the filesystem should be done asynchronously. (See
           also the sync option.)

       atime
           Do not use the noatime feature, so the inode access time is
           controlled by kernel defaults. See also the descriptions of the
           relatime and strictatime mount options.

       noatime
           Do not update inode access times on this filesystem (e.g. for
           faster access on the news spool to speed up news servers). This
           works for all inode types (directories too), so it implies
           nodiratime.

       auto
           Can be mounted with the -a option.

       noauto
           Can only be mounted explicitly (i.e., the -a option will not
           cause the filesystem to be mounted).
....
...
..
.
```

Kullanabileceğimiz tüm özellikler sırasıyla burada açıklanmış. Ben tek
tek hepsini ele almayacağım zaten görebildiğiniz gibi hangi özelliğin
hangi amaçla kullanıldığı belirtiliyor. Genellikle spesifik durumlar
hariç buradaki "**defaults**" seçeneğini bizim işimizi görüyor.

``` {.csharp}
defaults
           Use the default options: rw, suid, dev, exec, auto, nouser, and
           async.

           Note that the real set of all default mount options depends on
           the kernel and filesystem type. See the beginning of this
           section for more details.
```

Bu seçeneğin hangi özellikleri barındırdığı da burada yazıyor.
Varsayılan seçenek haricinde başka özellikle ihtiyacınız olursa buradaki
seçenekleri inceleyebilirsiniz. Ben diski bağlamak için **defaults**
seçeneğini kullanıyorum.

``` {.bash}
UUID=e0b3196f-8180-476b-8041-081a3d016d0f /home/taylan/Desktop/disk/ ext4 defaults
```

**dump** seçeneği yedeklemeyle ilgili, **0** olarak kalabilir.

**pass** ise sistem başlangıcında ilgili disk üzerinde `fsck` aracının
çalıştırılıp diskin kontrol edilip edilmeyeceğini belirtmemizi sağlıyor.
Eğer ilgili disk bölümü kontrol edilsin istersek **1** veya **2**
rakamlarından birini eklememiz gerekiyor. 1 rakamı öncelik belirttiği
için kök dizin haricinde 1 numarasını kullanmanız önerilmez. **2**
rakamı ile kök dizinin ardından bu bölümün de `fsck` kontrolünden
geçmesini sağlayabilirsiniz.

Eğer ilgili disk bölümün her sistem başlangıcında kontrol edilmesini
istemiyorsanız **0** olarak da bırakabilirsiniz. Hatta bu son iki sütun
yani **dump** ve **pass 0** olarak kalacaksa bu iki sütunu doğrudan boş
da bırakabilirsiniz.

Ancak benim önerim önemli bir disk bölümü ise **2** rakamı ile `fsck`
kontrolünü aktifleştirmenizdir.

``` {.bash}
UUID=e0b3196f-8180-476b-8041-081a3d016d0f /home/taylan/Desktop/disk/ ext4 defaults 0 2
```

Tamamdır, ben diskim için gereken tüm ayarlamayı yaptım. Şimdi dosyayı
kaydediyorum. Artık sistemi yeniden başlatıp diskin otomatik olarak
bağlanıp bağlanmayacağını test edebiliriz. `reboot` komutu ile sistemi
yeniden başlatıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ reboot
```

Evet sistemim yeninden başlatıldı. Şimdi kontrol etmek için konsolu açıp
`lsblk` komutu ile diskleri listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda       8:0    0    2G  0 disk 
└─sda1    8:1    0    1G  0 part /home/taylan/Desktop/disk
sdb       8:16   0    1G  0 disk 
sdc       8:32   0    1G  0 disk 
sdd       8:48   0   80G  0 disk 
├─sdd1    8:49   0   79G  0 part /
├─sdd2    8:50   0    1K  0 part 
└─sdd5    8:53   0  975M  0 part [SWAP]
sr0      11:0    1 1024M  0 rom  
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Evet, **sda1** ismi altında **d**isk bölümüm ***fstab*** dosyasında
belirttiğim şekilde masaüstümdeki ***disk*** klasörüne otomatik olarak
sorunsuzca bağlanmış. Aygıtın isminin değişebileceğinden bahsetmiştik.
Burada önemli olan **UUID** değeri olduğu için `lsblk -f` komutu ile tam
olarak benim istediğim disk bölümünün bağlandığını da teyit edebilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk -f
NAME    FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sda                                                                            
└─sda1  ext4   1.0         e0b3196f-8180-476b-8041-081a3d016d0f  906.2M     0% /home/taylan/Desktop/disk
sdb                                                                            
sdc                                                                            
sdd                                                                            
├─sdd1  ext4   1.0         491d3534-b3d9-47af-ad63-66b0e72fe8dd   61.6G    15% /
├─sdd2                                                                         
└─sdd5  swap   1           00253fba-ff78-4f04-b189-fbc974082345                [SWAP]
sr0                                                                            
nvme0n1                                                                        
nvme0n2
```

Gördüğünüz gibi UUID ile belirttiğim disk bölümü tam olarak belirttiğim
dizine bağlanmış. Ben ***/etc/fstab*** dosyasından eklediğim satırı
silene kadar da bu disk her sistem başlangıcında otomatik olarak
bağlanmaya devam edecek.

Sizler de bu şekilde disk bölümlerini sisteminize kalıcı olarak
bağlayabilirsiniz. Tamamdır artık disk bölümlerini nasıl
bağlayabileceğimizi öğrendiğimize göre şimdi de bağlı bulunanları nasıl
çıkarabileceğimizden bahsederek devam edelim.

Ayrıca aklınızda bulunsun ***/etc/fstab*** dosyasının okunması için
sistemi yeniden başlatmak zorunda da değiliz. Eğer `sudo mount -a`
komutunu kullanırsak ***fstab*** dosyasında tanımlanan tüm diskler
sisteme bağlanır. Yani `mount -a` komutu ***fstab*** dosyasını okuyup
buradaki tanımlamaların geçerli olmasını sağlar. Hatta ***fstab***
dosyasındaki tüm diskleri değil de yalnızca spesifik olarak tek bir
diskin bağlanmasını istersek `sudo mount /disk-adı` şeklinde de komut
girebiliriz. Örneğin ben yalnızca ***fstab*** dosyasında da tanımlı olan
**sda1** diskini bağlamak istersem komutumu `sudo mount /dev/sda1`
şeklinde girmem yeterli. Yani `mount` komutuna özellikle diskin
bağlanacağı konumu belirttiğimiz ikincil parametreyi girmezsek, `mount`
komutu ***fstab*** dosyasını okuyup buradaki tanımlamalara göre hareket
ediyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount /dev/sda1
mount: /home/taylan/Desktop/disk: /dev/sda1 already mounted on /home/taylan/Desktop/disk.
```

Sistemimi yeniden başlattığım için zaten bu bağlama işlemi
gerçekleştirilmişti, bu sebeple bu uyarıyı aldık.

Ben yeniden başlatma esnasında disklerin bağının geçersiz kaldığını ve
***fstab*** dosyasına ekleyerek kalıcı hale getirebildiğimizi daha net
görebilmeniz için sistemi yeniden başlattım. Yoksa normalde yeniden
başlatmamız gerekmiyor. Özellikle sistemimiz üzerinde sürekli
çalışmasını beklediğimiz servisler varsa, sistemi zorunda kalmadıkça
yeniden başlatmamız gerekmemeli. Linux da bu konuda son derece başarılı.
Yani eğer doğru şekilde yönetiliyorsa Linux sunucuları üzerinde çok uzun
**uptime** süreleri ile karşılaşmanız olasıdır.

Neyse, lafı daha fazla uzatmadan bağlı disklerin sistemden çıkarılmasını
yani `umount` işlemini ele alarak devam edelim.

Bağlı Diski Sistemden Çıkarmak \| `umount`
------------------------------------------

Tıpkı USB Flash disklerimizi çıkarmadan önce yaptığımız gibi disk
bölümlerini de bağlı oldukları bölümlerden `umount` komutu ile
çıkabiliyoruz. Bu sayede disk veya disk bölümü fiziksel olarak
bilgisayara bağlı olsa da işletim sistemi katmanında hiç bir kullanıcı
bu disk bölümüne ulaşamıyor. Örneğin USB diskinizi sistemden güvenli
şekilde çıkarmak isterseniz USB diskin bağlı olduğu konumun tam dizin
adresini `umount` komutuna argüman olarak girip, USB diskinizi güvenle
sistemden ayırabilirsiniz. Ben denemek için sistem başlangıcında
otomatik olarak bağlanmasını sağladığım yeni disk bölümünü çıkarmak
istiyorum. Bunun için `sudo umount ~/Desktop/disk` şeklinde komutumu
giriyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo umount ~/Desktop/disk 
                                                                             
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ lsblk                                                                    
NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS                                 
sda       8:0    0    2G  0 disk                                             
└─sda1    8:1    0    1G  0 part                                             
sdb       8:16   0    1G  0 disk                                             
sdc       8:32   0    1G  0 disk                                             
sdd       8:48   0   80G  0 disk                                             
├─sdd1    8:49   0   79G  0 part /                                           
├─sdd2    8:50   0    1K  0 part                                             
└─sdd5    8:53   0  975M  0 part [SWAP]                                      
sr0      11:0    1 1024M  0 rom                                              
nvme0n1 259:0    0    1G  0 disk 
nvme0n2 259:1    0   10G  0 disk
```

Bakın disk bölümü, ilgili dizin adresine bağlı değil artık. İşte sizler
de bu şekilde `umount` komutu ile disklerin mevcut bağlantılarını
koparabilirsiniz.

Bu `umount` komutunun en temel kullanımı. Bunun dışında `umount`
komutunun pek çok farklı kullanım seçeneği daha bulunuyor.

Örneğin eğer disk bölümü meşgul olduğu için bağını koparmamakta ısrar
ediyorsa `f` yani `force` seçeneği ile çıkarmaya zorlayabiliriz. Bir
disk bağını koparmama konusunda ısrarcı ise
`sudo umount -f /dev/disk-adı` şeklinde zorla çıkarmayı
deneyebilirsiniz. Yine de `force` yani "zorlama" seçeneği diskteki
verilerin bozulmasına sebep olabileceği için zorunlu olmayan durumlar
haricinde kullanmanızı kesinlikle önermem.

Elbette benim bahsettiğim bu seçenekler dışında `umount` komutunun
ekstra pek çok özelliği bulunuyor. Ancak zaten temelde bahsetmiş olduğum
yalın kullanımı `force` seçeneği dışında diğer seçeneklere nadiren
ihtiyaç duyarsınız. Elbette şöyle bir göz atıp ek özellikler hakkında
bilgi edinmeniz de hiç fena olmaz. Ancak ben bu eğitimde bahsetmeyi
gerekli bulmuyorum.

LVM \| Logical Volume Manager
-----------------------------

Disk yönetimiyle ilgili temelde bilmemiz gerekenleri ele aldık. Fakat
diski genişletme veya küçültme gibi işlemlerden hiç bahsetmedik. Çünkü
standart yaklaşımlar kullanarak oluşturduğumuz disk bölümlerinin
üzerinde işlemler yapmak zahmetli ve riskli olabiliyor. Bu sebeple daha
modern yaklaşım olan LVM çözümünden çok kısaca bahsetmek istiyorum.

Söz konusu LVM olduğunda temelde üç katman bulunuyor.

**Physical Volume (PV) :** Fiziksel depolama cihazlarını temsil eden
katman.

**Volume Group (VG):** Fiziksel disklerin birleştirilip sanal olarak
temsil edildiği gruptur.

**Logical Volume (LV):** Volume Group'u oluşturan sanal disk
bölümleridir.

Yapıyı en genel haliyle aşağıdaki şekilde soyutlayabiliriz.

![LVM-structure.webp](https://www.linuxdersleri.net/egitim/temel-linux/disk/LVM-structure.webp)

Bu iş için tanımlanan fiziksel disklerdeki depolama alanları
birleştirilip tek bir grup içerisinde toparlanıyor, daha sonra bu toplam
disk kapasitesinden sanal olarak ihtiyaca yönelik disk bölümleri
oluşturulabiliyor. Bu sayede disk alanlarını genişletip küçültme gibi
işlevler, veri kayıpları olmadan kolayca ele alınabiliyor. Yani fiziksel
olarak tek bir diskte sahip olmamız veya fiziksel sınırlara takılmamız
gerekmiyor. Soyutlayarak çok daha pratik çözümler üretebiliyoruz. Bu
yaklaşım sayesinde yedekleme, snapshot, ve diğer disk yönetimi
sorunlarını kolayca idare edebiliyoruz.

LVM Kurulumu
------------

Öncelikle hangi fiziksel diski veya disk bölümünü kullanacaksak, o
bölümü "physical volume" yani "fiziksel hacim" haline getirmemiz gerek.
LVM yapısının genel şemasını açıkladığımız diyagrama dönüp bakacak
olursanız bu durumu kendiniz de görebilirsiniz.

Physical Volume Oluşturmak \| `pvcreate`
----------------------------------------

Eğer fiziksel diskinizin tamamını kullanmak istemiyorsanız, öncelikle
`fdisk` gibi bir araç yardımıyla ne kadarlık bölümünü kullanacaksanız o
kadar bir disk bölümü oluşturun. Disk bölümü veya tüm diski
kullanacaksanız ilgili diskiniz hazırsa, `pvcreate` komutunun ardından
aygıt isimlerini girebilirsiniz. Komutun ismi de "**p**hysical
**v**olume **create**" yani "fiziksel hacim oluştur" ifadesinin
kısaltmasından geliyor.

Ben öncelikle hangi diskleri veya disk bölümlerini dahil etmek
istediğime karar vermek için `sudo fdisk -l` komutu ile listelemek
istiyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo fdisk -l                                                                                                                                           
[sudo] password for taylan: 
Disk /dev/nvme0n1: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/nvme0n2: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: ORCL-VBOX-NVME-VER12                    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdd: 80 GiB, 85899345920 bytes, 167772160 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xd562e290

Device     Boot     Start       End   Sectors  Size Id Type
/dev/sdd1  *         2048 165771263 165769216   79G 83 Linux
/dev/sdd2       165773310 167770111   1996802  975M  5 Extended
/dev/sdd5       165773312 167770111   1996800  975M 82 Linux swap / Solaris

Disk /dev/sda: 2 GiB, 2147483648 bytes, 4194304 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xb2de8f5b

Device     Boot Start     End Sectors Size Id Type
/dev/sda1        2048 2099199 2097152   1G 83 Linux

Disk /dev/sdc: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdb: 1 GiB, 1073741824 bytes, 2097152 sectors
Disk model: VBOX HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

Ben örnek olması için ***/dev/nvme0n2*** diskinin tamamını ve
***/dev/sda1*** bölümünü dahil etmek istiyorum. Bunun için
`pvcreate /dev/nvme0n2 /dev/sda1` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ pvcreate /dev/nvme0n2 /dev/sda1
Command 'pvcreate' not found, but can be installed with:
sudo apt install lvm2
Do you want to install it? (N/y)
```

Benim sistemimde **lvm** aracı yüklü değil kurmak için benden onay
isteniyor, ben kuruyorum.

Şimdi komutumuzu tekrar girebiliriz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvcreate /dev/nvme0n2 /dev/sda1                                                                                                                    
  Can't open /dev/sda1 exclusively.  Mounted filesystem?
  Can't open /dev/sda1 exclusively.  Mounted filesystem?
  Error opening device /dev/sda1 for reading at 0 length 4096.
  Cannot use /dev/sda1: device has a signature
  Physical volume "/dev/nvme0n2" successfully created.
```

***/dev/sda1*** disk bölümü halihazırda sisteme bağlı bulunduğu yani
kullanıldığı için bu disk bölümü için fiziksel hacim oluşturulamadı. Bu
durumda tek yapmamız gereken bu diski sistemden ayırıp aynı komutu
tekrar girmek.

Ben ***/etc/fstab*** dosyasına eklemiş olduğum konfigürasyon satırını
silip, ***/dev/sda1*** bölümünü `umount` ile sistemden ayırıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo nano /etc/fstab                                                                                                                                    

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount -a

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo umount /dev/sda1                                                                                                                                   

┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk -f                                                                                                                                                
NAME    FSTYPE      FSVER    LABEL UUID                                   FSAVAIL FSUSE% MOUNTPOINTS
sda                                                                                      
└─sda1  ext4        1.0            e0b3196f-8180-476b-8041-081a3d016d0f                  
sdb                                                                                      
sdc                                                                                      
sdd                                                                                      
├─sdd1  ext4        1.0            491d3534-b3d9-47af-ad63-66b0e72fe8dd     61.6G    15% /
├─sdd2                                                                                   
└─sdd5  swap        1              00253fba-ff78-4f04-b189-fbc974082345                  [SWAP]
sr0                                                                                      
nvme0n1                                                                                  
nvme0n2 LVM2_member LVM2 001       5JMH8c-E6sH-CU8Q-ffxQ-M2Qf-ibd9-iwfl4z
```

Şimdi `sudo pvcreate /dev/sda1` komutu ile "physical volume" oluşturmayı
tekrar deneyebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvcreate /dev/sda1
WARNING: ext4 signature detected on /dev/sda1 at offset 1080. Wipe it? [y/n]: y
```

Disk bölümünde daha önceden ext4 dosya sistemi tanımlandığı için bu
tanımlamanın silinmesi için onay bekleniyor. Eğer onay verirsem, dosya
sistemi tanımı silineceği için bu diskteki mevcut verilere
ulaşamayacağım. Yani içerisinde veriler bulunan bir disk bölümünü
fiziksel hacim olarak ayarlamaya çalışıyorsanız, bu diskteki verilere
tekrar ulaşamayacağınızın bilincinde olun lütfen. Gerekiyorsa
diskinizdeki verileri yedekleyin. Ben silinmesi için onay veriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvcreate /dev/sda1
WARNING: ext4 signature detected on /dev/sda1 at offset 1080. Wipe it? [y/n]: y
  Wiping ext4 signature on /dev/sda1.
  Physical volume "/dev/sda1" successfully created.
```

En nihayetinde ***/dev/sda1*** bölümünü "Physical volume-fiziksel hacim"
haline dönüştürmüş olduk. Hatta teyit etmek istersek `sudo pvs` komutunu
kullanabiliriz. Komutu "**p**hysical **v**olume **s**can" ifadesinin
kısaltmasından aklınızda tutabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvs                                                                                                                                                
  PV           VG Fmt  Attr PSize  PFree 
  /dev/nvme0n2    lvm2 ---  10.00g 10.00g
  /dev/sda1       lvm2 ---   1.00g  1.00g
```

Tüm işlemler gördüğünüz gibi son derece kolay. Ben örnek olması için
kasıtlı olarak içerisi dolu olan bir disk bölümünü de ele aldım. Bu
sayede böyle bir disk bölümü üzerindeki olası etkileri de görmüş olduk.

Şimdi diskleri ve disk bölümlerini fiziksel hacim haline çevirdiğimize
göre artık bunları ortak bir gruba alıp, ortak hacim havuzu
oluşturabiliriz. Bu sayede iki farklı diskin toplam alanını tek bir
diskmiş gibi kullanabiliyor olacağız.

Volume Group Oluşturmak \| `vgcreate`
-------------------------------------

İstediğimiz "physical volume"'leri birleştirip ortak bir alan havuzu
yapmak için "**v**olume **g**roup **create**" kısaltmasından gelen
`vgcreate` komutunu kullanabiliyoruz. Komutun kullanımı
`vgcreate grup-adı aygıt-adı` şeklindedir. Ben ***/dev/nvme0n2*** ve
***/dev/sda1*** "physical volume"'lerini eklemek istediğim için
`sudo vgcreate disk-grubu /dev/nvme0n2 /dev/sda1` şeklinde komutumu
giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgcreate disk-grubu /dev/nvme0n2 /dev/sda1
  Volume group "disk-grubu" successfully created
```

Bakın "disk-grubu" isimli yeni bir hacim grubu oluşturmuş olduk. Bu
grupta ***/dev/nvme0n2*** ve ***/dev/sda1*** hacimlerinin toplamı yer
alıyor. Grubu teyit etmek için "**v**olume **g**roup **s**can"
ifadesinin kısaltmasından gelen `vgs` komutunu kullanabiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgs                                                                                                                                                
  VG         #PV #LV #SN Attr   VSize  VFree 
  disk-grubu   2   0   0 wz--n- 10.99g 10.99g
```

Bakın toplam boyut, her iki diskin toplamı kadar.

Logical Volume Oluşturmak \| `lvcreate`
---------------------------------------

Volume group oluşturduk. Artık bu grup içinden ihtiyacımıza göre birden
fazla "mantıksal hacim" yani "logical volume" adı altında sanal disk
bölümü oluşturabiliriz. Yani "volume group" tek bir diskmiş gibi
davranıp bu disk alanını istediğimiz parçalara bölebiliriz.

En temel kullanımı `lvcreate -L BOYUTU -n İSMİ VOLUME-GROUP`
şeklindedir.

Örneğin ben "disk-grubu" isimli volume group üzerinde 3G boyutunda
"test" isimli bir logical volume oluşturmak için
`sudo lvcreate -L 3G -n test disk-grubu` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvcreate -L 3G -n test disk-grubu                                                                                                                  
  Logical volume "test" created.
```

Bakın "**test**" isimli mantıksal hacim oluşturuldu. Teyit etmek için
`lvs` komutunu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvs                                                                                                                                                
  LV   VG         Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  test disk-grubu -wi-a----- 3.00g
```

Logical volume oluşturduğumuzu teyit etmiş olduk. Artık bu mantıksal
disk bölümünü kullanabilmemiz için tek yapmamız gereken bir dosya
sistemi eklemek. Ben örnek olarak **ext4** dosya sistemi ekleyeceğim.
Siz dilediğiniz bir dosya sistemi ekleyebilirsiniz. Üstelik birden fazla
logical volume oluşturup her birine ayrı bir dosya sistemi de
tanımlayabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mkfs.ext4 /dev/mapper/disk--grubu-test 
mke2fs 1.46.5 (30-Dec-2021)
Creating filesystem with 786432 4k blocks and 196608 inodes
Filesystem UUID: fcfde6e1-c39e-4486-8c73-9e31f4fabde7
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
```

Tamamdır artık dosya sistemi hiyerarşisindeki dilediğim bir dizine
bağlayabilirim. Ben denemek için masaüstümdeki ***disk*** isimli klasöre
bağlamak istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo mount /dev/mapper/disk--grubu-test ~/Desktop/disk

┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk
NAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda                  8:0    0    2G  0 disk 
└─sda1               8:1    0    1G  0 part 
sdb                  8:16   0    1G  0 disk 
sdc                  8:32   0    1G  0 disk 
sdd                  8:48   0   80G  0 disk 
├─sdd1               8:49   0   79G  0 part /
├─sdd2               8:50   0    1K  0 part 
└─sdd5               8:53   0  975M  0 part [SWAP]
sr0                 11:0    1 1024M  0 rom  
nvme0n1            259:0    0    1G  0 disk 
nvme0n2            259:1    0   10G  0 disk 
└─disk--grubu-test 254:0    0    3G  0 lvm  /home/taylan/Desktop/disk
```

`lsblk` komutunun çıktılarından da görebildiğiniz gibi, istediğim konuma
bağlamayı başardım. Eğer bu disk bölümünün sistem açılışında otomatik
olarak bağlanmasını istiyorsanız, ***/etc/fstab*** dosyasına uygun
şekilde ekleyebilirsiniz. Tıpkı daha önce gerçekleştirdiğimiz standart
disk bölümleme ve bağlama işlemleri gibi son derece kolay. Tek fark
**lvm** yaklaşımı sayesinde bu bölümleri yönetme noktasında çok daha
fazla avantaja sahibiz.

### Logical Volume Türleri Hakkında \| RAID

Ben örnek olması için en yalın haliyle nasıl "logical volume"
oluşturabileceğimizi ele aldım. Ancak tek yaklaşım bundan ibaret değil.
**RAID** olarak geçen ve verilerin amaçlara uygun şekilde farklı
yaklaşımlarla depolanmasına olanak tanıyan çeşitli mantıksal hacimleme
yöntemleri de var. Fakat ben temel eğitimde bunların detaylarına
değinmeyeceğim. Buradan öğrendiğiniz temel bilginin üzerine biraz
araştırma ile kendi kendinize de keşfedebilirsiniz.

Boyutlandırma
-------------

Değişimleri gerçekleştirebilmek için öncelikle bu değişimlere uygun
ortama sahip olup olmadığımızı öğrenmemiz gerek. Bu sebeple disk
durumları hakkında aldığımız çıktıların ne anlama geldiğini biliyor
olmalıyız.

Volume Group'a Yeni Disk Eklemek \| `vgextend`
----------------------------------------------

Ben mevcut gruba yeni bir fiziksel disk eklemek istiyorum. Bunun için
sizin de bildiğiniz gibi bu fiziksel diski öncelikle "physical volume"
haline getirmemiz gerek.

Disklerimizi listeleyelim.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ lsblk 
NAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda                  8:0    0   80G  0 disk 
├─sda1               8:1    0   79G  0 part /
├─sda2               8:2    0    1K  0 part 
└─sda5               8:5    0  975M  0 part [SWAP]
sdb                  8:16   0    2G  0 disk 
└─sdb1               8:17   0    1G  0 part 
sdc                  8:32   0    1G  0 disk 
sdd                  8:48   0    1G  0 disk 
sr0                 11:0    1 1024M  0 rom  
nvme0n1            259:0    0    1G  0 disk 
nvme0n2            259:1    0   10G  0 disk 
└─disk--grubu-test 254:0    0    3G  0 lvm
```

Ben ***/dev/sdc*** diskini "**p**hysical **v**olume" yani kısaca
"**pv**" olarak değiştirmek için komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvcreate /dev/sdc
[sudo] password for taylan: 
  Physical volume "/dev/sdc" successfully created.
```

Tamamdır, artık bu pv'yi "volume group" içine dahil edebiliriz. Bunun
için `vgextend` komutunu kullanıyoruz. "**extend"** ifadesi
"genişletmek" anlamına geldiği için, aracın görevini net biçimde
açıklıyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgextend disk-grubu /dev/sdc
  Volume group "disk-grubu" successfully extended

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgs
  VG         #PV #LV #SN Attr   VSize   VFree 
  disk-grubu   3   1   0 wz--n- <11.99g <8.99g
```

`vgs` komutunun çıktılarından bizzat teyit ettiğimiz gibi pv'yi vg'a
ekleyip toplam disk hacmini genişletmiş olduk.

Volume Group'dan Disk Çıkarmak \| `vgreduce`
--------------------------------------------

Halihazırda volume group'a dahil olan bir physical volume'ü çıkarmak
için `vgreduce` komutunu kullanabiliyoruz. Buradaki "**reduce**" ifadesi
"azaltmak" anlamına geliyor. Ben en son eklediğim pv'yi çıkarmak
istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgreduce disk-grubu /dev/sdc
[sudo] password for taylan: 
  Removed "/dev/sdc" from volume group "disk-grubu"

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgs
  VG         #PV #LV #SN Attr   VSize  VFree
  disk-grubu   2   1   0 wz--n- 10.99g 7.99g
```

Gördüğünüz gibi gruptaki pv'ü çıkarmayı başardık.

Logical Volume Alanını Genişletmek \| `lvextend`
------------------------------------------------

Daha önce 3G boyutunda bir logical volume oluşturmuştuk. Eğer bu lv'ü
genişletmek istersek `lvextend` komutunu kullanabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvextend -L +2G /dev/mapper/disk--grubu-test                                                                           
  Size of logical volume disk-grubu/test changed from 3.00 GiB (768 extents) to 5.00 GiB (1280 extents).
  Logical volume disk-grubu/test successfully resized.

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvs                                                                                                                    
  LV   VG         Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  test disk-grubu -wi-ao---- 5.00g
```

Gördüğünüz gibi 3G olan logical volume, 5G'ye genişletilmiş oldu.

Logical Volume Alanını Küçültmek \| `lvreduce`
----------------------------------------------

**Azaltma işleminde mevcut disk üzerinde veri kayıpları yaşanabileceği
için, elzem olmayan durumlar haricinde kullanmanızı önermiyorum.**

Küçültmek için `lvreduce` komutunu kullanabiliyoruz. Ben 1G kadar
küçültmek için komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvreduce -L -1G /dev/mapper/disk--grubu-test
  WARNING: Reducing active and open logical volume to 4.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce disk-grubu/test? [y/n]:
```

Bakın burada da disk üzerindeki verilerin yok edilebileceği uyarısı var.
Eğer onay verirsem işleme devam edilecek. Bu lv'de benim önemli bir
dosyam olmadığı için ben "**y**" ile onay veriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvreduce -L -1G /dev/mapper/disk--grubu-test
  WARNING: Reducing active and open logical volume to 4.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce disk-grubu/test? [y/n]: y
  Size of logical volume disk-grubu/test changed from 5.00 GiB (1280 extents) to 4.00 GiB (1024 extents).
  Logical volume disk-grubu/test successfully resized.

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvs
  LV   VG         Attr       LSize Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  test disk-grubu -wi-ao---- 4.00g
```

Gördüğünüz gibi ilgili **lv**, 1G küçültülmüş oldu.

Logical Volume Silinmesi \| `lvremove`
--------------------------------------

Silmek için `lvremove` komutunu kullanabiliyoruz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvremove /dev/mapper/disk--grubu-test
  Logical volume disk-grubu/test contains a filesystem in use.
```

Gördüğünüz gibi eğer ilgili lv sisteme bağlı ise öncelikle sistemden
bağının `umount` komutu ile koparılması lazım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo umount /dev/mapper/disk--grubu-test

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvremove /dev/mapper/disk--grubu-test                                                                                  
Do you really want to remove active logical volume disk-grubu/test? [y/n]: y
  Logical volume "test" successfully removed.
```

Sistemden bağlantısını kesip silmek üzere `lvremove` komutunu
girdiğimizde gördüğünüz gibi "gerçekten silmek istediğinize emin
misiniz?" diye bizden onay bekleniyor. Ben tüm verilerin silinmesini
istediğim için onayı veriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvremove /dev/mapper/disk--grubu-test                                                                                  
Do you really want to remove active logical volume disk-grubu/test? [y/n]: y
  Logical volume "test" successfully removed.

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lvs
```

Böylelikle logical volume'ü tamamen silmiş olduk.

Physical Volume Silinmesi \| `pvremove`
---------------------------------------

Physical volume haline dönüştürdüğümüz fiziksel diski veya disk bölümünü
silip, eski standart fiziksel haline dönüştürmek istersek `pvremove`
komutunu kullanabiliriz. Öncelikle bu türdeki diskleri listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvs
  PV           VG         Fmt  Attr PSize    PFree   
  /dev/nvme0n2 disk-grubu lvm2 a--   <10.00g  <10.00g
  /dev/sdb1    disk-grubu lvm2 a--  1020.00m 1020.00m
  /dev/sdc                lvm2 ---     1.00g    1.00g
```

Ben buradan ***/dev/sdc*** diskini eski haline çevirmek için silmek
istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvremove /dev/sdc
  Labels on physical volume "/dev/sdc" successfully wiped.

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvs
  PV           VG         Fmt  Attr PSize    PFree   
  /dev/nvme0n2 disk-grubu lvm2 a--   <10.00g  <10.00g
  /dev/sdb1    disk-grubu lvm2 a--  1020.00m 1020.00m

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

***/dev/sdc*** herhangi bir gruba dahil olmadığı veya herhangi bir veri
barındırmadığı için anında silinmiş oldu.

Volume Group Silinmesi \| `vgremove`
------------------------------------

Mevcut bir "volume group"u silmek için `vgremove` komutunu
kullanabiliyoruz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgs
  VG         #PV #LV #SN Attr   VSize  VFree 
  disk-grubu   2   0   0 wz--n- 10.99g 10.99g

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgremove disk-grubu
  Volume group "disk-grubu" successfully removed

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo vgs

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo pvs
  PV           VG Fmt  Attr PSize  PFree 
  /dev/nvme0n2    lvm2 ---  10.00g 10.00g
  /dev/sdb1       lvm2 ---   1.00g  1.00g
```

Çıktılardan görebildiğiniz gibi grubu sildiğimizde, grupta bulunan pv de
etkileniyor. Bu sebeple grup içindeki verileri silme istemediğiniz
sürece doğrudan grubu asla silmeyin.

Böylelikle temel LVM anlatımlarının ve disk yönetimi bölümünün sonuna
gelmiş olduk. Buradaki anlatımlar LVM için yüzeysel giriş seviyesi
bilgilerdir. Kısa bir araştırma ile çok daha fazla detaya sahip olduğunu
görebilirsiniz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 7. Ders 96 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Dizinler Hakkında
-----------------

Linux işletim sisteminde bütün programlar, aygıtlar, dosyalar ve genel
olarak sistemin tüm ögeleri, hiyerarşik bir düzen içerisinde çeşitli
klasörlerde tutuluyor. Normalde eğer grafiksel arayüzdeyken dizinlerde
gezinti yapacaksak, dosya yöneticisi aracını kullanarak istediğimiz
dizinlerde gezinti yapıp dizinlerin içeriğini görüntüleyebiliyor ya da
gerektiğinde düzenleyebiliyoruz.

Grafiksel arayüze benzer şekilde söz konusu komut satırı üzerinden
sistemi yönetmek olduğunda da tabii ki işlerimizi tek bir dizin altında
yürütmeyeceğimiz için komut satırındayken de dizinler arasında
rahatlıkla gezinebiliyor olmamız gerekiyor. İşte bu bölümde, dizinlerde
rahatlıkla gezinme ve görüntüleme için gerekli komutlara tek tek
değiniyor olacağız. Yani bölümün sonunda, komut satırı üzerinden tüm
sistemdeki dizin hiyerarşisi içinde rahatlıkla gezinebiliyor
olacaksınız.

Fakat dizinlerde gezinmeden önce tabii ki üzerinde gezineceğimiz bu
dizin yapısını tanımamız gerekiyor. Çünkü üzerinde gezineceğimiz Linux
dosya sistemi hiyerarşisi, pek çoğumuzun alışık olduğu Windows'tan biraz
farklı. Dizin yapısını bilmediğimizde körlemesine gezinmek zorunda
kalırız bu da dizinlerde gezinti gibi son derece basit olan işlevi bile
zar zor yerine getirmemize neden olur. Zaten yeni başlayan
kullanıcıların dizinlerde gezinirken yaşadıkların sorunların neredeyse
tamamı Linux sisteminin dizin yapısını temel düzeyde bilmiyor
olmalarından kaynaklanıyor.

Linux Dosya Sistemi Hiyerarşisi
-------------------------------

Söz konusu Linux olduğunda pek çok farklı dağıtım olduğunu biliyoruz. Bu
sebeple temel dosya hiyerarşisi dışında dağıtıma özel olan farklı
dizinler de mevcut olabiliyor. Fakat bu durumum bizim için sorun değil
çünkü temel dosya sistemi hiyerarşisi tüm dağıtımlarda ortak olmak
durumunda. Biz de burada temel yapıdan bahsediyor olacağız.

Linux'ta tüm dosya ve dizinler "**root**" olarak ifade edilen "**kök"**
dizini altında hiyerarşik şekilde tutuluyor. Kök dizin de slash `/`
işareti ile temsil ediliyor. Ben anlaşılır olması için temel dizinleri
aşağıdaki diyagramda belirttim.

![hiyerarsi.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/hiyerarsi.webp)

Gördüğünüz gibi tüm dizinler `/` işareti ile temsil edilen kök dizinin
altında bulunuyor. Bu durumu bizzat sistemimizden teyit etmek için kök
dizini listelemek üzere `ls /` komutunu girebiliriz.

``` {.ruby}
└─$ ls /
bin             lib         opt   tmp
boot            lib32       proc  usr
dev             lib64       root  var
etc             libx32      run   vmlinuz
home            lost+found  sbin  vmlinuz.old
initrd.img      media       srv
initrd.img.old  mnt         sys
```

Burada kullanmış olduğumuz `ls` komutu listeleme yapan bir araç ve biz
de `/` dizini içerisindekileri listelemek için `ls /` komutunu
kullandık. Bu listede benim diyagramda belirttiklerime ek olarak harici
dizinler olduğunu görebiliyoruz. Zaten anlatımın başında kullanılan
dağıtıma göre bu gibi ekstra içerikler olabileceğinden bahsetmiştik. En
temel dizinleri tanımamız yeterli. Sırasıyla açıklayarak devam edelim.

Ana Dizin \| Kök Dizin \| /
---------------------------

Dosya sistemi hiyerarşisinin en tepe noktasını yani başlangıcını temsil
eden ana dizine kök(root) dizin deniyor olsa da aslında ana dizinin
doğrudan bir ismi olmadığı için yalnızca slash `/` işareti ile temsil
ediliyor. Kök dizin, yapısı gereği Linux sistemini başlatmak için
gereken tüm dosyaları içermesi gerekiyor.

/bin ve /sbin
-------------

***/bin*** ve ***/sbin*** dizinlerinin ismi, "**bin**ary" yani "ikili"
ifadesinin kısaltmasından geliyor. Bu dizinlerde; sistemin başlatılması,
yönetimi ve gerektiğinde onarımı için kullanılan araçların
çalıştırılabilir "**binary**" dosyalarını barındırılıyor. Örneğin
konsola girdiğimiz komutların **PATH** yolu üzerinde arandığını
biliyoruz. PATH yoluda bu ***/bin*** ve ***/sbin*** dizinleri de
bulunuyor. Bu sayede çalıştırılabilir olan ikili dosyalar bulunup
çalıştırılabiliyor.

***/bin*** (**Bin**aries): Bu dizin, tüm kullanıcıların erişebileceği
temel işlevleri gerçekleştirmek için kullanılan programları içeriyor.

***/sbin*** (**S**ystem **Bin**aries): Bu dizin, sistem yöneticileri
tarafından kullanılan ve sistem yönetimi ve bakımıyla ilgili önemli
programları içeriyor.

Örneğin sistem yöneticisi tarafından kullanılabilen fdisk isimli aracın
varlığını her iki dizin içerisinde sorgulayabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /sbin | grep fdisk
cfdisk
docfdisk
fdisk
sfdisk

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /bin | grep fdisk                                                                 

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Buradaki `grep` aracından daha sonra ayrıca bahsediyor olacağız, fakat
şimdilik filtreleme yapma işlevinde olduğunu bilmeniz yeterli. Biz
öncelikle `ls` komutu ile ilgili dizin içeriğini listeledik, daha sonra
`grep` aracı ile bu dizi içeriğinde "***fdisk***" isimli bir dosya var
mı diye filtrelemiş olduk. Bu sayede disk yönetimi gibi sistem
yöneticisinin yetkileri dahilinde olan `fdisk` aracının yalnızca
***/sbin*** dizini içinde bulunduğunu teyit etmiş olduk.

Benzer şekilde sistemin yeniden başlatılmasını sağlayan `reboot` isimli
araç için de aynı durumu teyit edebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /bin | grep reboot

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /sbin | grep reboot                                                                 
grub-reboot
reboot
```

Neticede "***bin***" olarak geçen dizinlerin "**binary**" yani
çalıştırılabilir ikili dosyaları barındıran dizinler olduğunu,
"***sbin***" dizininin ise sistem yöneticilerinin ihtiyaç duyabileceği
türden araçları barındırdığını teyit etmiş olduk.

/boot
-----

Önyükleme yani "boot" aşaması için gereken dosyaları barındıran
dizindir. Ne yaptığınızdan emin olmadığınız sürece bu dizini
kurcalamanız gerekmeyecektir.

/dev
----

***/dev*** dizini "**dev**ices" yani "aygıtlar" kelimesinin
kısaltmasından geliyor. Bu dizin, sisteme bağlı olan donanım aygıtlarını
temsil eden aygıt dosyalarını içeriyor. Linux üzerinde her şey bir dosya
gibi ele alındığı için sisteme bağlı olan aygıtları temsil eden dosyalar
da bu dizinde bulunuyor.

/etc
----

***/etc*** dizini, sistemdeki konfigürasyon dosyalarının tutulduğu
dizindir. Genellikle istisnalar hariç Linux sisteminde bir hizmetleri
yapılandırmamız veya diğer çeşitli temel ayarları değiştirmemiz
gerekiyorsa, bakacağımız ilk yer burasıdır.

/home
-----

Daha önce de bahsetmiş olduğumuz gibi ***home*** dizini altında her bir
kullanıcının ismiyle oluşturulmuş klasörler vardır. Bu klasörler ilgili
kullanıcının ev dizini olarak geçer. Her bir kullanıcının kendi
kullanıcı hesabına özgü olan çeşitli konfigürasyon dosyaları, belgeleri
resimleri ve diğer çeşitli dosyaları bu dizinde bulunur. Örneğin ben
"taylan" isimli kullanıcı hesabını yönettiğim için benim kullanıcı
hesabımın ev dizini ***/home/taylan*** adresinde yer alıyor. Dizin
içeriğine göz atmak için `ls /home/taylan/` komutuyla listeleyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ls /home/taylan/
Desktop    Music     Templates
Documents  Pictures  Videos
Downloads  Public    yeni-klasor
```

Bakın burada "Desktop" "Documents" "Downloads" "Pictures" ve benzeri
dizinlerin yanında benim kendi oluşturduğumu dizinler ve dosyalar da
bulunuyor. Eğer hatırlıyorsanız kendi kullanıcı hesabım için kabuğun
konfigürasyonlarını kendi ev dizinimdeki ***.bashrc*** dosyasını
değiştirerek düzenlemiştim. Diğer kullanıcıların da kendi ev
dizinlerinde kendilerine ait olan ve o kullanıcı hesabını etkileyen
dosyalar vardır. Bu sebeple her bir kullanıcının kendine ait dosyaları
barındırabileceği ev dizinleri ***/home*** klasörü a ltında tutuluyor.

/lib
----

Eğer ana dizinin içeriğini tekrar listeleyecek olursak **lib** ile
başlayan birden fazla dizin(lib32,lib64,libx32) görebiliyoruz.

![2.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/2.webp)

Buradaki **lib** ifadesi "**lib**rary" yani "kütüphane" ifadesinin
kısaltmasından geliyor.

Sistemdeki araçların ortak olarak kullandığı kütüphane(library)
dosyaları buradaki uygun dizinlerde tutuluyor. Bu sayede tekrar tekrar
aynı kütüphane dosyalarının diskte yer işgal etmesi önleniyor. İlgili
araçlar, gerektiğinde ortak olarak bu kütüphane dosyalarını
kullanabiliyorlar. Kütüphaneler için birden fazla dizin olması da
uyumluluk için 32 ve 64 bit kütüphane dosyaların barındırılmasından
kaynaklanıyor.

/usr
----

***/usr*** dizini aslında neredeyse tüm komut dosyalarının, kütüphane
dosyalarının ve çeşitli dokümantasyonlarla birlikte sistemin normal
işleyişi için gerekli olan dosyaların bulunduğu dizindir.

İlk zamanlar ***lib bin sbin*** dizinleri ayrı ayrı tutuluyorken,
hepsine tek bir noktadan ulaşma fikri dolayısıyla tüm dizinler aslında
***usr*** altında taşınmıştır. Bizim ana dizin altında ***lib bin
sbin*** olarak gördüğünüz dizinler de aslında geriye dönük uyumluluk
için ana dizinde gözüken ama ***usr*** klasörüne sembolik olarak bağlı
olan dizinlerdir. Yani bu dizinlerin asılları da ***usr*** dizini
altında.

Bu durumu gözlemlemek için `ls -ld /*` komutunu girebiliriz.

![usr.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/usr.webp)
Burada benim kırmızı kutucuklar içine alarak özellikle belirttiğim gibi,
***lib bin sbin*** dizinleri aslında ***/usr*** dizini altında
bulunuyor. Ana dizin altında hala bu dizinlerin sembolik bağlantılarını
görüyor olma nedenimiz geriye dönük uyumluluktur.

Geçmişte bu dizinler kendi başına ana dizin(***/***) altında bulunduğu
için geçmişten beri aynı konfigürasyonlar ile çalışan araç ve yapıların
çalışmaya devam edebilmesi için yani geriye dönük uyumluluk için
sembolik olarak hala ana dizin altında gözüküyorlar. Örneğin bir araç
binary dosyaya erişmek üzere ***/bin*** dizinini kontrol ediyorsa,
otomatik olarak ***/usr/bin*** dizinine yönlendirilerek sorunsuzca
aracın çalışmaya devam etmesi sağlanmış oluyor.

/opt
----

***/opt*** klasörü harici olarak kurulan bazı araçların(üçüncü taraf
yazılımlar) kendi isimlerindeki klasörlerde tüm gerekli dosyalarının
barındırıldığı dizindir. Yani ***usr*** dizininde olduğu gibi
çalıştırılabilir dosyası ***bin*** dizinine ya da kütüphane dosyaları
***lib*** dizinine eklenmez. İlgili aracın tüm dosyaları ***opt***
dizini altındaki kendi ismiyle oluşturulmuş olan klasör içinde bulunur.

***media*** ve ***mnt*** dizinlerinin her ikisi de medya aygıtlarının
bağlanması için kullanılıyor. Aralarındaki fark ***media*** dizini "USB
bellek, harici disk, CD/DVD sürücüsü vb." gibi harici çıkarılabilir
medya aygıtlarını bağlamak için kullanılırken, ***mnt*** dizini ise
genellikle geçici olarak disk bölümlerini bağlamak için kullanılan bir
dizindir.

/proc
-----

***proc*** dizini önyükleme sırasında oluşturulduğu ve kapatma sırasında
kaldırıldığı için her zaman mevcut gibi görünse de aslında sisteminiz ve
o anda çalışan işlemleri hakkında birçok alakalı bilgi içeren sanal bir
dosya sistemidir. Örneğin yeni bir işlem başlattığınızda bu dizin
altında bu işlemle ilişkili yeni bir sanal dizin oluşturulacaktır.
Dizinin "**proc**" ismi de "**process**" yani "**işlem**" ifadesinin
kısaltmasından geliyor zaten.

/tmp
----

***tmp*** dizini "**tem**porary" yani "geçici" ifadesinden
kısaltmasından geliyor. Geçici olarak tutulması gereken dosya ve
klasörler için kullanılan bir dizin adresidir. Hem kullanıcılar hem de
programlar, geçici içerikler için bu dizini kullanabiliyor. Modern Linux
dağıtımlarının çoğu, /tmp'yi varsayılan olarak RAM üzerinde (tmpfs dosya
sistemi ile) tutar, dolayısıyla bu dizin altındaki veriler sistem
yeniden başlatıldığında silinir. Ancak RAM üzerinde tutma durumu
özelleştirilip disk üzerinde kalıcı şekilde tutulması da sağlanabilir.
Bu yaklaşım kullanılan dağıtımın ve sistem yöneticisinin ihtiyaçları
doğrultusunda belirlenir.

/root
-----

***root*** dizini root kullanıcısının ev dizinidir. Tıpkı bizim ev
dizinlerimizin ***home*** dizini altında kullanıcı adımızla
barındırılıyor olması gibi root kullanıcısının ev dizini de ana dizinde
"root" isimli klasörde barındırılıyor.

/var
----

***var*** dizininin ismi "**var**iable" yani "değişken" ifadesinin
kısaltmasından geliyor. Bu şekilde isimlendirilmesinin nedeni, sürekli
yenileri eklenen ve değişen dosyaların burada barındırılıyor olmasıdır.
Log dosyaları, çeşitli veritabanı dosyaları ve benzeri pek çok veri bu
dizin altında tutuluyor.

/sys
----

***/sys*** dizini, çeşitli sistem bileşenleri ve sürücüleri hakkında
bilgiler içeren dizindir.

/srv
----

***/srv*** dizini "**s**e**rv**ice" yani "servis" ifadesinin kısaltması
olarak isimlendirilmmiş bir dizindir. Sistemin sunduğu hizmetlere ait
veri ve yapılandırma dosyalarını barındıran. Örneğin dosya paylaşımı
için kullanılan FTP hizmeti dosyaları burada tutulabilir. Ya da örneğin
Nginx ile bir websitesi sunuyorsanız, dosyaları /srv/www/ dizini altında
tutuluyor olabilir. Özetle sunucunun sunduğu hizmetlerin çeşitli
dosyalarını barından bir dizindir.

/run
----

Sistem başlangıcından itibaren, sistem kaynaklarının nasıl
kullanıldığına dair çeşitli bilgileri tutan bir dizindir. Bu veriler,
sistemin o anda çalışan işlemlerinin ihtiyaçlarını karşılamak için
gerekli olan türde geçici verilerdir. Örneğin geçici verileri tutmak
veya araçlar arasında veri paylaşımını ve yönetimini mümkün kılmak için
kullanılan çeşitli bilgiler bu dizin altında tutulur. İsminde de olduğu
gibi "**run**ning" yani "çalışma" halindeki bilgiler bulunduğundan,
sistem her yeniden başlatıldığında bu veriler de temizlenir.

Böylelikle temelde haberdar olmamız gereken dizinlerinden kısaca
bahsetmiş olduk. Bu sayede artık ihtiyacınız olan dosyaların ve
dizinlerin olası konumları hakkında genel bilgi sahibisiniz. Yine de
daha detaylı şekilde bilgi almak isterseniz, dosya sistemi hiyerarşi
standartlarının belirlendiği
[buradaki](https://refspecs.linuxfoundation.org/fhs.shtml) açıklamalara
göz atabilirsiniz.

Özetleyecek olursak Linux dosya sisteminde tüm dizinler ana
dizine(***/***) bağlıdır. Yani tıpkı ağaç gibi tek bir noktadan başlayan
ve dallanarak genişleyen bir hiyerarşik yapı kurulmuştur. Benimsenmiş
olan bu ortak hiyerarşi yapısı sayesinde Linux ekosisteminin çok daha
stabil ve sürdürülebilir olması sağlanmıştır. Standart bir dosya sistemi
hiyerarşisi olmasaydı, geliştiriciler ve kullanıcıların farklı
dağıtımları destekleyip kullanabilmesi çok çok zorlaşırdı. Dolayısıyla
özgür yazılım ekosisteminin sunduğu tüm faydalardan tüm dağıtımların ve
tüm kullanıcıların faydalanması da pek kolay olmazdı. Neyse ki burada
değindiğimiz dizin hiyerarşisi, istisnalar hariç neredeyse tüm
dağıtımlarda standart olduğu için dilediğiniz bir dağıtımdaki dizinlerde
sorunsuzca gezinebilirsiniz.

Artık bu bilgiler ışığında bu dizin hiyerarşisi içerisinde nasıl
gezinebileceğimizden bahsederek devam edebiliriz.

`pwd` Komutu
------------

Hani bir yeri ziyaret ettiğimizde karşımıza çıkan haritalarda şu an
buradasınız şeklinde yazar ya işte bunun komut satırı arayüzündeki
karşılığı da tam olarak pwd komutu.

![Untitled](https://www.linuxdersleri.net/egitim/temel-linux/dizin/pwd.webp)

Bu komut sayesinde mevcut bulunduğumuz dizinin tam adresini
öğrenebiliyoruz. `pwd` komutu, İngilizce "**p**rint **w**orking
**d**irectory" yani "çalışma dizini yazdır" ifadesinin kısaltmasından
geliyor. Özellikle komutun açılımından ve İngilizce karşılığından da
bahsettim çünkü komutların açılımlarını ve İngilizce karşılıklarını
bilirsek, daha sonra ilgili komutları çok daha kolay hatırlayabiliyoruz.
Zaten genellikle komutların açılımları da görevleri ile ilişkili oluyor.

Komutumuzu test etmek için komut satırımızı açalım. istisnalar hariç
komut satırı ilk açıldığına kabuk varsayılan olarak bizim mevcut
kullanıcı hesabımızın ev dizinimizde çalışmaya başlar. Bu durumu teyit
edebilmek için hemen `pwd` komutunu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan
```

Bakın aldığımız bu çıktı bizim şu an komut satırında çalışmakta
olduğumuz dizini belirtiyor. Bu çıktı benim şu anda kullanmakta olduğum
kullanıcının ev dizininde çalışmakta olduğumu belirtiyor. Daha net
görebilmek adına grafiksel arayüz üzerinden de bizzat kontrol
edebiliriz. Bunun için hemen dosya yöneticisini açalım.

![3.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/3.webp)

Zaten bakın, dosya yöneticim de varsayılan olarak benim kendi ev
dizinimde açılıyor. Burada benim Desktop(Masaüstü),
Documents(Dokümanlar) ya da Downloads(İndirilen) gibi kişisel amaçlarım
için kullanabileceğim klasörler var. İşte burası şu anda kullandığım
taylan kullanıcısına ait olan ev dizinidir.

Bu dizinin benim ev dizinim olduğunu ve aldığımız çıktının anlamını iyi
kavrayabilmemiz için ben öncelikle hemen dosya sistemi hiyerarşisinin en
tepe noktasına geçiş yapıp oradan tekrar bu dizine kadar gelerek size
bizzat göstermek istiyorum.

Bunun için buradan dosya sistemi kısmına tıklayalım.

![4.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/4.webp)

Eğer sizin kullandığınız dosya yöneticisi aracında benimki gibi "file
system-dosya sistemi" ifadesi geçmiyorsa, biraz kurcalayıp ana dizini
bulabilirsiniz. "Diğer dizinler" şeklinde bir sekme veya "bilgisayarım"
şeklinde bir sekme vardır, oradan ana dizine ulaşabilirsiniz. Grafiksel
arayüzler farklı olabildiği için ana dizine nasıl ulaşacağınızı kendiniz
bulabilirsiniz. Zaten ana dizine ulaştığınızda tıpkı bende olduğu
şekilde bu temel klasörleri görüyor olacaksınız.

![5.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/5.webp)

Bakın şu an gördüğümüz tüm bu klasörler, mevcut işletim sistemini
oluşturan dosyaları barındıran klasörler. Burada bulunduğum dizin
işletim sisteminin dosyalarını barındıran tüm dosya ve klasörlerin en
tepe noktası. Bu dizinin adresini görmek için adres çubuğuna
bakabiliriz.

![6.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/6.webp)

Bakın bulunduğumuz dizinin ismi **slash** `/` karakteri olarak
gözüküyor. Komut satırı arayüzünde aldığımız çıktıya da dönecek olursak
bakın çıktının en başında slash işareti bulunuyor. İşte bu slash işareti
tam olarak şu anda dosya yöneticisi üzerinden görüntülediğimiz bu dizini
temsil ediyor.

![7.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/7.webp)

Bu slash dizini tüm işletim sistemini oluşturan dosyaları barındıran en
tepedeki dizin. Diğer tüm dosya ve klasörler bu dizin altındaki diğer
klasörlerin altında bulunuyor. Bu durumu teyit etmek için çıktıda
aldığımız ***/home/taylan*** yolunu dosya yöneticisi üzerinden takip
edebiliriz.

![8.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/8.gif)

İşte komut satırında çalışmakta olduğumuz dizini belirten bu çıktı,
tıpkı bizim grafiksel arayüzden de adım adım takip ettiğimiz gibi benim
ev dizinimi temsil ediyor. Yani ben "taylan" kullanıcısı olarak
konsolumu ilk açtığımda tıpkı dosya yöneticisinde de olduğu gibi kendi
ev dizinimden(***/home/taylan***) çalışamaya başlıyorum.

Neticede konsolun ilk açıldığında kullanıcının ev dizininden çalışmaya
başladığını ve `pwd` komutunun da kabuğun o anda çalışmakta olduğu
dizinin bilgisini verdiğini bizzat teyit etmiş olduk. Dilerseniz farklı
bir dizine geçip, konsolu burada açarak `pwd` komutunu tekrar test
edebiliriz.

![9.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/9.gif)

Gördüğünüz gibi komut satırının çalışmakta olduğu dizini `pwd` komutu
ile öğrenmiş olduk.

Bence artık `pwd` komutunun işlevi tam olarak anlaşılmıştır. Komut
satırı arayüzündeyken hangi dizinde çalıştığınızı merak ediyorsanız
`pwd` komutunu kullanmanız yeterli.

Ayrıca `pwd` komutu dışında eğer dikkatinizi çektiyse hangi dizinde
çalıştığım aslında ismimden sonra konsolda **prompt** olarak
isimlendirilen kısmında da gözüküyor.

![10.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/10.webp)

Yani `pwd` komutunu kullanmadan da buraya bakarak, hangi dizinde
olduğunuzu öğrenebilirsiniz. Hatta bakın ilk açtığım konsolda ev dizinde
çalıştığım için ev dizinim tilde `~` işareti ile temsil ediliyor.

![11.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/11.webp)

Bu sebeple burada ben uzun uzadıya ***/home/taylan/*** dizini yerine bu
dizinle aynı anlama gelen ***\~*** işaretini görüyorum.

Aslında tıpkı çalışmakta olduğumuz dizini öğrenebildiğimiz gibi
**prompt** olarak geçen bu bölümden başka bazı bilgiler de
edinebiliyoruz. Ancak konumuzdan çok fazla uzaklaşmamak adına yeri
geldiğinde ayrıca değinmek üzere prompt konusunu şimdilik noktalayalım.
Ama aklınızda bulunsun prompt gerçekten önemli bir yapı. Tıpkı burada
bahsettiğimiz gibi gerektiğinde epey bilgi verici olabiliyor.

Konumuza dönecek olursak **prompt** üzerinde gözüken bu dosya bilgisi
her ne kadar kullanışlı olsa da her zaman buradan bilgi edinemeyeceğiniz
birkaç istisnai durum var. Öncelikle bu özellik her sistemde **prompt**
için konfigüre edilmemiş olabilir. Bunun haricinde çalıştığınız dizin
adresi çok uzun olduğu için komut satırında doğru şekilde
görüntülenemiyor da olabilir.

Dolayısıyla her ne kadar **promptta** yer alan, çalışmakta olduğumuz
dizinin bilgisi faydalı olsa da, çalıştığımız dizin hakkında en okunaklı
bilgiyi çoğunlukla yine `pwd` komutu sayesinde ediniyoruz.

`cd` Komutu
-----------

Dizinlerde gezinmek için İngilizce "**c**hange **d**irectory" yani
"dizini değiştirme" ifadesinin kısaltmasından gelen `cd` komutunu
kullanabiliyoruz. Dizin değiştirmek için tek yapmamız gereken `cd`
komutundan sonra gitmek istediğimiz dizinin tam adresini belirtmek.

Öncelikle bulunduğumuz dizini öğrenmek için `pwd` komutunu
kullanabiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan
```

Ben şu an kendi ev dizinim olan ***/home/taylan*** dizininde
bulunuyorum. Şimdi bir de bu dizinde hangi dosya ve klasörler var diye
`ls` komutu ile kontrol edelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls
Desktop    Music     Templates
Documents  Pictures  Videos
Downloads  Public    yeni-klasor
```

Bakın burada `ls` komutu sayesinde elde ettiğim çıktı, benim mevcut
bulunduğum dizinin içeriği. Ben "***Desktop***" klasörüne geçiş yapmak
için `cd Desktop` şeklinde komutumu girip, dizin değişimini teyit etmek
için de `pwd` komutunu kullanıyorum .

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd Desktop/

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                  
/home/taylan/Desktop
```

`pwd` komutunu kullanarak veya doğrudan prompt üzerindeki bilgi ile de
teyit edebildiğimiz üzere bakın şu an ***Desktop*** dizinine geçiş
yapmış bulunuyorum. Örnek üzerinden gördüğünüz gibi, mevcut bulunduğumuz
dizin içerisindeki bir klasörlere geçiş yapmak için yalnızca ilgili
klasörün ismini yazmamız yeterli oldu. Yani ben ev dizinimdeydim, ev
dizini içerisinde ***Desktop*** klasörü bulunuyordu. Bu sebeple yalnızca
`cd Desktop` komutu ile ***Desktop*** klasörüne kolayca geçiş
yapabildim. Yani **yalnızca klasörün ismini yazarak geçiş yapmak için
zaten halihazırda o klasörün bulunduğu dizinde olmamız gerekiyor**. İşte
bu kullanıma "relative path" yani "göreli yol" deniyor. Buradaki "göreli
yol" ifadesi, yalnızca bulunduğunuz dizinden itibaren geçerli olan yolu
tasvir ediyor.

Geçiş yapmak istediğim klasör mevcut çalışmakta olduğum dizin içinde
bulunmuyorsa, bu klasörün dosya sistemi hiyerarşisindeki tam dizin
adresini belirtmek zorundayım. Örneğin ben ana(***/***) dizindeki
***etc*** dizini altında yer alan ***apt*** klasörüne gitmek istiyorsam
`cd` komutunun ardından ***/etc/apt*** dizin adresini tam olarak girmem
gerekiyor. Burada ilk girdiğim slash "***/***" kök dizinini yani ana
dizini temsil ederken, ***etc*** ile ***apt*** arasında yer alan ikinci
slash "***/***" işareti ise ***etc*** dizini altındaki ***apt***
klasörüne geçiş yapılması gerektiğini belirtiyor. İlk slash işaretinden
sonraki slash işaretleri, dizin isimlerini birbirinden ayırmak için
kullandığımız bir sembol.

![12.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/12.webp)

Hemen geçiş yapmak için komutumuzu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd /etc/apt  

┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ pwd
/etc/apt
```

Prompta bakarak ve pwd komutu ile dizini değiştirdiğimizi de teyit etmiş
olduk. Yani ben şu anda ***etc*** dizini altındaki ***apt*** klasöründe
bulunuyorum. Peki bu dizine bir anda nasıl atlayabildik ? Tabii ki
ilgili dizinin tam adresini belirterek.

İlgili dizinin tam adresini verdiğim için kabuk tek seferde sorunsuzca
ilgili dizini bulup geçiş yapabildi. Buradaki tam adresten kastım,
sistem üzerindeki tüm dizinler **kök("*/"*) dizininden başladığı** için
kök dizini de dahil ederek ilgili dizine giden yolun tüm bilgisini adım
adım sunmak. Bu şekilde belirtilen dizin adreslerine de "absolute path"
yani "kesin yol" deniyor.

Göreli yol bulunduğumuz dizinden itibaren geçerli olan adresin tarif
edilmesiyken, kesin yol ilgili adresin dosya sistemi hiyerarşisinin en
tepe noktasından başlanarak eksiksizce tarif edilmesiyle oluyor.

Dizinler arasında gezinirken en çok dikkat etmeniz gereken detay bu
göreli ve kesin yol kavramları. Zaten anlaşılması sön derece kolay. Hadi
emin olmak için benzer örneği yanlış şekilde tekrar ele alalım. Daha
önce ben kendi ev dizinimde olduğum için yalnızca `cd Desktop` komutunu
girerek kendi masaüstü klasörüme geçiş yapmıştım. Şimdi aynı komutu
***apt*** dizini içindeyken girip yine masaüstüme geçiş yapmayı
deneyebilirim.

``` {.css}
┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ cd Desktop
bash: cd: Desktop: No such file or directory
```

Bakın böyle bir dosya veya klasör bulunmuyor diye hata aldık çünkü
gerçekten de bulunduğumuz ***apt*** klasörü içinde ***Desktop*** isminde
bir klasör bulunmuyor. Bu durumu `ls` komutu ile teyit edebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[/etc/apt]                            
└─$ ls                                               
apt.conf.d     sources.list    trusted.gpg.d             
auth.conf.d    sources.list~
preferences.d  sources.list.d
```

Ben bu ***etc*** dizini atlındaki ***apt*** klasöründeyken göreli
şekilde yani `cd Desktop` şeklinde komutumu girdiğimde, kabuk mevcut
dizindeki ***Desktop*** isimli klasöre geçiş yapmak istediğimi düşünüyor
ancak bu dizinde bu isimde bir klasör bulunmadığı için doğal olarak hata
veriyor.

Şimdi aynı komutu bu kez kendi ev dizinimdeki ***Desktop*** klasörünün
tam dizin adresini belirtecek şekilde yani kesin yolunu belirtecek
şekilde de girmeyi deneyebilirim.

``` {.swift}
┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ cd /home/taylan/Desktop/                               

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                                  
/home/taylan/Desktop
```

Bakın kesin yolu belirterek, şu anda hangi dizinde çalıştığım fark
etmeksizin gitmek istediğim Desktop dizinine komut satırı üzerinden de
sorunsuzca erişebildim.

Neticede bizzat örnekler üzerinden de teyit ettiğimiz gibi eğer geçiş
yapmak istediğiniz klasör çalışmakta olduğunuz mevcut dizinde
bulunmuyorsa, ilgili klasörün **tam dizin adresini** yani kesin yolunu
kök dizinden itibaren belirtmeniz gerekiyor. Eğer geçiş yapacağınız
klasör zaten kabuğun halihazırda çalışmakta olduğu dizinin içinde veya
altında bulunuyorsa o zaman göreli konumu kullanabilirsiniz. Göreli
konum belirtirken dizin adresinin en başına slash işaretini eklememiz
gerekmiyor çünkü **en baştaki slash işareti kök dizine gidilmesi,**
oradan diğer dizinlere geçiş yapılması gerektiği anlamına geliyor.

Örneğin ben tekrar ev dizinime dönmek için `cd /home/taylan/` şeklinde
komutumu girebilirim. Ancak ev dizinindeyken örneğin ***Desktop***
isimli klasöre geçiş yapmak için `cd /Desktop` şeklinde komut giremem.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ cd /home/taylan/                                       

┌──(taylan@linuxdersleri)-[~]
└─$ cd /Desktop                                          
bash: cd: /Desktop: No such file or directory
```

Böyle bir dosya veya dizin yok şeklinde hata alıyoruz çünkü bu
komutumuzla, öncelikle kök("***/***") dizine gitmemiz gerektiğini oradan
da ***Desktop*** isimli klasöre geçiş yapılması gerektiğini belirtmiş
oluyoruz. Ancak kök dizin altında "Desktop" isimli bir klasör
bulunmuyor.

`cd /Desktop` komutu yerine mevcut bulunduğumuz dizin altındaki
***Desktop*** klasörüne geçmek için yalnızca komutumuzu en başta slash
olmadan yani `cd Desktop` şeklinde girmemiz yeterli.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd /Desktop
bash: cd: /Desktop: No such file or directory

┌──(taylan@linuxdersleri)-[~]
└─$ cd Desktop                                          

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                                  
/home/taylan/Desktop
```

Yani, olay tamamen o anda hangi dizinde olduğunuz ve hangi dizine geçiş
yapmak istediğinizle ilgili. Kabuk sihirli bir biçimde gitmek
istediğiniz dizini kendi kendine bilemeyeceği için o anda bulunduğunuz
ve gitmek istediğiniz dizinlere göre uygun şekilde komut girmeniz
gerekiyor. Gitmek istediğiniz dizin, mevcut bulunduğunuz dizinde veya
altındaysa bu durumda başta slash işareti olmadan göreli yolu
belirtmeniz gerekiyor. Eğer gitmek istediğiniz dizin sizin o an
çalışmakta olduğunuz dizinin içinde değilse, o dizine giden kesin yolu
belirtmek için başta slash işareti ile ana dizinden başlayıp o dizine
kadar giden tüm yolu belirtmeniz gerekiyor.

Bu açıklamaları yapıp göreli ve kesin yol üzerinde özellikle duruyorum
çünkü yeni başlayan çoğu kullanıcı kesin yol için tam dizin adresi
belirtirken kök dizinini temsil eden en baştaki slash işaretini
unutabiliyor. Ya da tersi şekilde mevcut bulunduğu dizin altındaki bir
klasöre geçiş için en başta slash ekleyip ilgili dizinin kök dizini
altında olmamasına rağmen kök dizinde aranmasına sebep olabiliyor.
Neticede kabuğa doğru adres tarif edilmezse, kabuk da doğru dizini bulup
geçiş yapamıyor. Gerçek dünyadaki yol tarifleri gibi düşünün, yanlış yol
tarifiyle doğru adrese gitmemiz mümkün değil. Lütfen bu detaya dikkat
edin. Benim anlatımlarımla sınırlı kalmayın mutlaka bu konuda pratik
yapın. Zaten pratik yaptığınızda kesin yol ve göreli yol kavramını net
biçimde kavrayacaksınız çünkü benim anlattığımdan çok daha kolay bir
konu aslında. Yani uygulamak, anlatmaktan çok daha kolay. Tek
ihtiyacınız bizzat pratik yapıp işleyişi kavramak.

Neticede komut satırı üzerinden dizinlerde gezinmek için cd komutunu
kullanabildiğimizi öğrendik. Biz en temel kullanım biçimini ele aldık
fakat söz konusu komut satırı üzerinde rahatlıkla gezinebilmek olduğu
için `cd` komutunun bize pek çok kolaylıkla sağlayan esnek özellikleri
de bulunuyor.

Üst Dizine Geçiş
----------------

Bir üst dizine dönmek için `cd ..` komutunu kullanabiliyoruz.

``` {.bash}
└─$ pwd
/home/taylan/Desktop

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ cd ..

┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan
```

`pwd` komutu ile de teyit edebildiğimiz gibi `cd ..` komutunu kullanarak
bir üstteki dizine geçiş yapabiliyoruz.

Kabuk için tek nokta `.` karakteri **mevcut dizini** temsil ederken, iki
nokta `..` işareti ise **bir üst dizini** temsil ediyor. Yani iki nokta
kullandığınızda kabuk bir üst dizini kastettiğinizi anlıyor.

Bu komut yerine bir üst dizine dönmek için `cd /home/taylan/` komutunu
da kullanabildim ancak gördüğünüz gibi bu kadar zahmete hiç gerek yok.
İki nokta sayesinde bir üst dizini otomatik olarak belirtebiliyorum
zaten.

Üstelik tek tek `cd ..` komutunu kullanmak yerine tek seferde, gidilecek
daha üst dizinleri de belirtebiliriz. Ben iki üst dizine dönmek için
`cd ../../` komutunu giriyorum.

``` {.bash}
└─$ pwd
/home/taylan

┌──(taylan@linuxdersleri)-[~]
└─$ cd ../../

┌──(taylan@linuxdersleri)-[/]
└─$ pwd
/
```

Gördüğünüz gibi, iki üst dizine dönmek için peşi sıra slash işaretleri
ile ayırarak iki nokta karakterlerini yazmamız yeterli oldu.

Buradaki ilk iki nokta beni ***taylan*** dizininden çıkardı, ikinci iki
nokta, ***home*** dizininden çıkardı. Neticede kök dizine ulaşmış oldum.
Tıpkı iç içe olan dizinlere geçiş yaparken dizin isimlerini ayırmak için
belirttiğimiz gibi tek yapmamız gereken peşi sıra iki nokta karakterini
kullanırken üst dizinlere geçiş yapmak istediğimizin anlaşılması için bu
iki nokta karakteri arasında slash işaretini belirtmek.

Ayrıca bir üst dizine gidip, başka bir dizine geçiş de yapabiliriz.
Örnek gösterebilmek için önce `cd /home/taylan/Downloads` komutu ile
dizine geçiş yapalım.

``` {.swift}
┌──(taylan@linuxdersleri)-[/]
└─$ cd /home/taylan/Downloads/

┌──(taylan@linuxdersleri)-[~/Downloads]
└─$ pwd
/home/taylan/Downloads
```

Ben bu dizinden bir üst dizine dönmek, oradan da Desktop isimli klasöre
geçiş yapmak istiyorum. Normalde eğer kesin yolu belirtecek olsak,
`cd /home/taylan/Desktop` şeklinde uzun uzadıya yazmamız gerek ancak
bunun yerine `cd ../Desktop` komutunu da kullanabiliriz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~/Downloads]
└─$ pwd
/home/taylan/Downloads

┌──(taylan@linuxdersleri)-[~/Downloads]
└─$ cd ../Desktop/                                       

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                                  
/home/taylan/Desktop
```

Burada girmiş olduğumuz `cd ../Desktop/` komutu ile, kabuğa "mevcut
bulunduğun dizinden bir üst dizine dön, oradan da ***Desktop*** isimli
klasöre geçiş yap" demiş oluyoruz. Bakın aslında bu da göreli bir yol.
Neticede bir üst dizinde ***Desktop*** klasörünün yer aldığını
bildiğimiz için mevcut bulunduğumuz konumdan iki nokta işareti ile bir
üst dizine döndük, daha sonra slash işaretinin ardından yazdığımız için
***Desktop*** isimli klasöre de geçiş yapabildik.

Zaten komutlarınızı girerken dosya sistemindeki dizinlerin iç içe
klasörlerden oluştuğunun bilincinde olduğunuz sürece üst veya alt
dizinde olma duruma göre uygun komutu kolaylıkla verebilirsiniz.

Dizinler arası geçiş biçimi tamamen sizin ihtiyaçlarınıza göre
şekillenecektir. Tek yapmanız gereken bildiklerinizi harmanlayıp
kullanmak. Bu noktada elbette kesin yol ve göreli yol kavramını iyi bir
biçimde anlamış olmanız gerekiyor. Eğer anladıysanız zaten dizinler
arasında son derece esnek yöntemlerle gezinebilirsiniz.

Bir Önceki Dizine Dönüş
-----------------------

Komut satırı üzerinden işlerimizi hallerken kimi zaman birbirinden çok
uzak dizinler arasında hızlıca geçiş yapmak isteyebiliriz. Bu durumda en
son bulunduğumuz bir önceki dizine doğrudan atlamak için `cd -` komutunu
kullanabiliyoruz.

Hemen uygulamalı olarak görmek için öncelikle `cd /etc/apt` komutu ile
geçiş yapalım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd /etc/apt

┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ pwd
/etc/apt
```

Siz dilediğiniz bir dizine geçiş yapabilirsiniz. Ben şu anda
***/etc/apt*** dizinindeyim. Buradan da cd /home/taylan/Desktop komutu
ile ev dizinimdeki masaüstü dizinine geçiş yapıyorum.

``` {.swift}
┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ cd /home/taylan/Desktop/

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd
/home/taylan/Desktop
```

Şu anda da ***Desktop*** dizinindeyim gördüğünüz gibi. Eğer bir önceki
bulunduğum dizine yani ***/etc/apt*** dizinine dönmek istersem
`cd /etc/apt` ya da yalnızca `cd -` komutunu kullanabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ cd -
/etc/apt

┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ pwd                                                  
/etc/apt
```

Bakın bir önceki çalıştığım dizine tek seferde geçiş yaptım ve geçiş
yaptığım dizin de konsola basıldı. Tekrar deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ cd -                                                 
/home/taylan/Desktop

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                                  
/home/taylan/Desktop
```

Bakın kısacık bir komut ile bir önceki dizin adresine anında
atlayabiliyorum ve atlama işlemini kolay takip edebilmem için geçiş
yaptığım dizin konsola da bastırılıyor. Bence müthiş bir kolaylık.

Kabuk, her zaman bir önceki dizinin adres bilgisini tuttuğu için bu
şekilde çalışmakta olduğumuz bir önceki dizine `cd -` komutu ile hızlıca
geçiş yapabiliyoruz. Bu komut özellikle, iki dizin arasında gidip
geliyorken işlerimizi inanılmaz kolaylaştırıyor. Neticede uzun uzadıya
önceki çalıştığımız dizini yazmamıza veya dizinin tam yolunu
hatırlamamıza gerek kalmıyor. Bu özellik, dosya yöneticisi ile
dizinlerde gezinmekten yani grafiksel arayüz kullanımından bile çok daha
pratik bir gezinti deneyimi sağlıyor, haksız mıyım ?

Hazır daha iyi bir gezinti deneyiminden ve pratiklikten bahsetmişken
tabii ki otomatik tamamlama nimetlerinden bahsetmesek olmaz.

Otomatik Tamamlamadan Faydalanmak
---------------------------------

Daha önce kısayollar bölümünde bahsettiğimiz otomatik tamamlama özelliği
sayesinde geçiş yapabileceğimiz dizin isimlerinin otomatik olarak
tamamlanmasını da sağlayabiliriz.

Örneğin ben `cd /home/taylan/` komutunu yazdıktan sonra iki kez tab
tuşuna basarsam, ***taylan*** dizini içerisinde yer alan geçiş
yapabileceğim olası dizinler listelenir.

![13.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/13.gif)

Gitmek istediğim dizinin birazını yazıp örneğin **De** yazıp tekrar tab
tuşuna basarsam bulunduğum dizinde bu ifadeyle başlayan yalnızca
***Desktop*** klasörü bulunduğu için, klasör ismi otomatik olarak
"**Desktop"'a** tamamlanacaktır.

![14.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/14.gif)

Benzer şekilde örneğin `cd /` yazıp iki kez tab tuşuna basarsak ana
dizin altında bulunan gidilebilecek olası tüm dizinler yani klasörler
listelenecektir.

![15.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/15.gif)

Bizzat gördüğümüz gibi tab ile tamamlama işlevi, yalnızca ilgili dizinin
içinde bulunan diğer dizinleri karşımıza getiriyor. Zaten mantıken
olması gereken de bu. Dolayısıyla bir kısmını yazdığınız dizin adresine
göre, size sunulacak tamamlama önerileri de otomatik olarak değişiyor.

![16.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/16.gif)

Özetle, otomatik tamamlama özelliği sayesinde seçeneklerimizi
görebiliyor ve gerektiğinde uzun uzadıya yazmadan otomatik olarak
tamamlanmasını sağlayabiliyoruz.

Ev Dizini Kısayolu
------------------

Hatırlıyorsanız daha önce de tilde `~` işaretinin **mevcut kullanıcının
ev dizinini** temsil ettiğini belirtmiştik. Şimdi bu durumu uygulamalı
olarak tekrar `cd` komut üzerinden de teyit edebiliriz. Örneğin ben
kendi ev dizinime geçiş yapmak istediğimde `cd /home/kullanıcı-adım`
yani benim durumumda `cd /home/taylan/` şeklinde komut girmem gerekiyor.
Ancak aslında bu şekilde uzun uzadıya kendi ev dizinimi belirtmem de
şart değil. Bunun yerine yalnızca `cd ~` komutunu kullandığımda zaten
buradaki tilde işareti otomatik olarak benim ev dizin adresimin yerine
geçiyor olacak. Eğer tilde işaretini nasıl oluşturabileceğinizi
bilmiyorsanız tilde işaretini oluşturmak için klavyenizden AltGR + Ü
tuşlarına aynı anda basmanız yeterli.

Ben teyit edebilmek için öncelikle `cd /etc/` komutu ile ***etc***
dizine geçmek istiyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd /etc/

┌──(taylan@linuxdersleri)-[/etc]
└─$ pwd
/etc
```

Şu an ben ***etc*** dizinindeydim. Buradan kendi ev dizinime dönmek için
tek yapmam gereken `cd ~` komutunu girmek.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ cd ~

┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan
```

Bakın kendi ev dizinime doğrudan geçiş yaptım. Bunu hem `pwd` komutunun
çıktısında hem de prompt bölümündeki tilde **\~** işareti ile teyit
edebiliyorum.

Ayrıca ben burada tilde işaretini tek başına kullandım ama aslında tilde
işaretini tek başına kullanıp yalnızca ev dizinine geçiş için kullanmak
zorunda da değiliz. Ev dizinimiz altında yer alan dizinlere kolayca
geçiş yapmak için de tilde işaretini kullanabiliyoruz. Örneğin ben kendi
ev dizinimdeki Desktop klasörüne geçiş yapmak istersem `cd ~/Desktop`
şeklinde komut girebilirim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ cd ~/Desktop/                        

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                  
/home/taylan/Desktop
```

Ayrıca tilde kullanımı dışında eğer doğrudan ev dizinimize dönmek
istersek yalnızca `cd` komutunu girebiliriz. Test etmek için yine
`cd /etc` komutu ile ***etc*** dizine altında geçiş yapabiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ cd /etc/                             

┌──(taylan@linuxdersleri)-[/etc]
└─$ pwd                                  
/etc
```

Bakın ben şu anda ***etc*** dizininde çalışıyorum. Kendi ev dizinime
hızlıca dönmek için `cd` komutunu kullanmam yeterli.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ cd                                   

┌──(taylan@linuxdersleri)-[~]
└─$ pwd                                  
/home/taylan
```

Bakın hangi dizinde olduğum fark etmeksizin, yalnızca `cd` komutu ile
anında kendi ev dizinime dönmüş oldum. Bu da sıklıkla kullanacağımız bir
kısayol.

Belki şu an öğrendiklerinizin etkisi çok büyük gibi gelmiyor olabilir
ancak aslında burada öğrendiğiniz bilgiler ile yetkiniz olduğu sürece
tüm dosya sistemi üzerindeki dizinlerde rahatlıkla gezinebilirsiniz.
Yani öğrendikleriniz aslında komut satırı üzerindeki hakimiyetiniz için
çok değerli bilgiler. Neticede şimdiye kadar temelde `cd` komutu
hakkında bilmemiz gerekenlerden bahsettik ancak ben yine de son olarak
`cd` komutunu kullanırken dikkat etmeniz gereken birkaç detaydan daha
bahsetmek istiyorum. Çünkü yeni öğrenen kişiler tarafından cd komutu
kullanılırken bu hatalar sıklıkla yapılabiliyor.

Dikkat Edilmesi Gerekenler
--------------------------

### Göreli ve Kesin Yol

Dikkat etmenizi istediğim ilk ve bence en sık yapılan hatalardan biri
kesin yol belirtirken kök dizini belirtmek için kullandığımız en baştaki
slash işaretini unutmamanız. Daha önce en baştaki slash işaretinin kök
dizini yani ana dizini temsil ettiğini ve bu sebeple tam dizin adresi
belirtilirken unutmamanız gerektiğini birden fazla kez söylemiştim. Bu
önemli bir detay olduğu için tekrar hatırlatmak istiyorum.

![hiyerarsi.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/hiyerarsi.webp)

Anlatımın başında ele aldığımız hiyerarşik dosya sistemine tekrar
bakacak olursak zaten sistemi oluşturan tüm klasörlerin kök dizinden
başladığını görebiliyoruz. Ayrıca alt dizin ve üst dizin yaklaşımını da
net biçimde görebiliyoruz. Örneğin bakın buradaki temsilde, ali
kullanıcısının ev dizini kök dizini altındaki ***home*** klasöründe yer
alan ***ali*** isimli klasörde bulunuyor.

***home*** dizininde olan birisi için ***ali*** klasörü alt dizinken,
kök ***/*** dizin ise bir üst dizini temsil ediyor. Komutlarımızı da bu
doğrultuda girmemiz gerekiyor. Hatırlatacak olursak, mevcut bulunduğumuz
dizin tek nokta `.` işareti ile temsil ediliyorken, bir üst dizin iki
nokta `..` işareti ile temsil ediliyor.

![17.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/17.webp)

Yani örneğin ***home*** dizini içindeyken bir üst dizine dönmek için
`cd ..` şeklinde komutumuzu kullandığımızda kök dizine dönmüş oluyoruz.
Bunun dışında ***home*** dizini içinde bulunan herhangi bir klasöre yani
alt klasöre geçiş için de ilgili klasörün ismini girmemiz yeterli
oluyor. Örneğin `cd ali` komutu ile alttaki ***ali*** klasörüne kolayca
geçiş yapabiliyoruz. İşte buradaki durum göreli yola örnek. Home
dizininde yer alan birine göre ***ali*** klasörü bir alttaki dizindir
dolayısıyla yalnızca `cd ali` komutu ile bu dizine geçiş yapılabilir. Ya
da benzeri şekilde ***ali*** dizini içinde olan birisi için `cd ..`
komutu bir üst dizini yani ***home*** dizinini temsil ediyorken,
***home*** dizinindeki birisi `cd ..` komutunu girdiğimde bir üstündeki
kök dizini temsil etmiş oluyor.

![18.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/18.webp)

İşte zaten kök dizinden başlayan kesin bir yol rotası belirtmeden
girdiğimiz komutların hepsi mevcut bulunduğumuz dizine göre, gitmek
istediğimiz dizinin nerede olduğuyla ilgili. Bu sebeple bu yola göreli
yol diyoruz.

Ayrıca alt dizin ve üst dizine geçişler dışında yani göreli yol dışında,
dosya sistemi üzerinde o anda hangi dizinde olduğumuz fark etmeksizin
kök dizini kullanarak kesin dizin yolunu belirtip çok farklı
konumlardaki dizinlere ulaşmamız da mümkün. Örneğin ben ali
kullanıcısının ev dizinindeyken ***etc*** dizini atlındaki ***apt***
klasörüne geçiş yapmak istersem `cd /etc/apt` komutu ile kesin yolunu
belirterek, öncelikle kök dizine gidilmesi oradan ***etc*** dizinine
geçilmesi ve son olarak da ***apt*** klasörüne geçilmesi gerektiğini
kolayca ifade edebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan

┌──(taylan@linuxdersleri)-[~]
└─$ cd /etc/apt/

┌──(taylan@linuxdersleri)-[/etc/apt]
└─$ pwd
/etc/apt
```

Eğer komut girerken en baştaki slash işaretini atlarsam kök dizini
belirtmemiş olurum. Dolayısıyla mevcut bulunduğum dizindeki ***etc***
isimli bir klasöre oradan da ***apt*** isimli klasöre geçmek istediğim
anlaşılır.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ pwd
/home/taylan

┌──(taylan@linuxdersleri)-[~]
└─$ cd etc/apt/
bash: cd: etc/apt/: No such file or directory
```

Bu şekilde hata aldık çünkü mevcut bulunduğum(***/home/taylan/***) dizin
ile gerçekte gitmek istediğim ***etc/apt*** dizini aynı dizin kesişimine
sahip değil. Mevcut bulunduğum dizinin altında bu isimde klasörler
bulunmuyor, dolayısıyla geçiş de yapılamıyor.

Neticede buradaki basit hiyerarşik şemaya bakarak bile, hiyerarşik dosya
yapısına uygun olmayan yani gerçekte var olmayan dizin adresleri
belirttiğimizde ilgili dizine geçiş yapamayacağımızı açıkça
görebiliyoruz. Doğru komutlar girebilmek için kesin yol ve göreli yol
kavramını anlayana kadar kendi kendinize alıştırmalar yapın lütfen.

### Boşluk ve Özel Karakter Kullanımı

Sık yapılan hatalardan bir diğer ise, dosya ve dizin isimlerindeki
boşluklar ve özel karakterlerin kullanımı. Daha önce kabuğun nasıl
çalıştığından bahsederken kabuğun, girilen komuttaki boşluk
karakterlerinden komutu ayrı ayrı argümanlara ayırdığından ve kabuk için
özel anlam ifade eden karakteri de özel olarak ele aldığından
bahsetmiştik. Eğer komut girerken bir dosya veya klasör isminde boşluk
karakteri veya kabuk için özel anlam ifade eden özel bir karakter varsa
kabuk bizim girdiğimiz komutu yanlış anlayabiliyor.

Bu sebeple isminde özel karakterler veya boşluklar içeren klasörlerin
doğru algılanabilmesi için klasör isimlerini tırnak içinde yazmamız
gerekiyor. Ben basit bir örnek olması için isminde boşluk bulunan bir
klasör oluşturacağım. Klasör oluşturmak için ileride ayrıca ele
alacağımız `mkdir` komutunu kullanabiliriz. `mkdir` komutunun ardından
tırnak içinde klasörün adını `‘yeni klasor'` şeklinde yazalım ve `ls`
komutu ile klasörün varlığını da teyit edelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir 'yeni klasor'

┌──(taylan@linuxdersleri)-[~]
└─$ ls
 Desktop     Music      Templates      yeni-klasor
 Documents   Pictures   Videos
 Downloads   Public    'yeni klasor'
```

Bakın "***yeni klasor***" isimli klasör oluşturulmuş. Eğer komutumuzu
`mkdir 'yeni klasor'` şeklinde tırnak içinde girmeseydik, argümanlar
arasındaki boşluktan dolayı "***yeni***" ve "***klasor***" isimli iki
ayrı klasör oluşacaktı. Bu durumu teyit etmek için `mkdir yeni klasor`
şeklinde komutumuzu girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir yeni klasor

┌──(taylan@linuxdersleri)-[~]
└─$ ls
 Desktop     klasor     Public      yeni              
 Documents   Music      Templates  'yeni klasor'      
 Downloads   Pictures   Videos      yeni-klasor
```

Tırnak kullanmadığımız için aradaki boşluk karakteri dolayısıyla iki
ayrı argüman olarak algılanan "yeni" ve "klasor" isimli iki ayrı klasör
oluşturuldu.

İşte bizzat klasör oluşturma aşamasında gözlemediğimiz bu durum, aslında
dizinlerde gezinirken de bizzat geçerli. Eğer geçiş yapmak istediğimiz
klasör isminde boşluk veya özel bir karakter varsa, bu klasör ismini
mutlaka tırnak içinde özel olarak belirtmemiz gerekiyor. Burada dikkat
etmeniz gereken detay tek tırnak kullanmanızdır. Aslında bu örnek için
çift tırnak kullansak da sorun yaşamazdık ancak size önerim içerisinde
boşluk veya özel karakter barından komutlarınızda bu komutların özel
anlamının tamamen görmezden gelinmesi için tek tırnak içinde
yazmanızdır. Neden tek tırnak kullanmamız gerektiğini "kabuk
genişletmeleri" bölümünde ayrıca ele alacağız.

Örneğimize dönecek olursak neticede isminde boşluk karakteri bulunan
klasör çalışmakta olduğum dizinde oluşturuldu. Bu dizine geçiş yapmak
için `cd yeni klasor` şeklinde komut girmeyi deneyebiliriz.

``` {.css}
┌──(taylan@linuxdersleri)-[~]                                    
└─$ cd yeni klasor                                    
bash: cd: too many arguments
```

Bakın "çok fazla argüman" hatası aldık çünkü girmiş olduğumuz komuttaki
boşluk karakteri dolayısıyla `cd` aracına hem "***yeni***" hem de
"***klasor***" isimli iki ayrı dizine geçiş yapması gerektiğini söylemiş
olduk. Bunun yerine isminde boşluk karakteri bulunan dizine geçiş için
tek tırnak içinde ilgili klasörün tam adını yazmamız gerek.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd 'yeni klasor'

┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ pwd                                               
/home/taylan/yeni klasor
```

Bakın isminde boşluk olan dizine geçiş yapabildik. Kullandığımız
tırnaklar sayesinde girdiğimiz "**yeni klasor**" ifadesi kabuk
tarafından tek bir argüman olarak algılanıp ilgili klasöre başarılı
şekilde geçiş yapıldı. Bu örneğimizle birlikte kabuğun çalışma yapısını
tekrar hatırlayıp, içinde boşluk ya da kabuk tarafından farklı
algılanabilecek özel karakterler olan klasörlerin tırnak içinde tek bir
argüman olarak yazılması gerektiğini de öğrenmiş olduk.

Boşluk karakterine örnek verdik bir de özel karaktere örnek verecek
olursak, mesela değişken çağırırken kullandığımız dolar işaretini
kullanabiliriz. Normalde sizin de bildiğiniz gibi kabuk dolar işaretini
gördüğünde bu işaretin yanındaki ifadeyi değişken olarak kabul ediyor.
Yani dosya isminde dolar işareti olursa kabuk dosya ismini doğru şekilde
algılayamayabilir. Ben denemek için `mkdir 'ben$klasor'` şeklinde
komutumu giriyorum. Burada tek tırnak kullanmak önemli. Tek tırnak
içinde yazdığımızda kabuğun bu tırnak içindeki tüm ifadelerin özel
anlamlarını görmezden gelmesini sağlamış oluruz. `ls` komutu ile mevcut
dizindeki dosya ve klasörleri listeleyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ mkdir 'ben$klasor'

┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ ls                                                
'ben$klasor'
```

Bakın tam olarak tek tırnak içinde belirttiğim isimde yeni klasörüm
oluşturulmuş.

Şimdi test etmek için içerisinde özel karakter olan bu klasöre geçiş
yapmak üzere ismini olduğu gibi yazmayı deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ cd ben$klasor                                     
bash: cd: ben: No such file or directory
```

Bakın yanıt olarak böyle bir dosya ya da dizin olmadığı konusunda
uyarıldık. Hata aldık çünkü kabuk buradaki dolar işaretinin, klasör
isminin bir parçası olduğunu bilmiyor. Dolar işaretini gördüğü için
dolar işaretinden sonraki kısmı değişken olarak dikkate alıyor.

İşte bizim bu noktada klasörün isminin kabuk tarafından sıradan bir
argüman olarak anlaşılabilmesi için tek tırnak kullanmamız gerekiyor.
Yani aslında tek tırnak ile bu argümanı kabuk için sıradan hale
getirmemiz gerekiyor. Eğer çift tırnağın işe yarayacağını düşünüyorsanız
klasör ismini çift tırnak içinde de belirtebilirsiniz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ cd "ben$klasor"
bash: cd: ben: No such file or directory
```

Ancak gördüğünüz gibi çift tırnak işe yaramadı. Çünkü kabuk, çift
tırnağın içindeki bazı özel sembolleri de dikkate alıyor. Son olarak tek
tırnak ile klasörün ismini belirtmeyi deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ cd 'ben$klasor'

┌──(taylan@linuxdersleri)-[~/yeni klasor/ben$klasor]
└─$ pwd                                               
/home/taylan/yeni klasor/ben$klasor
```

Bakın klasöre sorunsuzca geçiş yapabildik. Çünkü tek tırnak işareti
sayesinde kabuk, dolar işaretinin özel anlamını görmezden gelerek dolar
işaretini yalnızca klasörün isminde geçen standart bir karakter olarak
gördü. Dolayısıyla kabuk buradaki argümana herhangi bir müdahalede
bulunmadan olduğu gibi `cd` komutuna aktardı. `cd` aracı da aldığı
argüman doğrultusunda bu dizine geçiş yapabilmemizi sağladı.

Bizzat birkaç kez teyit ettiğimiz gibi tek tırnak işareti bizim sorumuzu
gayet iyi çözüyor ancak belki tek tırnak kullanımı size o kadar da
konforlu gelmemiş olabilir. Bu durumda tüm ifadeyi tırnak içinde yazmak
yerine kabuk için özel olan herhangi bir karakterin kabuk tarafından
görmezden gelinmesi için ilgili özel karakterden hemen önce ters slash
`\` işaretini de kullanabiliriz. Ters slash işareti, bash için **kaçış
karakteri** anlamına geliyor ve dolayısıyla bash kabuğu bu karakteri
gördüğünde bu karakterden sonraki karakterin özel anlamını görmezden
geliyor. Yani örneğin ben `cd ~/yeni\ klasor` şeklinde komutumu
girersem, kabuk ters slash işaretinden sonraki boşluk karakterini
görmezden geliyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor/ben$klasor]
└─$ cd ~/yeni\ klasor                                 

┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ pwd                                               
/home/taylan/yeni klasor
```

Normalde sizin de bildiğiniz gibi kabuk için boşluk karakteri
argümanları ayırmayı sağlıyor yani özel bir anlam ifade ediyor. Fakat
girdiğim komutta boşluk karakterinden hemen önce ters slash `\` işareti
kullanıldığı için kabuk, boşluk karakterinin özel anlamını görmezden
gelip, onu standart bir karakter olarak ele aldı. Bu sayede isminde
boşluk karakteri bulunan klasöre sorunsuzca geçiş yapabildik. Aynı
yöntemi dolar işaretli klasör üzerinde de aynen deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ cd ben\$klasor/

┌──(taylan@linuxdersleri)-[~/yeni klasor/ben$klasor]
└─$ pwd                                               
/home/taylan/yeni klasor/ben$klasor
```

Bakın ters slash yani kaçış karakteri sayesinde dolar işaretinin özel
anlamı kabuk tarafından görmezden gelindi ve neticede sorunsuzca bu
dizine de geçiş yapabildik.

Görebildiğiniz gibi tek bir karakterin görmezden gelinmesi gerekiyorsa
kolayca ters slash işaretini kullanabiliyoruz. Ben örnekler sırasında
tek bir noktada bu karakteri kullandım ancak gerekiyorsa, görmezden
gelinmesi gereken tüm karakterlerden önce bu ters slash işaretini tekrar
tekrar kullanabilirsiniz. Örneğin ben "***bu bir deneme metnidir***"
isminde bir klasör oluşturmak istersem komutumu
`mkdir bu\ bir\ deneme\ metnidir` şeklinde girebilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir bu\ bir\ deneme\ metnidir

┌──(taylan@linuxdersleri)-[~]
└─$ ls
'bu bir deneme metnidir'   Music       yeni
 Desktop                   Pictures   'yeni klasor'
 Documents                 Public      yeni-klasor
 Downloads                 Templates
 klasor                    Videos
```

Burada kabuk tarafından görmezden gelinmesini istediğim tüm boşluk
karakterlerinden önce ters slash işaretini belirtmem gerekti. Şimdi yeni
oluşturduğum bu dizine geçiş yapmak için `cd` komutunda sonra bu yazıp
tab ile otomatik olarak klasör isminin tamamlanmasını sağlıyorum.

![19.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/19.gif)

Bakın burada da otomatik olarak boşluk karakterlerinden önce ters slash
karakteri ile öneri sunuldu. Komutumu onayladığımda ilgili dizine geçiş
yapabiliyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cd bu\ bir\ deneme\ metnidir/

┌──(taylan@linuxdersleri)-[~/bu bir deneme metnidir]
└─$ pwd
/home/taylan/bu bir deneme metnidir
```

Neticede örnekler üzerinden de gördüğünüz gibi ters slash kullanışlı
olsa de genelde pek okunaklı bir komut görünümü sunmadığı için genelde
tırnak içine alma daha sık tercih ediliyor. Yine de artık her iki
kullanım yönteminden de haberiniz var. Örneğin ters slash karakterini
kullanmayı tercih etmeseniz bile isminde boşluk geçen bir klasöre geçiş
yaparken tab önerisinde sunulan isimdeki ters slash işaretlerinin ne
anlama geldiğini artık biliyorsunuz.

### Küçük Büyük Harf Duyarlılığı

Hazır kabuk üzerindeki karakterlerden bahsetmişken dikkat etmemiz
gereken bir diğer önemli husus da, **Linux sisteminin küçük büyük harf
duyarlılığına sahip olduğu** gerçeği. Küçük büyük harf duyarlılığı ile
tam olarak neyi kast ediyorum ? Hemen bir örnek üzerinden açıklayalım.

Örnek olası için grafiksel arayüzde dosya yöneticisi üzerinden isimleri
aynı olan ama küçük büyük harfleri farklı olan klasörler oluşturmayı
deneyebiliriz. Öncelikle Linux üzerinde test edelim.

![20.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/20.gif)

Bakın küçük büyük harfleri farklı ama birebir aynı isimli birden fazla
klasörü oluşturabildik. Çünkü Linux için küçük büyük harfleri
dolayısıyla her biri ayrı bir klasör.

Aynı işlemi Windows sisteminde de deneyebiliriz.

![21.gif](https://www.linuxdersleri.net/egitim/temel-linux/dizin/21.gif)

Bakın ismini onayladığımızda aynı isimde başka bir klasör olduğu
konusunda uyarılıyoruz. Çünkü Windows üzerinde küçük büyük harf
duyarlılığı bulunmuyor. Windows sistemine göre hepsi aynı.

İşte bakın Windows üzerinden ele aldığımız bu örnek, Linux sisteminin
sahip olduğu küçük büyük harf duyarlılığını kanıtlıyor. Çünkü biraz önce
Linux'ta küçük büyük harfleri farklı olan aynı isimli birden fazla
klasörü sorunsuzca oluşturabildik. Linux için klasör isimleri
içerdikleri küçük büyük harf farkları dolayısıyla benzersiz birer
klasördür. İşte harf duyarlılığı olduğu için oluşturma aşamasında olduğu
gibi klasöre geçiş aşamasında da elbette klasörün küçük büyük harfli
karakterlerine dikkat ederek doğru adını girmemiz gerekiyor.

Örneğin ben tamamı büyük harflerle yazılmış olan ***DOSYA\_ADI***
klasörüne gitmek istersem `cd ~/DOSYA_ADI` yazmam gerekiyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ls
'bu bir deneme metnidir'   Downloads   Videos
 Desktop                   klasor      yeni
 Documents                 Music      'yeni klasor'
 DOSYA_ADI                 Pictures    yeni-klasor
 dosya_adı                 Public
 Dosya_adı                 Templates

┌──(taylan@linuxdersleri)-[~]
└─$ cd DOSYA_ADI

┌──(taylan@linuxdersleri)-[~/DOSYA_ADI]
└─$ pwd
/home/taylan/DOSYA_ADI
```

Bakın tamamı küçük harfli olan "***dosya\_adı***" ve yalnızca başlangıç
karakteri büyük olan "***Dosya\_adı***" klasörlerine değil doğrudan
tamamı büyük harflerden oluşan "***DOSYA\_ADI***" isimli klasöre
sorunsuzca geçiş yapabildim. Bizzat bu örnek üzerinden de teyit
edebildiğimiz gibi Linux üzerindeki küçük büyük harf duyarlılığı
sebebiyle kabuğa komutlar girerken girdiğimiz tüm komutlarda küçük büyük
harf duyarlılığa dikkat etmemiz gerekiyor.

Örneğin `cd ~/desktop` yazarsam, ev dizinimde küçük harfle başlayan
***desktop*** isimli bir klasör olmadığı için ilgili dizine geçiş
yapamam.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/DOSYA_ADI]
└─$ cd ~/desktop
bash: cd: /home/taylan/desktop: No such file or directory
```

Aynı komutu küçük büyük harflere dikkat ederek yani `cd ~/Desktop`
şeklinde yazmam gerekiyor.

``` {.perl}
┌──(taylan@linuxdersleri)-[~/DOSYA_ADI]                                
└─$ cd ~/Desktop/

┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ pwd                                                     
/home/taylan/Desktop
```

Dizinlerde gezinirken yeni başlayan kullanıcılar sıklıkla küçük büyük
harf duyarlılığına dikkat etmediği için bu detaydan da özel olarak
bahsetmek istedim. Ayrıca elbette **küçük büyük harf duyarlılığı
yalnızca klasör isimleri için değil, tüm sistem geneli için geçerli.**
İleride ele alacağımız komutlarda ve bu komutlara vereceğimiz seçenek ve
argümanlarda da küçük büyük harf duyarlılığa dikkat ederek komut giriyor
olacağız. Aksi halde doğru komutları girmemiş oluruz. Örneğin ev
dizinimdeki ***Documents*** klasörüne geçiş yapmak için `cd` komutunu
büyük yazıp `CD ~/Documents` şeklinde komut girmeyi deneyebilirim.

``` {.css}
┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ CD ~/Documents/
CD: command not found
```

Bakın böyle bir komut bulunamadığı konusunda uyarıldık. Çünkü gerçekten
de bash yerleşik kabuklarında veya **PATH** dizini üzerindeki herhangi
bir dizinde tamamı büyük harflerden oluşan **CD** ismi geçmiyor. Aynı
örneğin `cd ~/Documents` şeklinde tekrar deneyebiliriz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~/Desktop]
└─$ cd ~/Documents/

┌──(taylan@linuxdersleri)-[~/Documents]
└─$ pwd                                                     
/home/taylan/Documents
```

Dolayısıyla örneklerimiz üzerinden de bizzat tekrar tekrar teyit
ettiğimiz gibi Linux üzerinde çalışıyorken her zaman küçük büyük
harflere dikkat etmemiz gerekiyor.

Tamamdır bence dizinlerde gezinmek için bilmemiz gereken tüm detaylardan
bahsettik. Artık böylelikle sistem üzerinde yetkinizin bulunduğu tüm
dizinlerde rahatlıkla gezinebilirsiniz. Üstelik konsol kullanımına
alıştığınızda grafiksel arayüze oranla çok daha hızlı gezinebildiğinizi
kendiniz de bizzat fark edeceksiniz zaten. Bu noktada sizlerden tek
ricam dizinlerde gezinerek bol bol pratik yapmanız. Pratik yaptığınızda
konsol üzerinden dizinlerde gezinmenin ne kadar kolay olduğunu bizzat
deneyimleyeceksiniz.

`ls` Komutu
-----------

Daha önce tekrar tekrar deneyimlediğimiz gibi komut satırı üzerinden,
dizin içeriklerini listelemek için için `ls` komutunu kullanabiliyoruz.
`ls` komutu İngilizce "**l**i**s**t" yani "liste-listelemek" ifadesinin
kısaltmasından geliyor. En yalın kullanımı, mevcut dizindeki içerikleri
listelememizi sağlıyor.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls
'bu bir deneme metnidir'   Downloads   Videos
 Desktop                   klasor      yeni
 Documents                 Music      'yeni klasor'
 DOSYA_ADI                 Pictures    yeni-klasor
 dosya_adı                 Public
 Dosya_adı                 Template
```

Bakın bulunduğum dizindeki tüm dosya ve klasörler `ls` komutu sayesinde
konsola bastırdı. `ls` komutunu tek başına kullanmak yalnızca mevcut
dizindeki dosya ve klasörlerin isimlerini öğrenmek istediğimizde
faydalı. Ancak bizim dosya veya klasörler ile ilgili daha detaylı
bilgilere ihtiyacımız da olabilir. Şimdi istediğimiz detay seviyesinde
bilgi alabilmek için `ls` komutunun diğer seçenekleri ile neler
yapabileceğimizden bahsederek devam edebiliriz.

Ayrıntılı Liste Almak
---------------------

Eğer aldığımız çıktıda dosyanın veya klasörün türü, yetkileri, dosyanın
sahibi ve dosyanın oluşturulma veya değiştirilme tarihi gibi ekstra
detayları yani uzun çıktıları da istiyorsak İngilizce "**l**ong" yani
"uzun" ifadesinin kısaltmasından gelen `-l` seçeneğini kullanabiliriz.

``` {.yaml}
┌──(taylan@linuxdersleri)-[~]
└─$ ls -l
total 64
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:51 'bu bir deneme metnidir'
drwxr-xr-x 3 taylan taylan 4096 May 27 07:02  Desktop
drwxr-xr-x 4 taylan taylan 4096 Jul 18  2022  Documents
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  DOSYA_ADI
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  dosya_adı
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  Dosya_adı
drwxr-xr-x 3 taylan taylan 4096 May 26 05:36  Downloads
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  klasor
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Music
drwxr-xr-x 4 taylan taylan 4096 May 30 13:21  Pictures
drwxr-xr-x 3 taylan taylan 4096 Jun 25  2022  Public
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Templates
-rw-r--r-- 1 taylan taylan    0 Jun  4 05:06  test-dosyası
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Videos
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  yeni
drwxr-xr-x 3 taylan taylan 4096 Jun  4 03:46 'yeni klasor'
drwxr-xr-x 2 taylan taylan 4096 May 30 13:18  yeni-klasor
```

Aldığımız çıktıdaki sütunları ve bunların anlamlarını kısaca ele alacak
olursak;

En baştaki ilk karakter listelenen içeriğin tipini ifade ediyor. Örneğin
başında **d** olanlar klasörleri temsil ediyor. Buradaki **d** karakteri
İngilizce "**d**irectory" yani "dizin" ifadesinin kısaltmasından
geliyor. Başında **-** işareti olanlar ise standart dosyaları temsil
ediyor.

Hemen bu ilk karakterin yanında bulunan **rwx** gibi karakterleri
barındıran üçlü grup ise ilgili dosya veya klasörün yetkilerini temsil
ediyor. Bu konudan daha sonra detaylıca bahsedeceğiz zaten.

Yetkilerin hemen yanındaki rakamlar ise, ilgili dizinin içinde kaç
**hardlink** yani **katı linki** bulunduğunu belirtiyor. Hard link
kavramını da henüz öğrenmedik, şimdilik bu sütunun hard link sayısını
gösterdiği konusunda kulağınızı kabartmanız yeterli.

Bir sonraki sütunda, dosya ya da klasörün sahibini, onun yanındaki ise
grubunu belirtiyor. Dosyanın sahibi olan veya burada belirtilen grupta
bulunan tüm kullanıcılar dosya veya klasör üzerinde burada belirtilen
bazı yetkilere sahip oluyor. Bu kavramdan da ileride ayrıca
bahsedeceğiz.

Grubun hemen yanındaki sütun ise listelenen ögenin boyutunu bayt olarak
ifade ediyor.

Tarih bilgisi de ilgili dosya veya klasörün en son değiştirildiği tarihi
veriyor.

Ve elbette en son bölüm de klasör veya dosyanın ismini gösteriyor.

Biliyorum şimdi kısaca açıklamış olsam da buradaki çıktılar sizin için
çok da anlamlı gelmedi. Ancak merak etmeyin eğitimin devamında buradaki
tüm çıktılar sizin için de anlam ifade ediyor olacak.

Gizli Dosyaları Listelemek
--------------------------

`-l` seçeneği ile tüm ekstra detayları listelemiş olsak da, bu listede
gizli dosyalar yer almıyordu. Daha önce de kısaca bahsettiğimiz gibi
Linux sisteminde, başında nokta bulunan dosya veya klasörler gizli
statüsüne oluyor. Dolayısıyla biz özellikle belirtmediğimiz sürece gizli
dosya ve klasörler listelenmiyor. Zaten dosyaların gizli olmasının
nedeni o dosyaların özellikle hedef gösterilmedikleri sürece gizli
tutulup çeşitli işlemlerden de muaf kalmalarını sağlamak. Gizleme
özelliği sayesinde istemsizce silinmesi sorun oluşturabilecek çeşitli
dosya ve klasörler bilinçsiz veya hatalı işlemlerden korumuş oluyor.

Eğer standart olanlarla birlikte gizli içerikleri de listelemek istersek
`-a` seçeneği kullanabiliriz. Bu seçenek **a**ll yani "hepsi" ifadesinin
kısalmasından geliyor. Zaten biz de standart gizli demeden hepsini
listelemek istediğimiz için all seçeneğini kullanıyoruz.

Gizli dosyaları da listeleyebildiğimizi daha net gözlemleyebilmek için
öncelikle ls daha sonra ls -a komutunu kullanıp, çıktıları
kıyaslayabiliriz.

``` {.yaml}
┌──(taylan@linuxdersleri)-[~]
└─$ ls -l
total 64
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:51 'bu bir deneme metnidir'
drwxr-xr-x 3 taylan taylan 4096 May 27 07:02  Desktop
drwxr-xr-x 4 taylan taylan 4096 Jul 18  2022  Documents
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  DOSYA_ADI
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  dosya_adı
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  Dosya_adı
drwxr-xr-x 3 taylan taylan 4096 May 26 05:36  Downloads
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  klasor
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Music
drwxr-xr-x 4 taylan taylan 4096 May 30 13:21  Pictures
drwxr-xr-x 3 taylan taylan 4096 Jun 25  2022  Public
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Templates
-rw-r--r-- 1 taylan taylan    0 Jun  4 05:06  test-dosyası
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Videos
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  yeni
drwxr-xr-x 3 taylan taylan 4096 Jun  4 03:46 'yeni klasor'
drwxr-xr-x 2 taylan taylan 4096 May 30 13:18  yeni-klasor

┌──(taylan@linuxdersleri)-[~]
└─$ ls -la
total 272                                                           
drwxr-xr-x 25 taylan taylan  4096 Jun  4 05:06  .                       
drwxr-xr-x  4 root root  4096 Jul 14  2022  ..                      
-rw-------  1 taylan taylan 38073 May 31 14:44  .bash_history                
-rw-r--r--  1 taylan taylan   220 Feb 11  2022  .bash_logout                 
-rw-r--r--  1 root root  5589 May 29 04:21  .bashrc                           
-rw-r--r--  1 taylan taylan  3526 Feb 11  2022  .bashrc.original                  
-rw-r--r--  1 taylan taylan  5552 Jun 29  2022  .bashrc.save                      
-rw-------  1 taylan taylan  5571 Jun 29  2022  .bashrc.save.1
-rw-r--r--  1 taylan taylan  5572 Jun 30  2022  .bashrc.save.2
drwxr-xr-x  2 taylan taylan  4096 Jun  4 03:51 'bu bir deneme metnidir'
drwxr-xr-x 13 taylan taylan  4096 May 29 13:49  .cache
drwxr-xr-x 16 taylan taylan  4096 Apr 24 13:16  .config
drwxr-xr-x  3 taylan taylan  4096 May 27 07:02  Desktop
-rw-r--r--  1 taylan taylan    35 Feb 11  2022  .dmrc
drwxr-xr-x  4 taylan taylan  4096 Jul 18  2022  Documents
drwxr-xr-x  2 taylan taylan  4096 Jun  4 04:07  DOSYA_ADI
drwxr-xr-x  2 taylan taylan  4096 Jun  4 04:07  dosya_adı
drwxr-xr-x  2 taylan taylan  4096 Jun  4 04:07  Dosya_adı
drwxr-xr-x  3 taylan taylan  4096 May 26 05:36  Downloads
-rw-r--r--  1 taylan taylan 11759 Feb 11  2022  .face
lrwxrwxrwx  1 taylan taylan     5 Feb 11  2022  .face.icon -> .face
-rw-r--r--  1 taylan taylan     0 Jul  9  2022  .gizli-dosya
drwxr-xr-x  2 taylan taylan  4096 Jul  9  2022  .gizli-klasor
drwx------  3 taylan taylan  4096 Feb 11  2022  .gnupg
-rw-------  1 taylan taylan     0 Feb 11  2022  .ICEauthority
drwxr-xr-x  3 taylan taylan  4096 Feb 11  2022  .java
drwxr-xr-x  2 taylan taylan  4096 Jun  4 03:28  klasor
-rw-------  1 taylan taylan   115 May 29 15:31  .lesshst
drwx------  6 taylan taylan  4096 Apr 24 08:38  .local
drwx------  5 taylan taylan  4096 Jun 18  2022  .mozilla
drwxr-xr-x  2 taylan taylan  4096 Feb 11  2022  Music
drwxr-xr-x  4 taylan taylan  4096 May 30 13:21  Pictures
-rw-r--r--  1 taylan taylan   807 Feb 11  2022  .profile
drwxr-xr-x  3 taylan taylan  4096 Jun 25  2022  Public
-rw-------  1 root root 12288 Jul  7  2022  .swp
drwxr-xr-x  2 taylan taylan  4096 Feb 11  2022  Templates
-rw-r--r--  1 taylan taylan     0 Jun  4 05:06  test-dosyası
-rw-r-----  1 taylan taylan     6 Jun  4 03:12  .vboxclient-clipboard.pid
-rw-r-----  1 taylan taylan     6 Jun  4 03:12  .vboxclient-display-svga-x11.pid
-rw-r-----  1 taylan taylan     6 Jun  4 03:12  .vboxclient-draganddrop.pid
-rw-r-----  1 taylan taylan     6 Jun  4 03:12  .vboxclient-seamless.pid
drwxr-xr-x  2 taylan taylan  4096 Feb 11  2022  Videos
-rw-r--r--  1 taylan taylan   209 Apr 24 08:34  .wget-hsts
-rw-------  1 taylan taylan    49 Jun  4 03:12  .Xauthority
-rw-------  1 taylan taylan  6665 Jun  4 03:13  .xsession-errors
-rw-------  1 taylan taylan  6617 Jun  3 03:27  .xsession-errors.old
drwxr-xr-x  2 taylan taylan  4096 Jun  4 03:28  yeni
drwxr-xr-x  3 taylan taylan  4096 Jun  4 03:46 'yeni klasor'
drwxr-xr-x  2 taylan taylan  4096 May 30 13:18  yeni-klasor
-rw-------  1 taylan taylan   260 May 24 11:11  .zsh_history
-rw-r--r--  1 taylan taylan 10875 Feb 11  2022  .zshrc
```

Bakın bu kez standart dosya ve klasörlerle birlikte isminin başında
nokta bulunan dosya ve klasörler de listelenmiş oldu. Yani aslında bu
dosya ve klasörler hep buradaydı ancak biz özellikle belirtmediğimiz
için daha önce görememiştik.

Ayrıca ben burada `ls -la` şeklinde girmiş olduğum komutu dilersem
seçeneklerin sıralamasını değiştirip `ls -al` `ls -l -a` ya da
`ls -a -l` şeklinde de girebilirim.

![22.webp](https://www.linuxdersleri.net/egitim/temel-linux/dizin/22.webp)

Görebildiğiniz gibi gizli dosya ve klasörlerin yer aldığı ayrıntılı
liste karşımıza gelmiş oldu. Yani özetle aslında komut girme ve bir
aracın çoklu özelliklerini aynı anda kullanabilme konusunda son derece
esnekliğe sahibiz. Üstelik bu durum yalnızca `ls` komutuna özgü de
değil. İstisnalar hariç pek çok komutun seçeneklerini belirtirken bu
gibi esnekliklere sahibiz zaten. Eğer kullandığınız araç, spesifik
olarak belirli bir sıralamada seçenekleri belirtmenizi istiyorsa o
şekilde belirtmelisiniz ancak genelde seçeneklerin sıralaması konusunda
esnek kullanım imkanına sahibiz. Yani nasıl rahat edecekseniz komutunuzu
o şekilde girebilirsiniz. Yeter ki eksiksiz ve doğru şekilde girin.
Elbette doğru özellikleri ve seçenekleri kullanmak için de komutların
yardım sayfalarına da mutlaka göz atın. Örneğin kimi komut
seçeneklerinin hiç uzun seçenek alternatifleri yokken kimi komutların
seçenekleri çok fazla olduğu için kısa harfle kullanılamayan yalnızca
uzun olarak yazılması gereken seçenekler de bulunabiliyor. Neyse
neticede seçenekleri belirtme konusunda esnek olduğumuzu ls komutu
üzerinden uygulamalı şekilde teyit etmiş olduk.

Boyutların Okunaklı Çıktılarını Alma,
-------------------------------------

Aldığımız çıktılardaki büyüklük birimlerini daha okunaklı şekilde elde
etmek için "**h**uman readable" yani "insan tarafından okunabilir"
ifadesinin kısaltmasından gelen `h` seçeneğini kullanabiliyoruz.

Bunun için öncelikle normalde aldığımız büyüklük cinsini görmek için
`ls -l` şeklinde komutumuzu girelim.

``` {.yaml}
┌──(taylan@linuxdersleri)-[~]
└─$ ls -l                                                                                                                                         
total 64
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:51 'bu bir deneme metnidir'
drwxr-xr-x 3 taylan taylan 4096 May 27 07:02  Desktop
drwxr-xr-x 4 taylan taylan 4096 Jul 18  2022  Documents
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  DOSYA_ADI
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  dosya_adı
drwxr-xr-x 2 taylan taylan 4096 Jun  4 04:07  Dosya_adı
drwxr-xr-x 3 taylan taylan 4096 May 26 05:36  Downloads
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  klasor
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Music
drwxr-xr-x 4 taylan taylan 4096 May 30 13:21  Pictures
drwxr-xr-x 3 taylan taylan 4096 Jun 25  2022  Public
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Templates
-rw-r--r-- 1 taylan taylan    0 Jun  4 05:06  test-dosyası
drwxr-xr-x 2 taylan taylan 4096 Feb 11  2022  Videos
drwxr-xr-x 2 taylan taylan 4096 Jun  4 03:28  yeni
drwxr-xr-x 3 taylan taylan 4096 Jun  4 03:46 'yeni klasor'
drwxr-xr-x 2 taylan taylan 4096 May 30 13:18  yeni-klasor
```

Bakın buradaki boyutlar hep bayt cinsinden. Şimdi daha okunaklı olması
için `h` seçeneğini de ekleyebiliriz. Buradaki okunaklıdan kastımız da
dosya boyutunu KB, MB, GB türünden büyüklük olarak görülebilesi.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ ls -lh                                                                                                                                        
total 64K
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 03:51 'bu bir deneme metnidir'
drwxr-xr-x 3 taylan taylan 4.0K May 27 07:02  Desktop
drwxr-xr-x 4 taylan taylan 4.0K Jul 18  2022  Documents
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 04:07  DOSYA_ADI
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 04:07  dosya_adı
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 04:07  Dosya_adı
drwxr-xr-x 3 taylan taylan 4.0K May 26 05:36  Downloads
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 03:28  klasor
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022  Music
drwxr-xr-x 4 taylan taylan 4.0K May 30 13:21  Pictures
drwxr-xr-x 3 taylan taylan 4.0K Jun 25  2022  Public
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022  Templates
-rw-r--r-- 1 taylan taylan    0 Jun  4 05:06  test-dosyası
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022  Videos
drwxr-xr-x 2 taylan taylan 4.0K Jun  4 03:28  yeni
drwxr-xr-x 3 taylan taylan 4.0K Jun  4 03:46 'yeni klasor'
drwxr-xr-x 2 taylan taylan 4.0K May 30 13:18  yeni-klasor
```

Aldığımız çıktılara bakacak olursak, daha doğrusu çıktıları
kıyasladığınızda görebileceğiniz gibi `h` seçeneği sayesinde dosyaların
toplam boyutu ve bireysel boyutları çok daha kolay okunur şekilde
basılmış oldu. Bu seçenek özellikle büyük boyutlu dosya ve klasörlerin
boyutlarını öğrenmek için oldukça kullanışlı. Bayt cinsinden olduğu için
çok basamaklı sayıların büyüklük hesaplarını yapmakla uğraşmamıza gerek
kalmıyor böylece. Unutmayın, insan olarak rahat okumak istiyorsanız
"human readable" ifadesinin kısaltmasından gelen `h` seçeneğini
kullanmanız yeterli.

Boyutlarına Göre Sıralamak
--------------------------

Eğer çıktıları büyükten küçüğe olacak şekilde boyutlarına göre sıralamak
istersek, büyük `S` seçeneğini kullanabiliyoruz. Bu "S" seçeneği
muhtemelen tahmin ettiğiniz gibi İngilizce "**S**ize" yani "boyut"
ifadesinin kısaltmasından geliyor. Büyük `S` kullanıldığında tıpkı
karakterindeki büyüklük gibi **büyükten küçüğe** doğru olacak şekilde
listenin sıralanmasını sağlamış oluyoruz.

Daha net görülebilmesi için ***/boot*** dizini üzerinde çalışabiliriz.
Buradaki dosyaları `ls -l` ile listeleyelim.

``` {.sql}
┌──(taylan@linuxdersleri)-[~]
└─$ cd /boot/                                                                                                                                     

┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -l                                                                                                                                         
total 85888
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
```

Bakın aldığımız çıktıda dosya ve klasörler isimlerine göre yukarıdan
aşağıya doğru alfabetik şekilde sıralanmış halde karşımıza geldi. Şimdi
bir de büyük `S` seçeneğini de ekleyip tekrar listeleyelim.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lS                                                                                                                                        
total 85888
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
```

Bakın bu kez aldığımız çıktılar ilk listeden farklı olarak büyükten
küçüğe sıralanmış oldu. Hatta emin olmak için dilersem `h` seçeneğini de
ekleyip daha okunaklı bir çıktı elde edebilirim.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lSh                                                                                                                                       
total 84M
-rw-r--r-- 1 root root  77M Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root 7.0M Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root 240K Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root 4.0K Jul  5  2022 grub
-rw-r--r-- 1 root root   83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
```

Bakın büyük karakterli size seçeneği yani `S` seçeneği, `ls` komutunun
çıktılarını büyükten küçüğe doğru kolayca sıralayabilmemizi sağlıyor.

Değiştirilme Tarihlerine Göre Sıralama
--------------------------------------

Normalde `ls` komutunun `-l` seçeneği ile aldığımız ayrıntılı listede
dosyaların oluşturulma tarihleri veya değiştirildilerse, değiştirilme
tarihleri belirtiliyor. Dosya ve klasörleri **değiştirilme tarihlerine
göre en yeniden eskiye doğru** sıralamak istersek `t` seçeneğini
kullanabiliyoruz. Buradaki "`t`" seçeneği İngilizce "**t**ime" yani
"zaman" ifadesinin kısaltmasından geliyor. Ben örnek olarak bulunduğum
dizindeki dosya ve klasörleri `ls -lt` komutu ile listeliyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -l                                                                                                                                         
total 85888
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64

┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lt                                                                                                                                        
total 85888
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
```

Tarih kısmına baktığımızda `t` seçeneği ile aldığımız listenin en
üstünde yer alan içeriklerin, diğerlerine göre daha yeni düzenlemiş olan
içerikler olduğunu görebiliyoruz.

Çıktıları Tersine Çevirmek
--------------------------

Fark ettiyseniz şu ana kadar ele aldığımız seçeneklerde hep tek yönlü
listeleme mevcuttu. Örneğin boyutları sıralarken **büyükten küçüğe**,
tarihleri de **yeniden eskiye** doğru sıralamıştık. Eğer `ls`
çıktılarının normalde sunduğu herhangi bir çıktıyı tersten sıralamak
istersek İngilizce "**r**everse" yani "ters" ifadesinin kısaltması olan
`r` seçeneğini kullanmamız yeterli oluyor. Hemen bildiğimiz seçenekler
üzerinden deneyelim.

`ls -l` komutunu kullandığımızda dosya ve dizinler isimlerine göre
alfabetik olarak sıralanıyorlar.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -l
total 85888
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
```

Bu listeyi ters alfabetik olarak almak istersek `r` seçeneğini
ekleyebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lr
total 85888
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
```

Bakın bu kez aldığımız çıktılar önceki listenin tam tersi yani alfabetik
olarak tersten sıralanmış oldu.

`ls -lS` komutu ile **büyükten küçüğe** sıralama yapıyoruz. `r` seçeneği
sayesinde **küçükten büyüğe** sıralayabiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lS
total 85888
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64

┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lSr
total 85888
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
```

Değişim tarihlerine göre yeniden eskiye sıralamak için `ls -lt` komutunu
kullanıyorken, eskiden yeniye listelemek için `ls -ltr` komutunu
kullanabiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -lt
total 85888
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64

┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -ltr
total 85888
-rw-r--r-- 1 root root  7316800 Jan 31  2022 vmlinuz-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root       83 Jan 31  2022 System.map-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root   245359 Jan 31  2022 config-5.15.0-taylan3-amd64
-rw-r--r-- 1 root root 80372540 Feb 11  2022 initrd.img-5.15.0-taylan3-amd64
drwxr-xr-x 6 root root     4096 Jul  5  2022 grub
```

Neticede tekrar tekrar teyit edebildiğimiz üzere `r` seçeneği çıktıları
tersine çevirmek için kullanılan işlevsel bir özellik. Bu seçeneği
dilediğimiz başka seçenekler ile kullanıp, çıktıları tersine
çevirebiliyoruz. Bu sayede her bir özelliğin ek seçeneğine ihtiyacımız
olmuyor. Yani örneğin dosyaları hem küçükten büyüğe hem de büyükten
küçüğe sıralamak için ayrı ayrı seçeneklere ihtiyacımız kalmıyor. Tek
yapmamız gereken tersi durum için `r` seçeneğini kullanmak.

Dizin Adresini Belirterek İçeriğini Listelemek
----------------------------------------------

Eğer mevcut bulunduğumuz dizini değil de başka bir dizindeki içerikleri
listelemek istersek, ilgili dizininin tam adresini tıpkı `cd` komutunda
olduğu gibi `ls` komutunun ardından yazmamız yeterli.

Örneğin ben şu anda ***/boot*** dizini altında çalışıyorum. Buradayken
`ls` komutunu kullanırsam, mevcut dizindeki içerikler karşıma geliyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls                                                                                                                                            
config-5.15.0-taylan3-amd64  grub  initrd.img-5.15.0-taylan3-amd64  System.map-5.15.0-taylan3-amd64  vmlinuz-5.15.0-taylan3-amd64
```

Ama ben ***/etc*** dizini altındaki ***apt*** klasörünün içeriğini
listelemek istiyorum. Bunun için tek yapmam gereken `ls /etc/apt` komutu
ile içeriğini listelemek istediğim dizinin adresini açıkça belirtmek.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls /etc/apt                                                                                                                                   
apt.conf.d  auth.conf.d  preferences.d  sources.list  sources.list~  sources.list.d  trusted.gpg.d
```

Bakın hangi konumda çalışmakta olduğumdan bağımsız olarak, ***apt***
dizinin içeriği anında konsola listelendi.

İşte bu şekilde o konumda değilken, yetkimiz olan dizinlerin
içeriklerini görüntüleyebiliyoruz. Hazır yetki kavramına da değinmişken
yetkimiz olmayan dizinlerin içeriklerini görüntüleyemeyeceğimizi örneğin
***/root*** dizininin içeriğini sorgulayarak teyit edebiliriz. Normalde
**root** kullanıcısı sistem üzerindeki **en yetkili kullanıcı** olduğu
için bizim gibi standart kullanıcı hesapları root kullanıcısının ev
dizinini temsil eden ***/root*** klasörünü üzerinde yetkiye sahip değil.

Hemen denemek için konsola `ls /root` komutunu girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls /root                                                                                                                                      
ls: cannot open directory '/root': Permission denied
```

Bakın gördüğünüz gibi doğrudan yetki hatası aldım. Yetkilendirme
işlemlerinden bahsederken, nasıl yetki kısıtlaması yapabileceğimizden ve
yetki kısıtlaması olan dosyaları kimlerin nasıl ulaşabileceğinden de
ayrıca söz edeceğiz. Şimdilik tıpkı bu ***root*** klasöründe olduğu gibi
yetkimiz olmayan dizinlere erişemeyeceğimizi bilmemiz yeterli.

Dizin adreslerini belirterek dizin içeriklerini listeleyebilme özelliği
dosya taşıma kopyalama veya içerikleri teyit etme noktasında inanılmaz
kolaylık sunuyor. Çünkü `cd` komutu ile ilgili dizine gidip `ls`
komutunu yazmaktansa, `ls` komutuna doğrudan içeriğinin listelenmesini
istediğimiz dizini argüman olarak vermek çok daha kolay.

Dosya veya Dizinin Kendisini Listelemek
---------------------------------------

Doğrudan bizim istediğimiz bir veya birden fazla dosya veya klasörlerin
özelliklerini görebilmek için dosyanın tam dosya dizin adresin `ls -l`
komutundan sonra yazmamız yeterli. Örneğin ben kendi ev dizinimde
bulunan ***.bashrc*** dosyasının özelliklerini listelemek istersem
`ls -l ~/.bashrc` şeklinde komutumu girmem yeterli.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -l ~/.bashrc                                                                                                                               
-rw-r--r-- 1 root root 5589 May 29 04:21 /home/taylan/.bashrc
```

Bakın yalnızca ***.bashrc*** dosyasının özellikleri konsola basılmış
oldu. Benzer şekilde yalnızca tek bir klasörün özelliklerini de
listeleyebiliriz.

Normalde örneğin `ls -l /etc/apt` komutunu girdiğimizde ***apt*** dizini
içindeki tüm dosya ve klasörler listeleniyor.

``` {.yaml}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -l /etc/apt/                                                                                                                               
total 24
drwxr-xr-x 2 root root 4096 Feb 11  2022 apt.conf.d
drwxr-xr-x 2 root root 4096 Jan 19  2022 auth.conf.d
drwxr-xr-x 2 root root 4096 Jan 19  2022 preferences.d
-rw-r--r-- 1 root root  257 Feb 11  2022 sources.list
-rw-r--r-- 1 root root    0 Feb 11  2022 sources.list~
drwxr-xr-x 2 root root 4096 Jan 19  2022 sources.list.d
drwxr-xr-x 2 root root 4096 Feb 11  2022 trusted.gpg.d
```

Biz dizin içeriğinin değil de doğrudan ***apt*** dizinin özelliklerine
bakmak istersek, `ls` komutuna "**d**irectory" yani "dizin" ifadesinin
kısalmasında gelen `d` seçeneğini eklememiz yeterli. Denemek için bu kez
`ls -ld /etc/apt` komutunu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -ld /etc/apt/                                                                                                                              
drwxr-xr-x 7 root root 4096 Feb 11  2022 /etc/apt/
```

Bakın yalnızca ***/etc/apt/*** klasörünün bilgileri listelenmiş oldu.
Elbette tek tek girmek zorunda da değilsiniz. İsterseniz peşi sıra
birden fazla dosya ya da klasör ismini girip, özelliklerini konsola
bastırabilirsiniz. Örneğin ben başka bir dizinde olan ***/var/tmp***
klasörünü de ekleyip peşi sıra özelliklerin listelenmesini
sağlayabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -ld /etc/apt/ /var/tmp/                                                                                                                    
drwxr-xr-x 7 root root 4096 Feb 11  2022 /etc/apt/
drwxrwxrwt 7 root root 4096 Jun  4 06:09 /var/tmp/
```

Bakın iki farklı konumdaki klasörlerin tam dizin adreslerini yazıp,
özelliklerini kolayca listeleyebildim. Benzer şekilde elbette listelemek
istediğiniz dosya veya klasörlerin da tam adını belirttiğiniz sürece
sistemdeki farklı dizinlerde bulunan dosya ve dizinleri tek seferde
bastırabilirsiniz. Örneğin ben komutun sonuna ***\~/.bashrc*** dosyasını
da listelemek için ekliyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -ld /etc/apt/ /var/tmp/ ~/.bashrc                                                                                                          
drwxr-xr-x 7 root root 4096 Feb 11  2022 /etc/apt/
-rw-r--r-- 1 root root 5589 May 29 04:21 /home/taylan/.bashrc
drwxrwxrwt 7 root root 4096 Jun  4 06:09 /var/tmp/
```

Bakın `ls -ld` komutunun sonuna eklediğim klasörler ve dosyalar tek tek
bastırıldı.

Özetle `ls` komutunun görevi kendisine argüman olarak verilmiş olan
dosya veya dizinleri listelemek. Bu sebeple tam dizin adresini
belirttiğimiz ve yetkimiz olduğu sürece tek seferde pek çok farklı
dizindeki dosya ve klasörleri kolayca listeleyebiliyoruz.

Alt Dizinler de Dahil Tüm İçerikleri Listelemek
-----------------------------------------------

Eğer herhangi bir dizin altında yer alan tüm dizinlerin içeriklerini
listelemek istersek "**R**ecursive" yani "özyineleme" ifadesinin
kısalmasından gelen büyük **`R`** seçeneğini kullanma imkanına sahibiz.
Bu seçeneği kullandığımızda tüm alt klasörler de dahil mevcut dizin
altındaki tüm dosya ve klasörlerin içerikleri bizim için kademe kademe
listeleniyor. Zaten iç içe olan dizinlerin içeriğini bulup bize
listelediği için bu seçeneğin adı özyineleme olarak geçiyor. Örnek
üzerinden çok daha net anlaşılacağı için hemen basit bir örnek yapalım.

Ben örnek olması için ***/etc/apt*** dizini altındaki tüm içeriği
listelemek üzere `ls -R ~` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[/boot]
└─$ ls -R /etc/apt                                                                                                                               
/etc/apt:
apt.conf.d  auth.conf.d  preferences.d  sources.list  sources.list~  sources.list.d  trusted.gpg.d

/etc/apt/apt.conf.d:
00aptitude      00trustcdrom  01autoremove-kernels     50apt-file.conf      50taylan     80debtags
00CDMountPoint  01autoremove  02autoremove-postgresql  50command-not-found  70debconf

/etc/apt/auth.conf.d:

/etc/apt/preferences.d:

/etc/apt/sources.list.d:

/etc/apt/trusted.gpg.d:
debian-archive-bullseye-automatic.gpg           debian-archive-buster-security-automatic.gpg   debian-archive-stretch-stable.gpg
debian-archive-bullseye-security-automatic.gpg  debian-archive-buster-stable.gpg               taylan-archive-keyring.gpg
debian-archive-bullseye-stable.gpg              debian-archive-stretch-automatic.gpg
debian-archive-buster-automatic.gpg             debian-archive-stretch-security-automatic.gpg
```

Bakın tek tek hangi dizin altındaki hangi içerikler bulunduğu ve daha
alt dizinlerde de aynı şekilde hangi içeriklerin bulunduğu tek tek
konsola bastırıldı.

Çıktıları incelediğimde ev dizinim altındaki tüm içeriklerin
özyinelemeli olarak listelenmiş olduğunu görebiliyorum. İşte sizler de
alt dizinlerler de dahil tüm içeriği görmek istediğinizde bu şekilde
büyük `R` seçeneğini kullanabilirsiniz.

Özyineleme özelliğinden de bahsettiğimize göre benim `ls` komutu
hakkında aktarmak istediğim bilgilerin şimdilik sonuna gelmiş olduk.

Elbette `ls` komutunun bütün özellikleri benim anlattıklarım ile sınırlı
değil. `ls —help` komutu ile `ls` aracının sahip olduğu özellikler
hakkında her zaman ek bilgi alabilirsiniz.

Dizin Oluşturma ve Silme
------------------------

Dizin Oluşturma \| `mkdir` Komutu
---------------------------------

Şu ana kadar bulunduğumuz dizini öğrendik, dizinlerde gezindik ve
dizinlerin içeriklerini listeledik ama konsol üzerinden dizin
oluşturmaya dair özellikle bir anlatımda bulunmadık. Tabii ki şu ana
kadar dizin oluşturmamızı sağlayan `mkdir` aracını defaatle kullandık
ama, özellikle bu aracın üzerinde durmak henüz. Sizin de bildiğiniz ve
birden fazla kez deneyimlediğiniz gibi konsol üzerinden dizin oluşturmak
için İngilizce "**m**a**k**e **dir**ectory" yani "dizin oluştur"
ifadesinin kısaltması olan `mkdir` komutunu kullanabiliyoruz. En temel
kullanımı `mkdir klasor_adı` şeklinde. Bu kullanım ile mevcut çalışmakta
olduğumuz dizinde bizim belirttiğimiz isimde bir klasör oluşturuluyor.
Zaten eğitimin başından beri örnek vermek için ara da bu komutu bu
şekilde kullandık. Yani hiç de yabancı değiliz. Yine de ele almamız
gereken birkaç detayı daha bulunuyor.

Ben öncelikle standart kullanımını tekrar ele almak için bulunduğum
dizine folder1 isimli bir klasör oluşturmak üzere `mkdir folder1`
komutunu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir folder1

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls
folder1
```

`ls` komutu ile içerikleri listelediğimde, klasörün oluşturulduğunu
görebiliyorum.

Bulunduğumuz dizin dışında tam dizin adresi belirtirsek, eğer yetkimiz
de varsa istediğimiz konumda istediğimiz isimde bir dizin de
oluşturabiliriz.

Örneğin ben `mkdir ~/Documents/belgeler` komutu ile kendi ev dizinimdeki
***Documents*** klasörünün içinde ***belgeler*** isimli yeni bir klasör
oluşturabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir ~/Documents/belgeler
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls ~/Documents/
belgeler        metinler
linux-dersleri  metin.txt
```

Bakın çalışmakta olduğum dizinden bağımsız olarak istediğim bir konumda
yeni klasörün oluşturulması da sağlamış oldum. Biz bu şekilde komut
girdiğimizde `mkdir` aracı belirttiğimiz dizini kontrol ediyor, örneğin
benim girdiğim komutta ***Documents*** dizini kontrol edildi ve burada
belirtilen "***belgeler***" isimli bir klasör olmadığı için `mkdir`
aracı bu isimde yeni bir klasör oluşturdu. Zaten bu sayede yetkimiz
dahilinde olduğu sürece istediğimiz adreste istediğimiz klasörü
oluşturabilme esnekliğine sahip oluyoruz.

Daha önce yetkimiz olmayan ***/root*** dizininin içeriğini listelemeye
çalışmış ve yetki hatası almıştık hatırlarsanız. Aynı durum klasör
oluştururken de geçerli. Yetkimiz olmayan dizinlerin içine yeni
klasörler ekleyemeyiz. Denemek için ***/root*** dizini altında
"***yetkisiz***" isimli bir klasör oluşturmayı deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir /root/yetkisiz
mkdir: cannot create directory ‘/root/yetkisiz’: Permission denied
```

Gördüğünüz gibi yetkim olmadığı için bu dizinde yeni klasör
oluşturamadım.

Tekrar örneklerimize dönecek olursak, ben örneklerde hep tek bir klasör
oluşturdum. Ancak dilersek klasör isimlerini peş peşe yazarak tek
seferde birden fazla klasör de oluşturabiliriz. Denemek için üç klasör
birden oluşturalım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir folder2 folder3 folder4

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls
folder1  folder2  folder3  folder4
```

Bakın tek seferde birden fazla klasörü oluşturabildim. İşlemin hızlıca
sonuçlanması harika ama kimi zaman işlemi konsol üzerinden de takip
etmek isteyebiliriz.

Eğer çoklu klasör oluştururken klasör oluşturma işlemini daha kolay
takip etmek istersek, İngilizce "**v**erbose" yani "ayrıntılı"
ifadesinin kısaltması olan `v` seçeneğini de kullanmamız gerekiyor.

Örneğin ben biraz önce çoklu şekilde klasör oluşturduğumda klasörlerin
oluşturulduğuna dair herhangi bir çıktı almadım.

Eğer `mkdir` komutunun **`-v`** seçeneğini kullanırsak tüm oluşturma
işlemleri konsola basılacaktır.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]                              
└─$ mkdir -v a b c d                                 
mkdir: created directory 'a'                             
mkdir: created directory 'b'                                 
mkdir: created directory 'c'                                 
mkdir: created directory 'd'
```

Her bir klasörün oluşturulmasına dair adım adım bilgi edinmiş olduk.
`mkdir` komutunun **verbose** seçeneği özellikle farklı konumlarda çoklu
klasör oluşturma gibi işlemlerde, oluşturma işlemlerinin takibi
konusunda çok kullanışlı olabiliyor. Zaten **verbose** ifadesini tüm
eğitim boyunca komutların buradaki gibi işlem adımlarına dair
**ayrıntılı çıktılar** vermesi için kullanacağımız için şimdiden
tanıtmak istedim.

### İç içe Dizin Oluşturma

Şimdiye kadar hep derinliği olmayan yani alt klasörleri bulunmayan tekil
klasörler oluşturduk. Normalde bildiğiniz gibi klasörlerin içinde ve
üstünde dizinler yer alabiliyor. Yani iç içe bir yapı söz konusu. İşte
kimi zaman tekil bir klasör oluşturmamız gerekiyorken kimi zaman da tek
seferde iç içe birden fazla klasör oluşturmamız da gerekebiliyor.

Eğer tek seferde iç içe birden fazla klasörü oluşturmak istersek `mkdir`
komutunun `p` seçeneğini kullanabiliyoruz. Buradaki `p` seçeneği
İngilizcedeki "**p**arrent" yani "ebeveyn" ifadesinin kısalmasından
geliyor. Aslında bu ifade üst dizin alt dizin kavramıyla ilişkili.
Örneğin ben bir klasörün içine yeni bir klasör oluşturursam, bir üst
klasör alttaki klasörün **parrent**'ı yani **ebeveyni** olarak kabul
ediliyor. Bu seçenek de buradan aklınızda kalabilir.

Hemen uygulamalı olarak -p seçeneğinin etkisini gözlemleyelim. Ben
`mkdir -p buyukanne/anne/cocuk` şeklinde komutumu girmek istiyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]                                                 
└─$ mkdir -p buyukanne/anne/cocuk
```

Tamamdır, şimdi teyit etmek için `ls -R buyukanne` komutunu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls -R buyukanne/                                                                               
buyukanne/:
anne

buyukanne/anne:
cocuk

buyukanne/anne/cocuk:
```

Bakın ***buyukanne*** klasörünün içinde "***anne***" onun da içinde
"***cocuk***" isimli klasörler alt alta tek seferde `p` seçeneği
sayesinde oluşturulmuşlar. Bizde `ls -R` komutu sayesinde klasör
içeriğini özyinelemeli olarak bastırarak bu durumu teyit edebildik.

Eğer `p` seçeneğini kullanmasaydık, kabuk gerçekte var olmayan bir dizin
adresinde yeni klasör oluşturmaya çalıştığımız düşünecekti. Yani bizim
iç içe oluşturulması için verdiğimiz klasör isimlerini sanki halihazırda
var olan bir dizin yoluymuş da en sonraki klasör oluşturulacak klasör
ismiymiş gibi algılanacaktı. Hemen denemek için `p` seçeneği olmadan
`mkdir x/y/z` komutunu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir x/y/z                                                                                    
mkdir: cannot create directory ‘x/y/z’: No such file or directory
```

Böyle bir dosya ya da dizin olmadığı uyarısını döndürdü, haklı da.
Gerçekten böyle bir dizin yok. Çünkü biz bu komutu girdiğimizde `mkdir`
aracı ***x*** dizinine geçip oradan ***y*** dizinine geçecek, ***y***
dizini altında da ***x*** klasörünü oluşturacaktı. Çünkü `p` seçeneği
olmadan bizim girdiğimiz bu komut bunu ifade ediyor. Elbette bu dizinler
var olmadığı için komutumuz da hata verdi. Bizim amacımız da bu dizinin
oluşturulması, bunun için özellikle `p` seçeneği ile bu durumu
belirtmemiz gerekiyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir -p x/y/z                                                                                 

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls -lR x/                                                                                      
x/:
total 4
drwxr-xr-x 3 taylan taylan 4096 Jun  4 07:16 y

x/y:
total 4
drwxr-xr-x 2 taylan taylan 4096 Jun  4 07:16 z

x/y/z:
total 0
```

Bakın `p` seçeneğini kullandığımda bu kez dizinler iç içe sorunsuzca
oluşturuldu.

Tamamdır bence `mkdir` aracından yeterince bahsettik. Şimdi var olan
dizinleri nasıl silebileceğimizden bahsederek devam edelim.

Dizin Silme \| `rmdir` Komutu
-----------------------------

Söz konusu komut satırı üzerinden klasörleri silmek olduğunda da `rmdir`
ve `rm` olmak üzere ihtiyacımıza göre kullanabileceğimiz iki alternatif
aracımız var. Ben bu bölümde yalnızca `rmdir` aracına odaklanacağım.
Ancak merak etmeyin daha sonra eğitim içerisinde `rm` aracından da
ayrıca bahsedeceğiz zaten.

Biliyorsunuz klasörler yani dizin yapısı, içerisindeki dosya ve
klasörleri organize şekilde bir arada tutmak için tasarlanmış olan
harika bir çözüm. Yeterince alana sahip olduğumuz sürece bir klasör
içerisine istediğimiz kadar dosyayı barındırabiliyoruz. Bu durum da
tıpkı gerçek hayatta kullandığımız klasörleme yapısı gibi, işletim
sistemleri üzerinde de bize hiyerarşik bir düzen sağlıyor. Klasörlerin
içerisinde dosya barındırabilmesi her ne kadar işlevsel olsa da, bu
durum aynı zamanda klasörleri riskli getiriyor. Eğer yanlışlıkla
içerisinde kritik dosyaların bulunan bir klasörü silersek, tek seferde
içerisindeki tüm alt dosya ve klasörler de silineceği için tek bir
hatanın faturası çok ağır olabilir. Bu sebeple klasör silme işlemi Linux
üzerinde ciddiye alınıyor. Zaten son derece dikkatle yapılması da
gerekiyor. Klasörü silmek tek bir dosyayı silmeye benzemez. Tek seferde
büyük bir yıkıma sebep olabiliriz. Zaten bu tehlike göz önünde
bulundurularak klasör silmek için spesifik olarak güvenli bir araç olan
`rmdir` aracı geliştirilmiştir.

`rmdir` aracı yalnızca içeriği boş olan klasörleri silmemizi sağlıyor.
Bu sayede, içeriği dolu olan klasörlerin yanlışlıkla silinmesinin de
önüne geçilmiş oluyor. Özellikle toplu olarak klasör silmek için `rmdir`
aracını sıklıkla kullanılıyor çünkü klasörlerin boş olduğundan emin
olunabiliyor.

Aracın kullanımına geçecek olursak en temel kullanımı
`rmdir "silinecek klasör ismi"` şeklinde. Örneğin ***folder1***
klasörünü silmek için `rmdir folder1` komutunu girebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                                                             
a  b  buyukanne  c  d  folder1  folder2  folder3  folder4  x

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rmdir folder1                                                                                  

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                                                             
a  b  buyukanne  c  d  folder2  folder3  folder4  x
```

`ls` komutu ile de teyit ettiğimde, klasörün içerisin boş olduğu için
sorunsuzca silindiğini görebiliyorum. Şimdi `rmdir` aracının
davranışlarını gözlemleyebilmek için içerisinde başka bir klasör bulunan
***x*** klasörünü silmeyi de deneyebiliriz. Biliyorsunuz ***x*** klasörü
içinde ***y*** onun da içinde ***z*** klasörü yer alıyor, çünkü biz daha
önce `mkdir` aracının `p` seçeneği sayesinde iç içe oluşturduk. Şimdi
`rmdir x` komutu ile ***x*** klasörünü silmek üzere komutumuzu girelim.

``` {.scss}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                                                             
a  b  buyukanne  c  d  folder2  folder3  folder4  x

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rmdir x
rmdir: failed to remove 'x': Directory not empty
```

Bakın klasörün içi boş olmadığı için silme işlemi anında reddedildi.
Bunun yerine iç içe olan klasörlerin tam isimlerini girmeyi de
deneyebiliriz. Silme işlemini rahat gözlemleyebilmek için rmdir aracında
da mevcut olan **verbose** yani "ayrıntılı" çıktı sağlayan `v`
seçeneğini de komutumuza ekleyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rmdir -v x/y/z/                                                                                
rmdir: removing directory, 'x/y/z/'
```

Komut neticesinde en son klasör olan ***z*** klasörünün silindiğini
öğrendik. Çünkü ***z*** klasörünün içeriği tamamen boştu ve biz ***z***
klasörünün tam dizin adresini `rmdir` aracına iletmiş olduk. Dolayısıyla
yalnızca ***z*** klasörü içeriği boş olduğu için, `rmdir` aracı
tarafından kolayca silindi. Bu durumda ***x*** ve ***y*** klasörlerinin
hala silinmediğini teyit etmek için `ls -R x/` komutu ile dizin
içeriğini listeleyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls -R x/                                                                                       
x/:
y

x/y:
```

Bakın gördüğünüz gibi ***x/y*** dizini hala mevcut.

Eğer tek seferde içerisi boş olan tüm iç içe dizinleri silmek istersek
tıpkı dizinleri oluştururken kullandığımız gibi silerken de `p`
seçeneğini kullanabiliriz. Daha önce `mkdir` aracı ile iç içe dizin
oluşturmak için kullandığımız `p` seçeneğini, iç içe olan dizinleri tek
seferde silmek için de kullanabiliyoruz. Ben işlem ayrıntılarını da
takip edebilmek için `rmdir -vp x/y` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rmdir -vp x/y
rmdir: removing directory, 'x/y'
rmdir: removing directory, 'x'
```

Bakın ayrıntılı çıktılardan da takip edebildiğimiz gibi içe içe olan boş
klasörleri `p` seçeneği sayesinde silmeyi başardık.

Lütfen unutmayın, biz burada **iç içe olan boş klasörleri** sildik. Eğer
herhangi bir klasörün içerisinde dosya bulunuyor olsaydı bu işlem tabii
ki başarısız olacaktı.

Denemek için `mkdir -p a/b/c/` komutu ile iç içe yeni klasörler
oluşturalım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir -p a/b/c/
```

Klasörleri oluşturduktan sonra bu dizinlerden birine içerisi dolu bir
metin dosyası ekleyebiliriz. Ben en sondaki klasöre "***metin.txt***"
isminde bir dosya kaydetmek için
`echo "bu bir metin dosyasıdır" > a/b/c/metin.txt` komutunu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ echo "bu bir metin dosyasıdır"  > a/b/c/metin.txt                                              

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls a/b/c/
metin.txt
```

Bakın ***metin.txt*** dosyası en alt dizinde yer alıyor.

Şimdi tekrar `rmdir -vp a/` komutu ile iç içe olan klasörleri silmeyi
deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rmdir -vp a/
rmdir: removing directory, 'a/'
rmdir: failed to remove 'a/': Directory not empty
```

En sonraki klasörün içeriği boş olmadığı için silinemediği belirtiliyor.
Bu klasörü silmek için öncelikle içerisinde bulunan dosyaları taşımanız
veya silmeniz gerek.

Ayrıca kimi zaman içerisi dolu olan klasörleri `rmdir` aracını
kullanmadan doğrudan silmek de isteyebilirsiniz. Tam olarak bu işlem
için de zaten `rm` komutunu kullanabiliyoruz. Bu aracın kullanımından
ileride ayrıca bahsedeceğiz. Ancak temelde bilmeniz gereken,
içerisindeki her şey ile birlikte klasörleri silmek istediğimizde
`rm -dr` komutunu kullanabiliyor olmamızdır. Buradaki `r` seçeneği
"**r**ecursive" yani "özyineleme" anlamına geliyor. Bu seçenek sayesinde
dizinin sonuna kadar tüm içeriklerin otomatik olarak silinmesini
sağlanıyor. Buradaki `d` seçeneği de "**d**irectory" yani "dizin"
ifadesinin kısaltmasından geliyor. Burada özellikle `d` seçeneği ile
dizin silmek istediğimizi belirtmemiz gerekiyor çünkü normalde `rm`
aracı yalnızca dosyaları silmek için kullanılıyor. Hemen deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -dr a/                                                                                     

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls
b  buyukanne  c  d  folder2  folder3  folder4
```

***a*** klasörünün silinmiş olduğunu `ls` sayesinde teyit etmiş olduk.

Zaten ileride dosyalardan bahsederken dosyaları nasıl silebileceğimizden
de bahsetmemiz gerekecek. Dolayısıyla `rm` komutunun detaylarında da
ayrıca bahsedeceğiz. Şimdilik bu kadarlık bilgi yeterli. Dizinler
hakkında yeterince şeyden bahsettik.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 22. Ders 2 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

En nihayetinde artık temel Linux eğitiminin sonuna geldik. Her ne kadar
eğitim bitmiş olsa da aslında sizlerin de bizzat farkında olduğunuz gibi
Linux öğrenme yolculuğu daha yeni başlıyor. Sahip olduğunuz temel
bilgileri kullanarak merakınızın ve araştırmacı yönünüzün de yardımıyla
öğrenebileceklerinizin sınırı yok. Yani artık bundan sonrası tamamen
sizin ne kadar ilerlemek istediğinize bağlı.

Bu noktada sizlere, her şeyi bilmek veya öğrendiklerinizi sürekli
hatırlamak zorunda olmadığınızı belirtmek istiyorum. Neyi nasıl
arayacağınızı biliyorsanız, sık ihtiyaç duymadığınız bilgiler için
yardım sayfalarını ve interneti kullanmanız son derece normal bir
yaklaşımdır. Yani profesyonel de olsanız sürekli araştırma yapıyor
olacaksınız. Önemli olan neyi aradığınızın farkında olmanız ve
aradığınız şeyi kısa sürede bulabilmeniz.

Karşılaştığınız sorunların çözümleri için yeterince kafa yorduktan
sonra, [unix.stackexchange.com](http://unix.stackexchange.com/)
[askubuntu.com](https://askubuntu.com/)
[stackoverflow.com](https://stackoverflow.com/) ve benzeri çeşitli
forumların topluluk desteğinden faydalanabilirsiniz. Sorularınızı
yeterince açık şekilde sorduğunuz sürece, size yardımcı olmak isteyecek
pek çok gönüllü bulunuyor. Ayrıca daha önce benzeri soruların sorulmuş
olması ihtimaline karşı her daim öncelikle internet üzerinde anahtar
kelime araştırması yapmanız da son derece önemli. Bu sayede kendi
kendinize yeni bilgilere nasıl ulaşabileceğinizi ve nasıl doğru şekilde
soru sorabileceğinizi de öğrenmiş olacaksınız. Ek olarak her zaman soru
sormak yerine, sorulmuş olan sorulara cevap vermeye çalışmanız da
gelişiminizi destekleyecektir.

Son olarak söylemek istediğim; muhakkak eğitim boyunca iyi
açıklayamadığım, eksik kalan ya da hata yaptığım kısımlar olmuştur. Yani
belki size göre gereksiz ayrıntılara girip kafa karıştırdığım ya da bazı
ayrıntılardan bahsetmediğim için tam olarak anlaşılamamış konular,
kavramlar veya bölümler olabilir. Bu noktada size önerim tüm eğitimi
baştan sonra bir kez daha tekrar etmeniz ve eksik kalan kısımlar için
ekstra araştırma yapmanız olabilir.

Ben elimden geldiğince tüm eğitimi baştan sonra birbiri ile bağlantılı
olacak şekilde ele aldığım için eğitimi baştan sonra bir kez daha
uygulamalı şekilde takip ederseniz, tüm eğitim boyunca edinmiş olduğunuz
pek çok bilginin aslında birbiri ile ne kadar yakından ilişkili olduğunu
görebilir ve öğrendiklerinizi daha kalıcı hale getirebilirsiniz. Yani
örneğin başta sizin için anlamlı gelmeyen bir konu, eğitimi bitirdikten
sonraki bilgi birikiminiz ve farkındalığınız sayesinde, tekrar başa
döndüğünüzde sizin için çok daha anlaşılır olabilir. Ya da eğitimin
başında bahsedilen bazı kavramları unutmuş veya tam olarak öğrenememiş
de olabilirsiniz. **Bu sebeple eğer mümkünse eğitimi bir kez daha
uygulamalı olarak tekrar etmenizi tavsiye ediyorum.** Yine de umarım, en
azından bir kez bile baştan sonra takip etmiş olanlar için eğitime
ayırdıkları vaktin karşılığını verebilmişimdir. Lafı daha fazla
uzatmadan, eğitime katılan herkese tekrar teşekkür ediyor, ve sabırla
sonuna kadar beni takip ettiğiniz için de ayrıca tebrik ediyorum.

Neticede Linux dünyasına hoş geldiniz demekten mutluluk duyuyorum :)

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 18. Ders 54 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Bu bölümde "**process**" olarak geçen "**işlem**" kavramının anlaşılması
ve yönetilebilmesi üzerinde duracağız. Öncelikle isim tanımı ile
başlayacak olursak. Kimi zaman "**process**" terimi için Türkçe olarak
"**süreç**" ifadesi hatta doğrudan "**proses**" kullanılsa da, terimin
yapısı gereği Türkçe "**işlem**" ifadesi daha doğru bir tanımlama
olacaktır. Ben de anlatımlar sırasında "**process**" kavramı için
"**işlem**" ifadesini kullanıyor olacağım. Bu açıklamayı, harici Türkçe
kaynaklara göz attığınızda "**işlem**" yerine "**süreç**" ya da
"**proses**" ifadeleriyle karşılaşmanız halinde herhangi bir karışıklık
yaşamamanız için kısaca dile getirmek istedim.

ℹ️ Buradaki anlatımları yalnızca temel sistem yönetimi kapsamında ele
alıyor olacağız. Daha fazla detay için elbette işletim sistemi özelinde
harici kaynaklara(işletim sistemi nasıl çalışır? işletim sistemi nasıl
programlanır ? vb.) kaynaklara göz atabilirsiniz.

İşlem(Process) Nedir?
---------------------

Oldukça genel bir tanımla, söz konusu işletim sistemleri olduğunda;
diskimiz üzerinde mevcut bulunan ve sistemin çalıştırabileceği yapıda
olan her türlü programın öncelikle RAM yani hafızaya yüklenmesi ve
oradan da sırası geldiğinde CPU yani işlemci üzerinde işlenmesine
bütüncül olarak "***process***" yani "***işlem***" diyoruz.

![process.webp](https://www.linuxdersleri.net/egitim/temel-linux/islem/process.webp)

Buradaki açıklama **son derece yüzeysel** fakat bulunduğumuz noktada
temel işlem yönetimi için daha fazla bilgiye henüz gerek yok.

Kullandığımız araçlar, komutlar sistem üzerinde "**işlem**" olarak var
oldukları için sistemi yönetebilmek için işlemleri de yönetebiliyor
olmamız şart.

İşlem yönetimini de, kabuğun başlattığı ve sistem genelinde kabuktan
bağımsız başlatılmış olan işlemlerin yönetimi olarak ikiye ayırabiliriz.
Öncelikle kabuğun başlattığı işlemleri ele alacak olursak:

Kabuk başlatabileceği iki tür işlem vardır.

-   **Ön Planda(Foreground) Çalışanlar:** Çalışmak için kullanıcı(konsol
    vasıtası ile) etkileşimine ihtiyacı olan işlemlerdir.
-   **Arka Planda(Background) Çalışanlar:** Kullanıcı etkileşimi
    olmaksızın arka planda otomatik olarak işlerini yürüten işlemlerdir.

Bash Kabuğunda İşlem Başlatmak
------------------------------

Anlatımın başında da belirttiğimiz gibi arka planda ve ön planda çalışan
olmak üzere iki tür işlem mevcuttur.

Ön plandaki(foreground) işlemler terminal araçlarına bağımlı olan
işlemlerdir. Bu işlemlerin durdurulması, devam ettirilmesi veya
sonlandırılması gibi işlemler için bu işlemlerin başlatıldıkları kabuğa
ve konsola ihtiyaçları vardır. Bu sebeple ön planda çalışan işlem
sınıfındadırlar.

Arka plandaki(background) işlemler terminal aracından bağımsızdır.
Yönetimi(durdurulması, devam ettirilmesi, sonlandırılması vb..) için
işlemi başlatan konsola veya kabuğa yani kullanıcı etkileşimine ihtiyaç
duymadan arka planda işlerini yerine getirirler.

Ön Plandaki İşlemler
--------------------

Örneğin konsola `firefox` komutunu girecek olursak mevcut kabuk,
`firefox` aracını bulup çalıştıracaktır.

![firefox.webp](https://www.linuxdersleri.net/egitim/temel-linux/islem/firefox.webp)

Fakat **firefox** aracı açık olduğu sürece "`firefox`" komutunu girmiş
olduğumuz konsola yani bu kabuğa yeni herhangi bir komut giremeyiz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox
[GFX1-]: Unrecognized feature VIDEO_OVERLAY
ls
echo "deneme"
```

Çünkü **firefox** aracı mevcut konsola bağlı ve bizim konsoldan
etkileşim kurabileceğimiz şekilde ön planda başlatılan bir işlemdir. Bu
sayede ben bu aracı durdurma kapatma gibi işlemleri bu konsol üzerinden
gerçekleştirebilirim. Örneğin kapatmak için konsola Ctrl + C tuşlamasını
yapabilirim.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox
[GFX1-]: Unrecognized feature VIDEO_OVERLAY
ls
echo "deneme"
^CExiting due to channel error.
Exiting due to channel error.
Exiting due to channel error.
Exiting due to channel error.
```

Üstelik ön plandaki işlemler grafiksel arayüze sahip olmak zorunda da
değil. Örneğin `cat > deneme` komutunu girdiğimizde mevcut konsol, `cat`
aracının "***deneme***" isimli dosyaya veri yazması için işlemi
beklemeye başlıyor. Yani konsol sayesinde `cat` aracı ile etkileşimde
bulunuyoruz. Bu noktada mevcut konsola başka bir komut girmemiz mümkün
değil.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat > deneme
bu 
bir 
deneme
echo deneme
ls
```

Ben Ctrl + D tuşlaması ile veri girişini sonlandırana kadar `cat` işlemi
ön planda bu konsol üzerinden benden etkileşim bekliyor olacak. İşte bu
da ön planda çalışan ve kullanıcı etkileşimine ihtiyaç duyan işleme bir
diğer örnektir.

Arka Plan İşlemleri
-------------------

Arka plan işlemleri sistem tarafından başlatılabileceği gibi kabuğumuz
üzerinden başlatmamız da mümkündür. Örneğin ben **firefox** aracını arka
planda başlatmak ve mevcut konsolu meşgul etmesini önlemek istersem bash
kabuğuna `firefox &` komutunu girebilirim.

![firefox-bg.webp](https://www.linuxdersleri.net/egitim/temel-linux/islem/firefox-bg.webp)

Başlatılan **firefox** işleminin **pid** yani **işlem numarası** konsola
bastırıldı ve aracım açıldı. Burada bahsi geçen **pid** yani **işlem
numarası** ileride kullanacağımız benzersiz bir değer. Şimdilik bu
değere takılmayın. Firefox aracı arka planda açıldığı için bu aracı açan
konsol bu işlem ile meşgul değil. Bu sebeple konsola yeni komutlar
girmemiz mümkün.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox &
[1] 9830

┌──(taylan㉿linuxdersleri)-[~]
└─$ [GFX1-]: Unrecognized feature VIDEO_OVERLAY
└─$ ls
'bu bir deneme metnidir'   Desktop       Music       test
 deneme                    Documents     Pictures    testfile.sh
 deneme-kati               Downloads     Public      testfolder
 deneme-sembolik           isimler.txt   Templates   Videos

┌──(taylan㉿linuxdersleri)-[~]
└─$ echo "deneme"
deneme
```

Bash kabuğu üzerinde bir işlemi arka planda başlatmak bu kadar kolay.
Bizim başlattığımız arka plandaki işlemler dışında zaten sistem
üzerindeki neredeyse tüm işlemler arka plandadır. Yani çalışmaları için
doğrudan her zaman bizim etkileşimimize ihtiyaçları yoktur. Çalışır ve
görevlerini yerine getirirler.

İş Kontrolü \| Job Control
--------------------------

Eğer kabuk aracılığı ile bir işlem başlatıldıysa bu işlemi yine bu kabuk
üzerinden kontrol edebiliyoruz. Bunun için **bash** kabuğunda "**job
control**" isimli bir mekanizma mevcut.

### İşlemleri Listelemek \| `jobs`

Ben örnek olması için öncelikle `firefox &` komutu ile mevcut kabuk
üzerinden arka planda çalışan bir işlem başlatıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox &
[1] 12063

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Başlatılan işlemin işlem numarası konsola bastırıldı. Bu bilgi dışında
eğer başlatılan işlemin durumunu kontrol etmek istersek `jobs` komutunu
girip, mevcut kabuğun kontrolünde olan tüm işlemleri listeleyebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Running                 firefox &
```

Mevcut kabuk üzerinden yalnızca **firefox** aracını arkaplanda
çalıştırdığımız bu çıktıyı aldık. Bu çıktının mevcut kabuğa özel
olduğunu teyit etmek isterseniz yeni bir konsol açıp bu konsola yani
aslında bu yeni kabuğa yine `jobs` komutunu girebilirsiniz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Yeni kabukta bir çıktı almadık, çünkü bu yeni kabuk üzerinden henüz bir
işlem başlatmadık. Bu çıktıyla birlikte, kabukların yalnızca kendi
başlattıkları işlemleri "job control" mekanizması üzerinden
yönetebileceğini de teyit etmiş olduk.

Şimdi tekrar çıktımıza dönecek olursak işlemin başında gördüğümüz
"**1**" numarası, bu işlemin mevcut kabuktaki **işlem sırasıdır**. Yani
işlem numarasından(**pid**) farklı olarak, mevcut kabuktaki işlemlerin
sahip olduğu sıralama sayısıdır. Bu sayede mevcut kabuk üzerinde çok
daha az işlem başlatıldığı için bu sayılar üzerinden yönetmek çok daha
kolay oluyor.

İşlem numarasından sonra gelen "**Running**" ifadesi, bu işlemin şu anda
çalışmakta olduğunu bildiren durum bilgisidir. Bu bilgiden yola çıkarak
işlem hakkında bilgi alabiliyoruz.

Sonda ise, bu işlemin komut bilgisi yani bu işlemin hangi komuta ait
olduğu bildiriliyor.

İşlem Kontrolü
--------------

Bash kabuğunun kontrolünde olan işlemler, bash için birer "**iş**" yani
"**job**" olarak geçiyor. Bunların yönetimi için de birkaç farklı komuta
sahibiz.

### İşi Ön Plana Almak

Arka plandaki işlemi ön plana almak için "**f**ore**g**round" ifadesinin
kısaltmasından gelen `fg` aracınıı, `fg iş-numarası` şeklinde
kullanabiliyoruz. Arka planda çalışmakta olan **firefox** işleminin,
benim kabuğumdaki iş numarası **1** olduğu için ben `fg 1` şeklinde
komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Running                 firefox &

┌──(taylan㉿linuxdersleri)-[~]
└─$ fg 1
firefox
ls
echo
```

**firefox** işlemi ön plana alındığı için kabuğa yeni komutlar veremez
olduk çünkü kabuk şu anda yalnızca firefox işlemi ile meşgul. Ön
plandaki işlemi durdurmak için Ctrl + Z tuşlaması yapabiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ fg 1
firefox
ls
echo
^Z
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Stopped                 firefox
```

Ctrl + Z ile işlemi durdurduğum için `jobs` komutunun çıktısında
"**Stopped**" yazıyor. Şu anda **firefox** işlemi durduğu için
**firefox** aracını kullanamayız. Teyit etmek isterseniz firefox aracını
kullanmayı deneyebilirsiniz.

### İşi Arka Plana Almak

Başlatılmış olan işlemleri arka plana almak için işlemi durdurduktan
sonra "**b**ack**g**round" ifadesinin kısaltmasından gelen
`bg iş-numarası` şeklinde komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ bg 1
[1]+ firefox &

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Running                 firefox &
```

Daha önce durdurmuş olduğumuz işlem, arka plana alınmasıyla birlikte
`jobs` komutunun çıktısından da teyit edebildiğimiz üzere çalışmaya
devam ediyor.

### İşi Sonlandırmak

Eğer işlemi sonlandırmak istersek "öldürmek" anlamındaki
`kill % iş-numarası` komutunu kullanabiliyoruz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ jobs                                                                     
[1]+  Running                 firefox &                                                                                                                                     
                                                                             
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ kill %1                                                                  
                                                                             
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ jobs                                                                                                                                                    
[1]+  Terminated              firefox
```

`jobs` komutunun çıktısında, "**Terminated**" yani "sonlandırılmış"
olduğunu teyit edebiliyoruz.

### İşlemlerin Durdurulması

Daha önce ele aldık ancak üstünde bir kez daha durmak istiyorum.
Çalışmakta olan bir işlemi durdurmak için Ctrl + Z kısayolunu
kullanabiliyoruz. İşlem durduktan sonra işlemin arka planda veya ön
planda çalışmaya devam etmesi için `bg` veya `fg` komutlarını
kullanabiliyoruz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox                                                                                                                                                 
^Z
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs                                                                                                                                                    
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ fg 1
firefox
[GFX1-]: Unrecognized feature VIDEO_OVERLAY
^Z
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ bg 1                                                                                                                                                    
[1]+ firefox &

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs                                                                                                                                                    
[1]+  Running                 firefox &
```

### İşin Sahiplikten Çıkarılması

Kabuk, kendi başlatmış olduğu işlemlerin sahibi(owner) konumundadır.
Dolayısıyla kabuk kapanırsa ilgili işlem de sonlandırılır. Yani biz
mevcut kabuk üzerinde arkaplanda bir işlem başlatmış olsak bile, eğer bu
kabuk kapatılırsa ilgili işlem de otomatik olarak sonlandırılıyor.

Eğer kabuğun başlatmış olduğu bir işlemi kabuğun kontrolünden çıkarmak
istersek "sahip çıkmamak-reddetmek" anlamına gelen `disown` komutunu
kullanabiliyoruz. Ben test etmek için arka planda `firefox` aracını
başlatıp daha sonra bu aracın kontrolünü bash kabuğundan kaldırmak
istiyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox &
[1] 1504

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
[1]+  Running                 firefox &

┌──(taylan㉿linuxdersleri)-[~]
└─$ disown %1

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs
```

Gördüğünüz gibi `disown` komutunun ardından, `jobs` komutunun
çıktılarında bu işi göremedik. Çünkü bash kabuğu bu işin sahipliğini
bırakmış oldu. Artık bu işlemi yönetmek için sistem genelindeki
işlemleri yönetmek üzere kullandığımız yaklaşımları uygulamamız gerek.

Çoklu İşlemler Başlatmak
------------------------

Hazır bash kabuğunda işlem başlatmak ve kontrol etmekten bahsetmişken
birden fazla işlemi nasıl başlatabileceğimize de değinelim.

Birden fazla işlemi koşullara bağlı şekilde başlatmak için bash
kabuğunun sunduğu birkaç "meta karakter" mevcut.

Mantıksal Operatörler `&` `||` `&&` `;`
---------------------------------------

Bash kabuğunun, özellikle programlama yapılırken kullanılan pek çok
operatörü bulunuyor. Operatörden kastım özel işlevleri olan yani kabuk
için özel anlama sahip olan çeşitli karakterlerdir. İşte mantıksal
operatörler de bu özel karakterlerden birkaçıdır. Mantıksal operatörler
kullanarak birden fazla işlemin mantıksal durumlara göre
çalıştırılmasını sağlayabiliyoruz.

### Ya da(veya) Operatörü ( `||` )

**Ya da** operatörü yani çift pipe "**`||`**" operatörü kullanıldığında,
ilk komut başarısız olursa ikinci komut çalıştırılır. Eğer ilk komut
başarılı olursa ikinci komut çalıştırılmaz.

Hemen uygulamalı olarak deneyelim. Ben denemek için öncelikle
`echo bir || echo iki` şeklinde yazıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo bir || echo iki
bir
```

İlk komut başarılı olduğu için ikinci komut çalıştırılmadı dolayısıyla
"**iki**" çıktısını konsolda göremiyoruz. Eğer ilk komut hatalı olsaydı
ikinci komut çalıştırılacaktı. Ben denemek için `asdf || echo iki`
komutunu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ asdf || echo iki
Command 'asdf' not found, did you mean:
  command 'sadf' from deb sysstat
  command 'adsf' from deb ruby-adsf
  command 'sdf' from deb sdf
  command 'asdfg' from deb aoeui
Try: sudo apt install <deb name>
iki
```

İlk komut hatalı olduğu için ilk komuttan sonra bu kez ikinci komut da
çalıştırıldı. İşte "ya da" operatörünü kullandığımızda başarılı komut
bulunana kadar sırasıyla komutlar çalıştırılıyor. Bir komut başarılı
sonuç döndürürse ondan sonrası çalıştırılmıyor. Emin olmak için
`asdf || xyzt || echo bir || echo iki` şeklinde komut girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ asdf || xyzt || echo bir || echo iki
Command 'asdf' not found, did you mean:
  command 'asdfg' from deb aoeui
  command 'adsf' from deb ruby-adsf
  command 'sdf' from deb sdf
  command 'sadf' from deb sysstat
Try: sudo apt install <deb name>
xyzt: command not found
bir
```

İlk iki komut yani ilk iki işlem başarısız olduğu için üçüncü komuta
geçildi ve `echo bir` komutu çalıştırıldı. Ancak üçüncü komut başarılı
olduğu için son komut yani `echo iki` çalıştırılmadı.

### Ve Operatörü ( `&&` )

**Ve** "**`&&`**" operatöründe ise "**ya da**" operatörünün tersi
şekilde, hatalı komut ile karşılaşılıncaya kadar tüm komutlar sırasıyla
çalıştırılır. Diğer bir deyişle, **`&&`** operatörü kullanıldığında
soldaki komut başarılı olursa sağdaki komut çalıştırılır. Ben denemek
için `echo bir && echo iki && asdf && echo üç` şeklinde yazıyorum ve
komutu onaylıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo bir && echo iki && asdf && echo üç                              
bir
iki
Command 'asdf' not found, did you mean:
  command 'adsf' from deb ruby-adsf
  command 'sadf' from deb sysstat
  command 'asdfg' from deb aoeui
  command 'sdf' from deb sdf
Try: sudo apt install <deb name>
```

İlk komut başarılı olduğu için ikinci komut çalıştırıldı ve ikinci komut
başarılı olduğu için de üçüncü komut çalıştırıldı. Ancak üçüncü komut
başarısız olduğu için son komut çalıştırılmadı. Bu "`&&`" mantık
operatörünü, peşi sıra kullandığınız komutlardan bir komutun hata
vermesi durumunda devam edilmesini istemediğiniz durumlarda
kullanabilirsiniz.

Örneğin güncelleme işlemi için `sudo apt update && sudo apt upgrade -y`
komutunu kullanabiliriz. Bu sayede ilk komut yani repo indexlerini
güncelleme işlemi başarılı ise yükseltme işlemi uygulanır. Eğer index
bilgileri güncellenmezse zaten paketleri yükseltme işlemi de başarısız
olacağı için ilk komut başarılı olmadan ikinci komutun çalışmasının bir
önemi yoktur. İşte sizler de tıpkı bu basit örnekte olduğu gibi
çalıştırılması için kendisinden önceki komutların başarılı olmasına
ihtiyaç duyan komutlarınız için "**ve**" "`&&`" operatörünü
kullanabilirsiniz.

### Komut Ayırıcı ( `;` )

Bash kabuğu üzerinde; önceki ya da sonraki komutun çıkış durumundan yani
hatalı ya da hatasız olmasından bağımsız olarak, komutların hepsini peş
peşe çalıştırmak için noktalı virgül `;` karakterini kullanabiliyoruz.
Komutlar arasında noktalı virgül `;` kullandığımız sürece peşi sıra
istediğimiz sayıda komut girip hepsinin soldan sağa doğru sırasıyla
çalıştırılmasını sağlayabiliriz. Ben denemek için
`echo bir ; asdf; echo iki ; xyzt ; echo üç` şeklinde komutumu
giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo bir ; asdf; echo iki ; xyzt ; echo üç                           
bir
Command 'asdf' not found, did you mean:
  command 'asdfg' from deb aoeui
  command 'sdf' from deb sdf
  command 'adsf' from deb ruby-adsf
  command 'sadf' from deb sysstat
Try: sudo apt install <deb name>
iki
xyzt: command not found
üç
```

Hatalı da olsa hatasız da olsa tüm komutlar yazıldığı gibi yani soldan
sağa doğru sırasıyla çalıştırıldı.

Ayrıca ben hep ayrı ayrı bahsettim ancak mantıksal operatörler ile komut
ayırma karakterini bir arada kullanıp özel koşul belirten komut dizesi
oluşturabilirsiniz. Örneğim ben yalnızca ilk komut yanlışsa geri kalan
tüm komutların çalıştırılması için ilk komutun ardından "**ya da**"
operatörünü kullanabilirim. Bir önceki komutun başına `asdf` ekliyorum
ve `||` operatörünü kullanıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ asdf || echo bir ; asdf; echo iki ; xyzt ; echo üç                   
Command 'asdf' not found, did you mean:
  command 'asdfg' from deb aoeui
  command 'adsf' from deb ruby-adsf
  command 'sadf' from deb sysstat
  command 'sdf' from deb sdf
Try: sudo apt install <deb name>
bir
Command 'asdf' not found, did you mean:
  command 'sadf' from deb sysstat
  command 'asdfg' from deb aoeui
  command 'sdf' from deb sdf
  command 'adsf' from deb ruby-adsf
Try: sudo apt install <deb name>
iki
xyzt: command not found
üç
```

İlk komut hatalı olduğu için geri kalan tüm komutlar sırasıyla
çalıştırıldı. İlk komutu `echo test` komutu ile değiştirelim yani ilk
komutu başarılı olacak şekilde değiştirelim ve komutu onaylayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo test || echo bir ; asdf; echo iki ; xyzt ; echo üç              
test
Command 'asdf' not found, did you mean:
  command 'sdf' from deb sdf
  command 'sadf' from deb sysstat
  command 'asdfg' from deb aoeui
  command 'adsf' from deb ruby-adsf
Try: sudo apt install <deb name>
iki
xyzt: command not found
üç
```

Şimdi de yalnızca ilk komut(`echo test`) başarılı olduğu için veya `||`
operatörünün yapısı gereği ikinci komut(`echo bir`) başarılı da olsa
çalıştırılmadı ama ondan sonrakiler noktalı virgül sayesinde yine
sırasıyla çalıştırıldı. Peki ama neden böyle oldu ?

Aslında bunun sebebi tüm komutun parça parça işleniyor olması. Yani
kabuk ilk olarak ilk koşula baktı ve ilk komut doğru olduğu için "`||`"
operatörü sebebiyle ikinci komutu çalıştırmadı. Ama bu ikinci komuttan
sonra başka bir "ya da" operatörü olmadığı için de diğer komutları
sırasıyla çalıştırdı. Eğer buradaki komutların hepsini tek bir koşula
bağlı kılmak isteseydik yani örneğin ilk komut başarısız olursa
diğerlerini çalıştır eğer ilk komut başarılı ise diğer hiç bir komutu
çalıştırma demek isteseydik **komut gruplama** özelliğini
kullanabilirdik.

Komut Gruplama
--------------

Komutları gruplamak için parantez `(komut; komut2)` içinde
yazabilirsiniz. Önceki örneğimiz üzerinden gidecek olursak, komutları
gruplamadığımızda her biri ayrı ayrı ele alınıyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo test || echo bir ; asdf; echo iki ; xyzt ; echo üç              
test
Command 'asdf' not found, did you mean:
  command 'adsf' from deb ruby-adsf
  command 'sadf' from deb sysstat
  command 'asdfg' from deb aoeui
  command 'sdf' from deb sdf
Try: sudo apt install <deb name>
iki
xyzt: command not found
üç
```

Eğer gruplayacak olursak, grup içindeki tüm komutlar tek bir koşula
bağlanabiliyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo test || (echo bir ; asdf; echo iki ; xyzt ; echo üç)            
test

┌──(taylan㉿linuxdersleri)-[~]
└─$ asdf || (echo bir ; asdf; echo iki ; xyzt ; echo üç)            
Command 'asdf' not found, did you mean:
  command 'sdf' from deb sdf
  command 'adsf' from deb ruby-adsf
  command 'sadf' from deb sysstat
  command 'asdfg' from deb aoeui
Try: sudo apt install <deb name>
bir
Command 'asdf' not found, did you mean:
  command 'adsf' from deb ruby-adsf
  command 'asdfg' from deb aoeui
  command 'sadf' from deb sysstat
  command 'sdf' from deb sdf
Try: sudo apt install <deb name>
iki
xyzt: command not found
üç
```

Gördüğünüz gibi ilk girdiğimizde komutta "`||`" operatörü bulunduğundan,
ilk komut başarılı olduğu için gruptakiler çalıştırılmadı. İkinci
komutta ise, ilk komut başarısız olduğu için gruptaki komutlar
çalıştırıldı.

Sistem Genelindeki İşlemlerin Kontrolü
--------------------------------------

Şimdiye kadar ele aldığımız örneklerde hep bash kabuğu tarafından
başlatılan ve kontrol edilen işlemleri gördük. Fakat sistemdeki tüm
işlemler elbette bash kabuğu tarafından başlatılmıyor. Dolayısıyla
sistemi yönetebilmek için sistem genelinde başlatılmış olan işlemleri de
kontrol edebiliyor olmamız şart.

İşlemlerin Takibi
-----------------

İşlemleri yönetebilmek için öncelikle varlıklarından haberdar olmamız
gerek.

Anlık Takip \| `top`
--------------------

Sistem üzerinde çalışmakta olan işlemleri anlık olarak takip etmek üzere
`top` aracını kullanabiliyoruz.

``` {.yaml}
top - 06:18:00 up  1:21,  1 user,  load average: 0.05, 0.03, 0.00
Tasks: 169 total,   1 running, 168 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.7 us,  0.8 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  10688.6 total,   9663.9 free,    580.3 used,    444.4 buff/cache
MiB Swap:    975.0 total,    975.0 free,      0.0 used.   9848.9 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                              
    615 root      20   0  424836 126756  57780 S   4.3   1.2   0:14.63 Xorg                                                                                 
    999 taylan    20   0  420700  95376  74964 S   2.3   0.9   0:00.79 qterminal                                                                            
    821 taylan    20   0    9616   5372   4316 S   0.3   0.0   0:00.77 dbus-daemon                                                                          
    898 taylan    20   0  218440   2728   2240 S   0.3   0.0   0:19.50 VBoxClient                                                                           
    949 taylan    20   0 1065696  88752  65972 S   0.3   0.8   0:08.14 xfwm4                                                                                
    988 taylan    20   0  343196  26244  16996 S   0.3   0.2   0:00.16 Thunar                                                                               
   1000 taylan    20   0  209228  32484  19032 S   0.3   0.3   0:17.25 panel-13-cpugra                                                                      
   1109 taylan    20   0  373832  51812  29388 S   0.3   0.5   0:00.64 blueman-applet                                                                       
  20219 taylan    20   0   10200   3724   3092 R   0.3   0.0   0:00.03 top                                                                                  
      1 root      20   0  165520  11284   8288 S   0.0   0.1   0:01.42 systemd                                                                              
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.03 kthreadd                                                                             
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                                               
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp                                                                           
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0:0H-events_highpri                                                          
      9 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 mm_percpu_wq                                                                         
     10 root      20   0       0      0      0 S   0.0   0.0   0:00.00 rcu_tasks_rude_                                                                      
     11 root      20   0       0      0      0 S   0.0   0.0   0:00.00 rcu_tasks_trace                                                                      
     12 root      20   0       0      0      0 S   0.0   0.0   0:00.03 ksoftirqd/0                                                                          
     13 root      20   0       0      0      0 I   0.0   0.0   0:01.98 rcu_sched                                                                            
     14 root      rt   0       0      0      0 S   0.0   0.0   0:00.12 migration/0                                                                          
     15 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/0                                                                              
     16 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/1                                                                              
     17 root      rt   0       0      0      0 S   0.0   0.0   0:00.91 migration/1                                                                          
     18 root      20   0       0      0      0 S   0.0   0.0   0:00.04 ksoftirqd/1                                                                          
     20 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/1:0H-events_highpri                                                          
     21 root      20   0       0      0      0 S   0.0   0.0   0:00.00 cpuhp/2                                                                              
     22 root      rt   0       0      0      0 S   0.0   0.0   0:00.84 migration/2                                                                          
     23 root      20   0       0      0      0 S   0.0   0.0   0:00.18 ksoftirqd/2                                                                          
     25 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/2:0H-events_highpri                                                          
     29 root      20   0       0      0      0 S   0.0   0.0   0:00.02 kdevtmpfs
```

Biz q tuşuna basıp aracı kapatana kadar anlık olarak tüm işlemler
konsola bastırılıyor olacak.

Tablodaki temel sütunları açıklayacak olursak:

**PID:** **P**rocess **id** yani benzersiz işlem numarasıdır.

**USER:** İşlemin sahibi olan kullanıcıdır.

**PR:** Priority yani işlem önceliğini belirtir.

**NI:** İşlemin "nice" değeri. Diğer işlemlere ne kadar öncelik
vereceğini belirtir.

**S:** Status yani "durum" bilgisidir. Çeşitli durumlar mevcuttur:

-   
      'T' = traced or stopped   durdurulmuş
      ------------------------- -------------

**%CPU**: İşlem tarafından kullanılan CPU yüzdesi

**%MEM**; İşlem tarafından kullanılan RAM yüzdesi.

**TIME+:** İşlem tarafından tüketilen CPU zamanı.

**Command**: İşlemi başlatan komut.

Bu listede gezinmek için aşağı yukarı yön tuşlarını kullanabilirsiniz.
Ayrıca bir işlemi sonlandırmak için o işlemin üzerine geldikten sonra
"**k**ill" yani "öldürmek" ifadesinden gelen k tuşuna basıp enter ile
işlemin sonlandırılmasına onay verebilirsiniz. Fakat bu liste sürekli
güncellendiği için işlemlerin bu liste üzerinden sonlandırılması pek
pratik sayılmaz. Eğer araçtan çıkış yapmak isterseniz de q tuşuna
basmanız yeterli.

Esasen `top` aracı dışında çok daha işlevsel olan `htop` gibi çeşitli
araçları kurup kullanabilirsiniz fakat biz her sistemde varsayılan
olarak karşılaşabileceğimiz temel araç olduğu için yalnızca `top`
aracına değindik. Zaten diğer araçlar da benzer değerleri sunuyor, ek
olarak ek detaylar ve bazı kontrol imkanları sunuluyor.

Yine de işlemlerin anlık takibi ve temel bilgi edinme için `top` aracı
son derece işlevsel bir bilgi alma aracı. Tabloda yer alan detaylar şu
an sizin için pek anlamlı gelmemiş olabilir. İleride işlemleri daha
yakından tanıdıkça buradaki bilgilerin kıymeti daha net anlaşılacak.

`ps` Komutu
-----------

`ps` komutu "**p**rocess **s**tatus" yani "işlem durumu" ifadesinin
kısaltmasından gelen işlemler hakkında bilgi sunan bir araçtır.

Tek başına `ps` komutunu girdiğimizde, yalnızca o anda mevcut konsol
üzerinde çalışmakta olan işleme dair bilgi sunar.

``` {.objectivec}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ps                                                                                                                                                      
    PID TTY          TIME CMD
   1224 pts/0    00:00:00 bash
  24844 pts/0    00:00:00 ps
```

Bash kabuğuna `ps` komutunu girdiğimiz için bu çıktıyı aldık. Yani
komutu girdiğimiz anda bu işlemler çalışıyordu. Buradaki sütunların
anlamlarını açıklayacak olursak:

**PID:** benzersiz işlem numarasını

**TTY:** işlemlerin çalıştığı konsolun ismi

**TIME:** işlemin çalıştığı toplam süre

**CMD:** işlemi başlatan komutun adı

`ps` aracı anlık olarak çalıştığı için **TIME** yani süre bilgisiyle
kayda değer bir bilgi almamız pek olası olmasa da `ps` aracının en temel
çıktıları bu şekilde.

Manual sayfalarına bakacak olursanız `ps` aracının pek çok ek seçeneği
olduğunu görebilirsiniz. Hepsine tek tek değinmemize gerek yok. İhtiyaç
duyduğunuz özel bilgiler için uygun olan seçeneği araştırıp
kullanabilirsiniz. Biz birkaç temel örnekle ilerleyelim.

Geniş çaplı bilgi almak için genellikle `ps aux` komutu kullanılır.

`a`: tüm kullanıcılara ait olan işlemleri listeler.

`u`: işlemlerin sahibi olan kullanıcı bilgisini bastırır.

`x`: terminaller ile kontrol edilmeyen arka plan işlemlerini de
bastırmayı sağlar.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ps aux                                                                                                                                                  
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.1 165520 11284 ?        Ss   04:56   0:01 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    04:56   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   04:56   0:00 [rcu_gp]
root           4  0.0  0.0      0     0 ?        I<   04:56   0:00 [rcu_par_gp]
root           6  0.0  0.0      0     0 ?        I<   04:56   0:00 [kworker/0:0H-events_highpri]
root           9  0.0  0.0      0     0 ?        I<   04:56   0:00 [mm_percpu_wq]
root          10  0.0  0.0      0     0 ?        S    04:56   0:00 [rcu_tasks_rude_]
root          11  0.0  0.0      0     0 ?        S    04:56   0:00 [rcu_tasks_trace]
root          12  0.0  0.0      0     0 ?        S    04:56   0:00 [ksoftirqd/0]
message+     521  0.0  0.0  10476  5536 ?        Ss   04:57   0:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activatio
root         522  0.0  0.1 259004 18916 ?        Ssl  04:57   0:00 /usr/sbin/NetworkManager --no-daemon
root         524  0.0  0.1 236400 11340 ?        Ssl  04:57   0:00 /usr/libexec/polkitd --no-debug
root         525  0.0  0.0 221740  6304 ?        Ssl  04:57   0:00 /usr/sbin/rsyslogd -n -iNONE
root         526  0.0  0.0  23436  7444 ?        Ss   04:57   0:00 /lib/systemd/systemd-logind
root         573  0.0  0.1 243152 11660 ?        Ssl  04:57   0:00 /usr/sbin/ModemManager
root         587  0.0  0.0 309144  7620 ?        SLsl 04:57   0:00 /usr/sbin/lightdm
root         594  0.0  0.0 294012  3324 ?        Sl   04:57   0:01 /usr/sbin/VBoxService
root         615  0.4  1.2 429388 131352 tty7    Ssl+ 04:57   0:28 /usr/lib/xorg/Xorg :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novts
root         616  0.0  0.0   5872  1024 tty1     Ss+  04:57   0:00 /sbin/agetty -o -p -- \u --noclear - linux
root         628  0.0  0.0      0     0 ?        I    04:57   0:01 [kworker/0:3-events]
rtkit        739  0.0  0.0  22640  1548 ?        SNsl 04:57   0:00 /usr/libexec/rtkit-daemon
root         796  0.0  0.0 164744  8968 ?        Sl   04:59   0:00 lightdm --session-child 14 23
colord      1160  0.0  0.1 242696 13120 ?        Ssl  04:59   0:00 /usr/libexec/colord
taylan      1163  0.0  0.0 234804  8880 ?        Ssl  04:59   0:00 /usr/libexec/gvfs-gphoto2-volume-monitor
taylan      1175  0.0  0.0 311228  7680 ?        Ssl  04:59   0:00 /usr/libexec/gvfs-afc-volume-monitor
taylan      1184  0.0  0.0 233852  6412 ?        Ssl  04:59   0:00 /usr/libexec/gvfs-mtp-volume-monitor
taylan      1193  0.0  0.0 312084  7984 ?        Sl   04:59   0:00 /usr/libexec/gvfsd-trash --spawner :1.15 /org/gtk/gvfs/exec_spaw/0
taylan      1205  0.0  0.0 160304  5712 ?        Ssl  04:59   0:00 /usr/libexec/gvfsd-metadata
taylan      1224  0.0  0.0   8216  4940 pts/0    Ss   04:59   0:00 /usr/bin/bash
taylan      1263  0.0  0.0  45204  7116 ?        Ss   04:59   0:00 /usr/libexec/bluetooth/obexd
root        3636  0.0  0.0      0     0 ?        I    05:09   0:00 [kworker/1:0-cgroup_destroy]
root       20069  0.0  0.0      0     0 ?        I    06:17   0:01 [kworker/1:2-events]
root       20118  0.0  0.0      0     0 ?        I    06:17   0:00 [kworker/2:3-ata_sff]
root       21448  0.0  0.0      0     0 ?        R    06:22   0:00 [kworker/u6:0-events_unbound]
taylan     22895  0.0  0.8 418380 93196 ?        Sl   06:28   0:00 /usr/bin/qterminal
taylan     22898  0.0  0.0   8092  4860 pts/1    Ss+  06:28   0:00 /usr/bin/bash
root       24228  0.0  0.0      0     0 ?        I    06:34   0:00 [kworker/u6:2-events_unbound]
root       25535  0.0  0.0      0     0 ?        I    06:39   0:00 [kworker/0:1]
root       26392  0.0  0.0      0     0 ?        I    06:42   0:00 [kworker/2:1-events]
root       26920  0.0  0.0      0     0 ?        I    06:45   0:00 [kworker/u6:1-flush-8:0]
root       26921  0.0  0.0      0     0 ?        I    06:45   0:00 [kworker/u6:3-flush-8:0]
root       27556  0.0  0.0      0     0 ?        I    06:47   0:00 [kworker/1:1-events]
root       27646  0.0  0.0      0     0 ?        I    06:48   0:00 [kworker/2:0-ata_sff]
taylan     27840  0.0  0.0   9768  1580 pts/0    R+   06:48   0:00 ps aux
```

İşlemlerin Yönetimi \| Sinyaller
--------------------------------

Linux üzerinde, işlemlerle iletişim kurmak için sinyalleri kullanıyoruz.
Dolayısıyla bir işlemi durdurmak, duran işlemi devam ettirmek veya
işlemi sonlandırmak istediğimizde ilgili işleme bu duruma uygun olan
sinyali göndermemiz gerekiyor. Sinyal göndermek için de `kill` komutunu
kullanabiliyoruz.

`kill` Komutu \| Sinyal Gönderimi
---------------------------------

`kill` komutu ile gönderebileceğimiz tüm sinyalleri görmek için
`kill -l` komutunu kullanabiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

Elbette temel sistem yönetimi için buradaki tüm sinyallere ihtiyacımız
yok. Biz yaygın kullanıma sahip temel sinyalleri ele alacağız.

-   **`SIGKILL`** (9): Öldürme sinyali. Hedef işlemin anında
    sonlandırılmasını sağlar. Genellikle bir işlemi zorla sonlandırmak
    için son çare olarak kullanılır.
-   **`SIGSTOP`** (19): Durdurma sinyali. Hedef işlemin askıya alınarak
    durdurulmasını sağlar. Ctrl + Z kısayoluyla da bu sinyal
    üretilebiliyor.
-   **`SIGCONT`** (18): Devam sinyali. Daha önce durdurulan bir işlemin
    çalışmaya devam etmesini sağlıyor.

Sistem genelindeki işlemleri yönetirken bu sinyalleri bilmemiz yeterli.

### İşlemi Durdurmak \| SIGSTOP

Çalışmakta olan bir işlemi durdurmak için sinyalın ismini ya da sayısal
karşılığını `kill SIGSTOP pid` ya da `kill -19 pid` şeklinde
girebiliyoruz. Denemek için öncelikle grafiksel arayüzeden bir metin
editörü açalım. Benim sistemimde **mousepad** olduğu için ben bu aracı
çalıştırıyorum fakat siz herhangi bir aracı örnek olarak
çalıştırabilirsiniz. Aracı açtıktan sonra bu aracın işlem numarasını
öğrenmek için `ps x` komutunu girip sondaki çıktılara bakabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x                                                                                                                                                     
    PID TTY      STAT   TIME COMMAND
    797 ?        Ss     0:00 /lib/systemd/systemd --user
    798 ?        S      0:00 (sd-pam)
    812 ?        S<sl   0:00 /usr/bin/pipewire
    813 ?        Ssl    0:00 /usr/bin/pipewire-media-session
    814 ?        S<sl   0:00 /usr/bin/pulseaudio --daemonize=no --log-target=journal
    817 ?        Ss     0:01 /usr/bin/dbus-daemon --session --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
    825 ?        Ssl    0:00 xfce4-session
...
..
.    
34680 ?        Sl     0:00 mousepad
  34710 pts/0    R+     0:00 ps x
```

Gördüğünüz gibi benim açtığım işlem **34680** pid ile başlatılmış. Bu
işlem numarası sayesinde, bu işleme istediğim sinyali gönderebilirim.
Ben durdurmak istediğim için `kill -19 34680` şeklinde komutumu
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ kill -19 34680
```

Bu komutun ardından aracınıza dönüp aracı kullanmayı deneyebilirsiniz
fakat işlem durdurulduğu için elbette araç size yanıt vermeyecektir.

Ayrıca örneğin mevcut kabuk üzerinden ön planda çalışan bir işlem
başlattıysanız bu işlemi durdurmak için Ctrl + Z tuşlamasını da
kullanabilirsiniz. Bu tuşlama kabuk üzerinde çalışmakta olan işleme
**SIGSTOP** sinyali gönderip duraklatılmasını sağlıyor. Ben denemek için
konsola `firefox` komutunu girip mevcut kabuğa bağlı ön planda yeni bir
işlem başlatacağım. Daha sonra Ctrl + Z tuşlaması ile bu işlemi de
durduracağım.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ firefox                                                                                                                                                  
[GFX1-]: Unrecognized feature VIDEO_OVERLAY
^Z
[1]+  Stopped                 firefox

┌──(taylan㉿linuxdersleri)-[~]
└─$ jobs                                                                                                                                                     
[1]+  Stopped                 firefox
```

Gördüğünüz gibi kabuğun başlattığı işlem kabuğa bağlı ve ön planda
çalıştığı için normalde mevcut kabuk üzerinden bu işleme sinyal
göndermek üzere komut girmem mümkün değil. Bu sebeple Ctrl + Z kısayolu
ile bu ön plandaki işleme, durdurma sinyali gönderebilme çözümü
geliştirilmiş. Zaten daha önce iş kontrolünü ele alırken de bu yaklaşımı
kullanmıştık. Şimdi sinyallerden haberimiz olduğu için bu kısayol çok
daha anlamlı hale geldi.

### Durdurulmuş İşlemin Devam Ettirilmesi \| SIGCONT

Durdurulmuş işlemi devam ettirmek için **SIGCONT** veya sinyalin sayısal
karşılığı olan **18** sayısını kullanabiliyoruz. Ben durdurmuş olduğum
işlemi devam ettirmek için komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ kill -SIGCONT 34680
```

İşlemin devam ettiğini teyit etmek isterseniz ilgili aracı kullanmayı
deneyebilirsiniz. Denediğinizde aracı temsil eden işlem devam ettiği
için aracı kullanabildiğinizi bizzat görmüş olacaksınız.

### Sonlandırmak - Öldürmek \| SIGKILL

Eğer işlemi ani olarak kapatmak veya kapanmaya zorlamak istersek
**SIGKILL** sinyalini kullanabiliyoruz. Ben açık olan **mousepad**
editörünü temsil eden işlemi kapatmak üzere sinyal gönderiyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ kill -9 34680

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x | tail
   1167 ?        Ssl    0:00 /usr/libexec/gvfs-goa-volume-monitor
   1174 ?        Ssl    0:00 /usr/libexec/gvfs-gphoto2-volume-monitor
   1182 ?        Ssl    0:00 /usr/libexec/gvfs-afc-volume-monitor
   1187 ?        Ssl    0:00 /usr/libexec/gvfs-mtp-volume-monitor
   1196 ?        Sl     0:00 /usr/libexec/gvfsd-trash --spawner :1.15 /org/gtk/gvfs/exec_spaw/0
   1209 ?        Ssl    0:00 /usr/libexec/gvfsd-metadata
   1220 pts/0    Ss     0:00 /usr/bin/bash
   1258 ?        Ss     0:00 /usr/libexec/bluetooth/obexd
  45459 pts/0    R+     0:00 ps x
  45460 pts/0    S+     0:00 tail
```

Gördüğünüz gibi **SIGKILL** sinyalini temsil eden `-9` argümanını
girdiğim için ilgili işlem anında kapatıldı.

`killall` ve `pgrep` Araçlarının Kullanımı
------------------------------------------

Sinyal göndermek için ilgili işlemin benzersiz işlem numarasını yani
**pid** değerini bulmamız gerekiyor. Fakat sistem üzerinde çok fazla
işlem aynı anda çalıştığı için bu pek pratik bir yaklaşım sayılmaz. Bize
bu konuda kolaylıklar sunan çeşitli araçlar mevcut.

`killall` Komutu
----------------

`killall` komutu sayesinde argüman olarak verdiğimiz isimle eşleşen tüm
işlemler sonlandırılıyor. Bu sayede tek tek hepsinin **pid** değerlerini
bulmamız gerekmiyor.

Ben denemek için arka planda birden fazla `sleep` komutunun çalışması
için `sleep 1000 & sleep 400 & sleep 200 &` komutunu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sleep 1000 & sleep 400 & sleep 200 &
[1] 60387
[2] 60388
[3] 60389

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x | tail
   1187 ?        Ssl    0:00 /usr/libexec/gvfs-mtp-volume-monitor
   1196 ?        Sl     0:00 /usr/libexec/gvfsd-trash --spawner :1.15 /org/gtk/gvfs/exec_spaw/0
   1209 ?        Ssl    0:00 /usr/libexec/gvfsd-metadata
   1220 pts/0    Ss     0:00 /usr/bin/bash
   1258 ?        Ss     0:00 /usr/libexec/bluetooth/obexd
  60387 pts/0    S      0:00 sleep 1000
  60388 pts/0    S      0:00 sleep 400
  60389 pts/0    S      0:00 sleep 200
  60572 pts/0    R+     0:00 ps x
  60573 pts/0    S+     0:00 tail
```

Gördüğünüz gibi `sleep` isimli birden fazla işlem mevcut. Eğer bunları
sonlandırmak istersek, tek tek `kill` komutuna **pid** değerlerini
argüman olarak verebiliriz.

Bunun yerine `killall -9 sleep` komutunu kullanacak olursak, `sleep` ile
eşleşen tüm işlemler sonlandırılacak.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ killall -9 sleep                                                                                                                                         
[1]   Killed                  sleep 1000

[2]-  Killed                  sleep 400
[3]+  Killed                  sleep 200
┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x | tail                                                                                                                                         
   1167 ?        Ssl    0:00 /usr/libexec/gvfs-goa-volume-monitor
   1174 ?        Ssl    0:00 /usr/libexec/gvfs-gphoto2-volume-monitor
   1182 ?        Ssl    0:00 /usr/libexec/gvfs-afc-volume-monitor
   1187 ?        Ssl    0:00 /usr/libexec/gvfs-mtp-volume-monitor
   1196 ?        Sl     0:00 /usr/libexec/gvfsd-trash --spawner :1.15 /org/gtk/gvfs/exec_spaw/0
   1209 ?        Ssl    0:00 /usr/libexec/gvfsd-metadata
   1220 pts/0    Ss     0:00 /usr/bin/bash
   1258 ?        Ss     0:00 /usr/libexec/bluetooth/obexd
  61079 pts/0    R+     0:00 ps x
  61080 pts/0    S+     0:00 tail
```

`killall` komutunun en temel kullanımı bu şekilde. Eğer yardım çıktılara
göz atacak olursanız aslında çeşitli filtreler için çeşitli seçenekler
sunulduğunu da görebilirsiniz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ killall --help
Usage: killall [OPTION]... [--] NAME...
       killall -l, --list
       killall -V, --version

  -e,--exact          require exact match for very long names
  -I,--ignore-case    case insensitive process name match
  -g,--process-group  kill process group instead of process
  -y,--younger-than   kill processes younger than TIME
  -o,--older-than     kill processes older than TIME
  -i,--interactive    ask for confirmation before killing
  -l,--list           list all known signal names
  -q,--quiet          don't print complaints
  -r,--regexp         interpret NAME as an extended regular expression
  -s,--signal SIGNAL  send this signal instead of SIGTERM
  -u,--user USER      kill only process(es) running as USER
  -v,--verbose        report if the signal was successfully sent
  -V,--version        display version information
  -w,--wait           wait for processes to die
  -n,--ns PID         match processes that belong to the same namespaces
                      as PID
  -Z,--context REGEXP kill only process(es) having context
                      (must precede other arguments)
```

Bu seçeneklerden ihtiyacınıza göre filtreleme yapmanız mümkün. Örneğin
spesifik bir kullanıcının başlatmış olduğu işlemleri temsil etmek için
`-u` seçeneğini kullanabilirsiniz.

Ben denemek için "nil" isimli kullanıcı hesabına geçiş yapıp çeşitli
işlemler başlatıyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su nil
Password: 
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ sleep 1000 & sleep 500 & sleep 250&
[4] 62272
[5] 62273
[6] 62274

┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ nano &
[7] 62324

┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ vi &
[8] 62337

[7]+  Stopped                 nano
```

Şimdi kendi konsoluma dönüp **nil** kullanıcısına ait olan işlemleri
listeleyebilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ps -u nil                                                                                                                                
    PID TTY          TIME CMD
  61798 pts/1    00:00:00 bash
  62272 pts/1    00:00:00 sleep
  62273 pts/1    00:00:00 sleep
  62274 pts/1    00:00:00 sleep
  62324 pts/1    00:00:00 nano
  62337 pts/1    00:00:00 vi
```

Bakın hem birden fazla `sleep` hem de `nano` ve `vi` işlemleri **nil**
kullanıcısı tarafından çalıştırılmış. Şimdi ben **taylan** kullanıcısı
olarak `sleep 700 & sleep 350&` komutları ile kendi kullanıcı hesabım
üzerinden arka planda iki `sleep` işlemi daha başlatıyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sleep 700 & sleep 350&                                                                                                                                   
[1] 62872
[2] 62873

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps aux | tail                                                                                                                                            
nil        62272  0.0  0.0   5464   860 pts/1    S    10:10   0:00 sleep 1000
nil        62273  0.0  0.0   5464   880 pts/1    S    10:10   0:00 sleep 500
nil        62274  0.0  0.0   5464   892 pts/1    S    10:10   0:00 sleep 250
nil        62324  0.0  0.0   6752  3028 pts/1    T    10:10   0:00 nano
nil        62337  0.0  0.0  14448  9228 pts/1    T    10:10   0:00 vi
root       62531  0.0  0.0      0     0 ?        I    10:11   0:00 [kworker/1:2-events]
taylan     62872  0.0  0.0   5464   912 pts/0    S    10:12   0:00 sleep 700
taylan     62873  0.0  0.0   5464   892 pts/0    S    10:12   0:00 sleep 350
taylan     62890  0.0  0.0   9768  1592 pts/0    R+   10:12   0:00 ps aux
taylan     62891  0.0  0.0   5496   932 pts/0    S+   10:12   0:00 tail
```

Şimdi ben yalnızca **nil** kullanıcısına ait olan `sleep` işlemlerini
sonlandırmak istersem `sudo killall -u nil sleep` şeklinde komutumu
girebilirim. Komutu **taylan** kullanıcısı olarak girdiğim için `sudo`
ile yetkimi kanıtlamam gerek.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo killall -u nil sleep

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps aux | tail                                                                                                                                
root       61793  0.0  0.0  11108  4784 pts/1    S    10:08   0:00 su nil
nil        61798  0.0  0.0   8732  5364 pts/1    S+   10:08   0:00 bash
root       62028  0.0  0.0      0     0 ?        I    10:09   0:00 [kworker/0:0-events]
nil        62324  0.0  0.0   6752  3028 pts/1    T    10:10   0:00 nano
nil        62337  0.0  0.0  14448  9228 pts/1    T    10:10   0:00 vi
root       62531  0.0  0.0      0     0 ?        I    10:11   0:00 [kworker/1:2-events]
taylan     62872  0.0  0.0   5464   912 pts/0    S    10:12   0:00 sleep 700
taylan     62873  0.0  0.0   5464   892 pts/0    S    10:12   0:00 sleep 350
taylan     63024  0.0  0.0   9768  1588 pts/0    R+   10:13   0:00 ps aux
taylan     63025  0.0  0.0   5496   932 pts/0    S+   10:13   0:00 tail
```

Gördüğünüz gibi yalnızca "**nil**" kullanıcısına ait olan `sleep`
işlemleri sonlandırılmış. Neticede `killall` komutunun farklı kriterlere
göre filtreleme yaptığını bizzat görmüş olduk.

Elbette ben `killall` komutunun tüm seçeneklerini tek tek ele
almayacağım. Kullanımı son derece kolay olduğu için kısa bir deneme
yanılma ile kendiniz de gerektiğinde diğer tüm seçenekleri
keşfedebilirsiniz.

`pgrep` Komutu
--------------

Metinsel verileri filtrelemek için `grep` aracını kullanabiliyoruz.
`pgrep` komutu ise "**p**rocess" yani "işlemler" arasında bizim
aradığımız işlemin, işlem numarasını filtreleyen bir araç. Bu sayede
ilgili işlemin işlem numarasını manuel olarak bulmakla uğraşmamız
gerekmiyor. İsmi üzerinden kolaylıkla öğrenebiliyoruz.

Ben denemek için grafiksel arayüzden **firefox** aracını çalıştırıp, bu
işlemin **pid** değerini öğrenmek için `pgrep firefox` komutunu
giriyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ pgrep firefox                                                                                                                                            
64622

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x | tail
   1220 pts/0    Ss     0:00 /usr/bin/bash
   1258 ?        Ss     0:00 /usr/libexec/bluetooth/obexd
  61768 pts/1    Ss     0:00 /usr/bin/bash
  62872 pts/0    S      0:00 sleep 700
  64622 ?        Sl     0:04 /usr/lib/firefox-esr/firefox-esr
  64774 ?        Sl     0:00 /usr/lib/firefox-esr/firefox-esr -contentproc -childID 2 -isForBrowser -prefsLen 4657 -prefMapSize 238089 -jsInit 285716 -parentBuildID 20220105212146 -appdir /usr/lib/firefox-esr/browser 64622 true tab
  64810 ?        Sl     0:00 /usr/lib/firefox-esr/firefox-esr -contentproc -childID 3 -isForBrowser -prefsLen 5317 -prefMapSize 238089 -jsInit 285716 -parentBuildID 20220105212146 -appdir /usr/lib/firefox-esr/browser 64622 true tab
  64856 ?        Sl     0:00 /usr/lib/firefox-esr/firefox-esr -contentproc -childID 5 -isForBrowser -prefsLen 5317 -prefMapSize 238089 -jsInit 285716 -parentBuildID 20220105212146 -appdir /usr/lib/firefox-esr/browser 64622 true tab
  64948 pts/0    R+     0:00 ps x
  64949 pts/0    S+     0:00 tail
```

**firefox** ismiyle eşleşen ilk işlemin işlem numarası getirilmiş oldu.
Bu şekilde isimleri üzerinden işlemlerin benzersiz işlem numaralarına
erişebiliyoruz. Bu komut genellikle komut ikamesiyle birlikte işlemleri
sonlandırmak için kullanıyor. Örneğin ben bulduğum bu işlemi
sonlandırmak istersem `kill -9 $(pgrep firefox)` şeklinde komutumu
girebilirim. Komut ikamesi içindeki `pgrep firefox` komutu "**firefox**"
işleminin **pid** değerini bulup, `kill` komutuna argüman olarak
vereceği için bu işlem sonlandırılacak.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ kill -9 $(pgrep firefox)

┌──(taylan㉿linuxdersleri)-[~]
└─$ ps x | tail                                                                                                                                 
   1182 ?        Ssl    0:00 /usr/libexec/gvfs-afc-volume-monitor
   1187 ?        Ssl    0:00 /usr/libexec/gvfs-mtp-volume-monitor
   1196 ?        Sl     0:00 /usr/libexec/gvfsd-trash --spawner :1.15 /org/gtk/gvfs/exec_spaw/0
   1209 ?        Ssl    0:00 /usr/libexec/gvfsd-metadata
   1220 pts/0    Ss     0:00 /usr/bin/bash
   1258 ?        Ss     0:00 /usr/libexec/bluetooth/obexd
  61768 pts/1    Ss     0:00 /usr/bin/bash
  62872 pts/0    S      0:00 sleep 700
  65636 pts/0    R+     0:00 ps x
  65637 pts/0    S+     0:00 tail
```

Gördüğünüz gibi tam da tarif ettiğimiz gibi, `pgrep` aracının bulduğu
işlem numarası komut ikamesi yardımıyla `kill` aracına argüman olarak
verildiği için ilgili işlem sonlandırıldı.

Sizin de fark etmiş olabileceğiniz gibi bu yaklaşım aslında `killall`
komutu ile aynı işlevi görüyor. Yine de daha önce ele aldığımız komut
ikamesi yaklaşımını da hatırlamak için özellikle bu yöntemi ele almak
istedim.

İşlemlerin Öncelik Sırası \| `nice` \| `renice`
-----------------------------------------------

Temel sistem yönetiminde çok sık kullanmanız gerekmeyeceği ve anlatımı
temel seviye dışına çıkabileceği için bu eğitimde **nice** ve **renice**
kavramlarından bahsetmeyi planlamıyorum. Fakat bu açıklamayı yapıyor
olmamdan da anlaşılabileceği gibi, meraklı olan saygıdeğer okuyucularımı
bu konuları araştırmaya sevk ettiğimi de belirtmek isterim. En azından
bir göz atsanız hiç de fena olmaz :)

En nihayetinde Linux üzerinde işlem yönetimi için bilmemiz gereken en
temel yaklaşımları ele aldık. Elbette tüm anlatımlar bunlardan ibaret
değil fakat, giriş seviyesi için diğer detaylar biraz kafa karıştırıcı
ve anlamsız olabilir. Bu sebeple işlemler konusunda bu kadarlık bilginin
eğitime devam etmemize yeteceğini düşündüğüm için bir sonraki bölüme
"servis yönetimi" ile devam ediyor olacağız.

tmux
----

`tmux` aracı konsol üzerindeki verimliliğimizi artıran bir araç.
Doğrudan "işlem yönetimi" ile ilgili olmasa da diğer bölümlere nazaran
bu bölümde ele almanın daha uygun olacağını düşündüm.

`tmux` sayesinde tek bir konsol oturumunu birden fazla parçaya bölüp
kullanabiliyoruz. Bu araç varsayılan olarak yüklü gelmediği için
`sudo apt install tmux` ya da `sudo dnf install tmux` komutu ile
kurabilirsiniz.

``` {.java}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt install tmux
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following NEW packages will be installed:
  tmux
0 upgraded, 1 newly installed, 0 to remove and 1827 not upgraded.
Need to get 455 kB of archives.
After this operation, 1,137 kB of additional disk space will be used.
Get:1 http://kali.download/kali kali-rolling/main amd64 tmux amd64 3.3a-4 [455 kB]
Fetched 455 kB in 14s (32.1 kB/s)
Selecting previously unselected package tmux.
(Reading database ... 291994 files and directories currently installed.)
Preparing to unpack .../archives/tmux_3.3a-4_amd64.deb ...
Unpacking tmux (3.3a-4) ...
Setting up tmux (3.3a-4) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for kali-menu (2021.4.2) ...
```

Aracımız kurulduktan sonra `tmux` komutu ile başlatabiliyoruz.

![tmux.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux.webp)

`tmux` komutunu girdikten sonra, **tmux** oturumunda bash kabuğu
çalıştırılıyor. Bu araç üzerinden komutlarımızı girebiliyoruz. Dilersek
dikey ve yatay olarak yeni konsol oturumları eklememiz mümkün. `tmux`
kısayollarını kullanabilmek için öncelikle Ctrl + B tuşuna basıyoruz.
Daha sonra dikey olarak yeni konsol ekleyeceksek yüzde işareti % tuşuna
basıyoruz.

![tmux-vertical.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-vertical.webp)

Eğer yatay olarak bölüp yeni konsol oturumu eklenecekse Ctrl + B tuşuna
bastıktan sonra tırnak işaretini " oluşturan tuşa basıyoruz.

![tmux-horizontal.webp](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-horizontal.webp)

Bu konsollar arasında geçiş yapmak için Ctrl + B tuşuna bastıktan sonra
klavyemizdeki sağ sol yön tuşları ile ilgili konsol oturumuna geçiş
yapabiliyoruz. Zaten hangi konsolda olduğunuzu, pencereleri birbirinden
ayıran renkli çizgi sayesinde takip edebilirsiniz.

![tmux-new-sessions.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-new-sessions.gif)

Eğer bir oturumu sonlandırmak istiyorsanız üzerinde bulunduğunuz `tmux`
oturumunu `exit` komutunu girerek kapatabilirsiniz.

![tmux-exit.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-exit.gif)

Konsol oturumunu sonlandırmak yerine, ilgili konsolun arkaplanda
çalışmaya devam etmesini sağlayıp, bu konsol oturumundan geçici
süreliğine ayrılmanız da mümkün. Örneğin ben denemek için `tmux`
komutunu girip yeni bir konsol oturumu başlatıyorum. Ve bu oturumda
`top` komutunu çalıştırıyorum. Normalde eğer konsol kapanacak olursa bu
`top` aracı da kapanacağı için çalışmayı sürdürmeyecek. Fakat ben
oturumu tamamen kapatmak yerine oturumdan ayrılmak için Ctrl + B
tuşlamasını yapıp D tuşuna basıyorum. Buradaki D tuşu "**detach**" yani
"**ayırmak**" ifadesinden gelen bir kısaltma. Bu sayede konsoldaki hiç
bir işlem sonlandırılmadan biz konsoldan ayrılmış oluyoruz. Ayrıldığımız
oturumları görmek için de `tmux list-sessions` komutunu kullanıyoruz.

![tmux-detach.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-detach.gif)

Ayrıldığımız oturumlara geri dönmek için `tmux attach` komutunu
kullanabiliyoruz.

![tmux-attach.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-attach.gif)

Eğer ayrıldığımız birden fazla oturum varsa geçiş yapmak istediğimiz
oturumu `tmux attach -t oturum-sayısı` komutuyla özel olarak belirtmemiz
gerekiyor.

![tmux-multi-sessions.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-multi-sessions.gif)

Bu yaklaşım sayesinde oturumlarda gerçekleştirilen işlemler
sonlandırılmadan, başka konsol oturumlarında çalışabiliyoruz. Örneğin
bir konsolda ssh ile bağlantı sağlayıp işlemler gerçekleştiriyorken, bu
şekilde konsoldan ayrıldığımızda ssh bağlantısı ve tabii ilgili işlemler
arkaplanda devam edecek. Biz de dilediğimiz zaman bu konsol oturumuna
dönebileceğiz.

Bu esnek kullanım özelliğine ek olarak, konsol üzerinde kopyalama ve
yapıştırma gibi işlemleri gerçekleştirmemiz de mümkün. Bu özellik, komut
satırı arayüzünde çalışan tty konsolları üzerinde çalışmamız
gerektiğinde, fare kullanamadığımızda işimizi inanılmaz kolaylaştırıyor.

Kopyalamak için Ctrl + B tuşlamasından sonra \[ sembolünü temsil eden
tuşlamayı yapıyoruz. Bu noktadan itibaren imlecimizi mevcut konsol
yazıları üzerinde yön tuşları ile rahatça hareket ettirebiliyoruz.
Kopyalamak istediğimiz bölümün başına yön tuşları ile geldikten sonra
seçme işlemi için Ctrl + Space tuşuna bastıktan sonra yine yön tuşları
ile ilgili yazı seçiyoruz. Seçme işlemi bittikten sonra Ctrl + W tuşu
ile seçili metni kopyalıyoruz.

Kopyalanmış olan metni yapıştırmak için de Ctrl + B tuşlamasından sonra
\] sembolünü temsil eden tuşlamayı yapmamız yeterli oluyor.

![tmux-copy-paste.gif](https://www.linuxdersleri.net/egitim/temel-linux/network/tmux-copy-paste.gif)

`tmux` aracının en temel kullanımı bu şekilde. Tabii ki aracın kullanımı
ve konfigürasyonuna dair pek çok ek ayrıntı mevcut fakat temel kullanım
amacı için burada bahsetmiş olduğumuz kadarlık bilgi yeterli. Daha
fazlası için ek araştırma yapmakta özgürsünüz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 8. Ders 68 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Kabuk Üzerinde Genişletme
-------------------------

Bash kabuğunun nasıl çalıştığından bahsettiğimiz bölümde, kabuğa
girdiğimiz komutların öncelikle kabuk tarafından anlamlandırılmak üzere
metinsel olarak işlendiğinden bahsetmiştik. Kabuk, girilen komutları
inceleyip kendi üzerine düşen bir görev varsa bunları yapmak istiyor. Bu
işleme de **genişletme** deniyor.

Aslında kabuğun teknik olarak nasıl çalıştığının detaylarına girip
kafamızın karışmasını istemiyorum ancak bu bölümde anlatacaklarımızın
daha net olması için çok çok basit düzeyde haberdar olmamız gereken bir
işleyiş var.

Kabuğa bir komut girdiğimizde girdiğimiz komut "**lexical analysis &
parsing"** yani sözcük "analizi ve ayrıştırma" olarak geçen ilk aşamadan
geçiriliyor. Daha sonra anlamlandırılan ve ayrıştırılan komuttaki
genişletilmesi gereken bölümler buradaki genişletme kuralları dahilinde
sıraya uygun şekilde genişletilme adımlarından geçiriliyor. Son olarak
ayrıştırıp genişletilmiş olan yani son halini almış olan bu komut da
çalıştırılıp, işlem sonlandıktan sonra durum hakkında olumlu olumsuz
bilgi sunan çıkış kodu üretiliyor.

![diagram.webp](https://www.linuxdersleri.net/egitim/temel-linux/genisletme/diagram.webp)

Yani sırasıyla burada görselleştirmeye çalıştığım şemaya benzer bir
işleyiş söz konusu. Fakat tabii ki temel düzey için buradaki tüm
kavramlar fazla gelebilir. Bu sebeple biz bu eğitimde yalnızca en yaygın
kullanıma sahip birkaç genişletmeyi ele alacağız. Yine de daha fazla
detay almak isterseniz, GNU dokümanları içinde yer alan bu [bash
dokümantasyonu](https://www.gnu.org/software/bash/manual/bash.html)
ihtiyacınız olan tüm bilgileri size sağlayacaktır.

Ben burada bahsi geçen "genişletme" özelliğini basit bir örnek üzerinden
açıklayarak devam etmek istiyorum.

Örneğin konsolumuzu açıp, daha önce de yaptığımız gibi `echo merhaba`
yazarsak ne olur ?

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo merhaba
merhaba
```

Bakın `echo` aracı kendisine argüman olarak verilmiş olan "**merhaba**"
ifadesini konsola bastırdı. Bu sayede bu çıktıyı almış olduk. Şimdi bir
de `echo` komutunun ardından yalnızca `*` yıldız karakterini girmeyi
deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo *
bu bir deneme metnidir Desktop Documents DOSYA_ADI dosya_adı Dosya_adı Downloads klasor Music Pictures Public Templates test-dosyası Videos yeni yeni klasor yeni-klasor
```

Bakın yıldız karakteri yerine, konsolun çalışmakta olduğu mevcut
dizindeki dosya ve klasörlerin isimleri bastırıldı. Peki ama niye böyle
oldu ?

Bu durumun nedeni ikinci örneğimizde kullanmış olduğumuz `*`
yıldız(asterix) işaretinin bash üzerinde özel bir anlam taşıyor olması.
Yıldız işareti bash kabuğuna göre özel anlam taşıdığı için bash kabuğu
burada yıldız karakterini doğrudan `echo` aracına argüman olarak iletip
konsola bastırtmak yerine, `echo` aracını çalıştırmadan önce yıldız
karakterini genişletip, genişletme sonucu ortaya çıkan argümanları
`echo` aracına iletiyor. Normalde buradaki yıldız joker karakteri mevcut
dosya ve klasör isimlerindeki olası tüm karakterleri kapsama işlevinde.
Bizim örneğimizde kabuk `echo` komutundan sonra yıldız karakterini
gördüğünde, bu özel karakterin mevcut bulunduğumuz dizindeki tüm dosya
ve klasörlerin isimlerini temsil etmek için konulduğunu düşünüyor ve bu
doğrultuda yıldız karakterini dosya ve dizin isimleri olarak
genişletiyor. Neticede bizim `echo *` olarak girdiğimiz komut kabuk
tarafından `echo dosya ve dizin isimleri` olarak genişletilmiş oluyor.
`echo` aracı da kendisine argüman olarak verilmiş olan dosya ve dizin
isimlerini konsola bastırıyor.

![2.webp](https://www.linuxdersleri.net/egitim/temel-linux/genisletme/2.webp)

İşte tıpkı bu örneğimizde de deneyimlediğimiz gibi kabuk, bizim yazılı
şekilde verdiğimiz emirleri doğru şekilde algılayabilmek için komutları
çalıştırmadan önce komut metni içerisindeki özel anlam taşıyan ifadeleri
bulup gerçekte neyin kast edildiğini anlayabilmek için çeşitli
bağlamlara göre değerlendiriyor. Bu değerlendirme işini de tıpkı şemada
açıkladığımız gibi adım adım gerçekleştiriyor. Yani kabuk kendisinde
tanımlı olan görevler dahilinde, girdiğimiz komutta kendisinin yapması
gereken işlemler varsa ilk olarak bunları yapıyor. Girilen komutlar yani
argümanlar kabuk tarafından işlenip uygun şekilde genişletildikten sonra
da zaten ilgili araca bu argümanlar aktarılıyor.

İşte "**genişletme**" olarak bahsettiğimiz durum, kabuğa girilen yazılı
ifadelerin bağlamına göre değerlendirilip uygun değerlere dönüştürülmesi
yani genişletilmesidir.

Anlatım devamında kabuk üzerinde geçerli olan genişletme kurallarının
detaylarına ve gerektiğinde bu genişletmeden nasıl kaçınabileceğimize
uygulamalı olarak değiniyor olacağız. Eğer kabuğun genişletmeleri nasıl
ele aldığını bilirsek, çok daha az eforla kabuğa çok daha fazla iş
yaptırabiliriz.

Süslü(Kıvırcık) Parantez-Küme Ayracı Genişletmesi
-------------------------------------------------

Kıvırcık parantez genişletmesi sayesinde sayılar ve karakterlerle
istediğimiz aralıklarda verilerin oluşturulmasını sağlayabiliriz. Yani
kendi ihtiyaçlarımıza göre örüntüler oluşturabiliriz. Hatırlıyorsanız
komut satırının ne kadar işlevsel olabileceğinden bahsederken 1'den
100'e kadar isimlendirilmiş klasör oluşturmak için de kıvırcık parantez
genişletmesini kullanmıştık.

Yine benzer örneği ele alabiliriz. Normalde 1'den 5'e kadar
isimlendirilmiş klasörler oluşturmak için `mkdir 1 2 3 4 5` şeklinde tek
tek elimizle klasör isimlerini belirtmemiz gerek. Bunun yerine aralığı
kıvırcık parantez içinde `mkdir {1..5}` şeklinde yazabiliriz. Yani benim
`mkdir 1 2 3 4 5` şeklinde yazmamla aslında `mkdir {1..5}` yazmam en
nihayetinde `mkdir` aracı için aynı oluyor çünkü kıvırcık parantez
içindeki **1..5** ifadesi 1'den 5'e kadar olan sayılara genişletiliyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ mkdir {1..5}

┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ ls
1  2  3  4  5
```

Neticede işte bu yaklaşım sayesinde argüman alarak çalışan tüm araçlarda
genişletme özelliklerinin nimetlerinden faydalanmamız mümkün.
Örneklerimizi pek çok farklı araç üzerinde uygulayabiliriz ancak,
kolayca takip edilebilir olması için konsola çıktı bastıran `echo`
aracını kullanacağız. Bu sayede genişletme sonucunda üretilen tüm
argümanları doğrudan konsol üzerinden çıktı olarak görebiliyor olacağız.

Basit bir örnekle başlayacak olursak `echo a{d,l,t}a` komutunu
girebiliriz.

``` {.bash}
└─$ echo a{d,l,t}a
ada  ala  ata
```

İşte buradaki kıvırcık parantezin içindeki virgülle ayrılmış olan
karakterler, kabuk tarafından sırasıyla genişletilerek baştaki ve
sonraki **a** karakterleri ile birleştirilip **ada ala** ve **ata**
argümanlarına dönüştürüldü. `echo` aracı da bu argümanları konsolumuza
bastırdı. İşte en basit hali ile genişletme dediğimiz kavram bu.
Kıvırcık parantez içine virgüller ayırarak yazdığımız tüm karakterler
soldan sağa doğru sırasıyla parantezin dışındaki karakterlerle
birleştirilerek her biri için birer argüman üretiliyor. Yani
belirttiğimiz şablona göre istediğimiz çeşitlilikte argüman
üretebiliyoruz.

Ben yalnızca birer karakter ekledim ancak kıvırcık parantez içerisine
istediğimiz uzunlukta istediğimiz kadar karakteri ekleyebiliyoruz. Ben
bu kez `echo a{bbb,dd,l,tttt}a` şeklinde komutumuzu girelim.

``` {.bash}
└─$ echo a{bbb,dd,l,tttt}a
abbba adda ala atttta
```

Bakın her koşulda parantez içinde virgülle ayırarak verdiğimiz tüm
karakterler, peşi sıra kaç karakter kullanıldığına bakılmaksızın kabuk
tarafından genişletiliyor. Çıktıyı incelediğimizde virgülle ayırmış
olduğumuz karakterlerin tıpkı tanımlandıkları sıralamaya yani soldan
sağa doğru genişletildiğini teyit edebiliyoruz. Siz de elde etmek
istediğiniz argümanlar için bu sıraya dikkat ederek şablonunuzu
tanımayabilirsiniz. Yalnız, bu şekilde şablon tanımı üzerinden örüntüler
oluştururken boşluk karakterini kaçış karakteriyle birlikte kullanmanız
gerektiğine de dikkat edin lütfen. Aksi halde kabuk genişletme
uygulanamaz.

Boşluk karakterinin genişletmeye engel olduğunu kanıtlamak için aynı
komutumuzu bu kez içinde boşluk karakteri ile tekrar girebiliriz.

``` {.bash}
└─$ echo a{b b,d,l,t}a
a{b b,d,l,t}a
```

Bakın boşluk karakteri olduğu için genişletme gerçekleştirilmedi
dolayısıyla köşeli parantez ve içindeki tüm karakterler olduğu gibi
konsola bastırıldı. Çünkü kabuk burada bir karakter boşluk olduğunu
gördüğünde burada bu boşluk karakterinin kelimeleri bölümlemek için
bulunduğunu düşünüyor. Dolayısıyla genişletme yerine kelime bölümlemesi
yapılıp, genişletme yapısı kabuk tarafından görmezden geliniyor. Bizim
bu boşluğun bu amaçla eklenmediğini yani sıradan bir karakter olduğunu
kabuğa belirtmek için özellikle kaçış karakterini kullanmanız gerekiyor.
Denemek için boşluk karakterinden hemen önce kaçış karakterini
ekleyelim.

``` {.bash}
└─$ echo a{b\ b,d,l,t}a                                          
ab ba ada ala ata
```

Böylece, ne zaman bir karakterin kabuk tarafından standart olarak
algılanmasını istersek kaçış karakterini tıpkı bu örneğimizde olduğu
şekilde kullanabileceğimizi bir kez daha teyit etmiş olduk.

Tekrar kıvırcık parantez genişletmesine dönecek olursak burada biz
doğrudan genişletilecek tüm karakterleri belirttik. Eğer genişletilecek
karakterlerin hepsini yazmak yerine bir aralık belirtmek istersek; iki
nokta yan yana olacak şekilde `{başlangıç..bitiş..artış_oranı}` yapısını
da kullanabiliyoruz.

Ben a'dan z ye kadar olan tüm karakterleri bastırmak için `{a..z}`
şeklinde komutumu giriyorum.

``` {.scss}
└─$ echo {a..z}
a b c d e f g h i j k l m n o p q r s t u v w x y z
```

Bakın a'dan z'ye kadar olan tüm alfabetik karakterler sırasıyla tek tek
bastırıldı. Linux üzerinde küçük büyük harf duyarlılığı olduğundan daha
önce bahsetmiştik. Küçük büyük harf duyarlılığı sebebiyle eğer büyük
karakterler bastırılsın istersem `A..Z` şeklinde özellikle büyük
harfleri kullanmam gerekiyor.

``` {.scss}
└─$ echo {A..Z}                                                
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
```

Bakın A'dan Z'ye hepsi büyük harfli şekilde bastırıldı. İstersem aynı
şekilde sayı aralığı da belirtebilirim.

``` {.bash}
└─$ echo {1..10}                                                 
1 2 3 4 5 6 7 8 9 10
```

Gördüğünüz gibi tüm sayılar sırasıyla bastırıldı. Ayrıca genişletmeler
sırasında üretilen örüntünün sıralı şekilde teker teker ilerlemesi de
şart değil. İstersek kaçar kaçar ilerlemesi gerektiğini örüntünün sonuna
iki nokta koyduktan sonra belirtebiliriz. Örneğin 1'den 20'ye kadar olan
sayıların 2 şer 2 şer genişletilmesini istersek `{1..20..2}` şeklinde
belirtebiliriz.

``` {.bash}
└─$ echo {1..20..2}                                            
1 3 5 7 9 11 13 15 17 19
```

Bakın tüm sayılar birden başlayıp ikişer ikişer arttırılarak yani 1 3 5
7.. şeklinde iki sayı aralıkla genişletildi. Sayılar dışında bu aralığı
harfler üzerinde de benzer şekilde kullanabiliriz.

``` {.bash}
└─$ echo {a..z..2}                                            
a c e g i k m o q s u w y
```

Bakın tüm harfler alfabetik olarak a'dan başlayıp ikişer sıra kaymış
şekilde tek tek bastırıldı.

İşte sizler de bu şekilde ihtiyaçlarınıza uygun olan örüntüleri
oluşturmak için kıvırcık parantez kullanabilirsiniz. Şimdiye kadar
verdiğim basit örneklerden belki anlaşılamamış olabilir ancak buradaki
genişletmelerin her biri ayrı ayrı birer argüman olarak
genişletiliyorlar. Eğer genişletilecek argüman bir önceki argümandan
ayrılmadıysa yani bitişik yazıldıysa, genişletme bu argüman da dikkate
alınarak gerçekleştiriliyor.

Ne demek istediğimi daha net anlayabilmek için `echo deneme{1..5}`
şeklinde komutumuzu girelim.

``` {.bash}
└─$ echo deneme{1..5}                                           
deneme1 deneme2 deneme3 deneme4 deneme5
```

Bakın aldığımız çıktıda deneme ifadesinin sonuna 1'den 5'a kadar
rakamlar eklendi ve neticede 5 farklı argüman üretilmiş oldu. Bu çıktıyı
elde ettik çünkü **deneme** argümanından sonra boşluk bırakmadan
kıvırcık parantez içinde genişletme karakterlerini belirttik. Kabuk,
girdiğimiz komutu anlamlandırmak için öncelikle boşluklarından parçalara
ayırdığı için bizim **girdiğimiz genişletme karakterleri** ve
"**deneme**" argümanı aynı bütünün parçaları olarak değerlendirildi. Ve
genişletme karakteri de olduğu için kabuk, `deneme{1..5}` komutunun
aslında **deneme1 deneme2.. deneme5** olarak genişletilmesi için
eklendiğini anlayıp buna göre muamele etti.

Aynı örneği bu kez genişletme karakteri ile önceki argüman arasında bir
boşluk olacak şekilde yani `echo deneme {1..5}` şeklinde girelim.

``` {.bash}
└─$ echo deneme {1..5}                                           
deneme 1 2 3 4 5
```

Bakın gördüğünüz gibi **deneme** ve 1'den 5'e kadar olan sayılar argüman
olarak üretildi. Çünkü kabuk girmiş olduğumuz komutu boşluklarından
parçalara ayırdı dolayısıyla **deneme** argümanını ve genişletilecek
karakterleri ayrı ayrı ele aldı.

Bizim kabuğa verdiğimiz komutların kabuk tarafından nasıl ele alındığını
aşağı yukarı bildiğimizde işte tıpkı burada olduğu gibi girdiğimiz
komutların kabuk tarafında ne anlam ifade ettiğini de çok daha iyi
anlayabiliyoruz. Yani daha önce açıklamış olduğumuz kabuk nasıl çalışır
bölümünü gereksiz yere ele almadık. Kabuğun komutları algılayışını
bildiğimizde çok daha etkili şekilde emirler verebiliyoruz.

Tekrar örüntü oluşturmaya dönecek olursak, farklı türde örüntüler elde
etmek isterseniz birden fazla genişletme karakterini peş peşe de
kullanabilirsiniz. Denemek için `echo {1..3}{a..c}` şeklinde komutumuzu
girelim.

``` {.r}
└─$ echo {1..3}{a..c}                                            
1a 1b 1c 2a 2b 2c 3a 3b 3c
```

Bakın, iki genişletme karakteri bitişik şekilde kullanıldığı için 1'den
3'e kadar olan tüm rakamlar ve a'dan c'ye kadar olan karakterleri de
içeren argümanlar üretmiş oldu. Bu örnek kabuğun genişletmeleri nasıl
yaptığını gayet iyi özetliyor bence. Kabuk sırasıyla genişletme yaptığı
için soldan sağa doğru genişletilecek karakterleri arıyor. En soldaki
karakteri genişlettikten sonra ileride genişletilecek karakter var mı
diye bakıyor. Eğer varsa bunları da genişletiyor. İşte buradaki örnekte
kabuk ilk olarak 1 rakamına genişletti ve devamında ikinci genişletmeye
geçip a'dan c'ye kadar olan genişletmeyi uyguladı. Daha sonra 2 rakamına
genişletti ve aynı şekilde a'dan c'ye kadar olan genişletmeleri
sırasıyla tek tek uyguladı. Yani genişletmenin uygulanış biçim ve sırası
oldukça düzenli. Hatta bu düzeni daha net görebilmek adına bir adet daha
genişletme ekleyebiliriz. Bunun için `echo {1..3}{a..c}{A..C}` komutunu
girelim.

``` {.bash}
└─$ echo {1..3}{a..c}{A..C}
1aA 1aB 1aC 1bA 1bB 1bC 1cA 1cB 1cC 2aA 2aB 2aC 2bA 2bB 2bC 2cA 2cB 2cC 3aA 3aB 3aC 3bA 3bB 3bC 3cA 3cB 3cC
```

Çıktıları inceleyecek olursak, sırasıyla ilk genişletmenin uygulanıp
sonraki genişletmenin ilk basamağının da uygulandıktan sonra bir sonraki
genişletmenin uygulandığını görebiliyoruz. İlk genişletme basamağı 1 ve
a olduğu için 1aA 1aB 1aC şeklinde genişletmeler uygulanmış. Geri kalan
genişletmeler de benzer şekilde soldan sağa doğru adım adım uygulanmış.
Aslında burada aldığımız çıktılar `deneme{1..5}` örneğini ile birebir
benzer. Tek fark, biz burada birden fazla genişletme karakterini bitişik
olarak kullandığımız için üretilen örüntüler de bu doğrultuda çok
çeşitli oldu. Yoksa tüm işleyiş aynı.

Belki bu noktada aldığımız çıktılar sizlere biraz karmaşık gelmiş
olabilir, ancak merak etmeyin aslında son derece kolay. Tek yapmanız
gereken çıktıları biraz dikkatlice izleyip, genişletmelerin soldan sağa
doğru adım adım gerçekleştirildiğini fark etmektir. **Ayrıca zaten
genelde bu örneklerdeki gibi karmaşık veya anlamsız örüntüler
oluşturmanız da gerekmeyecek.** Ben sadece örüntü oluşturmanın temel
yapısından bahsetmek için bu şekilde örnekler veriyorum. Kendiniz de
farklı örnekler üzerinden farklı desenler üreterek genişletmenin tam
olarak nasıl çalıştığını rahatlıkla kavrayabilirsiniz. Örneğin bu son
girdiğim komutta genişletme karakteri arasında boşluk bırakırsam,
genişletmeler birbirinden bağımsız olacağı için ayrı ayrı sıralı
çıktıları alacağız.

``` {.bash}
└─$ echo {1..3} {a..c} {A..C}                                    
1 2 3 a b c A B C
```

Bakın boşluk bırakınca, genişletmeler birbirinden bağımsız olduğu için
argümanlarda birbirinden bağımsız oldu.

Neticede kıvırcık parantez genişletmeleri sayesinde çok çeşitli argüman
örüntüleri oluşturabileceğimizi `echo` komutu üzerinden ele aldık.
`echo` komutu üretilen argümanları gözlemleyebilmemiz için harika olsa
da ben basit bir gerçek dünya örneği de vermek istiyorum.

Örneğin diyelim ki kendi ev dizininiz içindeki ***Desktop*** klasörü
altında birbirinden farklı isimlerde yeni 5 tane klasör oluşturmak
istiyorsunuz. Bunun için ne yapabilirsiniz ? Örneğin komutunuzu
`mkdir ~/Desktop/bir ~/Desktop/iki ~/Desktop/uc` ve benzeri şeklinde
uzun uzadıya girebilirsiniz. Ama buna gerek yok çünkü artık siz
genişletmeden yararlanıp örüntü oluşturmayı biliyorsunuz. Yani tüm
komutu tekrar tekrar yazmak yerine isterseniz kıvırcık parantez
genişletmesi ile `mkdir ~/Desktop/{bir,iki,uc,dort,bes}` şeklinde tek
seferde istediğiniz isimlerde klasörlerin oluşturmasın da
sağlayabilirsiniz.

``` {.perl}
└─$ mkdir ~/Desktop/{bir,iki,uc,dort,bes}                    

┌──(taylan@linuxdersleri)-[~/yeni klasor]
└─$ ls ~/Desktop/                        
bes  bir  dort  iki  test.txt  uc  yeni-dizin
```

Bakın tek bir komutla istediğim örüntüye uyulması sayesinde birden fazla
klasörü kolayca oluşturabildim. İşte bu ve bunun gibi sizlere pratiklik
sağlayacak durumlarda kıvırcık parantez genişletmesini
kullanabilirsiniz.

Dosya İsmi Genişletme
---------------------

Bash kabuğu girmiş olduğumuz her bir argümana bakıp '\*', '**?**' ve
'**\[**' karakterleri var mı diye kontrol ediyor. Bu karakterlerden biri
görünüyorsa, bu argüman bir **dosya ismi genişletmesi** kalıbı olarak
kabul ediliyor ve kalıpla eşleşen dosya ve klasör isimleri alfabetik
olarak genişletiliyor. Yani dosya ismi genişletmesi aslında **var olan
dosya ve klasör isimleri ile eşleşecek kalıplar** oluşturmamızı
sağlıyor. Örneğin a ile başlayan veya .txt ile biten tüm dosya ve
klasörler gibi özel karakter kalıpları belirtip var olan dosya ve
dizinlerin bu kalıba göre filtrelenmesini sağlayabiliyoruz.

Bash kabuğuna dosya ismi genişletmesini belirtmek için başta da
söylediğim gibi "yıldız", "soru işareti" ve "köşeli parantez" joker
karakterinden uygun olan bir karakteri kullanmamız gerekiyor. Fark
ettiyseniz kabuk için özel anlam ifade eden bu karakterlere "**joker
karakterler**" dedim. Buradaki **joker karakter** ifadesi önemli çünkü
isminden de anlaşılabileceği gibi bu karakterler herhangi bir karakter
ile eşleşebildikleri için bu isme sahipler. Türkçe "joker karakterler"
olarak ifade ettiğim bu karakterlere İngilizce "wildcards" olarak
geçiyor.

"wildcards" ifadesine, komut satırı üzerindeki çeşitli araçları
kullanırken veya harici olarak İngilizce yardım sayfalarında sıklıkla
rast geliyor olacağımız için joker karakterin wildcards olarak geçtiğini
bilmeniz önemli. Örneğin kullanacağınız bir araç, bu "yıldız" "soru
işareti" ve "köşeli parantez" karakterlerini özel anlamları ile ele
almak için sizden wildcards seçeneğiyle bunu özellikle belirtmenizi
bekleyebilir. Özellikle belirtmediğiniz durumda size hata çıktısında
"wildcards kullanmalısınız" diye uyarı verebilir. Şimdi kısaca bu joker
karakterlerin kabuk için ifade ettiği anlamalara değinecek olursak;

**Yıldız karakteri:** sıfır veya sıfırdan daha fazla sayıda herhangi bir
karakter ile eşleşebiliyor.

**Soru işareti:** tam olarak yalnızca herhangi bir tek karakterle
eşleşiyor.

**Köşeli parantez:** ise köşeli parantez içinde belirten herhangi bir
karakter ile eşleşebiliyor.

Bu joker karakterlerin kullanımlarına tek tek değineceğiz ancak ilk
olarak dikkatinizi çekmek istediğim nokta bu karakterlerin **yalnızca
var olan dosya ve klasör isimlerine genişletilmek için**
kullanılabildikleridir. **Yeni dosya veya klasör oluşturmak gibi işlerde
kullanamayız.** Çünkü var olan dosya ve klasörler içerisinden bizim
belirttiğimiz kalıba uyan isimleri argüman olarak genişletmek için
varlar. Zaten bu karakterler "pattern matching" yani "desen eşleştirme"
karakteri olarak da geçiyor. Yani var olan dosya dizin isimleri ile
eşleşecek karakter desenleri oluşturmamızı sağlıyorlar.

Teorik açıklamanın anlamalı hale gelmesi için tabii ki örnekler yapmamız
gerekiyor. Örnekler yapmak için öncelikle ***/etc*** dizinine geçiş
yapalım. ***etc*** dizini altında pek çok farklı dosya ve klasör
bulunduğu için örnekler sırasında alıştırmalar yapabileceğimiz
çeşitlilikte dosya ve klasör ismi mevcut.

Daha önce süslü parantez genişletmesinde olduğu gibi bu genişletmelerin
sonuçlarını rahat gözlemleyebilmek adına yine `echo` komutunu
kullanabiliriz.

Yıldız Karakteri
----------------

Eğer `echo` komutumun ardından **yıldız joker karakterini** eklersem, bu
var olan tüm dosya ve klasörlerin bastırılması demek oluyor.

Hemen denemek için `echo *` komutunu girelim.

``` {.sql}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo *
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd gprofng.rc groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf hostname hosts hosts.allow hosts.deny idmapd.conf ifplugd ImageMagick-6 inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf ModemManager modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network NetworkManager networks nftables.conf nginx nikto.conf nsswitch.conf ODBCDataSources odbc.ini odbcinst.ini openal OpenCL openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rarfiles.lst rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudoers.save sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d UPower vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant X11 xattr.conf xdg xfce4 xl2tpd zsh zsh_command_not_found
```

Bakın tıpkı `ls` çıktısında olduğu gibi mevcut dizindeki tüm dosya ve
klasörlerin isimleri konsola bastırıldı. Tabii ki `ls` komutunda olduğu
gibi renkli ve düzenli bir çıktı olmadı ancak gizli dosya ve dizinler
hariç tüm içerikler `echo` komutuna argüman olarak iletildiği için
`echo` komutu tarafından konsola batırıldı.

Belirttiğim gibi yıldız işareti tüm dosyaları ve klasörleri kapsıyor
olsa da gizli dosya ve klasörleri kapsamıyor. Yani başında nokta işareti
ile gizlenmiş olan dosya ve klasörlerin isimlerini yıldız genişletme
karakterini kapsamıyor. Gizli olanları özellikle kapsaması için yıldız
işaretinden önce nokta karakterini de ekleyip gizli isimleri özellikle
kapsayabiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo .*                                                      
. .. .java .pwd.lock
```

Ben bu girmiş olduğum komutta; yıldız karakterinden önce nokta işaretini
koyduğum için başlangıcı nokta olan ve devamında herhangi bir karakter
olan tüm dosya ve dizinlerin kapsanması sağlanıyor. Benim çalıştığım
***etc*** dizini altında da bu biçimde olan yani gizli olan içerikler
bunlarmış.

Ayrıca bu aldığımız çıktılarda yer alan tek nokta `.` mevcut dizini
temsil ediyorken, iki nokta `..` da bir üst dizini temsil eden
klasörler. Örneğin biz `cd ..` şeklinde komut girip bir üst dizine
dönerken, aslında üst dizini temsil eden bu iki nokta klasörüne geçiş
yaptığımız için bir üst dizine dönebiliyorduk. Veya daha önce betik
dosyalarımızı çalıştırırken de gördüğümüz gibi bir dosyaya çalıştırırken
`./dosya-ismi` şeklinde komut girdiğimizde de mevcut dizini temsil eden
bu dizin sayesinde bu dosya kabuk tarafından çalıştırılabiliyordu. Nokta
işareti kabuğa bu dizinin tam adresini verdiği için mevcut dizin içinde
olan dosyanın tam konumunu kolayca belirtebiliyorduk.

Her neyse bakın başında nokta bulunan dosya ve klasör isimlerini
kapsayabilmek için nokta ve yıldız karakterlerini bir arada kullandık.
Bu kullandığımız karakterler de mevcut bulunduğumuz dizinde yer alan bu
dosya ve klasörlerin isimlerine genişletilip `echo` aracına argüman
olarak verildi, dolayısıyla konsolumuza bu çıktıları bastırabildik.

Normalde yıldız işaretinin gizli içerikleri kapsamıyor olmasının nedeni
farkında olmadan önemli dosyalar üzerinde yanlış işlem yapmamızı
önlemektir. Zaten klasör veya dosyaların gizli olmasının amacı göz
önünden uzak tutularak korunmalarını sağlamak. Bash kabuğunun joker
karakteri olan yıldız işareti her şeyi kapsamasına rağmen gizli dosya ve
klasörleri bilerek dışarıda tutuyor.

Tamamdır, temel olgulardan da bahsettiğimize göre şimdi yıldız joker
karakterini ihtiyacımıza göre nasıl kullanabileceğimize dair birkaç
farklı örnek uygulama yapabiliriz.

Gizli içerikleri görmek için başı nokta ile başlayanları listeledik.
Nokra yerine dilediğimiz herhangi bir karakteri de belirtebilirdik.
Hatta dilersek tersi şekilde sonu belirli bir karakter veya karakterler
ile bitenleri de listeleyebiliriz. Örneğin ben sonu "**i"** ile biten
her şeyi bastırmak istersem `echo *i` şeklinde komutumu kullanabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo *i
avahi odbc.ini odbcinst.ini
```

Bakın buradaki tüm dosya ve dizin isimlerinin sonunda "i" harfi var.

Benzer şekilde birden fazla karakteri de spesifik olarak belirtebiliriz.
Örneğin sonu "**.d"** ile biten içerikleri bastırmak için de benzer
şekilde `echo *.d` komutunu girebiliriz.

``` {.bash}
└─$ echo *.d
apparmor.d bash_completion.d binfmt.d cron.d environment.d grub.d init.d insserv.conf.d ipsec.d ld.so.conf.d libpaper.d logrotate.d modprobe.d modules-load.d pam.d profile.d rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d request-key.d rsyslog.d sane.d sddm.conf.d sensors.d strongswan.d sudoers.d sysctl.d tmpfiles.d update-motd.d
```

Bakın yalnızca sonu "**.d"** ile bitenler listelenmiş oldu.

Görebildiğiniz gibi kullanımı son derece kolay. Spesifik olarak
eşleşmesini istediğim bir veya birden fazla karakter varsa onları
komutumda uygun şekilde belirttiğim sürece dosya ve dizin isimleri
içinden tam olarak aradığım isimlerdekilere genişletiliyor.

Ben yine örnek olması için başlangıcı "**in**" ile başlayan tüm dosya ve
dizin isimlerinin genişletilerek `echo` aracına iletilmesini istiyorum.
Bunun için `echo in*` komutunu girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo in*
inetsim init.d initramfs-tools inputrc insserv.conf.d
```

Bakın başlangıcı "**in**" olan tüm dosya veya klasör isimleri karakter
uzunlukları fark etmeksizin bastırılmış oldu.

Başlangıç veya son yerine eğer herhangi bir yerinde "**in**" karakteri
geçen tüm içerikleri bastırmak istersem `echo *in*` komutunu
kullanabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo *in*                                                    
bindresvport.blacklist binfmt.d cryptsetup-initramfs inetsim init.d initramfs-tools inputrc insserv.conf.d king-phisher login.defs machine-id minicom nginx odbc.ini odbcinst.ini proxychains4.conf selinux terminfo
```

Bakın bu girdiğimiz genişletme tanımı sayesinde dosya veya klasör
isimlerinin herhangi bir yerinde "in" geçen tüm içerikler bastırılmış
oldu. Yıldız işareti sıfır veya herhangi bir karakter anlamın geldiği
için bu kadar geniş bir eşleşeme imkanı sağlamış oldu. Yani biz bu
genişletme karakteri tanımı ile, başlangıcında sıfır veya sıfırdan başka
herhangi bir uzunlukta karakter olan daha sonra "in" karakterinin
geçtiği ve yine sonunda sıfır veya sıfırdan başka herhangi bir uzunlukta
karakter olan tüm dosya ve dizin isimlerinin genişletilmesini sağladık.
Bu sayede başında sonunda veya ortasında "**in**" ifadesi geçen tüm
içerikler de bastırıldı.

İşte sizler de sıfır veya daha fazla sayıda herhangi bir karakter ile
eşleşecek bir düzende dosya veya dizin ismi genişletmesi yapılsın
istiyorsanız yıldız joker karakterini uygun biçimde, genişletmenin
başında sonunda veya her ikisinde de birden ihtiyacınıza uygun şekilde
kullanabilirsiniz.

Soru İşareti
------------

Daha önce soru işareti karakterinin herhangi bir tek karakter yerine
geçtiğini belirtmiştik. Burada dikkat etmeniz gereken detay soru işareti
joker karakterinin sıfır değil her zaman **tam olarak tek bir**
karakteri temsil ettiği.

Örneğin ben başlangıcı "**ss**" olan ancak devamındaki karakterin
herhangi bir karakter olduğu dosya ve klasörleri `echo` aracına argüman
olarak vermek istiyorum. Bunun için `echo ss?` komutunu girmem yeterli.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo ss?                                                     
ssh ssl
```

Bakın "**ss**h" ve "**ss**l" çıktılarını aldım. Bu çıktılarda yalnızca
başlangıcı "**ss**" olan ve sonundaki tek bir karakteri herhangi bir
karakter olan dosya ve klasörler yer alıyor. Yani fark ettiyseniz soru
işareti yalnızca tek bir karakteri kapsıyor.

Hatta bu durumu teyit etmek için bir veya birden fazla kez soru işareti
kullandığımızda ne olacağına göz atabiliriz. Ben örnek için öncelikle
echo s? şeklinde yazıyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo s?                                                     
sv
```

Bakın tek bir karakter ile eşleştirildiği için ben "**s**v" çıktısını
aldım. Şimdi bir de komutumuzu `echo s??` şeklinde tekrar girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo s??                                                     
ssh ssl
```

Bakın bu kez "sv" çıktısı yok, onun yerine "s" karakterinden sonra
herhangi iki karakter bulunan "ssh" ve "ssl" çıktılarını almış olduk.
Yani bakın kaç tane soru işareti varsa yalnızca o sayı adedince karakter
ile eşleşme yapılıyor. Ayrıca dikkat ettiyseniz daha önce de söylediğim
gibi soru işareti karakteri 0 karakter ile eşleşme yapmıyor. Eğer soru
işareti sıfır karakteri de kapsıyor olsaydı "sv" çıktısını da yine
almamız gerekiyordu. Çünkü ben çift soru işareti kullandığımda ilk soru
işareti "sv" için "v" karakterini tamamladıktan sonra "sv" isminin
devamında başka bir karakter olmadığı için yani sıfır karakter bulunduğu
için ikinci soru işareti sıfır karakteri kapsayıp bize "sv" çıktısını
vermeliydi. Ancak soru işareti sıfırdan farklı yalnızca tek bir
karakteri kapsıyor. İşte siz de dilediğiniz **tek bir karakteri**
kapsaması için istediğiniz gibi **soru işaretini** kullanabilirsiniz.
Örneğin isim ortasında kullanımına dair bir örnek olması için
`echo rc?.d` komutu ile farklı rakamlarla temsil edilen klasörleri
konsola bastırabiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo rc?.d
rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d
```

Bakın buradaki soru işareti rakamların ve "S" karakterinin yerini alıp
bize bu klasörlerin isimlerini verdi. Bir diğer örnek olarak üç
karakterden oluşan tüm içerikleri listelemek için `echo ???` komutumuzu
girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo ???
apt gss opt php ppp rmt rpc ssh ssl ufw vim X11 xdg zsh
```

Bakın tam olarak isminde 3 karakter bulunan içerikler konsolumuza
bastırılmış oldu.

Yani özetle tekrar tekrar teyit ettiğimiz gibi buradaki soru işareti
mutlaka tek bir karakter ile eşleşecek şekilde genişletiliyor. Kaç tane
soru işareti kullanıldıysa o kadar sayıda herhangi bir karakter ile
eşleşme sağlanabiliyor.

Köşeli Parantez
---------------

Köşeli parantez içerisine yazdığımız karakterler soldan sağa doğru
genişletiliyor. Örneğin başlangıcında **a c z** ve **d**
karakterlerinden herhangi biri olan tüm içerikleri bastırmak istersem
komutumu `echo [aczd]*` şeklinde girebilirim.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [aczd]*
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg zsh zsh_command_not_found
```

Bu komut sayesinde köşeli parantez içindeki tüm karakterler soldan sağa
doğru tek tek genişletiliyor ve yıldız karakteri sayesinde de devamında
herhangi bir uzunlukta karakterler olan tüm dosya ve dizineler kapsanmış
oluyor. Yani neticede köşeli parantez içinde belirttiğimiz
karakterlerden biri ile başlayan tüm içerikler bastırılıyor.

Eğer burada olduğu şekilde tek tek spesifik olarak karakterleri girmek
yerine aralık belirtmek istersek tire işaretini kullanabiliriz. Örneğin
a'da d'ye tüm karakteri kapsamak için \[a-d\] şeklinde komut
girebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [a-d]*                                                
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg
```

Bakın başlangıç harfi a'dan d'ye kadar olan yani **a b c d**
karakterlerinden biri ile başlayan tüm dosya ve dizinler konsola
bastırıldı.

Benzer şekilde sayılar için de aralık belirtebiliriz. Örneğin ben
isminde 1'den 5'e kadar olan rakamlardan birini barındıran tüm dosya ve
klasörleri listelemek istersem komutumu `echo *[1-5]*` şeklinde
girebilirim.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo *[1-5]*                                                 
apache2 bash.bashrc.save.1 dbus-1 dns2tcpd.conf e2scrub.conf gtk-2.0 gtk-3.0 iproute2 java-11-openjdk libnl-3 mke2fs.conf openni2 polkit-1 proxychains4.conf python2.7 python3 python3.10 python3.9 rc1.d rc2.d rc3.d rc4.d rc5.d sensors3.conf udisks2 X11 xfce4 xl2tpd
```

Bakın isminin herhangi bir yerinde 1'den 5'e kadar olan rakamlardan
birini barından tüm dosya ve klasörler listelendi. Yani sayısal olarak
aralık belirtebildiğimizi de bu örnekle teyit etmiş olduk.

Ayrıca birkaç örnektir bizzat yaptığımız gibi farkındaysanız genişletme
karakterlerini bir arada kullanabiliyoruz. Yani ben burada köşeli
parantez genişletmesiyle birlikte yıldız joker karakterini de kullanıp
istediğim dosya ve dizin isimlerini elde ettim. Benzer şekilde tabii ki
soru işaretini de dilediğiniz gibi yıldız veya köşeli parantez
genişletmesiyle birlikte kullanabilirsiniz. Mesela `echo [a-l]??`
şeklinde komutumuzu girersek, buradaki köşeli parantez genişletmesi
a'dan l'ye kadar olan karakterlerin hepsini kapsayacak, buradaki çift
soru işareti de bu a'dan l'ye kadar olan karakterlerle başlayan ve
devamında **tam olarak iki tane rastgele karakter** bulunduran dosya ve
klasör isimlerine genişletmeyi sağlayacak.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [a-l]??
apt gss
```

Bakın başlangıç harfi a'dan l'ye kadar olan karakteri kapsarken, bu
karakterin devamında soru işaretleri sayesinde tam olarak 2 rastgele
karakter bulunuyor. İşte tıpkı bu örneğimizde olduğu gibi joker
karakterleri, ihtiyaç duyduğunuz çözüm için istediğiniz gibi düzenleyip
tanımlayabilirsiniz.

Bölüm sonunda bu karakterlerin bir arada kullanımını daha net
anlayabilmek için zaten sizlere birkaç alıştırma bırakmış olacağım.
Şimdi tekrar köşeli parantez genişletmesine dönecek olursak.

Linux üzerinde küçük büyük harf duyarlılığı olduğundan daha önce
bahsetmiştik. Bu doğrultuda eğer genişletilecek dosya veya klasör ismi
olarak büyük harfleri belirtmek istiyorsak özellikle büyük harfleri
yazmamız gerekiyor. Örneğin büyük N ile başlayan içerikleri listelemek
için komutumu `echo N*` şeklinde girmem gerekir.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo N*
NetworkManager
```

Bakın bende bir tane isim eşleşmesi var ve gördüğünüz gibi isim
başlangıcındaki karakter de büyük harfli. Bu dizinde başlangıç harfi
büyük olan tüm içerikleri öğrenmek istersem `echo [A-Z]*` şeklinde büyük
karakterlerle aralık da belirtebilirim.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [A-Z]*                                                
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11
```

Bakın başlangıç karakteri büyük olan tüm içerikler listelendi.

Hatta eğer `echo [A-z]*` şeklinde belirtirsek büyük küçük harfler de
dahil başlangıcında a'dan z'ye kadar olan büyük küçük herhangi bir
karakter bulunan tüm içerikler listelenecektir.

``` {.sql}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [A-z]*                                                
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf hostname hosts hosts.allow hosts.deny idmapd.conf ifplugd ImageMagick-6 inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf ModemManager modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network NetworkManager networks nftables.conf nginx nikto.conf nsswitch.conf ODBCDataSources odbc.ini odbcinst.ini openal OpenCL openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d UPower vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant X11 xattr.conf xdg xfce4 xl2tpd zsh zsh_command_not_found
```

Bakın tam da söylediğim gibi, belirttiğimiz bu aralık sayesinde
başlangıç karakterinde küçük büyük harf olması fark etmeksizin tüm
içerikler listelendi.

Ben örnek olarak hep başlangıçtaki karakterler üzerinden çalıştım ancak
siz yıldız işaretinin ve soru işaretinin işlevini öğrendiğiniz için
istediğiniz şekilde çıktıları sınırlayabilirsiniz. Genişletme
karakterlerini istediğiniz sonuçları elde etmek için
özelleştirebileceğiniz kadar detay öğrendik. Zaten temel dosya ismi
genişletmeleri için 3 joker karakter(`*`,`?`,`[]`) kullanıyoruz hepsi
bu.

Hariç Tutmak
------------

Biz şu ana kadar hep belirttiğimiz karakterler ile eşleşecek şekilde
komut girdik. Dilersek köşeli parantez genişletmesini kullanırken,
belirttiğimiz karakterler dışındakileri kapsayacak şekilde de komut
girebiliriz. Yani hariç tutulacak karakterleri özellikle belirtip, geri
kalan karakteri barındıran dosya ve dizinlerin genişletilmesini
sağlayabiliriz. Bunun için tek yapmamız gereken ünlem `!` işaretini
kullanmak. Örneğin başlangıcında a'dan y'ye kadar olan herhangi bir
karakter geçmeyen içerikleri bastırmak istersek komutumuzu
`echo [!a-y]*` şeklinde girebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [!a-y]*                                                 
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11 zsh zsh_command_not_found
```

Bakın belirttiğim karakterler hariç tüm eşleşenler bastırıldı. **z**
karakterinden hemen önce **y** geldiği için aslında ben girdiğim bu
genişletme tanımı ile **z** karakteri ve büyük karakterlerle
başlayanları bastır demiş oldum. Çünkü küçük harflerle a'dan y'ye kadar
olan tüm karakterlerle başlayanları elediğimde geriye bunlar kalıyor.
Emin olmak için ünlem işaretini kaldırıp komutumuzu tekrar girebiliriz.

``` {.sql}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [!a-y]*                                                 
ImageMagick-6 ModemManager NetworkManager ODBCDataSources OpenCL UPower X11 zsh zsh_command_not_found

┌──(taylan@linuxdersleri)-[/etc]
└─$ echo [a-y]*                                                 
adduser.conf adjtime alsa alternatives apache2 apparmor apparmor.d apt avahi bash.bashrc bash.bashrc.save bash.bashrc.save.1 bash_completion bash_completion.d bindresvport.blacklist binfmt.d bluetooth ca-certificates ca-certificates.conf chatscripts cifs-utils cloud console-setup cron.d cron.daily cron.hourly cron.monthly crontab cron.weekly cryptsetup-initramfs cryptsetup-nuke-password crypttab dbus-1 dconf debconf.conf debian_version debtags default deluser.conf dhcp dictionaries-common dns2tcpd.conf dpkg e2scrub.conf emacs environment environment.d ethertypes ettercap firebird firefox-esr fonts freetds fstab fuse.conf gai.conf geoclue ghostscript glvnd gprofng.rc groff group group- grub.d gshadow gshadow- gss gtk-2.0 gtk-3.0 guymager hdparm.conf host.conf hostname hosts hosts.allow hosts.deny idmapd.conf ifplugd inetsim init.d initramfs-tools inputrc insserv.conf.d ipp-usb iproute2 ipsec.conf ipsec.d ipsec.secrets issue issue.net java-11-openjdk john kernel kernel-img.conf king-phisher kismet ld.so.cache ld.so.conf ld.so.conf.d libao.conf libaudit.conf libblockdev libnl-3 libpaper.d lightdm lighttpd locale.alias locale.gen localtime logcheck login.defs logrotate.conf logrotate.d macchanger machine-id magic magic.mime mailcap mailcap.order manpath.config matplotlibrc mime.types minicom miredo miredo.conf mke2fs.conf modprobe.d modules modules-load.d motd mtab mysql nanorc netconfig netsniff-ng network networks nftables.conf nginx nikto.conf nsswitch.conf odbc.ini odbcinst.ini openal openfortivpn openni2 openvpn opt os-release pam.conf pam.d papersize passwd passwd- perl php plymouth polkit-1 postgresql postgresql-common powershell-empire ppp profile profile.d protocols proxychains4.conf pulse python2.7 python3 python3.10 python3.9 rarfiles.lst rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d rearj.cfg redsocks.conf request-key.conf request-key.d resolv.conf responder rmt rpc rsyslog.conf rsyslog.d runit samba sane.d scalpel screenrc sddm.conf.d searchsploit_rc security selinux sensors3.conf sensors.d services shadow shadow- shells skel smartd.conf smartmontools smi.conf snmp speech-dispatcher sqlmap ssh ssl sslsplit strongswan.conf strongswan.d stunnel subgid subgid- subuid subuid- subversion sudo.conf sudoers sudoers.d sudoers.save sudo_logsrvd.conf sv sysctl.conf sysctl.d sysstat systemd terminfo theHarvester tightvncserver.conf timezone timidity tmpfiles.d ucf.conf udev udisks2 ufw updatedb.conf update-motd.d vdpau_wrapper.cfg vim vpnc vulkan wgetrc wireshark wpa_supplicant xattr.conf xdg xfce4 xl2tpd
```

Bakın bu kez tersi şekilde başlangıç harfinde z karakteri bulunan veya
başlangıç harfi büyük olan hiç bir içerik bastırılmadı çünkü bunları
genişletme kapsamına dahil etmedik. Bu iki çıktıyı kıyaslarsanız, ünlem
işaretinin hariç tutma görevinde olduğunu net biçimde görebilirsiniz.

**ℹ️ Not:** Bu hariç tutma özelliği her zaman beklendiği şekilde sonuç
vermeyebilir. Daha kesin yaklaşım için `find` aracının hariç tutma
özelliği olan ünlem işaretini kullanmanız özellikle karmaşık
filtrelemelerde daha sağlıklı olabilir.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[/etc]
└─$ find -maxdepth 1 ! -name "[a-y]*"                                                                                                                                 
.
./.java
./ModemManager
./NetworkManager
./ImageMagick-6
./OpenCL
./UPower
./.pwd.lock
./zsh
./ODBCDataSources
./X11
./zsh_command_not_found
```

`find` aracının yalnızca mevcut dizinde sorgulama yapması yani alt
dizinlere bakmaması için ayrıca `-maxdepth 1` seçeneğini de ekledim. Ben
genellikle daha kesin sonuçlar için bu yaklaşımı tercih ediyorum.

Ben anlatımlar sırasında mümkün oldukça temel işleyişi anlamamıza
yetecek kadar örnek verdim ama yapısı gereği joker karakterleri
kullanarak sınırsız sayıda örüntü oluşturabiliriz. Yani temelde nasıl
çalıştığını bildiğiniz zaman ihtiyaçlarınıza göre istediğiniz kalıbı
oluşturabilirsiniz. Zaten bu karakterlerin amacı da dosya isimleri ile
eşleşecek desenler oluşturabilmek. Burada ele aldıklarımız joker
karakterleri etkili kullanmanın tek yolu da bolca pratik yapmanızdır.
Pratik yaptıkça tam mantığını kavrayıp aslında ne kadar işlevsel ve
kolay kullanılabilir olduğunu bizzat deneyimlemiş olacaksınız.

Ayrıca ben anlatımlar sırasında hep `echo` komutunu kullandım ancak
sizler dilediğiniz bir araca argüman vermek için dosya ismi
genişletmesini kullanabilirsiniz. Örneğin sonu "**.txt**" ile biten tüm
dosyaları silmek istediğinizde `rm *.txt` komutunu kullanmanız yeterli
olacaktır. Denemek için öncelikle kıvırcık parantez genişletmesinden de
faydalanarak `sudo touch {1..9}.txt` komutu ile 1'den 9'a kadar
isimlendirilmiş sonu "**.txt**" ile biten dosyalarımızı oluşturalım.
`sudo` komutunu kullanıyorum çünkü ***etc*** dizini atlında çalıştığımız
için dosya oluşturma ve silme gibi işlemler için yetki gerekiyor.
İleride bu konuya ayıraca değineceğiz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ sudo touch {1..9}.txt
[sudo] password for taylan:
```

Dosyaların durumunu teyit etmek için `ls *.txt` komutu ile listeleyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ ls *.txt
1.txt  2.txt  3.txt  4.txt  5.txt  6.txt  7.txt  8.txt  9.txt
```

Bakın dosyalar oluşturulmuş. Şimdi sonu "**.txt**" ile biten tüm
dosyaları silmek için `sudo rm *.txt` şeklinde komutumuzu girelim.

**!! Dikkat:** Çalıştığınız dizinde, içerisinde önemli veriler bulunan
ve sonu ".txt" ile biten dosyalarınız varsa bu komutu girmeyin! Benim
çalıştığım dizinde sonu ".txt" ile biten önemli bir dosya olmadığı için
yeni oluşturduğum dosyaları silmek üzere ben bu komutumu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ sudo rm *.txt

┌──(taylan@linuxdersleri)-[/etc]
└─$ ls *.txt
ls: cannot access '*.txt': No such file or directory
```

Bakın sonu "**.txt**" ile biten tüm dosyalar buradaki dosya ismi
genişletmesi sayesinde `rm` komutuna argüman olarak aktarıldı,
dolayısıyla `rm` aracı da bu dosyaların hepsini sildi. Bu sebeple
`ls *.txt` komutunun neticesinde herhangi bir çıktı da alamadık çünkü
hepsi silinmişti.

Tüm bu yaklaşımları ele aldıktan sonra, anlatımın başında değinmiş
olduğum "dosya ismi genişletmeleri yalnızca mevcut dosya ve dizin
isimlerine genişleyebilir" açıklaması üzerinde özellikle durmak
istiyorum. Bu açıklama "dosya ismi genişletmesi" kullanarak önceden var
olamayan metinsel bir veri üretemeyeceğimiz anlamına geliyor. Yani
örneğin ben 1'den 5'e kadar isimlendirilmiş yeni klasörler oluşturmak
için `mkdir [1-5]` şeklinde komut giremem.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ sudo mkdir [1-5]
[sudo] password for taylan: 

┌──(taylan@linuxdersleri)-[/etc]
└─$ ls [1-5]
```

Bakın ilgili klasörler oluşturulmamış çünkü köşeli parantez karakteri
dosya ismi genişletmesi olduğu için yalnızca var olan dosya ve dizin
isimlerinden eşleşebilecek örüntüler oluşturuyor. Yani dosya ismi
genişletmelerini yeni veriler üretmek için kullanamazsınız. Bunun yerine
örneğin süslü parantez genişletmesini kullanabilirsiniz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ sudo mkdir {1..5}

┌──(taylan@linuxdersleri)-[/etc]
└─$ ls [1-5]                                            
1:

2:

3:

4:

5:
```

Bakın süslü parantez kullandığımızda dosya ismi genişletmesi karakteri
olan köşeli parantezin aksine yeni klasör isimleri üretmeyi başardık.

Dosya ismi genişletmesini anlatımlarını noktalamadan önce, "dosya ismi"
genişletmesi ile sıklıkla karıştırılan "regex" kavramından da bahsetmek
istiyorum. Bu sayede dosya ismi genişletmelerini daha net anlamış
olacağız.

Regex
-----

Eğer daha önce herhangi bir programlama dili ile ilgilendiyseniz
"**regex**" yani "**reg**ular **ex**pression" kavramıyla mutlaka
karşılaşmışsınızdır. Regex en özet haliyle, spesifik olarak belirli bir
karakter kalıbı ile eşleşecek desenler oluşturmamıza izin veren özel
karaktere verilen isimdir. Regex doğru şekilde kullanıldığında her türlü
metinsel ifadenin aranması bulunması ve ayrıştırılması konusunda
inanılmaz kolaylık sağlıyor. Biz regex ile aradığımız karakter kalıbını
belirtip metinsel veri girişi sağladığımızda regex, metinsel verideki
kalıba uyan tüm karakterleri sorunsuzca ayrıştırıp bize iletiyor. Yani
regex kullanırken dosya ismi genişletmesinde olduğu gibi yalnızca mevcut
dosya veya dizin isimleri ile sınırlı değiliz. Regex'e istediğimiz
metinsel veriyi girdi olarak verip bu verilerden istediklerimizi
ayrıştırabiliyoruz.

Ben özellikle dosya ismi genişletmesinden hemen sonra regex kavramından
bahsetmek istiyorum çünkü regex için kullanılan karakterle kabuk
genişletmelerinde kullanılan karakterler ile aynı görünümde olup biraz
daha farklı şekilde çalıştıkları için genellikle regex ile kabuk
genişletmeleri karıştırılabiliyor.

Regex için "`+`, `*`, `?`, `^`, `$`, `(`, `)`, `[`, `]`, `{`, `}`, `|`,
`\`" karakterleri özel anlama geliyor. Biz bu karakterleri kullanarak
desenler üretip tüm metinsel verileri istediğimiz gibi
filtreleyebiliyoruz. Regex inanılmaz derecede esnek ve kullanışlı
olmasının yanında sizin de fark edebileceğiniz gibi bash kabuğu
tarafından kullanılan bazı genişletme karakterlerini regex de
kullanıyor. Üstelik regex için kullanılan bu özel karakterler bash
kabuğundakilere benzer özellikler sergiliyor olsalar da aslında tam
olarak bash kabuğundaki gibi çalışmıyorlar. Örneğin bash kabuğunda "?"
karakteri **yalnızca herhangi tek bir karakteri** kapsamak için
kullanıyorken, regex üzerinde soru işareti **sıfır veya bir tane
karakteri** kapsamak için kullanılıyor. Belki size önemli bir fark gibi
gelmemiş olabilir fakat bu gibi detaylar üretilecek örüntüleri tamamen
değiştireceği için aslında çok önemli.

Genelde modern programlama dillerinin hepsinde regex kullanmak mümkün
ancak bash kabuğu programlanabilir yapıda olmasına karşın doğrudan kendi
içinde regex kullanmıyor. Bunun yerine bir önceki kısımda da ele
aldığımız şekilde mevcut dosya ve klasörlerin isimlerine genişletilmek
üzere "dosya ismi genişletmesi" ya da diğer adıyla "globbing" olarak
geçen kabuğun sağladığı "yıldız" "soru işareti" ve "köşeli parantez"
joker karakterlerini kullanıyor. **Bash kabuğu yalnızca kendi
bünyesindeki genişletmeleri kullanıyor.** Çünkü bash kabuğu,
kullanıcılara sistem üzerindeki araçları bulma ve çalıştırma için bir
ortam sağlamak amacında. Bu amacı doğrultusunda da kendisine ait olan bu
özel genişletme karakterleriyle bazı kolaylıklar sunuyor, hepsi bu.
Zaten regex ile bash kabuğunun genişletmeler için kullandığı karakterler
benzer olduğu için bash kabuğunun aynı karakterler ile hem genişletme
sunup hem de aynı anda regex desteklemesi pek makul değil.

Peki bash kabuğu üzerinde regex'in imkanlarından faydalanmamız mümkün
değil mi ? Elbette mümkün.

Bash kabuğu dahili olarak regex desteklemediği için kabuğun
genişletmelerini kullanmak yerine regex kullanarak metinlerdeki
örüntüleri bulmamız gerektiğinde de, `sed` `awk` veya `grep` gibi regex
destekleyen araçlar ile işimizi halledebiliyoruz.

Yani kabuğun genişletme özellikleri kabuğun kendisine ait olan gömülü
özellikler. Dolayısıyla bash kabuğu üzerinde doğrudan yalın şekilde bu
özel karakterleri kullandığımızda kabuk her zaman bunları genişletme
karakteri olarak yorumluyor olacak.

Eğer harici olarak regex kullanmamız gerekiyorsa, regex yeteneğine sahip
olan `grep` `sed` `awk` gibi araçları kullanarak metinsel verileri
istediğimiz biçimde işleyebiliyoruz. Zaten kabuğun amacının bize komut
satırında çalışma ortamı sağlamak olduğundan daha önce tekrar tekrar
bahsettik. Dolayısıyla zaten kabuğun doğrudan kendi içinde regex
desteklemesi gerekmiyor çünkü kabuğun asıl görevi bizim ihtiyacımız olan
araçları bulup bu araçları konsol üzerinden rahat yönetebilmemiz. Biz
istediğimiz aracı kabuk sayesinde çalıştırdıktan sonra zaten o aracın
tüm özelliklerini kabuktan bağımsız olarak kullanabiliyoruz.

Yani kabuğun regex desteklememesi bir eksiklik değil, kabuğun yapısının
bir parçasıdır. Kabuk tüm bölüm boyunca bahsettiğimiz gibi bize gerekli
çalışma ortamını sağlayacak genişletme özelliklerine zaten sahip. Eğer
regex gibi ek özellikler gerekiyorsa, bu özellikleri destekleyen harici
araçları kullanarak işlerimizi halledebiliyoruz.

Regex ile kabuğa ait genişletmeler arasındaki farkı iyi anlamamız,
kabuğa vereceğimiz komutların sonuçları üzerinde çok etkili.

Ben kabuğa ait genişletme karakterleri ile regex in farkını size
göstermek için çok basit bir örnek ele almak istiyorum. Ancak vereceğim
örneğin net biçimde anlaşılabilmesi için de öncelikle alıntı karakteri
olarak geçen tek ve çift tırnak kullanımına da çok kısaca değinmemiz
gerekiyor.

Alıntı Karakterleri
-------------------

Kabuk için özel anlam ifade eden
metakarakterlerin(`? { } $ ; & | < > ( ) ' " \ # ~ ! ^ = + - _ . , : % @ / *`)
kabuk tarafından özel anlamlarına genişletildiğini tüm bu bölüm boyunca
adım adım ele aldık. Eğer kabuk için özel anlamı olan karakterlerin
kabuğun genişletmesinden muaf tutulmasını istersek bu karakterleri
tırnak içinde yazarak kabuk için sıradan karakterler olarak
görülmelerini sağlayabiliyoruz.

Eğer hatırlıyorsanız, `mkdir yeni klasor` şeklinde komut girdiğimizde
aradaki boşluktan dolayı "yeni" ve "klasor" isimli iki ayrı klasör
oluşturulmuştu. Çünkü kabuk buradaki boşluk karakterini, komutu
argümanlara ayırmak için koyduğumuzu düşünüyordu.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls
Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos

┌──(taylan@linuxdersleri)-[~]
└─$ mkdir yeni klasor

┌──(taylan@linuxdersleri)-[~]
└─$ ls
Desktop    Downloads  Music     Public     Videos
Documents  klasor     Pictures  Templates  yeni
```

Bakın burada yine iki ayrı klasör oluşturuldu. Bu duruma çözüm olarak da
klasör ismini tırnak içinde yazmıştık. Tekrar deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir 'yeni klasor'

┌──(taylan@linuxdersleri)-[~]
└─$ ls
 Desktop     klasor     Public      yeni
 Documents   Music      Templates  'yeni klasor'
 Downloads   Pictures   Videos
```

Bakın bu kez tırnak içinde yazdığımız için buradaki boşluk karakteri
klasörün ismine dahil edildi ve bu isimde tek bir klasör oluşturuldu.
İşte bizzat bu örnek üzerinden ele aldığımız durum burada bahsi geçen
**alıntılama** kavramının ta kendisi. Tırnak içinde yazmaya alıntılama
deniyor ve tırnak içindeki karakterler kabuk için ifade ettikleri özel
anlamlardan muaf tutuluyorlar.

Söz konusu alıntılama olduğunda tek ve çift tırnak kullanabileceğimiz
iki alternatif yöntem bulunuyor.

Bash kabuğu için tek tırnak en katı alıntılama biçimi. Bu sebeple tek
tırnak içindeki hiç bir karakter kabuk tarafından özel anlamaları
dahilinde ele alınmıyor.

Hemen denemek için şu ana kadar ele aldığımız genişletme karakterlerini
tek tırnak içinde yazıp `echo` aracı ile konsola bastırmayı deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo '{1..5} [a-z]* ~ $SHELL' 
{1..5} [a-z]* ~ $SHELL
```

Bakın tek tırnak içinde yazmış olduğum hiç bir genişletme karakteri
kabuk tarafından genişletilmedi. Nasıl yazdıysam aynen `echo` aracına
standart karakterler olarak iletilip konsola bastırılması sağlandı.

Şimdi aynı örneği çift tırnak içinde tekrar deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[/etc]
└─$ echo "{1..5} [a-z]* ~ $SHELL"
{1..5} [a-z]* ~ /usr/bin/bash
```

Değişken genişletmesinin uygulanıp diğerlerinin uygulanmadığı bir çıktı
aldık. Çok fazla detaylarına girmeyeceğiz ancak çıktılarda
görebildiğiniz gibi **değişken** olarak da bilinen buradaki **parametre
genişletmesi** çift tırnak içinde geçerliliğini korumaya devam ediyor.

**Kıvırcık parantez genişletmesi, tilde genişletmesi ve dosya ismi
genişletmeleri ise çift tırnak içinde geçerliliğini yitiriyor**. Çünkü
bash kabuğu çift tırnak içindeki dolar işaretini ve ters slash
karakterleri istisna olarak görüp özel işlevlerini yerine getirmelerini
sağlıyor.

Aslında başka genişletme kuralları ve detayları da var ancak konuyu
detaylandırıp kafamızı karıştırmayalım. Burada dikkatinizi çekmek
istediğim asıl nokta, kıvırcık parantez tilde ve dosya ismi genişletmesi
gibi bazı özel karakterlerin kullanıldığı bu genişletmelerin çift veya
tek tırnak içinde geçerli olmadığı.

Genişletmeler tırnaklar içinde geçerli olmadığı için bizler de regex
destekleyen araçlara komut girerken regex karakterlerinin kabuk
tarafından yanlış anlaşılmasını önlemek için tırnak içinde yazıyoruz.
Çünkü regex karakterleri ile kabuğun kullandığı metakarakterler
birbirine benziyor. Örneğin regex de kıvırcık ve köşeli parantezleri
kullanıyor. Ayrıca nokta soru işareti yıldız gibi özel karakterleri de
kullanıyor. İşte regex ile kabuğun kullandığı aynı karakterlerin
karıştırılmaması için regex kullanmak istediğimizde tırnaklardan
faydalanabiliyoruz.

Söylediklerim yeterince anlaşılır olmadıysa hemen basit bir örnek
üzerinden somut şekilde açıklamaya çalışalım. Örnek için de ileride
ayrıca ele alacağımız `grep` aracını kullanabiliriz. `grep` aracı
filtreleme yapmamızı sağlayan bir araç.

Öncelikle test edebilmemiz için bir test ortamı oluşturalım. Ben mevcut
bulunduğum dizinine `mkdir ada` komutu ile ismi "ada" olan bir klasör
oluşturuyorum.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir ada
```

Şimdi bir de içerisinde "**a**" ile başlayıp "**a**" ile biten birkaç
kelime bulunan birkaç dosya oluşturalım. Bunun için
`echo a{b..e}a > metin1.txt` şeklinde komutumuzu girip `cat` ile dosya
içeriğini teyit edebiliriz.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo a{b..e}a > metin1.txt

┌──(taylan@linuxdersleri)-[~]
└─$ cat metin1.txt 
aba aca ada aea
```

Bakın "aba aca ada aea" şeklinde yeni kelimeler bu dosyaya eklenmiş.
Şimdi yeni bir tane dosya oluşturmak için `echo a{f..k}a > metin2.txt`
şeklinde komutumuzu girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo a{f..k}a > metin2.txt

┌──(taylan@linuxdersleri)-[~]
└─$ cat metin2.txt                       
afa aga aha aia aja aka
```

Bakın bu dosyada da "**a**" ile başlayıp "**a**" ile biten çeşitli
ifadeler var. Tamamdır şimdi testimize geçebiliriz.

`grep` aracı ile araştırma yaparken `grep` komutundan sonra araştırmak
istediğimiz karakter kalıbını yazıp daha sonra bu kalıbın araştırılacağı
metinleri de argüman olarak eklememiz gerekiyor.

Şimdi ben `grep 'a*a' metin*.txt` şeklinde komutumu giriyorum.

![3.webp](https://www.linuxdersleri.net/egitim/temel-linux/genisletme/3.webp)

Bakın içerisinde "a" ile başlayıp "a" ile biten bütün kelimelerdeki "a"
karakterleri renkli şekilde bize sunuldu. Yani filtrelemiş olduk. Şimdi
aynı komutu tırnak işaretleri olmadan tekrar girmeyi deneyebiliriz.

![4.webp](https://www.linuxdersleri.net/egitim/temel-linux/genisletme/4.webp)

Bakın bu kez yalnızca "ada" ifadesini içeren satırın filtrelendiğini ve
"ada" ifadesinin renklendirildiğini görüyoruz. Şimdi neden bu iki
çıktının birbirinden farklı olduğunu açıklayacak olursak.

Burada tırnak işareti kullanarak girdiğimiz komuttaki bu asterix yani
yıldız karakteri tırnak içinde olduğu için kabuk tarafından
genişletilmedi. Yani görmezden gelindi fakat sondaki `metin*` argümanı
tırnak içinde olmadığı için dosya ismi genişletmesi dolayısıyla
"***metin1.txt***" ve "***metin2.txt***" argümanlarına dönüştürülmüş
oldu. Ve en nihayetinde genişletmeler uygulandıktan sonra en son halini
alan bu argümanlar `grep` aracına iletildi. `grep` aracı da regex'i
desteklediği için bu kalıbı regex kalıbı olarak dikkate alıp
***metin1.txt*** ve ***metin2.txt*** dosyaları içinden bu kalıpla
eşleşenleri bize çıktı olarak sunmuş oldu.

Tırnak işareti kullanmadığımız komuttaysa, kabuğumuz tırnak içinde
olmadığı için bu kalıbı dosya ismi genişletmesi olarak görüp, `grep`
aracını çalıştırmadan önce bu genişletmeyi uyguladı. Benim bulunduğum
dizinde "***ada***" isimli bir klasör olduğu için buradaki "`a*a`"
ifadesi de kabuk tarafından dosya ismi genişletmesi dolayısıyla `ada`
argümanına dönüştürüldü. Ayrıca sondaki "`metin*`" ifadesi de dosya
genişletmesi ile metin ifadesiyle başlayan "***metin1.txt***" ve
"***metin2.txt***" dosyalarına genişletildiği için komutumuz
`grep ada metin1.txt metin2.txt` halini almış oluyor. `grep` aracına da
bu argümanlar iletildi. Dolayısıyla `grep` aracı bu dosyalar içinde
"**ada**" ifadesini arayıp filtrelemiş oldu.

İşte bakın bizzat örnekler üzerinden de teyit ettiğimiz gibi regex
karakterlerini çift tırnak içinde yazmadığımızda kabuk bu karakteri
görmezden gelmediği için kabuğun kendine ait olan genişletme
karakterleri olduğunu düşünüp genişletmeyi uyguluyor.

Kabuğa girdimiz komutlar öncelikle kabuk tarafından anlamlandırıldığı
için kabuk örneğin `grep` aracını çalıştırmadan önce kendi üzerine düşen
görevi yerine getirip varsa genişletmeleri uyguluyor. Genişletmelerden
sonra komutumuzdaki argümanlar son halini aldığında `grep` aracı
çalıştırılıp bu argümanlar `grep` aracına iletiliyor.

Bu sebeple kabuğun genişletmesinden kaçıp, girdiğimiz bu argümanın
`grep` aracına bu şekilde ulaşması için de tırnak içinde yazmamız
gerekti. Hatta tırnak içinde yazmadan kaçış karakteri sayesinde yine bu
asterix karakterinin özel anlamının kabuk tarafından görmezden
gelinmesini de sağlayabiliriz. Ben denemek için komutumu
`grep a\*a metin*` şeklinde giriyorum.

![5.webp](https://www.linuxdersleri.net/egitim/temel-linux/genisletme/5.webp)

Bakın tıpkı tırnak içinde yazdığımızdaki gibi buradaki ifade dosya ismi
genişletmesi olarak sayılmadan `grep` aracına iletildiği için bu kalıp
da regex dahilinde değerlendirildi. Buradaki ters slash `\` kaçış
karakteri, kendisinden sonra gelen karakterin özel anlamının görmezden
gelinmesini sağladığı için ben asterix karakterinden hemen önce
kullanarak kabuğun dosya ismi genişletmesini önlemiş oldum.

Böylelikle regex ile kabuk genişletmelerinin benzer gözüküyor olmalarına
karşın farklı çalışma yapıları olduğunu bu örnekle ele almış olduk.
Genellikle önemsiz gözüken bu gibi detaylar girdiğimiz komutların
bambaşka sonuçlar üretmesine neden olduğu için aslında çok önemli. Bu
sebeple zaten tek tek tüm temel detaylardan bahsetmeye gayret ediyoruz.
Regex kullanımından da eğitimin devamında yeri geldiğinde çok kısaca
bahsediyor olacağız.

Ben şimdi son olarak çok kısaca komut ikamesi genişletmesinden de
bahsedip genişletme anlatımlarını sonlandırmak istiyorum.

Komut İkamesi Genişletmesi
--------------------------

Esasen temel eğitimde bu genişletmeden bahsetmeyi düşünmüyordum fakat,
sık karşılaşabileceğiniz ve gerektiğinde işinize yarayabileceği için çok
kısaca ele almak istiyorum.

Komut ikamesi kavramı, ikame kelimesinin de yardımıyla çıkarım
yapabileceğimiz gibi, komutların ürettiği sonuçların bu genişletmenin
kullanıldığı tanımlamanın yeri almasından ibaret. Biliyorum ilk kez
duyduğunuz bu tanımlama hiç bir şey ifade etmiyor. Hemen daha anlamlı
hale getirmek için örnekler üzerinden ele almaya çalışalım.

Normalde komut ikamesi daha çok kabuk programlamada kullanılıyor o
yüzden size şimdi çok mantıklı gelmese de birkaç örnek vermek istiyorum.
Ancak merak etmeyin eğitimin devamında biraz daha fazla detay
öğrendikten sonra daha makul bir kullanım örneğini ele alırız mutlaka.
Siz şimdi yalnızca komut ikamesi genişletmesinin nasıl çalıştığına
odaklanın lütfen.

Ben "mevcut dizin" ifadesinden sonra konsola bulunduğum dizinin
bastırılmasını istiyorum. Bunun için `echo “mevcut dizin $(pwd)”`
şeklinde komutumu girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "mevcut dizin $(pwd)"
mevcut dizin /home/taylan
```

Bakın mevcut dizin ifadesinden sonra `pwd` komutunun çıktısı argüman
olarak genişletildiği için buradaki çıktıya bastırılmış oldu. Buradaki
dolar işaretinden sonra parantez içinde yazmış olduğum tanımlama aslında
**komut ikamesi genişletmesi** olarak geçiyor. Ben parantez içinde `pwd`
komutunu girdiğim için bu `pwd` komutu alt kabukta çalıştırıp bu komutun
sonucu bu tanımlamanın yerine argüman olarak genişletilmiş oldu.

Ek bir örnek olarak bir dosya içindeki ifadeleri, yeni oluşturulacak
klasör isimleri üzerinde kullanabiliriz. Öncelikle
`echo “birinci ikinci ucuncu” > dosya.txt` komutu ile içerisinde
"birinci ikinci ucuncu" ifadeleri bulunan dosyamızı oluşturalım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "birinci ikinci ucuncu" > dosya.txt

┌──(taylan@linuxdersleri)-[~]
└─$ cat dosya.txt 
birinci ikinci ucuncu
```

Tamamdır dosyamızı oluşturduk. Şimdi bu dosyanın içeriğindeki isimlerin
alınıp okunması ve bu isimlerle yeni klasörler oluşturulmasını için
`mkdir $(cat dosya.txt)` şeklinde komutumuzu girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir $(cat dosya.txt)

┌──(taylan@linuxdersleri)-[~]
└─$ ls                                   
 ada         ikinci       Public
 birinci     klasor       Templates
 Desktop     metin1.txt   ucuncu
 Documents   metin2.txt   Videos
 dosya.txt   Music        yeni
 Downloads   Pictures    'yeni klasor'
```

Bakın tam olarak dosyanın içerisine yazdığımız ifadeler klasör isimleri
olarak kullanılmış. Yani dosya içeriğinin okunup bu dosya içeriği
üzerinden `mkdir` aracına iş yaptırmış olduk. Normalde `mkdir` aracı
kendisi bu şekilde dosyadan okuyup klasör oluşturmayı desteklemiyor
ancak biz komut ikamesi sayesinde dosya içeriğini `cat` aracı ile okuyup
bu çıktıları bu `mkdir` aracına argüman olarak iletmeyi başardık.

Tıpkı bu örneğimizde olduğu gibi siz de komut ikamesinden farklı
durumlarda faydalanabilirsiniz. Mesela aynı şekilde oluşturduğumuz
dizinleri silmek için de `rmdir $(cat dosya.txt)` şeklinde komutumuzu
girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ rmdir $(cat dosya.txt)               

┌──(taylan@linuxdersleri)-[~]
└─$ ls                                   
 ada         klasor       Public
 Desktop     metin1.txt   Templates
 Documents   metin2.txt   Videos
 dosya.txt   Music        yeni
 Downloads   Pictures    'yeni klasor'
```

Bakın dosyadaki isimlerden oluşturulmuş olan klasörler yine aynı şekilde
dosyadaki isimler sayesinde silinmiş oldu. `mkdir` ve `rmdir` aracı
normalde bu şekilde dosyadan içerik okuyarak çalışmıyorlar ama biz komut
ikamesi yardımıyla gereken çözümü üretmeyi başardık.

Benim ele aldığım bu örnekler komut ikamesinin kullanımına dair son
derece basit örnekler ama bence komut ikamesi genişletmesinin nasıl
çalıştığını anlamamız için yeterli. Örneğin biz komut ikamesini
`$(komut)` şeklinde tanımladık ama alternatif olarak ters tırnak `'`
içinde(Türkçe klavyemizden AltGr + , tuşlaması ile ters tırnak
üretebilirsiniz) yazdığımız komutlar da komut ikamesi olarak görülüyor.

Örneğin ben denemek için `echo “burası 'pwd' "` şeklinde ters tırnak
içinde komutumu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "burası `pwd`"                  
burası /home/taylan

┌──(taylan@linuxdersleri)-[~]
└─$ echo "burası $(pwd)"                 
burası /home/taylan
```

Bakın ters tırnak içine aldığımız komut çalıştırıldı ve çıktısı bu
komutun bulunduğu yere genişletilerek `echo` aracına argüman olarak
verildi. Dolayısıyla bu çıktıyı da alabildik. Yani komut ikamesi
genişletmesi için ters tırnak veya dolar işaretinden sonra parantez
içinde komut girebilirsiniz. Ben dolar işaretinden sonra parantez içinde
yazma kuralını öneriyor olsam da siz her iki kullanımla da karşılaşıyor
olacaksınız. Bu sebeple özellikle ters tırnak kullanımından da bahsetmek
istedim.

En nihayetinde bu bölüm içerisinde kabuk üzerinde yer alan en sık
kullanılan birkaç genişletme türlerinden bahsedip, gerektiğine nasıl
faydalanabileceğimizi öğrenmiş olduk. Daha fazlası için bash kabuğunun
[dokümantasyonlarına](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html)
göz atabilirsiniz fakat giriş seviyesi temel eğitim için yani bence
mevcut eğitimi takip etmek için bahsettiklerimiz yeterli.

Genişletmeleri daha iyi anlamak için tek yapmanız gereken burada
bahsetmiş olduğumuz genişletmelere dair bol bol pratik yapmak. Pratik
yaptıkça aslında ne kadar basit ve kullanışlı bir yapı olduğunu fark
edeceksiniz.

Alıştırmalar
------------

Alıştırmaları gerçekleştirebilmek için dilerseniz çalışma ortamı
oluşturabilirsiniz. Bunun için aşağıdaki adımları takip etmeniz yeterli.

Öncelikle test ortamı için yeni bir klasör oluşturup bu dizine geçiş
yapalım.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir test-ortami
┌──(taylan@linuxdersleri)-[~]
└─$ cd test-ortami
┌──(taylan@linuxdersleri)-[~/test-ortami]
└─$
```

Bu dizine, aşağıdaki betik dosyasını `cat > betik.sh` komutunun ardından
Ctrl + D tuşlaması ile kaydedip `chmod +x betik.sh` ile yetki verelim ve
`./betik.sh` komutu ile dosyayı çalıştıralım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/test-ortami]
└─$ cat > betik.sh
#!/bin/bash

# Rastgele uzantılar
extensions=("txt" "csv" "docx" "pdf" "jpg" "png")

# Maksimum dosya sayısı
max_files=75

# Karakter kümesi
chars="a-zA-Z0-9"

# Dosya sayacı
file_count=0

while [ $file_count -lt $max_files ]; do
  # Rastgele dosya ismi oluşturma
  random_filename=$(tr -dc "$chars" < /dev/urandom | head -c 5)
  
  # Rastgele uzantı seçimi
  random_extension=$(shuf -n 1 -e "${extensions[@]}")
  
  # Tam dosya ismi
  filename="${random_filename}.${random_extension}"
  
  # Dosya oluşturma
  touch "$filename"
  
  # Dosya sayacını artırma
  ((file_count++))
done

ls # Üretilen mevcut dizindeki dosyaları yazdırmak için

┌──(taylan@linuxdersleri)-[~/test-oratami]
└─$ chmod +x betik.sh
```

Bu betik mevcut bulunduğunuz dizine 75 rastgele dosya oluşturacaktır. Bu
sayede bu dizinde her türlü genişletme alıştırması yapmak için yeterli
örneğe sahip olabilirsiniz. Gerekli çalışma ortamını kurduktan sonra
aşağıdaki alıştırmaları pratiğe dökmeyi deneyebilirsiniz.

**ℹ️ Not:** **Buradaki betik dosyası her seferinde rastgele veriler
ürettiği için aşağıdaki alıştırmalarda yer alan örüntülere tamamen
uyacak dosya isimleri oluşturulmamış olabilir.** Bu durumda soruya uygun
olan dosya veya klasör isimlerini kendiniz oluşturup genişletme
kurallarını test edebilirsiniz.

Sorular
-------

1.  Başlangıcında herhangi tek bir karakter olan ve devamındaki
    karakterler "**x**", "**y**" veya "**t**" olup sonraki karakterleri
    de herhangi türden karakter olan dosya ismi genişletmesini nasıl
    tanımlarsınız?

2.  Başlangıcında "**a**" olan ve sonu "**.txt**" veya "**.pdf**" veya
    "**.webp**" ile biten dosya ve dizinleri nasıl filtreleyebilirsiniz?

3.  "**a**" ile başlayıp "**g**" ile biten tüm dosya ve klasörleri
    kapsamak için genişletmeyi nasıl tanımlarsınız?

4.  İlk harfi herhangi tek bir karakter olan ve devamında "**x**"
    karakteri bulunan ve sonrasındaki karakter sayısı ve biçimi fark
    etmeyen bir dosya ismi genişletmesini nasıl tanımlarsınız?

5.  Sonunda "**.txt**" uzantısı bulunanlar hariç tüm dosyaları nasıl
    filtrelersiniz ?

6.  Başlangıcında 1'den 13'e kadar sayılardan biri olan ve devamında tam
    olarak herhangi 7 karakteri barındıranları nasıl filtrelersiniz ?

7.  İsminin başında "**1**", "**4**", veya "**5**" rakamlarından birini
    barındıran ama sonunda "**a**", "**b**", "**t**" veya "**g**"
    karakterlerini barındırmayan dosya ismi genişletmesini nasıl
    tanımlarsınız?

8.  İlk karakteri "**x**", "**y**" veya "**t**" olan ancak son karakteri
    "**x**", "**y**" veya "**t**" olmayan dosya ismi genişletmelerini
    nasıl tanımlarsınız?

9.  İlk karakteri "**m**", "**n**" veya "**o**" olan ve son karakteri
    "**a**", "**b**" veya "**t**" olan dosya ismi genişletmelerini nasıl
    tanımlarsınız?

10. İlk karakteri "**a**" veya "**b**" olan ve içinde "**x**" veya
    "**y**" karakteri bulunan dosya ismi genişletmelerini nasıl
    tanımlarsınız?

11. İlk karakteri "**5**" rakamından küçük, son karakteri ise küçük bir
    harf olan dosya ismi genişletmelerini nasıl tanımlarsınız?

12. İlk karakteri "**p**" veya "**q**" olan ve içinde "**xyz**" karakter
    dizisi geçen dosya ismi genişletmelerini nasıl tanımlarsınız?

13. İsminin içinde "**linux**" geçen dosya ismi genişletmelerini nasıl
    tanımlarsınız?

14. İlk iki karakteri "**ab**" olan ve içinde "**123**" sayı dizisi
    geçen dosya ismi genişletmelerini nasıl tanımlarsınız?

15. İlk karakteri "**a**" olan ve en az beş karakter içeren dosya ismi
    genişletmelerini nasıl tanımlarsınız?

16. İlk karakteri "**x**" veya "**y**" olan ve son karakteri "**x**"
    olan dosya ismi genişletmelerini nasıl tanımlarsınız?

17. İsminin içinde "**abc**" geçmeyen dosya ismi genişletmelerini nasıl
    tanımlarsınız? (`find` aracının hariç tutma özelliği olan `!`
    işaretini kullanabilirsiniz.)

18. İlk karakteri bir büyük harf olan ve içinde en az iki sayı geçen
    dosya ismi genişletmelerini nasıl tanımlarsınız?

19. İlk iki karakteri bir harf olan ve son karakteri "**.txt**" olan
    dosya ismi genişletmelerini nasıl tanımlarsınız?

20. İlk karakteri bir sayı olan ve içinde en az üç harf bulunan(küçük
    veya büyük harf, dosya uzantıları fark etmeksizin) dosya ismi
    genişletmelerini nasıl tanımlarsınız?

Yanıtlar
--------

1.  `ls ?[xyt]*`
2.  `ls a*.{txt,pdf,jpg}`
3.  `ls a*g`
4.  `ls ?x*`
5.  `find . ! -name "*.txt"`
6.  `ls [1-13]???????`
7.  `ls [145]*[!abtg]`
8.  `ls [xyt]*[^xyt]` veya `ls [xyt]*[!xyt]`
9.  `ls [mno]*[abt]`
10. `ls [ab]*[xy]*`
11. `ls [0-5]*[a-z]`
12. `ls [pq]*xyz*`
13. `ls *linux*`
14. `ls ab*123*`
15. `ls a????*`
16. `ls [xy]*x`
17. `find . ! -name "*[abc]*"`
18. `ls [A-Z]*[0-9]*[0-9]*`
19. `ls [a-z][a-z]*.txt`
20. `ls [0-9]*[a-zA-Z]*[a-zA-Z]*[a-zA-Z]*`

**ℹ️ Hatırlatma:** Betik dosyasının, buradaki sorulara uyacak
örüntülerde dosya isimleri üretmeyebileceğini ve dolayısıyla doğru
genişletmeyi kullansanız bile sonuç alamayabileceğinizi unutmayın
lütfen. En kesin yol, ilgili örüntüye uyacak birkaç dosyayı elle
oluşturup genişletmeyi tekrar kontrol etmektir.

Örnek alıştırmalar burada son buldu fakat elbette benzer şekilde daha
fazlası için kendi kendinize olası filtreleme problemleri
tasarlayabilirsiniz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 11. Ders 47 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Şimdiye kadar dosya oluşturma ve düzenlemeye dair pek çok araçtan söz
etmiş olduk. Anlatımın devamında dosyalarla ilgili birkaç ayrıntıdan
daha bahsediyor olacağız. Fakat diğer ayrıntılardan bahsetmeden önce
belki de en temel işlevler olan kopyalama taşıma ve silme işlevlerini
yerine getirebileceğimiz araçlarından bahsetmek istiyorum.

`cp` Komutu
-----------

Komut satırı üzerinden dosya veya dizinleri kopyalamak istediğimizde
"**c**o**p**y" ifadesinin kısaltmasından gelen `cp` aracını
kullanabiliyoruz.

Ben denemek için öncelikle "orijinal" isminde bir dosya oluşturup,
içerisine "ben dosyayım" yazıp kaydediyorum.

``` {.bash}
└─$ echo "ben dosyayım" > orijinal

└─$ cat orijinal 
ben dosyayım
```

Bakın dosyam sorunsuzca kaydedildi.

Dosya İsmini Değiştirmek
------------------------

Eğer bu dosyayı bulunduğum dizine farklı bir isimle kopyalamak istersem
`cp orijinal dosya dosyanın_kopyası` şeklinde komut girebilirim.

``` {.bash}
└─$ cp orijinal kopya

└─$ ls
kopya  orijinal

└─$ paste orijinal kopya 
ben dosyayım    ben dosyayım
```

Bakın orijinal dosya ile kopyalamış olduğum dosyanın içeriği birebir
aynı. Tek fark kopyalanırken oluşturulan dosya isminin benim istediğim
şekilde olması. `cp` komutunun en temel kullanımı bu şekilde.

Eğer mevcut bulunduğumuz dizine değil de istediğimiz farklı bir dizine
dosya veya dizin kopyalamak istersek tek yapmamız gereken kopyanın tam
olarak hangi dizine hangi isimle kaydolacağını belirtmek. Ben orijinal
dosyasını, kendi ev dizinimdeki ***Documents*** klasörünün altına aynı
isimde kopyalamak istiyorum. Bunun için `cp orijinal ~/Documents`
şeklinde yazıyorum.

``` {.ruby}
└─$ cp orijinal ~/Documents/

└─$ ls ~/Documents/                                              
belgeler  bulbeni  metinler  metin.txt  orijinal
```

Bakın burada ilk olarak orijinal dosyanın yani kopyalanacak dosyanın
ismini girip, daha sonra kopyanın tam olarak nereye kaydolması
gerektiğini belirtebiliyoruz. Burada klasör isminden sonra özellikle bir
dosya ismi belirtmediğim için orijinal dosyanın ismi de birebir
kopyalanıp bu dizine kaydoldu.

Eğer dosyayı farklı bir isimle kopyalamak isteseydim, dizin adresinden
sonra dosyanın ismini belirtebilirdim. Örneğin
`cp orijinal ~/Documents/kopya` şeklinde komut girebilirim.

``` {.ruby}
└─$ cp orijinal ~/Documents/kopya                                

└─$ ls ~/Documents/                                              
belgeler  bulbeni  kopya  metinler  metin.txt  orijinal
```

Bakın istediğim dizine tam olarak istediğim isimde dosyamı sorunsuzca
kopyalayabildim.

Tabii ki ben yalnızca mevcut bulunduğum dizindeki bir dosyayı başka bir
dizine kopyalamak üzere örnekler gösterdim ama yetkiniz olduğu sürece
istediğiniz dizindeki dosyayı istediğiniz başka bir konuma
kopyalayabilirsiniz. Örneğin ben `cp ~/Documents/orijinal /tmp/` komutu
ile ***Documents*** dizini altındaki "***orijinal***" isimli dosyayı
***/tmp*** dizini altında kopyalayabilirim.

``` {.bash}
└─$ cp ~/Documents/orijinal /tmp/                                

└─$ cat /tmp/orijinal                                            
ben dosyayım
```

Bakın dosyam sorunsuzca kopyalanmış.

Şimdiye kadar tek bir dosayı kopyalamayı ele aldım ama aslında birden
fazla dosyayı da aynı anda kopyalayabiliriz. Örnek olması için öncelikle
`touch a b c d` komutu ile ***a b c*** ve ***d*** isimli dosyalar
oluşturup bu dosyalarımı tek seferde ***Document*** klasörüne kopyalamak
istersem komutumu `cp a b c d ~/Documents/` şeklinde girmem yeterli.

``` {.ruby}
└─$ touch a b c d

└─$ cp a b c d ~/Documents/

└─$ ls ~/Documents/
a  belgeler  c  kopya     metin.txt
b  bulbeni   d  metinler  orijinal
```

Bakın tek seferde birden fazla dosyamızı istediğimiz dizine kopyalamayı
başarmışız.

Bu çoklu kopyalama işleminden sonra muhtemelen `cp` aracının girdiğimiz
argümanlardan hangilerinin kopyalanacak dosyalar, hangisinin dosyaların
kopyalanacağı dizin olduğunu nasıl anladığını merak etmiş olabilirsiniz.
Aslında çok basit, birden fazla dosya ismi belirtildiği durumda en
sondaki argümanın bu dosyaların kopyalanacağı adres olması zorunlu. Yani
`cp` aracı bu beklenti ile komutumuzu okuyor. Dolayısıyla girdiğimiz
komuttaki en son argüman `cp` aracı için, bu argümandan önceki tüm
dosyaların kopyalanacağı dizini temsil ediyor.

Neticede birden fazla dosyamızı tek seferde başarılı şekilde kopyalamayı
başardık. Bu harika fakat bazen kopyalama işlemini kontrollü şekilde
gerçekleştirmek de isteyebiliriz. Çünkü özellikle çoklu şekilde
dosyaları bir yerden başka bir yere kopyalarken, hedef gösterdiğimiz
dizinde bizim kopyaladığımız dosyalar ile aynı isimde dosyalar
bulunabiliyor. Eğer özellikle önlem almazsak, kopyalama emri verdiğimiz
için kopyaladığımız dosyalar aynı isimli dosyaların üzerine yazılıyor.
Yani ilgili dizindeki aynı isimli dosyaların içerikleri tahrip ediliyor.
Bu duruma çözüm olarak, üzerine yazılma durumu varsa `cp` aracının bizi
uyarıp bizden izin istemesini talep edebiliriz. Bunun için `-i`
seçeneğini kullanmamız yeterli.

Ben aynı isimli dosyayı `cp` komutu ile ilgiliniz dizine taşıyacak
olursak, herhangi bir uyarı vermeden yeni taşınan dosya eskisinin
üzerine yazılacak. Yani eski dosyadaki veriler silinecek.

``` {.bash}
└─$ cat yeni/dosya 
bu bir dosya

└─$ echo "bu yeni" > dosya                                       

└─$ cp dosya yeni/

└─$ cat yeni/dosya 
bu yeni
```

Bakın herhangi bir uyarı olmadan eski dosya silindi. Eğer biz üzerine
yazma konusunda uyarılmak yani kontrollü şekilde kopyalamak yapmak
istiyorsak `i` seçeneğini kullanabiliriz.

``` {.bash}
└─$ echo "bu son" > dosya

└─$ cp -i dosya yeni/                                            
cp: overwrite 'yeni/dosya'? y
```

Aynı isimli dosya mevcut olduğu için kopyalamadan önce üzerine yazma
için "**y**" yani "yes" ile onay alındı. Eğer üzerine yazmak
istemeseydim "**n**" yani "no" ile reddedebilirdim.

Klasörleri Kopyalamak
---------------------

Şimdiye kadar hep dosyalar üzerinde çalıştık ancak dilersek dizinleri de
kopyalayabiliyoruz. Fakat dizinler kendi içlerinde alt dizinler ve
dosyalar barındırabileceği için bir dizini kopyalarken alt dizinlerin de
kopyalanması için "recursive" yani "özyinelemeli" kopyalama seçeneğini
de komutumuzu eklememiz gerekiyor. Buradaki "özyineleme" ifadesi, dizin
altındaki tüm alt dizinlere teker teker bakıp, tüm dosya ve klasörlerin
otomatik olarak seçilip kopyalanabilmesini sağlıyor. Zaten Linux
üzerinde dizinlerle çalışırken içi dolu olan dizinler üzerinde işlem
yapmak için istisnalar hariç hep "recursive" yani "özyineleme"
seçeneğini özellikle aktifleştirmemiz gerekiyor. Şimdiye kadar bu durumu
zaten bizzat tekrar tekrar deneyimledik. Şimdi tekrar `cp` aracına
dönecek olursak, öncelikle herhangi bir seçenek belirtmeden bir dizini
kopyalamayı deneyebiliriz.

Ben denemek için kendi ev dizinimdeki "***yeni***" isimli klasörü
"***Documents***" dizini altına taşımak üzere `cp ~/yeni/ ~/Documents/`
şeklinde komutumu giriyorum.

``` {.bash}
└─$ cp ~/yeni/ ~/Documents/
cp: -r not specified; omitting directory '/home/taylan/yeni/
```

Bakın komut hata verdi ve hata çıktısında `-r` seçeneğini kullanmadığım
için dizinin kopyalanamadığı belirtilmiş. Şimdi aynı komutumuzu çağırıp
bu kez `-r` seçeneğini de ekleyip tekrar deneyelim.

``` {.ruby}
└─$ cp -r yeni/ Documents/

└─$ ls ~/Documents/
a  belgeler  c  kopya     metin.txt  yeni
b  bulbeni   d  metinler  orijinal
```

Bu kez herhangi bir hata almadık ve `ls` komutu ile de bu dizin taşınmış
olduğunuz bizzat teyit etmiş olduk.

Ben yalnızca en sık kullanacağımız yöntemleri ele aldım ancak `cp —help`
komutu ile bizzat görebileceğiniz gibi `cp` aracının pek çok ek seçeneği
mevcut. İhtiyaç duymanız halinde bu özelliklere göz atıp
kullanabilirsiniz.

`mv` Komutu
-----------

Dosya veya dizinleri kopyalamak yerine taşımak yani yerini değiştirmek
istediğimizde İngilizce "**m**o**v**e" yani "taşıma" ifadesinin
kısaltmasından gelen `mv` aracını kullanabiliyoruz. `mv` aracının
kullanımı da tıpkı `cp` aracı gibi oldukça kolay. Zaten her iki aracın
da hemen hemen pek çok seçeneği ortak kısaltmalar ile tanımlandığı için
rahatlıkla kullanabiliyoruz. Gelin örnekler üzerinden temel kullanımını
ele alalım.

Taşımak istediğimiz dosyayı `mv dosya_adı tanışanacağı_yeni_konum`
şeklinde belirtmemiz yeterli oluyor. Ben örnek olarak mevcut bulunduğum
dizindeki "***dosya***" isimli dosyayı Documents dizini altında taşımak
üzere `mv dosya Documents` şeklinde komutumu giriyorum.

``` {.bash}
└─$ mv dosya Documents/

└─$ ls Documents/                                                
a  belgeler  c  dosya  metinler   orijinal
b  bulbeni   d  kopya  metin.txt
```

Gördüğünüz gibi ilgili dosya taşınmış oldu. Benzer şekilde klasör de
taşıyabiliriz.

``` {.bash}
└─$ mv klasor/ Documents/                                        

└─$ ls Documents/                                                
a  belgeler  c  dosya   kopya     metin.txt
b  bulbeni   d  klasor  metinler  orijinal
```

Benzer şekilde istersek aynı anda birden fazla klasörü veya dosyayı da
taşıyabiliriz. Ben denemek için genişletme karakterinin de yardımıyla
"dosya" "kopya" ve "klasör" için komutumu giriyorum.

``` {.bash}
└─$ mv Documents/{dosya,kopya,klasor} Pictures/                

└─$ ls Pictures/                                                 
 bulbeni
 dosya
 klasor
 kopya
```

Gördüğünüz gibi aynı anda birden fazla dosya ve klasörü taşımamız da
mümkün. Ben örnek sırasında kolaylık olsun diye köşeli parantez
genişletmesini kullandım fakat çoklu taşıma için elbette genişletme
kullanmak zorunda değilsiniz. Taşınması gerekenlerin dizinlerini ve
isimlerini eksiksiz şekilde belirtmeniz yeterli.

Ben örnekler sırasında dosya veya klasörlerin isimlerini değiştirmek
istemediğim için yalnızca taşınacakları adresleri belirttim. Bunun
yerine taşındıkları konumda hangi isimle kaydedilmeleri gerektiğini de
spesifik olarak belirtebiliyoruz aslında. Ben örnek olarak
"***Pictures***" dizini altındaki "***dosya***" isimli dosyayı Desktop
konumuna "***yepyeni-dosya***" ismiyle taşımak istiyorum.

``` {.bash}
└─$ mv Pictures/dosya Desktop/yepyeni-dosya                      

└─$ ls Desktop/
test.txt  yeni-dizin  yepyeni-dosya
```

Gördüğünüz gibi taşınacağı konumun ardından isim belirttiğimizde taşıma
ile birlikte isim değişikliğini de gerçekleştirmiş oluyoruz. Bu yaklaşım
herhangi bir dosya ve klasörün ismini değiştirmek için kullanılan temel
yaklaşımdır. Yani örneğin ben mevcut bulunduğum dizindeki klasörün
yalnızca ismini değiştirmek için kullanabilirim.

``` {.bash}
└─$ ls Pictures/
 bulbeni
 klasor
 kopya
'Yeni Klasor'

┌──(taylan@linuxdersleri)-[~]
└─$ mv Pictures/klasor/ Pictures/yeni-isim

┌──(taylan@linuxdersleri)-[~]
└─$ ls Pictures/                                                 
 bulbeni
 kopya
 yeni-isim
'Yeni Klasor'
```

Gördüğünüz gibi ilgili klasörün dizin adresini değiştirmeden yalnızca
ismini değiştirmiş olduk. İsim değiştirebilme özelliği süper ama isim
değiştirmek için `mv` komutunu kullanırken, **o dizinde daha önceden
yeni tanımladığınız isimde bir klasör olmamasına mutlaka dikkat edin**.
Aksi halde `mv` komutu isim değiştirmek yerine, o isimdeki klasörün
içerisine taşır.

``` {.bash}
└─$ mv Pictures/yeni-isim/ Pictures/Yeni\ Klasor

└─$ ls -R Pictures/                 
Pictures/:
 bulbeni
 kopya
'Yeni Klasor'

Pictures/bulbeni:

'Pictures/Yeni Klasor':
yeni-isim

'Pictures/Yeni Klasor/yeni-isim':
deneme.txt  dosya1  dosya2  dosys3  liste  liste2  oku-beni
```

Gördüğünüz gibi ben klasör ismini daha önce var olan "***Yeni Klasor***"
olarak değiştirmek üzere `mv` komutunu kullandığımda, `mv` aracı isim
değişikliğinden ziyade bu klasörün hedef dizin adresi olduğunu düşündüğü
için bu dizin altında taşıma yapıyor. Zaten bu durumu tahmin etmek zor
değil ancak, yine de dikkat etmeniz için özellikle vurgulamak istedim.

Ayrıca olası veri kayıplarını önlemek adına daha önce `cp` aracını ele
alırken de bahsetmiş olduğum üzerine yazma durumlarından da kısaca
bahsetmek istiyorum. Örneğin çoklu şekilde dosya veya klasörleri
taşıyorsak daha önce `cp` komutunda olduğu gibi her adımda bizden onay
alınmasını talep edebiliriz.

Örneğin benim bulunduğum dizinde a b c d isimli dosyalar var. Ayrıca
yeni isimli klasör içinde de aynı isimli dosyalar mevcut. Eğer ben
mevcut bulunduğum dizindeki dosyaları yeni klasörüne taşırsam, dosyalar
bu klasörün içindekilerin üzerine yazılıyor olacak.

``` {.ruby}
└─$ ls yeni/                                                     
a  b  c  d  dosya  kopya  orijinal

┌──(taylan@linuxdersleri)-[~]
└─$ mv a b c d yeni

┌──(taylan@linuxdersleri)-[~]
└─$ ls yeni/                                              
a  b  c  d  dosya  kopya  orijinal
```

Gördüğünüz gibi herhangi bir uyarı almadan taşıma işlemi
gerçekleştirildi. Ben taşıma işlemi sırasında onay alınması için `-i`
seçeneğini kullanmak istiyorum. Bunun için yine aynı isimli dosyalar
oluşturup bunları kontrollü şekilde taşımayı deneyelim. Hatta benzersiz
dosyaları da dahil edelim.

``` {.bash}
└─$ touch a b c d                                      

┌──(taylan@linuxdersleri)-[~]
└─$ mv -i a b c d dosya1 dosya2 yeni/                                   
mv: overwrite 'yeni/a'? y
mv: overwrite 'yeni/b'? y
mv: overwrite 'yeni/c'? n
mv: overwrite 'yeni/d'? n

┌──(taylan@linuxdersleri)-[~]
└─$ ls yeni/
a  b  c  d  dosya  dosya1  dosya2  kopya  orijinal
```

Gördüğünüz gibi yalnızca aynı isimli dosyaların taşınması için onay
istendi. Benim "y" ile onayladıklarım taşınırken, "n" ile reddettiklerim
taşınmadı. Ayrıca benzersiz olan dosyalar da herhangi bir soru
sorulmadan taşınmış oldu. Bu yaklaşım sayesinde üzerine yazma tehlikesi
olmadan, çoklu şekilde dosya taşımamız mümkün oluyor.

Denemek için "***Documents"*** dizini altındaki "***a" "b" "c" "d"*** ve
"***bulbeni"*** isimli dosyaları "***yeni/"*** dizinine taşıyabiliriz.

``` {.bash}
└─$ ls Documents/
a  b  belgeler  bulbeni  c  d  metinler  metin.txt  orijinal

└─$ mv -n Documents/[a-d] Documents/bulbeni yeni/

└─$ ls Documents/                                                                                                
a  b  belgeler  c  d  metinler  metin.txt  orijinal

└─$ ls yeni/                                                                                                     
a  b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal
```

Gördüğünüz gibi "***a" "b" "c" "d"*** dosyaları ile aynı isimli dosyalar
"***yeni/"*** klasöründe bulunduğu için bunlar taşınmazken,
"***bulbeni***" isimli dosya taşınmış oldu. Örnek üzerinden bizzat teyit
ettiğimiz gibi siz de üzerine yazmaya karşı otomatik olarak korumak
isterseniz `-n` seçeneğini kullanabilirsiniz.

`mv` komutu hakkında temelde bilmemiz gerekenler bunlar. Kendi kendinize
biraz daha kurcalarsanız ne kadar kolay kullanılabilir olduğunu bizzat
deneyimleyebilirsiniz. Ben kendimi tekrar etmek istemediğim için çok
fazla örnek vermedim ama siz kendi kendinize hem dosya hem de dizinleri
taşıyarak alıştırmalar yapıp `mv` aracının kullanımını iyi biçimde
kavrayın. Ayrıca her zaman olduğu gibi elbette daha fazlası için
`mv —help` komutu ile diğer seçenekleri ve özellikleri
görüntüleyebilirsiniz.

`rm` Komutu
-----------

Kopyalama ve taşıma araçlarından ve bunların temel kullanımlarından
bahsettik. Şimdi bir diğer temel işlev olan silme işlevinden de
bahsetmek istiyorum. Daha önce de çok kısaca bahsettiğimiz gibi mevcut
dosya ve klasörleri komut satırı üzerinden silmek istediğimizde `rm`
aracını kullanabiliyoruz. `rm` aracının ismi İngilizce "**r**e**m**ove"
yani "silme/kaldırma" ifadesinin kısaltmasından geliyor. Tıpkı `cp` ve
`mv` aracında olduğu gibi `rm` aracının kullanımı da son derece kolay.

İstersek tek bir dosyayı istersek de aynı anda birden fazla dosyayı
silmek için tek yapmamız gereken, silmek istediğimiz dosyaların
isimlerini `rm` komutundan sonra yazmak. Ben bulunduğum dizindeki "a"
isimli dosyayı silmek istiyorum.

``` {.bash}
└─$ ls                                                           
a  b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm a

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal
```

Bakın "a" isimli dosya artık bulunmuyor.

Eğer birden fazla dosyayı silmek istersem isimlerin peş peşe yazmam
yeterli.

``` {.bash}
└─$ ls                                                           
b  bulbeni  c  d  dosya  dosya1  dosya2  kopya  orijinal

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm b c d                                                     

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
bulbeni  dosya  dosya1  dosya2  kopya  orijinal
```

Gördüğünüz gibi birden fazla dosyayı sorunsuzca silmiş olduk. Ben
bulunduğum konumdaki dosyaları sildim. Ancak elbette sistem üzerinde
yetkinizin bulunduğu tüm dosyaları tam dizin adreslerini belirterek
silebilirsiniz.

``` {.bash}
└─$ ls ~/Documents/
a  b  belgeler  c  d  metinler  metin.txt  orijinal

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm ~/Documents/orijinal 

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls ~/Documents/                                     
a  b  belgeler  c  d  metinler  metin.txt
```

***Documents*** klasörü altındaki "***orijinal***" isimli dosyayı
sorunsuzca silmiş oldum.

İşte dosyaları tekil veya çoklu şekilde silmek bu kadar kolay. Tek
yapmanız gereken silmek istediğiniz dosyanın tam olarak konumunu
belirtmek.

Ayrıca ben üzerinde özellikle durmadım ama fark ettiyseniz toplu şekilde
dosya silerken bizden ekstra bir onay alınmadan tek seferde tüm dosyalar
silinmişti. Bu durum kimi zaman istenmeyen sonuçlara yol açabilir. Önlem
olarak eğer istersek silmeden önce her dosya için bizden onay
istenmesini sağlayabiliriz. Bu sayede toplu silme işlemlerinde yanlış
dosyaları silme riskinden kaçınabiliriz. Örnek senaryomuzda, bir dizin
içinde tüm dosyaları silmek üzere konsola `rm *` komutunu girdiğimizi
farz edelim. Bu durumda kabuk yıldız işareti sayesinde bulunduğumuz
dizindeki tüm dosyaları kapsayacağı için tüm dosyaların silinmesi emrini
vermiş oluyoruz.

Örneğin ben şu an içinde bulunduğum "***yeni***" klasörü içerisindeki
yer şeyi silmek üzere `rm *` komutunu girebilirim. Fakat ben tüm
dosyaları silmek istemiyorum, bazılarını eleyip geri kalanları silmek
istiyorum. Bunun için `cp` ve `mv` komutlarında da olduğu gibi `-i`
seçeneğini kullanabiliriz. Denemek için komutumuza `-i` seçeneğini de
ekleyip bu şekilde girelim.

``` {.csharp}
└─$ ls                                                           
bulbeni  dosya  dosya1  dosya2  kopya  orijinal

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -i *                                                      
rm: remove regular empty file 'bulbeni'? n
rm: remove regular file 'dosya'? y
rm: remove regular empty file 'dosya1'? y
rm: remove regular empty file 'dosya2'? y
rm: remove regular file 'kopya'? y
rm: remove regular file 'orijinal'? n

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
bulbeni  orijinal
```

Gördüğünüz gibi "**y**" ile onay verdiklerim silinirken, "**n**" ile
reddettiklerim silinmedi.

Neticede `i` seçeneği sayesinde tüm silme işleminin adım adım bizden
onay alınarak gerçekleştirilmesini sağlamış olduk.

Tamamdır bence dosyaları silmekle ilgili tüm temel bilgilerden
bahsettik. Şimdi klasörleri nasıl silebileceğimizi örnekler üzerinden
ele alalım.

Klasörlerin Silinmesi
---------------------

Normalde `rm` komutunu ekstra bir seçenek belirtmeden kullandığımızda
`rm` aracı yalnızca kendisine argüman olarak verilmiş olan dosyaları
siliyor. Yani aynı isimle eşleşen klasörleri silmiyor. Klasörleri
silmesi için silinmek istenilenin klasör olduğunu İngilizce
"**d**irectory" yani "klasör" ifadesinin kısaltmasından gelen `-d`
seçeneği ile özellikle belirtmemiz gerekiyor.

Hemen deneyelim. Ben test etmek için `mkdir sil-beni` komutu ile yeni
klasör oluşturup, `rm` komutu ile oluşturduğum klasörü silmeyi
deniyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ mkdir sil-beni                                               

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm sil-beni/                                                 
rm: cannot remove 'sil-beni/': Is a directory
```

Bakın aldığımız çıktıda, klasör olduğu için silinemediği konusunda
uyarıldık. Eğer "directory" yani "klasör" ifadesinin kısaltması olan `d`
seçeneğini kullanırsak silebileceğiz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -d sil-beni/                                              

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
bulbeni  orijinal
```

Gördüğünüz gibi `d` seçeneği sayesinde klasörüm sorunsuzca silinmiş
oldu.

Dosyalara benzer şekilde klasörleri de çoklu şekilde silebiliriz. Ben
denemek için `mkdir x y z` komutu ile birden fazla klasör oluşturacağım.
Ve bunları da `rm -di x y z` komutu ile kontrollü şekilde sileceğim.

``` {.bash}
└─$ mkdir x y z

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -di x y z
rm: remove directory 'x'? y
rm: remove directory 'y'? n
rm: remove directory 'z'? y

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
bulbeni  orijinal  y
```

Gördüğünüz gibi `i` seçeneği sayesinde benden onay alınan klasörler
silinmiş oldu.

İçerisi Dolu Olan Klasörlerin Silinmesi
---------------------------------------

Şu ana kadar klasörleri silerken hiç bir problem yaşamadık, çünkü klasör
içerikleri boştu. Eğer klasörlerin içinde başka dosyalar ve klasörler
bulunuyorsa, `rm -d` komutu ile silmemiz mümkün değil.

Mesela teyit etmek için daha önceden oluşturduğum ***Documents*** dizini
altındaki klasörümü silmeyi deneyebilirim.

``` {.bash}
└─$ ls -R ~/Documents/                                           
/home/taylan/Documents/:
a  b  belgeler  c  d  metinler  metin.txt

/home/taylan/Documents/belgeler:

/home/taylan/Documents/metinler:
1.gz  2.gz  3.gz  4.gz  5.gz

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -d ~/Documents/metinler                                   
rm: cannot remove '/home/taylan/Documents/metinler': Directory not empty
```

Gördüğünüz gibi "***metinler***" klasörünün içerisi dolu olduğu için
silme işlemi reddedildi.

İçerisi dolu dizinleri silmek için `-r` seçeneğini kullanmamız
gerekiyor. Buradaki `r` seçeneği İngilizce "**r**ecursive" yani
"özyinelemeli" ifadesinin kısaltmasından geliyor. Bu seçenek sayesinde
klasörün içinde iç içe birden fazla klasör ve dosya olsa da tüm
dosyaların ve klasörlerin silinebilmesi mümkün oluyor. Hatırlıyorsanız
klasör içeriklerini kopyalarken de bu şekilde "recursive" seçeneğini
eklemiştik. En alt dizine kadar bakılıp silmesi de özyineleme özelliğini
temsil ediyor yani. Hatta "recursive" yani "özyineleme" seçeneğini
yalnızca klasörler üzerinde kullandığımız için bu seçenek varken aslında
`rm` aracına ek olarak `-d` seçeneğini de girmemiz gerekmiyor. Yani
`rm -r silinecek-klasör` şeklinde komutumuzu girdiğimizde, belirttiğimiz
dizin tüm içeriğiyle birlikte silinecektir.

``` {.bash}
└─$ rm -r ~/Documents/metinler/

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls -R ~/Documents/                                           
/home/taylan/Documents/:
a  b  belgeler  c  d  metin.txt

/home/taylan/Documents/belgeler:
```

Bakın yalnızca `-r` seçeneğini kullanarak içi dolu klasörü silmeyi
başardım.

Ben kullanmadım ancak özellikle iç içe klasörler ve dosyalar barındıran
klasörleri silerken, `i` seçeneğini ekleyerek yanlış bir dosyayı veya
klasörü silmediğinizden emin olmanızı da önerebilirim. Yine de klasörden
tek seferde kurtulmak istediğinize eminseniz elbette `i` seçeneğini
kullanmak zorunda değilsiniz.

Ayrıca hatırlıyorsanız, boş dizinleri silmek için daha önce `rmdir`
aracını kullanmıştık. İşte `rm -d` komutu `rmdir` aracı ile aynı işlevi
görüyor. İçerisi dolu olan dizinleri silmek için de `rm -r` komutunu
kullanıyoruz. Dolayısıyla emin olmadığınız sürece `rm -r` komutunu
kullanmanız önermem. Yine de elbette klasörü içeriğiyle birlikte silmek
istediğinizden eminseniz kullanabilirsiniz.

Son olarak eğer, tüm silme adımlarının ayrıntılarını da takip etmek
isterseniz "verbose" yani "ayrıntılı" ifadesinin kısaltması olan `v`
seçeneğini de kullanabilirsiniz. Toplu şekilde klasör silerek kullanımı
teyit edebiliriz. Çabucak test etmek için `mkdir {1..9}` komutuyla yeni
klasörler oluşturup, toplu şekilde silmek ve silme işlemiyle ilgili
ayrıntıları da öğrenmek için `rm -dv {1..9}` şeklinde komutumuzu
girebiliriz.

``` {.bash}
└─$ ls                                                           
1  2  3  4  5  6  7  8  9  bulbeni  orijinal  y

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ rm -dv {1..9}                                                
removed directory '1'
removed directory '2'
removed directory '3'
removed directory '4'
removed directory '5'
removed directory '6'
removed directory '7'
removed directory '8'
removed directory '9'
```

Bakın tüm silme işlemi adım adım bastırıldı. Bu şekilde toplu silme
işlemlerini takip etmek istiyorsanız `v` seçeneğini de
kullanabilirsiniz.

Neticede `rm` komutu hakkında bilmemiz gereken tüm temel yaklaşımlardan
bahsettik. Diğer seçenekleri görmek için yardım sayfasına göz
atabilirsiniz.

shred Komutu \| Dosyaları Geri Döndürülemez Şekilde Silmek
----------------------------------------------------------

Geri döndürülemez yani kalıcı silme kavramından bahsetmeden önce silme
işlemlerinin temelde nasıl işlediğinden çok kısaca bahsetmek istiyorum.
Bu sayede kalıcı silmeden kastın ne olduğu daha net anlaşılabilir.

Eğer herhangi bir dosyayı sildiğinizde o dosyanın tamamen yok olduğunu
düşünüyorsanız kesinlikle yanılıyorsunuz. Kısaca özetlemek gerekirse
işletim sistemleri dosya silme emri aldığında o dosyayı gerçekten
diskten silmek yerine, dosyaya ulaşmanızı sağlayan yolun bilgisini
silerler.

![shred-1.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/shred-1.webp)

Yani aslında dosya hala disk üzerinde mevcut olmasına rağmen, sadece
dosyaya giden bağlantı siliniyor. Bu yöntemin kullanılma nedeni dosyayı
gerçekten silmeye oranla çok daha hızlı sonuç vermesidir. Peki ama
gerçek silme işleminden kastımız tam olarak ne ?

Gerçek silme işlemi dediğimiz kavram; disk üzerinde yer kaplayan her
türlü verinin ancak üzerine yeni veriler yazılması ile ortadan
kaldırılabilecek olmasını ifade ediyor.

![shred-2.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/shred-2.webp)

Çünkü üstüne yeni veri yazılarak tahrip edilmeyen her türlü verinin
tekrar kurtarılma ihtimali var. Adli bilişim alanında bu iş için
kullanılan pek çok yazılımsal ve harici olarak fiziksel kurtarma yöntemi
bulunuyor.

İşin özü eğer bir dosyadan geri döndürülemez şekilde kurtulmak
istiyorsak o dosyayı silerken üzerine birden fazla kez rastgele veri
yazılmasını sağlamamız gerekiyor. Pek çok işletim sisteminde bu üzerine
yazma işlemi için harici yazılımlar yükleyip kullanmamız gerekebiliyor.
Ancak söz konusu Linux olduğunda pek çok dağıtımda varsayılan olarak
yüklü gelen `shred` isimli aracı kullanabilme kolaylığa sahibiz.

Zaten `shred` ifadesi Türkçe olarak "parçalamak" anlamına geliyor. Eğer
herhangi bir arama motoruna yazarsanız, karşınıza parçalanmış kağıt
görselleri çıkacaktır. Bu aracı kullanarak, dosyaların üzerine veriler
yazılarak tahrip edilmesini sağlayabiliyoruz. Dosya içeriği tahrip
olduktan sonra da dosyayı güvenle sıradan şekilde silebiliyoruz çünkü
dosya geri getirilse bile orijinali tahrip edildiği için gerçek
içeriğine ulaşılamıyor.

Silme mekanizmalarından bence yeterince bahsettik. Şimdi lafı daha fazla
uzatmadan `shred` komutunun kullanımından bahsederek devam edelim.

`shred` Komutu
--------------

`shred` komutunu herhangi bir ek seçenek belirtmeden kullandığımızda
varsayılan olarak kendisine argüman olarak verilmiş olan dosyanın
üzerine 3 kez rastgele bitler yazılmasını sağlıyor. Eğer daha fazla kez
yazılmasını istersek, `-n` seçeneğini kullanıp kaç kez yazılması
gerektiğini özellikle de belirtebiliyoruz.. Ayrıca `-v` seçeneğini
ekleyerek "**v**erbose" yani "ayrıntılı" çıktı vermesini de
sağlayabiliriz. Bu sayede tüm adımları konsoldan takip edebiliriz.

Ben denemek için `echo “bu bir dosyadır” > okubeni` komutu ile içerisi
dolu yeni bir dosya oluşturuyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ echo "bu bir dosyadır" > okubeni                             

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ cat okubeni                                                  
bu bir dosyadır
```

Şimdi `shred` aracını kullanarak dosya içeriğine rastgele bitler
yazılmasını sağlayabiliriz. Ben varsayılan şekilde yani 3 kez rastgele
bitler yazılması için `shred` aracına özellikle bir sayı vermek
istemiyorum ama işlem adımlarını takip etmek için "verbose" yani
ayrıntılı çıktı seçeneğini ekleyeceğim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ shred -v okubeni                                             
shred: okubeni: pass 1/3 (random)...
shred: okubeni: pass 2/3 (random)...
shred: okubeni: pass 3/3 (random)...

┌──(taylan@linuxdersleri)-[~/yeni]
└─$ cat okubeni                                                  
�r��WwQ%���uuD��J󶤈�����X����m�M���h�E"E�-�F:����ǀi�7▒.>�        d��zO���R�e)a�������F�Z� 䵙x�Z;$s��/��}C���F����u}��o(�K��h���W軄R��XP�KLB�d>�4�7r���c�C�#BD��v�O�I忧�ٱ�-O�/��)%m��
```

Gördüğünüz gibi dosyanın içeriği tamamen okunamaz halde. Artık bu
dosyayı `rm` komutu ile gönül rahatlığıyla silebiliriz çünkü dosya geri
getirilse bile içeriğindeki verilere ulaşılması pek olası değil. Çünkü
içerisine 3 kez rastgele veriler yazıldı. İşte `shred` aracının
kullanımı bu kadar kolay.

Ayrıca daha önce de bahsettiğim şekilde istersek kaç kez rastgele veri
yazılacağını da `-n` seçeneğinin ardından özellikle belirtebiliyoruz.
Örneğin ben 5 kez rastgele veri yazılmasını istersem
`shred -n 5 dosya-adı` şeklinde komutumu girebilirim. Hatta sayıyı
belirtmeye ek olarak rastgele yazma işleminden hemen sonra bu dosyanın
silinmesini de sağlayabiliriz. Dosyanın silinmesi için de `-u`
seçeneğini eklememiz yeterli oluyor.

Ben denemek için bu "***okubeni***" dosyasının üzerine 5 kez rastgele
veri yazılıp daha sonra silinmesini için komutumu girmek istiyorum.
Tabii tüm işlem adımlarını takip edebilmek için bir de `-v` seçeneği ile
ayrıntıların da bastırılmasını istiyorum. Bunun için
`shred -uvn 5 okubeni` şeklinde komutumu giriyorum.

``` {.vbnet}
└─$ shred -uvn 5 okubeni 
shred: okubeni: pass 1/5 (random)...
shred: okubeni: pass 2/5 (ffffff)...
shred: okubeni: pass 3/5 (random)...
shred: okubeni: pass 4/5 (000000)...
shred: okubeni: pass 5/5 (random)...
shred: okubeni: removing
shred: okubeni: renamed to 0000000
shred: 0000000: renamed to 000000
shred: 000000: renamed to 00000
shred: 00000: renamed to 0000
shred: 0000: renamed to 000
shred: 000: renamed to 00
shred: 00: renamed to 0
shred: okubeni: removed
```

Bakın öncelikle dosya içeriğine rastgele 5 kez veriler yazılmış, daha
sonra dosya silinmiş ve son olarak dosyanın isminin de silinmesi için
dosya ismi de adım adım sıfırlar ile doldurularak yok edilmiş. Bu
yaklaşım sayesinde dosyanın isminin dahi disk üzerinden kurtarılması pek
olası değil.

Hatta teyit etmek için `ls` komutu ile mevcut dizinimizi
listeleyebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~/yeni]
└─$ ls                                                           
bulbeni  orijinal  y
```

Bakın gördüğünüz gibi dosyamız işlem sonunda otomatik olarak silinmiş.

Ayrıca benim örnekler üzerinde kullandığım dosyanın içeriği çok küçük
olduğu için tüm işlem çok kısa sürede tamamlandı ancak bu durum her
zaman böyle olmayabilir. Yani üzerine yazma işlemi, üzerine yazılacak
olan dosyanın boyutuna göre değişken uzunlukta sürebilir, sabırla işlem
tamamlanana kadar beklemelisiniz. Benim dosya boyutum çok küçük olduğu
için işlem çok kısa sürede tamamlandı.

Kalıcı olarak istediğiniz dosyalarınızı bu yaklaşım sayesinde güvenli
şekilde silebilirsiniz.

Linux Geri Dönüşüm Kutusu
-------------------------

Komut satırı üzerinden bir dosyayı sildiğimizde, normalde grafiksel
arayüzde olduğu gibi sildiğimiz dosya çöp kutusuna gönderilmiyor. Yani
çöp kutusu olarak geçen dizin yalnızca grafiksel arayüzdeki dosya silme
işlemlerinde kullanılan sembolik bir dosya yolu.

Denemek için grafiksel arayüzdeyken bir dosyanın üzerine tıklayıp
silebilir daha sonra geri dönüşüm klasörüne bakabiliriz.

![trash.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/trash.gif)

Bakın silmiş olduğumuz dosya burada bulunuyor. Şimdi denemek için
`touch deneme` komutu ile yeni bir dosya oluşturup bu dosyayı da `rm`
komutu ile silelim.

![trash-on-commanline.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/trash-on-commanline.gif)

Bakın komut satırı üzerinden silme işlemi gerçekleştirdiğimiz için çöp
kutusuna herhangi bir dosya eklenmedi. Zaten komut satırı üzerinden
sildiğimizde buradaki çöp kutusuna geliyor olsaydı önceki silme
işlemlerinin kalıntılarını burada görüyor olmamız gerekiyordu.

Komut satırından silinen dosyaların burada gözükmüyor olmasına ek olarak
Windows sisteminden de aşina olduğumuz gibi grafiksel arayüzdeyken,
Shift + Delete tuşlaması ile bir dosya veya klasörü sildiğimizde bu
dosya veya klasör bu çöp dizinine gelmeden komut satırında olduğu
şekilde siliniyor.

![shift-delete.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/shift-delete.gif)

Tabii ki Shift + Delete tuşlaması bizim `shred` komutu ile sildiğimiz
gibi silmiyor ancak en azından sadece çöp dizinine de taşımış olmuyor.

Komut satırından veya Shift + Delete ile grafiksel arayüzden sildiğiniz
dosyaları geri getirmek isterseniz de `testdisk` gibi harici veri
kurtarma yazılımları ile ilgili dosyalarınızı kurtarabilirsiniz. Tabii
ki daha önce de belirttiğim şekilde eğer `shred` aracı ile dosya
içeriklerini tahrip ettiyseniz yani kalıcı olarak sildiyseniz kurtarma
yazılımları ile, ilgili dosyaları kurtarmanız pek olası değil.

Artık böylelikle silme ve kurtarma planlarınızı, şimdiye kadar
bahsettiğimiz bilgiler ışığında gerçekleştirebilirsiniz.

Sembolik ve Katı Link \| Soft Link & Hard Link
----------------------------------------------

Anlatımın devamında çok kısaca sembolik ve katı linklerden de bahsetmek
istiyorum.

Fakat sembolik ve katı linklerden bahsetmeden önce, link yapısını yani
aslında buradaki link ifadesinden kastımızı anlamak için öncelikle
"inode" kavramı üzerinde durmamız gerekiyor. Merak etmeyin çok ayrıntıya
girmeyeceğiz.

inode
-----

Dosya sistemindeki veriler depolama birimlerimizde yani diskte bloklar
halinde tutuluyorlar. Dosyalarla ilişkili olan verilerin hangi bloklarda
olduğunun bilgisini de bizlere "**i**ndex **node**" yani kısaca
"**inode**" olarak isimlendirilen yapı haber veriyor.

Örneğin ben ***metin.txt*** isimli bir dosyanın içerisine "merhabalar"
yazıp kaydettiğimde, "merhabalar" ifadesi diskte belirli bir bloğa
kaydediliyor. Ve bu verinin disk üzerinde tam olarak bulunduğu bloğun
veya blokların bilgisi de **inode** olarak isimlendirilen benzersiz
sayısal bir değere atanıyor. ***metin.txt*** dosyası ise bu **inode**
değerine link olarak bağlanıyor. Bu sayede biz ***metin.txt***
dosyasının içeriğini okumak istediğimizde aslında arkaplanda
***metin.txt*** dosyasının bağlı olduğu **inode** değerine bakılıyor.
**inode** değerinin disk üzerinde işaret ettiği bloklardan da bu veriler
getiriliyor. Neticede biz metin.txt ismiyle ilişkili olan "merhabalar"
verisine disk üzerinde kaydedildiği yerden tekrar ulaşmış oluyoruz.

![inode.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/inode.webp)

Yani aslında buradaki ***metin.txt*** dosyası yalnızca benzersiz bir
**inode** değerine bağlı olan **linktir**. **inode** değeri de ilgili
verinin diskteki yerini bildiği için ***metin.txt*** linki üzerinden bu
veriye ulaşabiliyoruz.

İşte tıpkı bu örneğimizde olduğu gibi dosya sistemindeki benzersiz olan
her bir dosya ve klasörün de benzersiz bir inode değeri bulunuyor. Bizim
gördüğümüz dosya ve klasör isimleri de yalnızca bu inode değerlerine
yönlendirme yapan linkler aslında. Dosya veya klasör isminden inode
değerine, inode değerleri üzerinden de disk üzerinde depolanmış olan
verilere kolayca erişebiliyoruz. Buradaki linkler yalnızca biz
insanların disk üzerindeki verilere kolay erişebilmesi için okunaklı
isimlerden oluşan bağlantı noktaları aslında. Yani diskteki "xx yy zz"
bloklarındaki verileri okumak istiyorum demek yerine, "metin.txt"
dosyasını okumak istiyorum demek bizim için çok daha kolay olduğu için
dosya ve klasör isimleri yalnızca birer linktir.

Tamam temel seviye için "inode" ve "link" kavramı hakkında bu kadarlık
bilgi yeterli.

Şimdi esas konumuz olan link kavramına odaklanacak olursak, Linux
üzerinde **sembolik** ve **katı** olmak üzere iki link çeşidi bulunuyor.
Gelin öncelikle sembolik linkten bahsederek başlayalım.

Sembolik Link \| Soft Link
--------------------------

Ben "**sembolik link**" diyor olacağım ancak farklı kaynaklarda "**soft
link**" olarak ifade edildiğini de görebilirsiniz. Sembolik linkleri,
Windows sisteminden de alışık olduğumuz sıradan kısayollara
benzetebiliriz. Sembolik linklerin görevleri yalnızca orijinal içeriğe
yönlendirme yapmaktır.

Daha anlaşılır olması için gerçek bir örnek üzerinden devam edebilmek
adına öncelikle nasıl sembolik link oluşturabileceğimizi öğrenelim.

Link oluşturmak için "**l**i**n**k" ifadesinin kısaltmasından gelen `ln`
komutunu kullanıyoruz. Sembolik link oluşturmak için de "**s**ymbolic"
ifadesinin kısalması olan `s` seçeneğini kullanmamız gerekiyor.

Ben test ortamı hazırlamak için öncelikle kendi ev dizinimde
`mkdir linkler` komutuyla "***linkler***" isimli bir klasör oluşturup,
`echo “deneme” > ~/linkler/metin` komutuyla, bu dizin altında
"***metin***" isimli dosyaya "deneme" ifadesini ekliyorum.

``` {.ruby}
└─$ mkdir linkler

┌──(taylan@linuxdersleri)-[~]
└─$ echo "deneme" > ~/linkler/metin

┌──(taylan@linuxdersleri)-[~]
└─$ cat ~/linkler/metin                                            
deneme
```

Test ortamımız hazır. Şimdi bu dosyanın sembolik linkini oluşturmayı
deneyelim.

Sembolik link oluştururken dosya ve klasörlerin tam dosya dizin
adreslerini mutlaka belirtmemiz gerekiyor. Çünkü sembolik dosyaları
sistem üzerinde herhangi bir dosya konumunda kullanabiliriz. **Tam dizin
adresini belirtmezsek doğru şekilde çalışmaz.** Örneğin ben tam dizin
adresi yerine göreceli yolu belirterek yeni bir sembolik link oluşturmak
ve bu linki başka bir konuma taşımak istiyorum.

``` {.bash}
└─$ ln -s linkler/metin sembolik_metin2

└─$ mv sembolik_metin2 Documents/                                             

└─$ cat Documents/sembolik_metin2                                             
cat: Documents/sembolik_metin2: No such file or directory
```

Gördüğünüz gibi orijinal dosyanın tam dizin adresini belirtmediğim için
sembolik link dosyasının konumunu değiştirdiğimde bu dosya göreli yola
göre orijinal dosyayı aradığı için bu dosya bulunamadı. **Dolayısıyla
link belirtirken tam dizin adresini girmeniz şart!**

Ben bu dizindeki dosyanın sembolik linkini mevcut bulunduğum dizinde
oluşturmak için `ln -s ~/linkler/metin sembolik_metin` şeklinde komutumu
giriyorum. Teyit etmek için `ls -l sembolik_metin` komutuyla
listeleyelim.

``` {.ruby}
└─$ ln -s ~/linkler/metin sembolik_metin

└─$ ls -l sembolik_metin 
lrwxrwxrwx 1 taylan taylan 13 Jun 26 04:07 sembolik_metin -> /home/taylan/linkler/metin
```

Bakın burada ***sembolik\_metin*** dosyasının oluşturulduğunu
görebiliyorum. Ayrıca çıktılara dikkatlice bakacak olursanız, ok
işaretinin orijinal dosyaya referans verdiğini görebilirsiniz. Buradaki
çıktının anlamı "***sembolik\_metin***" isimli dosyanın "***metin***"
dosyasının sembolik bir bağlantısı olduğu. Bunlar dışında çıktıların en
solunda yani dosya türünün belirtildiği bölümde "**l**" karakteri
bulunuyor. Buradaki "**l**" ifadesi "sembolik link" anlamına geliyor.
Dolayısıyla her iki şekilde de başarılı şekilde sembolik linkimizi
üretmeyi başardığımızı teyit etmiş olduk.

Hemen sembolik linkin nasıl bir işlevi olduğunu görmek için birkaç basit
örnek yapalım. Öncelikle oluşturduğumuz sembolik link üzerinden orijinal
dosyanın içeriğini okumayı deneyebiliriz. Ben bunun için
`cat sembolik-metin` şeklinde komutumu giriyorum.

``` {.bash}
└─$ cat sembolik_metin 
deneme
```

Bakın konsola "deneme" ifadesi bastırıldı. Yani sembolik link üzerinden
orijinal dosyamızın içeriğine ulaşmış olduk.

Şimdi orijinal dosyaya yeni veri ekleyerek bu durumu tekrar test edelim.

``` {.bash}
└─$ echo "yeni" >> ~/linkler/metin 

└─$ cat sembolik_metin 
deneme
yeni
```

Bakın orijinal dosyadaki değişikliğe bu dosya üzerinden de
erişebiliyoruz. Neticede sembolik linkler aslında orijinal dosyaların
kısayolları görevinde olduğu için tek yaptığı orijinal dosyaya
yönlendirme yapmak. Dolayısıyla orijinal dosya içeriğindeki
değişikliklere sembolik link dosyaları üzerinden de aynen
ulaşabiliyoruz.

Şimdi tersini deneyelim. Yani sembolik dosyanın üzerine yeni veri
ekleyip orijinal dosyaya etki edip etmeyeceğini görelim. Ben yeni veri
eklemek üzere `echo “sembolik ekleme” >> sembolik-metin` şeklinde
komutumu giriyorum.

``` {.bash}
└─$ echo "sembolik ekleme" >> sembolik_metin 

└─$ cat sembolik_metin                                           
deneme
yeni
sembolik ekleme

└─$ cat linkler/metin                                            
deneme
yeni
sembolik ekleme
```

Bakın sembolik bağlantıdaki değişiklik orijinal dosyada da geçerli
olmuş. Peki ama nasıl ?

Biz burada bu dosyaya veri eklemek üzere komutumuzu girdiğimizde, bu
sembolik linke yönlendirmiş olduğumuz veriler orijinal dosyaya
yönlendirilip, bu dosya üzerinden diskteki verilere ekleme yapılması
sağlanıyor. Bu sayede tıpkı orijinal dosya üzerinden ekleme yapmışız
gibi değişiklikler geçerli oluyor.

![soft-link.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/soft-link.webp)

Yani bizzat teyit ettiğimiz gibi sembolik bağlantılar aslında orijinal
dosyaya yönlendirme yapan kısayol dosyaları. Bu sebeple örneğin orijinal
dosya silinirse, sembolik linkler üzerinden diskteki verilere ulaşmamız
mümkün olmuyor. Çünkü dediğimiz gibi sembolik linkler yalnızca orijinal
dosyaya yönlendirme yapıyor, bu orijinal dosya da zaten disk üzerindeki
verilere ulaşmamızı sağlayan bir bağlantı. Eğer bu bağlantı kesilirse,
diskteki veriler silinmemiş olsa bile o verilere ulaşmamız mümkün
olmuyor.

![soft-link-hard-link-deleted.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/soft-link-hard-link-deleted.webp)

Zaten biz standart şekilde dosya sildiğimizde arkaplanda yalnızca
diskteki o verilere giden bu bağlantı adresi silinmiş oluyor. Yani
diskte veriler mevcut olsa da o verilere ulaşmamızı sağlayan bağlantıyı
kaybettiğimiz için ulaşamıyoruz. Bu sebeple standart şekilde silinen ve
üzerine veri yazılamayan verilerin diskten kurtarılması mümkün oluyor.

Teorik olarak açıkladık. Şimdi bu durumu bizzat deneyimlemek için
orijinal dosya olan "***linkler***" klasörü içerisindeki "***metin***"
dosyasını silmek üzere `rm linkler/metin` şeklinde komutumuzu girip,
`cat` komutu ile sembolik link dosyasını okumayı deneyebiliriz.

``` {.bash}
└─$ rm linkler/metin                                             

┌──(taylan@linuxdersleri)-[~]
└─$ cat sembolik_metin                                           
cat: sembolik_metin: No such file or directory
```

Bakın böyle bir dosya veya dizin yok hatası alıyoruz. `ls -l` komutu ile
listeleyelim.

![soft-link-deleted.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/soft-link-deleted.webp)

Bakın sembolik link dosyası gözüküyor ama orijinal dosya silindiği için
bu sembolik link kırmızı renkle listelenmiş oldu. Zaten sembolik link
bizi bu dosyaya yönlendirdiği, ama bu dizinde böyle bir dosya olmadığı
için bu hatayı aldık.

Yani benim `cat sembolik-metin` komutunu girmemle, `cat linkler/metin`
komutunu girmem aynı şey.

``` {.bash}
└─$ cat sembolik_metin                                                      
cat: sembolik_metin: No such file or directory

└─$ cat linkler/metin
cat: linkler/metin: No such file or directory
```

Bakın yine böyle bir dosya ve dizin yok şeklinde `cat` komutu bize hata
döndürdü. İşte gördüğünüz gibi sembolik linkler yalnızca orijinal
dosyalara yani aslında orijinal linklere yönlendirme yapan
kısayollardır. Orijinal bağlantılar olmazsa, disk üzerindeki verilere
ulaşmamız mümkün olmuyor.

### Klasörler için Sembolik Link

Aynı şekilde klasörler için de sembolik linkeler oluşturabilirsiniz. Ben
denemek için `ln -s linkler linkler-sembolik` komutu ile yeni sembolik
klasörümü oluşturmak istiyorum.

``` {.ruby}
└─$ ln -s ~/linkler/ linkler-sembolik                                           

└─$ ls -l linkler-sembolik
lrwxrwxrwx 1 taylan taylan 8 Jun 26 04:38 linkler-sembolik -> /home/taylan/linkler/
```

Bakın tıpkı sembolik dosyada olduğu gibi sembolik klasör de bağlı olduğu
klasöre yönlendirme yapıyor. Sembolik klasörler de tıpkı dosyalar gibi
yalnızca orijinal klasöre yönlendirme yaptığı için orijinal klasör
silinirse sembolik link çalışmaz.

Denemek için `echo “deneme” > linkler-sembolik/metin` şeklinde
komutumuzu girebiliriz.

``` {.bash}
└─$ echo "deneme" > linkler-sembolik/metin

└─$ ls linkler-sembolik                                                       
metin

└─$ ls linkler
metin
```

Yukarıdaki çıktılara bakacak olursanız, sembolik klasöre yönlendirmiş
olduğum dosyanın orijinal klasöre kaydolduğunu görebilirsiniz. Yani
tıpkı dosyalar olduğu gibi sembolik klasörler de orijinal klasöre
yönlendirme yapan kısayollar aslında.

Ben örnekler sırasında birer tane sembolik dosya ve klasör oluşturdum.
Ancak istiyorsanız tek bir dosya veya klasör için birden fazla sembolik
link de oluşturabilirsiniz. Zaten sembolik linkler kısayol görevinde
olduğu için kısayol yapısına ihtiyaç duyulan her yerde kullanılabilir.
Örneğin sık kullandığınız bir dizin veya dosya için masaüstünüzde bir
sembolik bağlantı oluşturabilirsiniz.

### Sembolik Linkleri Silmek

Sembolik link dosyalarını silmek için de doğrudan silmek istediğiniz
sembolik link dosyasının ismini `rm` komutuna argüman olarak
verebilirsiniz.

``` {.bash}
└─$ rm sembolik_metin 

└─$ ls -l sembolik-metin
ls: cannot access 'sembolik-metin': No such file or directory

└─$ rm -d linkler-sembolik

└─$ ls -l linkler-sembolik                                                    
ls: cannot access 'linkler-sembolik': No such file or directory
```

Gördüğünüz gibi sembolik dosya ve klasörleri standart şekilde silmiş
olduk.

Katı Link
---------

Şimdi katı linklerden bahsedecek olursak. Sembolik linklere "soft link"
denilmesi gibi, katı linklere de "hard link" denebiliyor. Katı link
oluşturmak için doğrudan `ln` komutunu seçenek belirtmeden
kullanabiliyoruz.

Ben denemek için yine `echo “orijinal dosyayım” > linkler/metin`
şeklinde komutumu giriyorum.

``` {.bash}
└─$ echo "orijinal dosyayım" > linkler/metin
```

Şimdi bu dosya için bir katı link oluşturmak üzere
`ln linkler/metin kati-metin` şeklinde komutumuzu girebiliriz.

``` {.bash}
└─$ ln linkler/metin katı-metin                                               

┌──(taylan@linuxdersleri)-[~]
└─$ ls -l katı-metin                                                          
-rw-r--r-- 2 taylan taylan 19 Jun 26 04:47 katı-metin
```

Bakın dosyam oluşturulmuş fakat bu dosyanın bir link dosyası olduğuna
dair burada herhangi bir emare yok. Halbuki sembolik linkte açıkça link
dosyası olduğu ve hangi dosyaya bağlı olduğu buradaki çıktılarda
belirtiliyordu.

Burada katı linke dair özel bir çıktı almadık çünkü aslında katı link
dediğimiz kavram sistemimiz üzerindeki tüm standart dosya ve dizinleri
temsil ediyor. Yani benim oluşturduğum orijinal metin dosyası da disk
üzerindeki verilere yönlendirme yapan bir katı link.

![hard-link.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/hard-link.webp)

Ben burada "***kati-metin***" isimli yeni bir katı link oluşturduğumda,
tıpkı orijinal dosya gibi doğrudan beni diskteki verilere yönlendiren
inode değerine bir bağlantı oluşturmuş oldum.

![hard-link2.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/hard-link2.webp)

Sembolik linkte nasıl oluyordu. Sembolik linkler, orijinal linklere yani
aslında katı linkli dosyalara yönlendirme yapıyordu, oradan da disk
üzerindeki verilere ulaşabiliyorduk.

![soft-link2.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/soft-link2.webp)

Katı linkte ise hem orijinal dosya hem de yeni oluşturduğumuz katı link
dosyası inode değerine bağlı olduğu için aynı disk verisinin yerini
biliyor ve bizi oraya yönlendirebiliyor.

Dolayısıyla ben orijinal veya bu yeni oluşturduğum katı link dosyasında
değişiklik yaptığımda diskteki bu veri değiştiği için bu değişikliğe her
iki dosya üzerinden de ulaşabiliyorum. Hatta orijinal dosya silinse bile
yeni oluşturduğum katı link dosyası, inode sayesinde verilerin disk
üzerinde tam olarak hangi bloklarda olduğunu bildiği için benim o
verilere ulaşmam mümkün oluyor.

![hard-link3.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/hard-link3.webp)

Hemen bu durumu bizzat teyit etmek için öncelikle basit bir test olarak
yeni oluşturduğumuz katı link dosyası üzerinden yeni veri eklemeyi
deneyebiliriz.

Ben denemek için `echo “yeni veri” >> katı-metin` şeklinde komutumu
giriyorum.

``` {.bash}
└─$ echo "yeni veri" >> katı-metin 

└─$ cat katı-metin                                                            
orijinal dosyayım
yeni veri

└─$ cat linkler/metin                                                         
orijinal dosyayım
yeni veri
```

Eklediğim değişikliğe her iki dosya üzerinden de aynı şekilde
ulaşabildim. Benzer şekilde `echo “orijinal ekleme” >> linkler/metin`
şeklinde tekrar orijinal dosya üzerinden veri eklemeyi de deneyebiliriz.

``` {.bash}
└─$ echo "orijinal ekleme" >> linkler/metin 

└─$ cat linkler/metin                                   
orijinal dosyayım
yeni veri
orijinal ekleme

└─$ cat katı-metin                                   
orijinal dosyayım
yeni veri
orijinal ekleme
```

Bakın orijinal dosya üzerindeki değişiklik bu dosyayı da aynen
etkiliyor. Çünkü zaten tüm değişiklikler inode değeri üzerinden
gerçekleştirildiği için iki dosya aynı veriye erişebilen iki ayrı dosya
gibi.

Şimdi ben son olarak orijinal dosyayı sildiğimde bu diskteki bu verilere
ulaşıp ulaşamayacağımı test etmek için `rm linkler/metin` komutunu girip
orijinal dosyamı siliyorum.

``` {.bash}
└─$ rm linkler/metin                                                          

└─$ cat katı-metin                                                            
orijinal dosyayım
yeni veri
orijinal ekleme
```

Gördüğünüz gibi orijinal dosya silinmiş olmasına rağmen hala disk
üzerindeki aynı verilere erişmeye devam edebiliyorum. Çünkü işleyiş
aslında aşağıdaki şemadaki gibi.

![hard-link3.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/hard-link3.webp)

En nihayetinde gördüğünüz gibi aslında sistemiz üzerindeki standart
dosya ve klasörler disk üzerindeki veri bloklarına inode üzerinden
yönlendirme yapan bağlantı adresleri. Biz bu bağlantı adresleri yani
linkler sayesinde kolay okunabilir isimlerle diskteki verilerimizi
düzenle tutup tekrar tekrar erişebiliyoruz.

Yani katı link oluşturma yaklaşımı sayesinde disk üzerinde tekrar aynı
veriler için fazladan depolama alanı harcanmasına gerek kalmadan,
dosyaların yedeklerinin alınması mümkün oluyor. Daha önce de silme
işleminin aslında verilere ulaşmamızı sağlayan bağlantıların
silinmesinden ibaret olduğunu söylemiştik. Eğer verilere ulaşmamızı
sağlayan birden fazla katı link olursa, bir katı link silinse bile
diskimiz üzerindeki verilere ulaşmaya devam edebiliyoruz. Katı link
yaklaşımı tam olarak bu amaçla kullanılıyor. Ve disk üzerinde fazladan
depolama alını işgal etmeden yedeklemek için harika bir çözüm.

Tabii ki katı linkler örneklerimiz üzerinden bizzat teyit ettiğimiz gibi
mevcut verilerin üzerine yazılmasına engel olmuyor. Yalnızca ilişkili
verilere giden yolun silinmesi ihtimali için yedekleme imkanı tanıyor.
Yani eğer üzerine veri yazılması konusunda endişe duyduğunuz verileriniz
varsa tabii ki bunları başka bir dizine kopyalayıp tekrar aynı verilerin
diskte farklı bloklarda yedeklenmesini sağlamanız gerekiyor.

![backup.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/backup.webp)

Bakın dosyayı kopyaladığımızda, dosya içindeki veriler disk üzerinde
başka bir bloğa yazılıp, bu bloğun adresi de yeni inode numarası
üzerinden ulaşılabilir oluyor. Bu sayede orijinal dosyanın üzerine veri
yazılsa bile bu bloktaki verilere müdahale edilmemiş oluyor.

Katı link ile standart kopyalanmış dosyaların farkı işte tam olarak bu.

### Klasörler için Katı Link

Standart dosya sistemi yani hiyerarşik dizin yapısı gereği, klasörler
için katı link oluşturmayacağımızı da belirtmek istiyorum.
İnanmıyorsanız `ln linkler/ linkler-katı` komutuyla yeni bir tane
oluşturmayı deneyebiliriz.

``` {.bash}
└─$ ln linkler/ linkler-katı                                                  
ln: linkler/: hard link not allowed for directory
```

Bakın dizinler için hard link yani katı linkler kabul edilmiyormuş.

Umarım sembolik ve katı linklerin farkları ve kullanım biçimleri net bir
biçimde anlaşılmıştır. Biraz pratik yaparsanız ve gerekiyorsa bu dersi
baştan dikkatlice tekrar okursanız aslında ne kadar kolay olduğunu zaten
göreceksiniz.

Ve artık böylelikle dosya işlemleri için bilmemiz gereken temel araçları
tanıdığımıza göre bu bölümü sonlandırabiliriz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 16. Ders 110 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Bu bölüm içerisinde Linux sistemindeki kullanıcı ve grup yönetimi gibi
kavramlara değinip yetkiler üzerine konuşacağız.

Sistem kaynaklarına erişimi olan ve sistemini yetkileri dahilinde
yönetenlere genel olarak kullanıcı diyoruz. Linux'ta "**süper(Super
User)**", "**sistem(System User)**" ve "**normal(Normal User)**" olmak
üzere üç tür kullanıcı bulunuyor. Şimdi sırasıyla bu kullanıcıları
açıklayacak olursak;

**Süper Kullanıcı:** Aslında daha çok "**root**" yani "**Kök
Kullanıcı**" olarak bilinen, sistem üzerindeki tüm haklara sahip olan en
yetkili kullanıcı hesabına verilen bir isim. Yani biz root hesabını
kullanıyorken, sistemdeki en yetkili olan "süper kullanıcı" hesabını
yönetiyor olacağız.

**Sistem Kullanıcısı:** Yazılım veya uygulamalar tarafından oluşturulan
ve yönetilen kullanıcılara da "sistem kullanıcısı" deniyor. Örneğin
sistemimizde saatin senkronize edilmesini sağlayan "**ntp**" isimli bir
araç yüklüyse bu aracın görevini yerine getirmek için kendisine ait bir
sistem kullanıcı hesabı bulunuyordur. Bu sayede gerektiğinde bu
kullanıcı hesabı üzerinden görevlerini yerine getirebilir. Tabii ki tüm
araçların kendilerine ait kullanıcı hesapları olmasa da işte tıpkı
"**ntp**" aracında olduğu gibi sistemdeki çeşitli yazılımların, işlerini
görmek için kendi kullanıcı hesapları olması gerekebiliyor. Bu hesaplar
insanların değil yazılımların, sistemdeki çeşitli görevleri yerine
getirebilmek için kullandığı türden hesaplardır. Bu sebeple bu tür
hesaplara "sistem kullanıcı" hesabı deniyor. Bu kullanıcıların
yetkileri, yalnızca görevlerini yerine getirebilecekleri düzeyde olduğu
için yetkileri olmayan işler yapamazlar.

**Normal Kullanıcı:** Normal olarak geçen kullanıcı hesapları, kök
kullanıcısının oluşturduğu standart kullanıcı hesaplarıdır. Standart
kullanıcıların temel görevleri yerine getirebilmeleri için oluşturulan
hesaplardır. Bu tür hesapları standart insanlar kullanacağı için normal
kullanıcılar kendi ev dizinlere sahiptir. Yani genellikle ***/home***
dizini altında kullanıcı isimleriyle oluşturulmuş olan bir klasörde,
kişisel dosyalarını barındırmaları için bir ev dizinleri vardır. Ev
dizini, insanların kişisel dosyalarını düzenli şekilde tutabilmeleri ve
kendi kullanıcı hesaplarına yönelik kişiselleştirilmiş çalışma ortamına
sahip olabilmeleri için önemli bir yaklaşım. Ev dizini kavramının ne
olduğunu biliyorsunuz zaten. Ev dizinleri dışında tabii ki normal
kullanıcılar da sahip oldukları yetkiler dahilinde sistemdeki araçları
kullanabilirler. Yetkilerinin düşük veya yüksek olmasına göre sistem
üzerinde yetkileri dahilinde hareket edebilirler.

`sudo` Komutunu Anlamak
-----------------------

Sistemi yönetirken, yetki gerektiren işlemler yapmamız gerebilir.
Sistemde en yetkili kullanıcının **root** olduğunu öğrendik. Bu durumda
ilgili görevleri yerine getirmek için root hesabına geçiş yapabiliriz.
Ancak root hesabındayken, tüm yetkilere sahip olacağınız için, hatalı
şekilde kritik dosyaları silmenizi önleyecek veya sistemin işleyişine
zarar verecek bir eyleminizde sizi uyaracak bir mekanizma yoktur. Çünkü
root hesabını yalnızca gerektiğinde kullandığınız ve ne yaptığınızı
bildiğiniz varsayılır. Zaten root hesabını kullanmak tehlikeli
olabileceği için çoğu sistemde root hesabı pasif şekilde gelir. Siz
aktifleştirmediğiniz sürece root hesabı kullanılamaz.

Buna karşın root hesabı aktif olmasa bile yetki gerektiren işlerimiz
için geçici olarak root yetkileri ile hareket edebilmemizi sağlayan
`sudo` komutunu kullanabiliyoruz. `sudo` sayesinde root hesabı aktif
değilken veya root aktifse bile root hesabının şifresini bilmeden
yönetici ayrıcalıkları ile işlerimizi yürütmemiz mümkün oluyor. Elbette
hangi kullanıcıların hangi ayrıcalıklara erişebileceğini belirlemek için
düzenlememiz gereken konfigürasyonlar bulunuyor. Fakat henüz bölümün
başındayken bu detaylardan bahsetmeyeceğiz. İleride bu detaylar çok daha
anlaşılır olacaktır.

Şimdilik `sudo` komutunun kullanıcıya, işlemleri yetkili şekilde
gerçekleştirebilme imkanı tanıdığını bilmemiz yeterli. Hatta hemen basit
bir örnek olarak **root** kullanıcısının ev dizini görüntülemeyi
deneyebiliriz. Ben görüntülemek için `ls /root` komutunu giriyorum.

``` {.bash}
[taylan@linuxdersleri ~]$ ls /root/
ls: cannot open directory '/root/': Permission denied
```

Gördüğünüz gibi erişim hatası aldık. Şimdi aynı komutu `sudo` komutu
başta olacak şekilde tekrar girelim.

``` {.bash}
[taylan@linuxdersleri ~]$ sudo ls /root
[sudo] password for taylan:
```

Buraya kendi hesabımın parolasını girmem gerekiyor. Güvenlik için parola
yazarken gözükmüyor, gözükmese de yazıp Enter ile onaylayın.

``` {.bash}
[taylan@linuxdersleri ~]$ sudo ls /root
[sudo] password for taylan: 
anaconda-ks.cfg  Desktop  Documents  DownloadsMusic  Pictures  Public  Templates  Videos
[taylan@linuxdersleri ~]$
```

Parolamı doğru yazdığım için yetkili şekilde ***/root*** dizinin
içeriğini görüntüleyebildim. İşte `sudo` komutunun en temel kullanımı bu
şekilde. Bu bölüme gelinceye kadar, yetki gerektiren işlemiz için
defalarca `sudo` komutunu kullandığımız için zaten bu duruma aşina
olduğunuzu düşünüyorum. Şimdilik bu kadarlık bilgi de yeterli. Temel
kavramları netleştirmek için öncelikle nasıl yeni bir kullanıcı hesabı
oluşturabileceğimizden bahsederek başlayalım.

Kullanıcı Hesabı Oluşturmak
---------------------------

Yeni bir kullanıcı hesabı oluşturmak istiyorsak, kullanıcı hesabı
oluşturabilecek yetkimizin olması gerekiyor. Dolayısıyla bu işlem için
en yetkili kullanıcı olan root kullanıcı hesabına ihtiyacımız var. Fakat
bu durumun bir istisnası bulunuyor. Eğer normal bir kullanıcı root
hesabının bulunduğu yetki grubuna dahil edildiyse bu kullanıcı, root
gibi davranarak yetki gerektiren işlemleri yapabilir. Biz yetkili gruba
dahil olduğumuzu kanıtlamak için `sudo` komutunu kullanıyoruz. Zaten
`sudo` komutuna da kısaca değindik.

Yeni bir hesap oluşturmak için, "`adduser`" ya da "`useradd`"
komutlarından herhangi birini kullanabiliyoruz. `adduser` daha
kullanışlı olduğu için benim öncelikli tercihim. Yine de biz her ikisini
de kısaca ele alacağız.

`adduser`
---------

Ben "**nil**" isminde yeni bir kullanıcı oluşturmak istiyorum. Bunun
için `sudo adduser nil` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo adduser nil
[sudo] password for taylan:
```

Eğer `sudo` komutunu kullanmazsak, yetkimiz olmadığı için işlem
başarısız olur. Bu işlemi gerçekleştirme yetkimiz olduğunu kanıtlamak
için mevcut kullanıcı hesabımızın parolasını girip işlemi onaylamamız
gerekiyor.

``` {.vbnet}
[sudo] password for taylan: 
Adding user `nil' ...
Adding new group `nil' (1002) ...
Adding new user `nil' (1001) with group `nil' ...
Creating home directory `/home/nil' ...
Copying files from `/etc/skel' ...
New password:
```

Çıktıları inceleyecek olursak:

-   Belirttiğim isimde yani "**nil**" ismiyle kullanıcını eklendiği,

-   "**nil**" isimli yeni bir grup oluşturulduğu,

-   "**nil**" kullanıcısının bu gruba eklendiği,

-   **nil**'in ev dizinin ***/home/nil*** dizininde oluşturulduğu,

-   ev dizinine ***/etc/skel*** dizinindeki dosyaların kopyalandığı
    belirtilmiş.

Bu ***/etc/skel*** klasörü standart kullanıcılar için gerekli olan temel
dosyaları barındıran bir klasör. Zaten ev dizinin temel iskeletini
oluşturmaya atıfta bulunmak için "**skel**" klasör ismi de İngilizce
"**iskelet**" ifadesinden geliyor.

Kullanıcı hesabına ait temel işlemler gerçekleştirildikten sonra, bizden
bu kullanıcının parolasını tanımlamamız bekleniyor.

``` {.sql}
New password: 
Retype new password: 
passwd: password updated successfully
Changing the user information for nil
Enter the new value, or press ENTER for the default
        Full Name []:
```

Parola tanımlama işleminden sonra, eğer istersem kullanıcıyla ilgili
burada bana sorulacak olan ek kişisel bilgileri doldurabilirim. Şu an
için pek gerekli değil o yüzden Enter ile tüm soruları geçiyorum. Tabii
ki siz dilerseniz doldurabilirsiniz.

``` {.less}
Enter the new value, or press ENTER for the default
        Full Name []: 
        Room Number []: 
        Work Phone []: 
        Home Phone []: 
        Other []: 
Is the information correct? [Y/n]
```

Son olarak bilgileri de "**y**" ile onaylayıp işlemi tamamlıyorum.
Böylelikle "**nil**" kullanıcı hesabı oluşturulmuş oldu. Teyit etmek
için `ls /home/` komutuyla ev dizinin içeriğini sorgulayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /home/
kali  nil  taylan
```

***/home*** dizini altında **nil** isimli kullanıcının ev dizini
oluşturulmuş. İşte `adduser` komutu ile kullanıcı oluşturma işlemi bu
kadar kolay.

`useradd`
---------

Normalde `useradd` komutunu kullandığımızda, biz özellikle belirtmezsek,
`adduser` komutunda olduğu gibi kullanıcının ev dizini oluşturulmuyor.

Kullanıcının ev dizinin de oluşturulması için özellikle komutumuzu
`useradd -m kullanıcı-adı` şeklinde girmemiz gerekiyor. Ben "**ali**"
isimli bir kullanıcı hesabı oluşturmak istiyorum. Bunun için
`useradd -m ali` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo useradd -m ali

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Hiç bir çıktı almadık, bize ne şifre sordu ne de başka bir bilgi
yalnızca kullanıcı sisteme eklendi. Eklendiğini de ***/home*** dizinini
listeleyerek teyit edebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /home/
ali  kali  nil  taylan
```

Bu kullanıcının bir parolası olmadığı için tabii ki şu an bu hesapta
oturum açamayız. Bu kullanıcı hesabına parola tanımlamak için de
`passwd` komutunu kullanabiliriz. Ben `sudo passwd ali` şeklinde
yazıyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo passwd ali
New password: 
Retype new password: 
passwd: password updated successfully
```

Böylelikle **ali** kullanıcısı için de bir parola tanımlamış olduk.
Sizlerin de fark etmiş olduğu gibi, ele aldığımız önceki araç yani
`adduser` komutu çok daha kullanıcı dostu bir araç. Çünkü ev dizinini
otomatik oluşturup parola oluşturmamız için bizden talepte bulunuyor ve
kullanıcıyla ilgili diğer çeşitli bilgileri de sorup doldurmamızı
sağlıyor. Bu sebeple zaten yeni kullanıcı oluşturmak için genellikle
`adduser` aracı tercih ediliyor.

Neticede kullanıcı oluşturmanın en temel iki yolundan bahsetmiş olduk.
Şimdi hazır kullanıcı oluşturmaktan bahsetmişken, kullanıcı hesaplarıyla
ilişkili olan birkaç dosyadan da bahsetmek istiyorum.

***/etc/passwd*** Dosyası Hakkında
----------------------------------

İçeriğini inceleyebilmek için `cat /etc/passwd` komutu ile dosyamızı
okuyalım.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /etc/passwd                                                                                                                                   
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
_apt:x:102:65534::/nonexistent:/usr/sbin/nologin
mysql:x:103:110:MySQL Server,,,:/nonexistent:/bin/false
tss:x:104:111:TPM software stack,,,:/var/lib/tpm:/bin/false
strongswan:x:105:65534::/var/lib/strongswan:/usr/sbin/nologin
systemd-timesync:x:106:112:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
redsocks:x:107:113::/var/run/redsocks:/usr/sbin/nologin
rwhod:x:108:65534::/var/spool/rwho:/usr/sbin/nologin
iodine:x:109:65534::/run/iodine:/usr/sbin/nologin
messagebus:x:110:114::/nonexistent:/usr/sbin/nologin
miredo:x:111:65534::/var/run/miredo:/usr/sbin/nologin
_rpc:x:112:65534::/run/rpcbind:/usr/sbin/nologin
usbmux:x:113:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
tcpdump:x:114:120::/nonexistent:/usr/sbin/nologin
rtkit:x:115:121:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:116:65534::/run/sshd:/usr/sbin/nologin
dnsmasq:x:117:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
statd:x:118:65534::/var/lib/nfs:/usr/sbin/nologin
avahi:x:119:125:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
nm-openvpn:x:120:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
stunnel4:x:121:127::/var/run/stunnel4:/usr/sbin/nologin
nm-openconnect:x:122:128:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologin
Debian-snmp:x:123:129::/var/lib/snmp:/bin/false
speech-dispatcher:x:124:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false
sslh:x:125:130::/nonexistent:/usr/sbin/nologin
postgres:x:126:131:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:128:135::/var/lib/saned:/usr/sbin/nologin
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:,,,:/home/taylan:/usr/bin/bash
nil:x:1001:1002:,,,:/home/nil:/bin/bash
ali:x:1002:1004::/home/ali:/bin/sh
```

Dosyanın sonuna, yeni eklemiş olduğum iki kullanıcı hesabı için iki
satır daha eklenmiş. Bu dosyada, sistemdeki her bir kullanıcı hesabının
soldan sağa sırasıyla; ismi, parolası, kullanıcı numarası, grup
numarası, hesap bilgileri(hesap bilgilerinden kasıt; `adduser` komutuyla
bize sorulan tam isim, telefon numarası, oda numarası gibi bilgiler), ev
dizini ve varsayılan kabuk programı bilgisi satırlar halinde tutuluyor.

![passwd.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/passwd.webp)

Biz `adduser` ya da `useradd` gibi araçları kullanarak kullanıcı
oluşturduğumuzda aslında araçların yaptığı işlerden biri de bu dosyaya,
ilgili kullanıcı hesabının detaylarını eklemek oluyor.

``` {.ruby}
nil:x:1001:1002:,,,:/home/nil:/bin/bash
ali:x:1002:1004::/home/ali:/bin/sh
```

Örneğin `adduser` komutu ile oluşturduğumuz "**nil**" kullanıcısının
kabuğu **bash** olarak ayarlanmışken, `useradd` komutu "**ali**"
kullanıcısının varsayılan kabuğunu **sh** olarak tanımlamış. Farklı
kabukları tanımlamış olsalar da neticede her iki araç da kullanıcı
bilgilerini bu dosyaya eklemiş. Listenin geri kalanına baktığımızda
mevcut kullanıcı hesabımıza ek olarak, farklı araç ve yazılımların
sistem kullanıcı hesaplarının da aynı şekilde bu listede olduğunu
görebiliyoruz. Yani bu dosya mevcut sistemdeki tüm kullanıcı
hesaplarının temel bilgilerini barındıran dosyamız.

Bu dosya, kullanıcıların hesap detaylarını barındırdığı için dosya
içerisinde gerçekleştireceğimiz değişklikler de ilgili hesapları
doğrudan etkiliyor. Örneğin ben dilersem buradan **ali** kullanıcısının
kabuğunu, **bash** kabuğunun tam dosya adresini belirterek **bash**
olarak değiştirebilirim. Bunun için `sudo nano /etc/passwd` komutu ile
yetkili şekilde ***passwd*** dosyasını açalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo nano /etc/passwd
[sudo] password for taylan:
```

**ali** kullanıcısının kabuğunda değişiklik yapmak için son satıra
gelip, kabuk bölümüne bash kabuğunun dosya adresini yazabiliriz.

![change-shell.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/change-shell.webp)

Dosyamı kaydettiğimde, **ali** kullanıcısının kabuğu da "bash" olarak
değişmiş olacak. Zaten eğer hatırlıyorsanız, eğitimin başında varsayılan
kabuğunu bash olarak değiştirmek için de bu dosyada değişiklik
yapmıştık. İşte Linux sisteminde her şey dosya yapısı üzerinden ele
alındığı için sistem yönetimi ve düzenlemesi de dosyalar üzerinden
kolayca gerçekleştirilebiliyor. Pek çok araç yani pek çok komutta
aslında bu ve bunun gibi dosyalar üzerinde, kısayoldan düzenleme
yapmamıza olanak sağlıyor. Biz hangi dosyanın hangi işlevde olduğunu
biliyorsak, istersek manuel olarak elle dosyayı düzenleriz istersek de
aynı işi yapan bir aracı yani komutu kullanırız. Bu dosya üzerinden
açıkladığımız gibi sistemdeki dosyaların işlevlerini bildiğimiz zaman
denetim ve yönetim noktasında pek çok avantaja sahip oluyoruz. Ben Ctrl
+ x ile dosyayı kaydetmek üzere kapatıp kaydetme işlemini de
onaylıyorum. Neticede **ali** kullanıcı hesabı için varsayılan kabuğu,
kullanıcı hesapları hakkında bilgileri barındıran bu ***/etc/passwd***
dosyasında elle düzenleme yaparak değiştirmiş oldum.

Tıpkı bu kabuk düzenleme işlemi gibi aslında istersek `adduser` veya
`useradd` gibi araçları kullanmadan kendimiz bu ***passwd*** dosyasına
yeni kullanıcı hesabı tanımlayıp yeni kullanıcı da oluşturabiliriz.

Manuel şekilde kullanıcı oluşturabiliyor olsak da, yine de **en kolay ve
mantıklı yöntem** `adduser` komutunu kullanıp `adduser` komutunun yeni
kullanıcı için gereken tüm ayarlamaları yapmasını sağlamaktır. Dosya
içeriğinde oynama yapıp kullanıcı hesabıyla ilgili bilgileri kolayca
değiştirebiliyor olmamız güzel bir esneklik evet. Ancak tek tek pek çok
ayarlama yapmamız gerektiği için sıfırdan kullanıcı oluştururken
önerdiğim veya kullandığım bir yöntem değil. Oluşturması da silmesi de
daha sonra zahmetli olabiliyor. Zaten dilerseniz henüz kullanıcı
hesabını oluşturma aşamasında `adduser` komutunun seçeneklerini
kullanarak da kullanıcı hesapları ile ilgili detayları ***/etc/passwd***
dosyasını elle düzenlemeye gerek kalmadan belirtebilirsiniz. Hangi
seçenekler olduğunu görmek için `adduser --help` komutu ile çıktıları
inceleyebilirsiniz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]                                                                                                                              
└─$ adduser --help
adduser [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]                                                                                          
[--firstuid ID] [--lastuid ID] [--gecos GECOS] [--ingroup GROUP | --gid ID]
[--disabled-password] [--disabled-login] [--add_extra_groups] USER
   Add a normal user

adduser --system [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID]
[--gecos GECOS] [--group | --ingroup GROUP | --gid ID] [--disabled-password]
[--disabled-login] [--add_extra_groups] USER
   Add a system user

adduser --group [--gid ID] GROUP
addgroup [--gid ID] GROUP
   Add a user group

addgroup --system [--gid ID] GROUP
   Add a system group

adduser USER GROUP
   Add an existing user to an existing group

general options:
  --quiet | -q      don't give process information to stdout
  --force-badname   allow usernames which do not match the
                    NAME_REGEX configuration variable
  --help | -h       usage message
  --version | -v    version number and copyright
  --conf | -c FILE  use FILE as configuration file
```

Yeni kullanıcı oluşturma aşamasında; spesifik ev dizinini veya farklı
bir kabuğu belirtebiliriz, dilersek ev dizini olmamasını sağlayabiliriz,
kullanıcı numarasını belirtebiliriz ve benzeri tüm ayarlamaları buradaki
seçenekleri kullanarak gerçekleştirebiliriz. Tek yapmanız gereken
`adduser` komutunun doğru seçeneklerini kullanmaktır.

***/etc/passwd*** dosyası hakkında son birkaç detaydan daha bahsedip
parolaların tutulduğu dosyayı açıklamak istiyorum. Tekrar
`sudo nano /etc/passwd` komutuyla dosyamızı açıp üzerinden konuşmaya
devam edelim.

### Hesabı Deaktif Hale Getirmek

Eğer bir kullanıcı hesabının bilgilerini silmeden o kullanıcı hesabını
deaktif halde getirmek istersek; ilgili kullanıcının varsayılan kabuk
programı yerine, kullanıcının oturum açmasını reddeden
***/usr/sbin/nologin*** dosyasını yazabiliriz.

``` {.ruby}
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:,,,:/home/taylan:/usr/bin/bash
nil:x:1001:1002:,,,:/home/nil:/bin/bash
ali:x:1002:1004::/home/ali:/bin/bash
```

Burada çeşitli araçlara ait olan sistem kullanıcıların neredeyse hepsi
bu şekilde ayarlı. Araçlara ait kullanıcılar olduğu için zaten bu
kullanıcıların oturum açıp kabuk kullanması gerekmediği için bu şekilde
belirtilmişler. İşte bizler de herhangi bir kullanıcının oturum açmasını
kibarca reddetmek için buraya kabuk yerine bu dosyayı ekleyebiliriz.

Ben **ali** kullanıcısının oturum açmasını engellemek için buradaki
kabuğu ***/usr/sbin/nologin*** şeklinde giriyorum.

``` {.ruby}
ali:x:1002:1004::/home/ali:/usr/sbin/nologin
```

Tamamdır dosyamızı kaydedip kapatalım.

Mevcut konsolumuz üzerinden yeni bir kullanıcı hesabına geçiş yapmak
için `su` komutunun ardından geçiş yapmak istediğimiz hesabın ismini
girmemiz yeterli oluyor. Ben **ali** kullanıcısına geçiş yapmak için
`su ali` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su ali                                                                               
Password: 
This account is currently not available.
```

"***bu hesap şu anda müsait değil***" şeklinde hata aldık. Normalde eğer
bir kabuk programı tanımlı olsaydı direk o kabuk başlatılacaktı fakat
biz ***nologin*** dosyasını varsayılan olarak ayarladığımız için bu
şekilde hesabı pasif hale getirmiş olduk.

Tekrar ***passwd*** dosyasına bakacak olursak ***nologin*** seçeneği
dışında, listede ***/bin/false*** şeklinde olan kullanıcı hesapları
olduğunu da görebiliriz.

``` {.ruby}
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
```

***nologin*** dosyasına benzer şekilde ***false*** dosyası da
kullanıcının oturum açmasına engel olmak için kullanılan dosya. Fakat
***nologin*** dosyasından farklı olarak kullanıcıya bu durumda bir uyarı
verilmeden kullanıcı doğrudan reddediliyor. Bu bilgiler ışığında,
gerektiğinde siz de bu şekilde kullanıcı bilgisini dosyadan silmeden
kullanıcı hesabını kolayca pasifleştirebilirsiniz. Daha sonra
dilediğiniz zaman da tekrar bu dosyayı düzenleyip kullanıcıya kabuk
tanımlayarak aktifleştirebilirsiniz.

Ayrıca hiç değinmedik ama mutlaka parola bölümündeki "**x**"'ler
dikkatinizi çekmiştir. Buradaki "**x**" karakterleri, kullanıcı
hesabının parolasının ***/etc/shadow*** dosyasında şifrelenmiş şekilde
tutulduğuna işaret ediyor. Zaten kullanıcı hesaplarına ait parolalar
şifresiz şekilde yani okunabilir biçimde bu listede bulunsaydı
hesapların güvenliğini riske girerdi. Bunun yerine tüm kullanıcıların
parola bilgileri ***/etc/shadow*** dosyasında şifrelenmiş şekilde
tutuluyor. Daha iyi anlamak için şimdi ***/etc/shadow*** dosyasından
bahsederek devam edelim.

***/etc/shadow*** Dosyası
-------------------------

Dosya hakkında konuşmak için önce dosyamızı açalım. Ben açmak için
`sudo nano /etc/shadow` komutunu giriyorum. Eğer `sudo` komutuyla bu
dosyayı yetkili şekilde açmazsanız dosya içeriğini görüntüleyemezsiniz
çünkü bu dosyada kullanıcı hesaplarının parola bilgileri bulunuyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo nano /etc/shadow
```

![shadow.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/shadow.webp)

Tıpkı ***passwd*** dosyasına benziyor fakat ***shadow*** dosyasında,
kullanıcıların parolalarıyla ilgili çeşitli bilgiler tutuluyor.

Örneğin en son oluşturduğumuz kullanıcılar hakkında bilgi almak için
satırın en sonuna inelim.

``` {.swift}
...
lightdm:*:19034:0:99999:7:::
colord:*:19034:0:99999:7:::
geoclue:*:19034:0:99999:7:::
king-phisher:*:19034:0:99999:7:::
taylan:$y$j9T$Pyz0SQwuvSF01.mwGAhvH/$qzPyKX48Q/or41dhLgZeaOCmE9zK0dTBXR1hvGPvwV2:19536:0>
nil:$y$j9T$/s/63wuMbCMeshxKZipnC1$YHg/TzBK83mhgdG2O9hpSaQ0Ovvcbw6UHG1ZyRnJT5A:19545:0:99>
ali:$y$j9T$yMJlpgDGakI6Z9SUpCY9D.$FPXXtQsbFzwN6WkcgryAU3.OS5gYJRfvgRX8vFIt4h/:19545:0:99>
```

Mevcut kullanıcı hesabım da dahil yeni oluşturduğum kullanıcıların
isimleri ve yanlarında da parola bilgileri bulunuyor.

Burada iki nokta üst üste işaretiyle birbirinden ayrılmış bölümleri tek
tek ele almak istemiyorum çünkü ele alsam bile muhtemelen aklımızda
kalmayacak. Eğer buradaki detayları merak ediyorsanız kısa bir araştırma
ile bu sütunların ne ifade ettiğini öğrenebilirsiniz. Ben özellikle
bahsetmiyorum çünkü aslında buradaki seçenekleri çok daha kolay okuyup
değiştirmemiz için kullanabileceğimiz bir araç var. Anlatımın devamında
o araçtan bahsedeceğim için buradaki unutulacak detaylarla vakit
kaybetmemize gerek yok. Yine de ilk iki sütunu açıklayacak olursak.

İlk sütunda kullanıcı hesabının ismi bulunuyor. İkinci sütunda ise
şifrelenmiş şekilde o kullanıcının parola bilgisi bulunuyor. Biz
hesabımızda oturum açmaya çalıştığımızda eğer doğru parolayı girersek,
girdiğimiz parola tekrar buradaki yöntemle şifreleniyor ve bu dosyadaki
değer ile eşleşiyorsa bu kullanıcı hesabında oturum açabiliyoruz.

Şimdilik ***/etc*** dizini altındaki ***shadow*** dosyasının
kullanıcılara ait parola bilgilerini tuttuğunu bilmeniz yeterli.

Kullanıcı hesapları hakkında anlatımlarımıza devam edeceğiz. Fakat daha
fazla devam etmeden önce "grup" kavramından da bahsetmek istiyorum.

Linux Üzerinde Gruplar
----------------------

Grup yapısı sayesinde, ortak izinlere sahip olmasını istediğimiz
kullanıcıları aynı grupta toplayıp bireysel kullanıcı yetkileri dışında
toplu şekilde erişim yetkileri tanımlayabiliyoruz.

Öncelikle grup yönetiminden bahsedelim, daha sonra zaten grupların neden
bu kadar önemli olduğunu yetkilendirme bölümünde daha iyi anlamış
olacağız.

Normalde yeni bir kullanıcı oluştururken bizzat deneyimlediğimiz gibi;
oluşturulan kullanıcının kendisine ait, kullanıcı hesabıyla aynı isimde
bir grup oluşturuluyor. İşte bu grup o kullanıcının "birincil grubu"
olarak geçiyor. Sistem üzerindeki tüm kullanıcıların birincil grubu
bulunuyor. Örneğin ben **ali** isimli kullanıcı oluşturduğum için
**ali** kullanıcısının birincil grubu **ali** isimli grup oluyor.

Öncelikle bu durumu teyit etmek için mesela **ali** kullanıcısının
grubunu sorgulamak üzere `groups ali` şeklinde komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ groups ali
ali : ali
```

Buradaki `groups` komutundan sonra argüman olarak girdiğimiz kullanıcı
isimlerinin dahil olduğu gruplar bu araç sayesinde bastırılıyor. Bakın
**ali** kullanıcısı **ali** isimli gruba dahilmiş.

Bunun dışında mesela kendi kullanıcı hesabımızı da sorgulayabiliriz. Ben
şu an **taylan** kullanıcı hesabını yönettiğim için `groups taylan`
şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ groups taylan                                                                        
taylan : taylan adm dialout cdrom floppy sudo audio dip video plugdev netdev wireshark bluetooth scanner kaboxer
```

Bu sefer birden fazla grup listelendi. **taylan** kullanıcısı, birincil
olarak **taylan** grubu dahil olmak üzere ikincil şekilde pek çok harici
gruba da dahilmiş.

Örneğin **taylan** kullanıcısı buradaki **sudo** grubuna dahil olduğu
için `sudo` aracıyla gerektiğinde **root** yetkileriyle komutlarını
çalıştırabiliyor. Ama **ali** kullanıcısı **sudo** grubunda olmadığı
için `sudo` aracını kullanıp yetkili şekilde işlem yapmaya kalkarsa
erişim yetkisi hatası alır. İşte gruplar zaten bu şekilde birden fazla
kullanıcıya ortak şekilde bazı yetkileri vermek için kullanılıyor.

***/etc/group*** Dosyası Hakkında
---------------------------------

`groups` komutuyla aldığımız çıktıların dışında, kullanıcıların hangi
gruplara dahil olduğunun bilgisini öğrenmek için ***/etc/group***
dosyasını da kontrol edebiliriz. Ben göz atmak için `cat` ile dosyayı
okumak istiyorum.

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /etc/group                                                                                                                                          
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:root,taylan
tty:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
uucp:x:10:
man:x:12:
proxy:x:13:
kmem:x:15:
dialout:x:20:root,taylan
fax:x:21:
voice:x:22:
cdrom:x:24:taylan
floppy:x:25:taylan
tape:x:26:
sudo:x:27:taylan
audio:x:29:pulse,taylan
dip:x:30:taylan
www-data:x:33:
backup:x:34:
operator:x:37:
list:x:38:
irc:x:39:
src:x:40:
gnats:x:41:
shadow:x:42:
utmp:x:43:
video:x:44:taylan
sasl:x:45:
plugdev:x:46:taylan
staff:x:50:
games:x:60:
users:x:100:
nogroup:x:65534:
systemd-journal:x:101:
systemd-network:x:102:
systemd-resolve:x:103:
input:x:104:
sgx:x:105:
kvm:x:106:
render:x:107:
crontab:x:108:
netdev:x:109:taylan
mysql:x:110:
tss:x:111:
systemd-timesync:x:112:
redsocks:x:113:
messagebus:x:114:
kismet:x:115:
_ssh:x:116:
ssl-cert:x:117:postgres
plocate:x:118:
wireshark:x:119:root,taylan
tcpdump:x:120:
rtkit:x:121:
bluetooth:x:122:taylan
kali-trusted:x:123:
i2c:x:124:
avahi:x:125:
nm-openvpn:x:126:
stunnel4:x:127:
nm-openconnect:x:128:
Debian-snmp:x:129:
sslh:x:130:
postgres:x:131:
pulse:x:132:
pulse-access:x:133:
scanner:x:134:saned,taylan
saned:x:135:
sambashare:x:136:
inetsim:x:137:
lightdm:x:138:
colord:x:139:
geoclue:x:140:
kpadmins:x:141:
taylan:1000:
vboxsf:x:142:
kaboxer:x:143:root,taylan
taylan:x:1000:
nil:x:1002:
ali:x:1004:
```

Burada yer alan ilk sütunların hepsi grupların isimleridir. Örneğin en
alt satıra inecek olursak, **nil** ve **ali** kullanıcılarının da kendi
isimlerinde grupları oluşturulduğu için onların grupları da burada
gözüküyor. İlk sütun grup isimleri dedik. İkinci sütun, varsa grubun
şifresini temsil ediyor. Ancak çoğunlukla grup şifresi kullanılmadığı
için bu konuyu es geçebiliriz. Sondaki sayı ise, bu grubu temsil eden
benzersiz "grup numarası". Hatırlıyorsanız kullanıcıları temsil eden
"**user id**" yani "kullanıcı numaraları" da ***/etc/passwd***
dosyasında her kullanıcının kendi satırında yazıyordu. Buradaki sayı da
bu grubun "grup numarası" işte. Ayrıca en sondaki iki nokta üst üste
işaretinden sonra bazı gruplarda boş sütunlar varken bazılarında
kullanıcı isimleri var.

``` {.less}
kaboxer:x:143:root,taylan
yeni-grup:x:1003:
taylan:x:1000:
nil:x:1002:
ali:x:1004:
```

Bu sondaki sütun, bu gruba dahil olan ikincil kullanıcıları temsil
ediyor. Yani örneğin **nil** gruba **nil** kullanıcısı dışında hiç kimse
dahil olmadığı için buradaki sütun boş. Ama burada **kaboxer** olarak
geçen gruba **root** ve **taylan** kullanıcıları dahil olduğu için o
kullanıcıların isimleri burada yazıyor. Hatta aldığım çıktıya dönüp
dikkatlice bakacak olursanız pek çok grubun sonunda mevcut kullanıcı
hesabımın yani **taylan** kullanıcısının bu gruplara ekli olduğunu
görebilirsiniz. Zaten **taylan** kullanıcısının dahil olduğu grupları
listelediğimizde bu grupların isimlerini görmüştük. İşte bir kez daha
teyit etmiş olduk. Neticede bizzat gördüğümüz gibi gruplarla ilgili
bilgiler bu dosyada tutuluyor. Yani istersek bu dosyada değişiklik
yaparak gruplarla ilgili tanımlamaları değiştirebiliriz. Fakat tabii ki
daha önce de olduğu gibi bu işi elle yapmak yerine bu iş için uygun olan
aracı kullanarak çok daha sağlıklı şekilde grup oluşturma, gruba yeni
kullanıcı ekleme ve çıkarma gibi işlemleri yapabiliriz. Yani ne
yaptığınızın gerçekten farkında olmadığınız sürece manuel şekilde
müdahale etmenizi önermem.

Yeni Grup Oluşturmak
--------------------

Yeni bir grup oluşturmak için `groupadd` aracını kullanabiliriz. Ben
**yeni-grup** isminde bir grup oluşturmak istediğim için
`sudo groupadd yeni-grup` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo groupadd yeni-grup
```

Tamamdır grubumun sorunsuzca oluşturulmuş olması gerek. Teyit etmek için
`tail -1 /etc/group` komutunu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail -1 /etc/group
yeni-grup:x:1005:
```

**yeni-grup** isimli grup oluşturulmuş ve grup numarası olarak da boşta
bu sayı bulunduğu için bu sayı tanımlanmış. Şimdi oluşturduğumuz bu
gruba yeni bir kullanıcı eklemeyi deneyebiliriz.

Gruba Kullanıcı Eklemek
-----------------------

Mevcut gruba kullanıcı eklemek için `gpasswd` aracını kullanabiliriz.
Ben **ali** isimli kullanıcıyı "yeni-grup" grubuna eklemek istediğim
için `gpasswd -a ali yeni-grup` şeklinde komutumu yazıyorum. `gpasswd`
aracına vermiş olduğum `-a` seçeneği benim "add" yani "ekleme" yapmak
istediğimi belirten bir seçenek. Ekleme seçeneğinin ardından hangi
kullanıcının hangi gruba ekleneceğini de argümanlar olarak yazıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ gpasswd -a ali yeni-grup                                                             
gpasswd: Permission denied.
```

Ben başta `sudo` komutu olmadan girdiğim için yetki hatası aldım.
`sudo !!` komutuyla en sonra girdiğimiz komutu yetkili şekilde tekrar
çalıştırmayı deneyelim. Bildiğiniz gibi buradaki çift ünlem işareti, en
son çalıştırılan komutu geçmişten çağırıyor. Ben de `sudo` komutundan
sonra en son çalıştırılan bu komutu çağırıp yetkili şekilde tekrar
çalıştırılmasını sağlıyorum. Zaten genelde yetki gerektiren işlerde
`sudo` komutunu girmeyi unuttuğumuzda bu şekilde `sudo !!` komutuyla en
son girdiğimiz komutu sıklıkla çağırıyoruz, büyük kolaylık gerçekten.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo !!                                                                              
sudo gpasswd -a ali yeni-grup 
Adding user ali to group yeni-grup
```

Bu kez herhangi bir yetki hatası almadık.

Şimdi tekrar konumuza dönecek olursak, girdiğimiz komut neticesinde
**ali** kullanıcısının **yeni-grup** isimli gruba eklenmiş olması
gerekiyor. Bunu teyit etmek için yine `tail -1 /etc/group` ya da
`groups ali` şekline komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail -1 /etc/group                                                                   
yeni-grup:x:1005:ali

┌──(taylan㉿linuxdersleri)-[~]
└─$ groups ali
ali : ali yeni-grup
```

Çıktılardan teyit edebildiğimiz üzere, **yeni-grub**'un sonuna **ali**
kullanıcısı da eklenmiş. Yani gruba ekleme işlemi başarılı.

Gruptan Kullanıcı Silmek
------------------------

`gpasswd` aracının `-d` seçeneği yani "**d**elete" seçeneğiyle gruba
ekli olan kullanıcıyı silebiliriz. Ben eklediğim **ali** kullanıcısını
silmek için `sudo gpasswd -d ali yeni-grup` şeklinde komutumu giriyorum.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo gpasswd -d ali yeni-grup 
Removing user ali from group yeni-grup
```

Şimdi gruptan silindiğini teyit etmek için `groups ali` komutuyla ali
kullanıcısının dahil olduğu grupları sorgulayalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ groups ali
ali : ali
```

Artık **yeni-grup** çıktılarda gözükmüyor. Yani **ali** kullanıcısını bu
gruptan sildiğimizi teyit edebiliyoruz.

Grubu Silmek
------------

Grup oluştururken `groupadd` aracını kullanmıştık. Silmek için de
`groupdel` aracını kullanabiliyoruz. Ben **yeni-grup** isimli grubu
silmek için `sudo groupdel yeni-grup` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo groupdel yeni-grup

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Tamamdır grubumun silinmiş olması lazım. Teyit etmek için
`grep “yeni-grup” /etc/group` komutunu kullanabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ grep "yeni-grup" /etc/group

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Herhangi bir çıktı almadık çünkü bu grubu biraz önce silmiştik. Yani
silme işlemini de böylelikle teyit etmiş olduk.

Kullanıcı hesapları ve gruplar hakkında temelde bilmemiz gerekenlerden
bahsettiğimize göre anlatımlarımıza erişim yetkileri ile devam
edebiliriz.

Erişim Yetkileri
----------------

Erişim yetkilerinden bahsedebilmek için öncelikle bu yetkilerin nasıl
gözüktüğünü bilmemiz gerekiyor. Ben bunun için ev dizinindeyken, `ls -l`
komutuyla detaylı şekilde mevcut dizinimi listeliyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l                                                                                
total 52
drwxr-xr-x 2 taylan taylan 4096 Jun 28 10:58 'bu bir deneme metnidir'
-rw-r--r-- 1 taylan taylan   59 Jul  2 10:29  deneme
drwxr-xr-x 2 taylan taylan 4096 Jul  4 01:45  Desktop
drwxr-xr-x 3 taylan taylan 4096 Jul  3 12:10  Documents
drwxr-xr-x 2 taylan taylan 4096 Jul  5 10:25  Downloads
-rw-r--r-- 1 taylan taylan 7751 Jul  2 14:38  isimler.txt
drwxr-xr-x 2 taylan taylan 4096 Jun 28 10:59  Music
drwxr-xr-x 2 taylan taylan 4096 Jun 28 07:47  Pictures
drwxr-xr-x 2 taylan taylan 4096 Jun 28 01:35  Public
drwxr-xr-x 2 taylan taylan 4096 Jun 28 01:35  Templates
drwxr-xr-x 2 taylan taylan 4096 Jun 28 12:30  test
drwxr-xr-x 2 taylan taylan 4096 Jun 28 01:35  Videos
```

Aldığımız çıktılarda yer alan ilk sütun dosya ve dizinlerin yetkilerini
diğer bir deyişle modlarını temsil eden bölüm. Buradaki "**mod**"
ifadesi önemli çünkü ileride bu yetkileri değiştirirken aslında
"**mod**" değiştirme(`chmod`) aracını kullanıyor olacağız. Yetkilerin
devamında yer alan sütunlar da ilgili dosya ve dizinin "hangi kullanıcı"
ve "hangi gruba" ait olduğunu yani "**sahiplik**" bilgisini belirtiyor.

![ls
-l.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/ls-l.webp)

Ben kendi ev dizinimi listelediğim için tüm dosya ve dizinleri sahibi ve
grubu hep **taylan** kullanıcısı olarak gözüküyor. Bu konuya daha sonra
ayrıca değineceğiz. Şimdi tekrar buradaki "yetki" yani "mod"
tanımlamalarına dönecek olursak, en genel açıklama aşağıdaki görselde
olduğu şekilde:

![permission.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/permission.webp)

Elbette kavramların netleşebilmesi için tek tek buradaki karakterlerin
ne anlama geldiğini açıklamamız gerek.

Dosya Türü
----------

İlk karakter her zaman dosya veya dizinin "türü" hakkında bilgi sunan
karakter oluyor. Örneğin dizinler "**d**irectory" ifadesinin
kısaltmasından gelen "**d**" karakteri ile temsil ediliyorken, standart
dosyalar kısa çizgi "**-**" ile belirtiliyor. Ayrıca sembolik linkler de
"**l**" karakteri ile temsil ediliyor. Tabii ki buradaki çıktılar
yalnızca örnek yani sistemdeki tüm dosya türleri burada yer almıyor.
Aldığınız çıktıdaki karakterin ne anlama geldiğini bilmediğinizde kısa
bir internet araştırmasıyla bu karakter temsili hakkında kolayca pek çok
bilgi edinebilirsiniz. Şimdilik yalnızca bu ilk karakter alanın, mevcut
dosya veya klasörün türünü temsil ettiğini bilmemiz yeterli.

![permission-first-column.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/permission-first-column.webp)

Erişim Yetkileri
----------------

Dosya türünün ardından gelen 9 basamaklı karakterlere geçecek olursak.
Bu karakterleri 3'er basamaklı 3 gruba ayırmamız gerekiyor. Çünkü
buradaki ilk üç karakter bu dosyanın sahibinin izinlerini temsil
ediyorken, ikinci üç karakter de bu dosyanın grubunun sahip olduğu
yetkileri temsil ediyor. Son üç karakter ise sahibi ve grubu
haricindekileri yani hem bu dosyanın sahibi olmayan hem de bu dosyanın
grubuyla aynı grupta bulunmayan diğer kullanıcılar için yetkileri temsil
ediyor.

![ownership.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/ownership.webp)

Bu üç ayrı yetki grubu sayesinde her bir dosya ve klasörü yalnızca
istediğimiz kullanıcıların erişebileceği şekilde yetkilendirebiliyoruz.

Bu yetki karakterinde kullanılan "**r**", karakteri "**r**ead" yani
"okuma" yetkisini temsil eden karakter. Eğer bu karakteri görüyorsanız o
dosya veya klasörün içeriğini görüntüleyebilirsiniz.

"**w**" karakteri, "**w**rite" yani "yazma" yetkisini temsil eden
karakter. Bu karakter varsa dosya içeriğini düzenleyip, klasörlerde de
dosya ekleme ve silme gibi işlemleri gerçekleştirebilirsiniz.

"**x**" karakteri ise "e**x**ecute" yani "çalıştırma" yetkisini temsil
ediyor. Bu yetki varsa dosyaları çalıştırabilir ya da klasör
içeriklerini yazma yetkisi de varsa düzenleyebilirsiniz. Klasör
içeriklerini düzenlemek için yazma ve çalıştırma yetkisinin her ikisinin
de bulunması şart, aksi halde düzenleme yapılamıyor. Ama okuma yetkisi
olmadan da düzenleme yapılabilir.

Söylediklerim şu an için pek anlaşılır gelmemiş olabilir. Örnekler
üzerinden ele alırsak netleşmiş olacak.

Ben testler sırasında kullanabilmek için basit bir betik dosyası
oluşturmak istiyorum. Bunun için
`echo "echo ben betik dosyasıyım" > testfile.sh` şeklinde komutumu
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo "echo ben betik dosyasıyım" > testfile.sh
```

`ls -l testfile.sh` komutuyla yetkileriyle birlikte dosya bilgisini
bastıralım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
-rw-r--r-- 1 taylan taylan 23 Jul  7 06:01 testfile.sh
```

Öncelikle dosyanın yetkilerine göz atacak olursak; bu dosyanın sahibi
hem okuma hem yazma yetkisine sahipken, dosyanın grubundaki kullanıcılar
ve diğer kullanıcılar bu dosyayı yalnızca okuyabiliyormuş.

Bu dosyanın sahibi "taylan" kullanıcısı olduğu için taylan kullanıcısı
**rw-** yani **okuma ve yazma** yetkilerine sahip.

Dosya "taylan" grubuna dahil olduğu için taylan grubundaki tüm
kullanıcılar da bu dosya üzerinde **r---** yani yalnızca **okuma**
yetkisine sahip.

Dosyanın sahibi olmayan veya bu grupta bulunmayan diğer tüm kullanıcılar
da dosya üzerinde **r---** yani yine yalnızca **okuma** yetkisine sahip.

Buradaki çıktıdan bizzat teyit ettiğimiz gibi ilgili yetki mevcutsa harf
karşılığı gösteriliyorken, yetki yoksa kısa çizgi ile bu yetkinin
olmadığı belirtiliyor. Zaten yetki tanımlamasının sıralaması hep **okuma
yazma çalıştırma** yani **rwx** şeklinde gittiği için hangi yetkinin
olup olmadığını kolayca anlayabiliyoruz.

### Erişim Yetkilerinin Etkileri

Öncelikle dosyanın sahibi üzerinden yetkilerin nasıl çalıştığını görmek
için yeni bir konsol açalım ve dosyamızın okuma yetkisini test etmek
için `cat testfile.sh` komutuyla açalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat testfile.sh 
ben betik dosyasıyım
```

Ben dosyanın sahibi olan taylan kullanıcısı olduğum için buradaki okuma
yetkim sayesinde bu dosyanın içeriğini okuyabiliyorum. Şimdi yazma
yetkisini test etmek için `echo “test” >> testfile.sh` komutu ile yeni
veri girişinde bulunalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo "test" >> testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ cat testfile.sh 
ben betik dosyasıyım
test
```

Yazma yetkim sayesinde dosyaya "test" ifadesini eklemeyi başardım. Şimdi
son olarak bu dosyamızı çalıştırmayı denemek için tıpkı daha önce de
yaptığımız gibi `./testfile.sh` şeklinde komutumuzu girelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ./testfile.sh
bash: ./testfile.sh: Permission denied
```

Bu kez yetki hatası aldık. Dosyanın yetkilerini tekrar hatırlayacak
olursak, dosya sahibinin yani benim bu dosyayı çalıştırma "x" yetkim
olmadığını görebiliyoruz.

``` {.scss}
└─$ ls -l testfile.sh 
-rw-r--r-- 1 taylan taylan 23 Jul  7 06:01 testfile.sh
```

Dolayısıyla bu dosyayı bir betik dosyası yani bir program gibi
çalıştırmam mümkün değil. Çalıştırabilmek için daha önce de yaptığımız
gibi `chmod` aracı yardımıyla bu dosyaya çalıştırma yetkisi vermemiz
gerek. Bu yetkilere "**mod**" denildiğini özellikle söylemiştim. İşte bu
yetkileri değiştirmek için kullandığımız araç da "**ch**ange **mod**e"
ifadesinin kısaltması olarak `chmod` şeklinde isimlendirilmiş.

Betik dosyama çalıştırma yetkisi vermek için daha önce de birkaç kez
yaptığımız gibi `chmod +x testfile.sh` komutunu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod +x testfile.sh
```

Şimdi tekrar `ls -l` komutuyla listeleyelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
-rwxr-xr-x 1 taylan taylan 28 Jul  7 06:08 testfile.sh
```

Tüm yetki grupları için çalıştırılma yetkisi verilmiş. Yani artık bu
dosyayı herkes çalıştırabilir. Ben denemek için tekrar `./testfile.sh`
şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ./testfile.sh
ben betik dosyasıyım
```

Bu kez betik dosyam sorunsuzca çalıştı. Yani çalıştırma yetkisi vermeyi
başardık. Fakat bu örneğimizde herkese çalıştırma yetkisi vermiş olduk.
Bu yaklaşım pek güvenli ve her zaman isteyeceğimiz bir yaklaşım değil.
Şimdi yetki verme işlemini nasıl daha spesifik olarak
tanımlayabileceğimizden bahsederek devam edelim.

### Erişim Yetkilerini Tanımlamak

Tüm izinleri daha rahat gösterebilmek için öncelikle dosyamdaki tüm
yetkileri kaldırmak üzere `chmod -rwx testfile.sh` komutunu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod -rwx testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                                                                        
---------- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Dosyamın tüm yetkileri kaldırılmış. Ben yalnızca dosyanın sahibine
çalıştırma yetkisi vermek için `chmod u+x testfile.sh` komutunu
giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod u+x testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                                                                    
---x------ 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Girmiş olduğum komuttaki `u` parametresi "**u**ser" yani "kullanıcı"
ifadesinin kısaltmasından gelen "**dosyanın sahibini**" temsil eden
parametredir. `+x` tanımı da yalnızca **çalıştırma yetkisi eklemek**
istediğimi belirtmek için kullandığım bir parametre. Neticede `ls -l`
komutunun çıktısıyla bizzat teyit edebildiğimiz gibi dosyanın sahibine
çalıştırma yetkisi vermeyi başardık.

Yetkiyi silmek istersek de artı yerine eksi işaretini kullanabiliriz.
Ben yine dosyanın sahibinden çalıştırma yetkisini kaldırmak istediğim
için `chmod u-x testfile.sh` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod u-x testfile.sh                                                                                                    

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                                                                    
---------- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Eksi işareti sayesinde yetki kaldırma işlemini de sorunsuzca
gerçekleştirdik.

Eğer dosya sahibinin yetkilerini değil de dosya grubunun yetkilerini
değiştirmek istersek `u` yerine `g` karakterini kullanabiliriz. Ben
denemek için gruptaki kullanıcılara **okuma ve yazma** yetkisi vermek
için `chmod g+rw testfile.sh` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g+rw testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
----rw---- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Dosyanın grubu için okuma ve çalıştırma yetkileri verilmiş.

Diğer kullanıcılar için yetki tanımlaması yaparken de "**o**thers" yani
"diğerleri" ifadesinin kısaltmasından gelen `o` karakterini
kullanabiliyoruz. Ben diğer kullanıcılara yalnızca okuma yetkisi vermek
istediğim için `chmod o+r testfile.sh` şeklinde komutumu giriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod o+r testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                                                                        
----rw-r-- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Diğer kullanıcılar için yalnızca okuma yetkisi tanımlanmış.

İşte bu ele aldığımız yaklaşımlar sayesinde toplu veya tekil olarak
istediğimiz yetki tanımlamasını yapabiliyoruz. Örneğin tüm
kullanıcıların okuma yetkisini kaldırmak istersek `chmod -r testfile.sh`
şeklinde komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod -r testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
-----w---- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Okuma yetkisi olanların yalnızca okuma yetkileri kaldırılmış oldu.
Neticede burada öğrendiğiniz ekleme ve çıkarma yaklaşımı sayesinde hem
spesifik kullanıcı grubuna hem de toplu şekilde tüm kullanıcı
yetkilerine ekleme ve çıkarma yapabilirsiniz. Bu arada fark ettiyseniz
biz şimdiye kadar hep ekleme ve çıkarma yaptık. Eğer artı ve eksi
işaretleriyle ekleme veya çıkarma yapmak yerine doğrudan tanımlamak
istediğimiz yetkiler varsa eşittir işaretini kullanabiliyoruz.

Örneğin ***testfile.sh*** dosyasının şu anda yalnızca grubu için yazma
yetkisi bulunuyor. Ben grubuna doğrudan okuma ve çalıştırma yetkisi
tanımlamak için `chmod g=rx testfile.sh` şeklinde komutumu girebilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rx testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
----r-x--- 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Gördüğünüz gibi yazma yetkisi kaldırılıp yalnızca okuma ve çalıştırma
yetkisi verilmiş oldu.

Yani özetleyecek olursak; yetki ekleme işlemi için artı, çıkarma işlemi
için eksi ve doğrudan yetkiyi tanımlamak için de eşittir işaretini
kullanabiliyoruz.

### Rakamlar ile Yetki Tanımlaması

Ayrıca bizim burada kullandığımız yetkileri temsil eden harfler yerine
aslında yetki tanımlamak için bu yetkilerin rakam karşılıklarını
kullanma imkanımız da var. Üstelik rakamları kullanarak birden fazla
yetki gruba tek sefer yetki tanımlamak çok daha kolay. Neden daha kolay
olduğunu anlayabilmemiz için öncelikle rakamla nasıl yetki
tanımlayabileceğimizden bahsetmemiz lazım.

**r** karakteri ile temsil edilen **okuma** yetkisinin sayısal karşılığı
**4** rakamıdır.

**w** karakteri ile temsil edilen **yazma** yetkisinin sayısal karşılığı
**2** rakamıdır.

**x** karakteri ile temsil edilen **çalıştırma** yetkisinin sayısal
karşılığı **1** rakamıdır.

Biz üç yetki grubuna(sahibi-grubu-diğerleri) yetki tanımlaması yapmak
için üç basamaklı şekilde bu rakamların toplamlarını girebiliyoruz.

Önceki örneklerimizi hep dosyalar üzerinde uyguladık fakat yetkiler,
klasörler için de aynen geçerli. Ben bu durumu kanıtlamak için
örneklerimde kullanmak üzere yeni bir klasör oluşturmak istiyorum.

`mkdir testfolder` komutuyla hemen oluşturalım. Hatta tam bir klasör
olması için `touch testfolder/dosya{1..4}` komutuyla birden fazla
dosyayı da içerisine ekleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ mkdir testfolder

┌──(taylan㉿linuxdersleri)-[~]
└─$ touch testfolder/dosya{1..4}

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder                                                                                                              
drwxr-xr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder
```

Şu anda klasörümün yetkileri bu şekilde. Eğer ben klasör grubundaki
kullanıcılara yazma yetkisi vermek istersem **yazma(w)** yetkisini
temsil eden **2** rakamını kullanabilirim.

**Ekleme** yapacağım için yine `chmod` komutundan sonra `+` işaretini
kullanmam gerekiyor. Şimdi ben yalnızca klasör grubundaki kullanıcılara
yazma yetkisi eklemek istediğim için `chmod +020 testfolder` şeklinde
komutumu yazıyorum. Burada üç basamaklı sayı yazmamız gerekiyor çünkü
ilk sayı her zaman kullanıcıya, ikinci sayı gruba, üçüncü sayı da diğer
kullanıcılara ait olan yetkileri temsil ediyor. Ben yalnızca gruba yazma
yetkisi eklemek istediğim için diğer yetkilere ekleme yapılmaması için
**0** şeklinde yazdım ve grubu temsil eden ortadaki sayıya yazma
yetkisini temsil eden **2** rakamını girdim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod +020 testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/
drwxrwxr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Klasör grubundakilere yazma yetkisi de eklenmiş.

Kullanımı daha iyi anlamak için mesela yalnızca klasör sahibine okuma
izni verip geri kalan tüm yetkileri silmeyi deneyebiliriz. Yetki
kaldırma işlemi yapacağımız için eksi işaretini kullanacağız.

Klasör sahibinden yazma(2) ve çalıştırma(1) yetkisini eksiltmek
istediğimiz için yazma ve çalıştırmayı temsil eden 2 ve 1 rakamlarının
toplamını yani 3 rakamını buraya yazmamız gerekiyor. Daha sonra diğer
tüm kullanıcıların tüm yetkilerini kaldırmak istediğimiz için okuma(4)
yazma(2) ve çalıştırma(1) yetkilerinin sayı toplamları 4 + 2 + 1 den 7
ettiği ikinci ve üçüncü sayı kısmına da 7 rakamlarını ekleyebiliriz.
Yani komutumuz `chmod -377 testfolder` halini alıyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod -377 testfolder/                                                                                                   

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                                                                   
dr-------- 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Gördüğünüz gibi klasörün sahibinin yalnızca okuma yetkisi varken grup ve
diğer kullanıcıların yetkileri kaldırılmış.

Bence bu örnek bu yetki işlemini gayet net biçimde açıklıyor. Yine de
bir tane daha örnek ele alabiliriz. Şu anda bu klasörün yalnızca sahibi
için okuma yetkisi var.

Eğer sahibine yazma ve çalıştırma yetkisi ekleyip, grubu için yalnızca
okuma ve yazma yetkisi eklemek ve diğer kullanıcılar için de yalnızca
okuma yetkisi eklemek istersek komutumuzu nasıl girmemiz gerekir ?

Yetki eklemesi yapacağım için `chmod +` şeklinde yazıyorum. İlk
sayımızda klasörün sahibine yazma ve çalıştırma yetkisi vereceğiz. Yazma
yetkisi 2 rakamıyla temsil ediliyor, çalıştırma da 1 rakamıyla. Her iki
yetkiyi temsil etmesi için toplamlarını yani 3 rakamını yazabiliriz.

Grubu için okuma ve yazma yetkisi yani 4 ve 2 rakamlarının toplamını 6
rakamıyla girebiliriz.

Son olarak diğer kullanıcılara yalnızca okuma yetkisi eklemek için de 4
rakamını yazabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod +364 testfolder/                                                                                                   

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                                                                       
drwxrw-r-- 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Tam olarak istediğimiz yetkileri eklemeyi başardık.

Yetkileri temsil eden rakamları kullanarak yetki ekleme ve çıkarma
işlemi bu şekilde. Ayrıca ekleme ve çıkarma işlemi dışında dilerseniz
daha önce de yaptığımız gibi doğrudan yetki tanımlaması da
yapabilirsiniz.

Örneğin ben dosyanın sahibine tüm yetkileri vermek, grubuna ve
diğerlerine yalnızca okuma ile çalıştırma yetkisi vermek için
`chmod 755 testfolder` komutunu girebilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod 755 testfolder/                                                                                                  

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                                                                    
drwxr-xr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Belki bu sayıların kullanımı başta biraz kafa karıştırıcı gelmiş
olabilir fakat kendiniz biraz pratik yaparsanız aslında ne kadar kolay
ve kullanışlı olduğunu bizzat görebilirsiniz. Test etmek için dosya veya
klasörler oluşturup, bir yetki tanımlaması planlayıp bu yetkilendirmeyi
doğru şekilde tanımlayıp tanımlayamayacağınızı test edebilirsiniz. Bu
şekilde alıştırmalar yaparsanız zaten tam olarak kullanımını kavramış
olacaksınız.

### Yetki Tanımlarının Alt Dizinlere İşlenmesi

Kimi zaman klasörler üzerinde çalışıyorken, klasör içerisindeki dosya ve
dizinlerde de ortak yetki tanımlaması yapmak isteyebiliyoruz. Bu noktada
"özyineleme" yani "**r**ecursive" ifadesinin kısaltmasından gelen `R`
seçeneğini kullanabiliyoruz.

Öncelikle klasörler üzerindeki standart yetki tanımlamalarının alt
dizinlerde geçerli olmadığını teyit edelim.

``` {.diff}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                                                                    
drwxr-xr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfolder/                                                                                                        
total 0
-rw-r--r-- 1 taylan taylan 0 Jul  7 07:39 dosya1
-rw-r--r-- 1 taylan taylan 0 Jul  7 07:39 dosya2
-rw-r--r-- 1 taylan taylan 0 Jul  7 07:39 dosya3
-rw-r--r-- 1 taylan taylan 0 Jul  7 07:39 dosya4
```

Gördüğünüz gibi daha önceki yetki tanımlamalarımız klasör içindeki
dosyalarda geçerli olmamış. Klasör ve içerisindeki dosyaların yetkileri
farklı gözüküyor. Şimdi özyinelemeli şekilde komutumuzu girip değişimi
kontrol edelim.

Ben denemek için tüm kullanıcılara çalıştırmak yetkisi eklemek üzere
`chmod -R +111 testfolder` şeklinde komutumu giriyorum. Buradaki büyük
`R` seçeneği sayesinde buradaki yetki ekleme işleminin bu klasörün
içinde yer alan tüm içeriklerde de aynen geçerli olması lazım.

``` {.diff}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod -R +111 testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                                                                      
drwxr-xr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfolder/                                                                                                      
total 0
-rwxr-xr-x 1 taylan taylan 0 Jul  7 07:39 dosya1
-rwxr-xr-x 1 taylan taylan 0 Jul  7 07:39 dosya2
-rwxr-xr-x 1 taylan taylan 0 Jul  7 07:39 dosya3
-rwxr-xr-x 1 taylan taylan 0 Jul  7 07:39 dosya4
```

Alt dizindekiler de dahil tüm dosyalarda tüm kullanıcılar için
çalıştırma yetkisi eklenmiş.

Ben yetkilendirme tanımlaması için sayıları kullandım ama harfler ile de
aynı şekilde `R` seçeneği sayesinde tüm alt dizinlerdeki içeriklerde
aynı izin tanımlamalarının geçerli olmasını sağlayabiliriz.

Dizinlerdeki yetki tanımlamalarıyla ilgili bahsetmek istediklerim bu
kadar. Artık bu erişim yetkilerinin etkilerini anlayabilmek için birkaç
test yaparak devam etsek hiç fena olmaz.

Erişim Yetkilerinin Etkileri
----------------------------

Şimdiye kadar kullanıcılardan, gruplardan ve erişim izinlerinden
bahsettik ancak doğrudan erişim yetkilerinin dosya ve dizinler
üzerindeki etkilerini gözlemlemedik.

Dosya veya dizinlerin; "sahibi", "grubundaki kullanıcılar" ve
"diğerleri" şeklinde yetki tanımlamaları olduğunu öğrendik.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
-rwxr-xr-x 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Örneğin ***testfile.sh*** dosyasını **taylan** kullanıcısı oluşturduğu
için dosyanın sahibi ve grubu **taylan** olarak geçiyor.

Burada bahsi geçen **taylan** grubu **taylan** kullanıcısının birincil
grubu olduğu için tabii ki biz özellikle başka bir kullanıcıyı ekleyene
kadar bu grupta başka bir kullanıcı bulunmuyor. Ben grup yetkilerini
test edebilmek için **ali** isimli kullanıcı hesabını bu **taylan**
grubuna eklemek istiyorum. Bunun için `sudo gpasswd -a ali taylan`
şeklinde komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]                         
└─$ sudo gpasswd -a ali taylan
[sudo] password for taylan:                            
Adding user ali to group taylan
```

`groups ali` komutuyla **ali** kullanıcısının gruplarını sorgulayalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ groups ali
ali : ali taylan
```

**ali**, **taylan** grubuna dahil olmuş.

Neticede şu anda sistemimde bu dosyanın sahibi olan "taylan"
kullanıcısı, bu dosya için tanımlı olan taylan grubundaki "ali"
kullanıcısı ve bunların hiç birine dahil olmayan "nil" isimli bir
kullanıcı hesabım bulunuyor. Ben şimdi sırasıyla bu kullanıcı hesapları
üzerinden dosya üzerindeki yetkileri test etmek istiyorum. Bunun için
iki yeni konsol daha açalım.

Öncelikle `su ali` komutuyla ali kullanıcı hesabında oturum açıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su ali
Password: 
This account is currently not available.
```

Daha önce örnekler sırasında ali kullanıcısının oturum açmasını
engellemek için ***passwd*** dosyasında varsayılan kabuk yerine
***nologin*** dosyasını eklediğim için oturum açamıyoruz.
`sudo nano /etc/passwd` komutuyla dosyayı açıp **ali** satırındaki
***nologin*** dosyasını ***/usr/bin/bash*** olarak değiştirip
kaydedelim.

Şimdi tekrar `su ali` komutuyla geçiş yapmayı deneyelim.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su ali
Password: 
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$
```

Bu kez sorunsuzca ali kullanıcı hesabında oturum açmış olduk.

Şimdi diğer konsolumuzda da **nil** kullanıcı hesabında oturum açmak
üzere `su nil` şeklinde komutumuzu girelim.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su nil
Password: 
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$
```

Tamamdır, bu konsol üzerinde de nil kullanıcı hesabında oturum açmış
oldum.

Ben sırasıyla dosya ve klasörlerin hangi yetkilere hangi şekilde tepki
verdiğini ele alabilmek için olası yetki türlerini "ali" kullanıcısı
üzerinden test etmek istiyorum. ali kullanıcısını taylan gruba eklediğim
için "***testfile.sh***" ve "***testfolder***" üzerinde çalışırken,
gruplar için geçerli olan yetkileri değiştirmem yeterli olacak. İleride
dosyanın sahibi, grubu ve diğer kullanıcılar için yetki sınırını da
örnekleyeceğiz ancak şimdilik erişim yetkilerinin sonuçlarını test
edelim.

Dosyalar Üzerindeki Etkisi
--------------------------

Test etmek üzere kullanacağım dosyam "***testfile.sh***" dosyası.

### `r—` \| Yalnızca Okuma

Dosyamıza yalnızca okuma yetkisi verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=r testfile.sh 
                                                
┌──(taylan㉿linuxdersleri)-[~]                  
└─$ ls -l testfile.sh 
-rwxr--r-x 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

ali kullanıcısı üzerinden sırasıyla okuma yazma ve çalıştırmayı
deneyelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfile.sh 
echo ben betik dosyasıyım
test

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "ekle" >> testfile.sh
bash: testfile.sh: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh
bash: ./testfile.sh: Permission denied
```

Gördüğünüz gibi okuma yetkisi bulunan dosyayı yalnızca okuyabiliyoruz.

### `rw-` \| Okuma ve Yazma

Okuma ve yazma yetkisini verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]                  
└─$ chmod g=rw testfile.sh                      
                                                
┌──(taylan㉿linuxdersleri)-[~]                  
└─$ ls -l testfile.sh 
-rwxrw-r-x 1 taylan taylan 33 Jul  7 06:15 testfile.sh
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "ekle" >> testfile.sh   

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfile.sh                 
echo ben betik dosyasıyım
test
ekle

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh
bash: ./testfile.sh: Permission denied
```

Çalıştırma(x) yetkisi olmadığı için betik dosyasının çalıştırılamadığını
gördük.

### `rwx` \| Okuma Yazma Çalıştırma

Tüm yetkileri verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]                  
└─$ chmod g=rwx testfile.sh                     

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                     
-rwxrwxr-x 1 taylan taylan 38 Jul  8 01:38 testfile.sh
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "ekle2" >> testfile.sh     

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfile.sh   
echo ben betik dosyasıyım
test
ekle
ekle2

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh     
ben betik dosyasıyım
./testfile.sh: line 3: ekle: command not found
./testfile.sh: line 4: ekle2: command not found
```

Yazma, okuma ve çalıştırmayı başardık.

### `r-x` \| Okuma Çalıştırma

Yetkiyi verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rx testfile.sh                     

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                      
-rwxr-xr-x 1 taylan taylan 44 Jul  8 01:40 testfile.sh
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfile.sh                 
echo ben betik dosyasıyım
test
ekle
ekle2

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "ekle3" >> testfile.sh  
bash: testfile.sh: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh     
ben betik dosyasıyım
./testfile.sh: line 3: ekle: command not found
./testfile.sh: line 4: ekle2: command not found
```

Yazma yetkisi olmadığı için yeni veri eklemesi yapamadık. Silme işlemi
de yapamazdık çünkü dosya üzerinde değişiklik hakkına sahip değiliz.
Yazma yetkisi dosya üzerinde değişiklik yapma yetkisini temsil ediyor.

### `—x` \| Çalıştırma

Yetkiyi verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=x testfile.sh                     

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh 
-rwx--xr-x 1 taylan taylan 44 Jul  8 01:40 testfile.sh
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfile.sh                 
cat: testfile.sh: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "ekle2" >> testfile.sh  
bash: testfile.sh: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh     
bash: ./testfile.sh: Permission denied
```

Çalıştırma yetkimiz olmasına rağmen "yetki hatası" aldık çünkü okuma
yetkisi olmadan çalıştırma yetkisi tek başına yeterli değil. Dosya
içeriğinin okunması mümkün olmadığı için çalıştırılması da doğal olarak
mümkün olmuyor. Bu sebeple dosyalar üzerindeki yalın "çalıştırma(x)"
izni dosyayı çalıştırmak için yeterli değil.

Hemen okuma izni de ekleyip tekrar deneyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rx testfile.sh                      

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                      
-rwxr-xr-x 1 taylan taylan 44 Jul  8 01:40 testfile.sh
```

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ./testfile.sh                   
ben betik dosyasıyım
./testfile.sh: line 3: ekle: command not found
./testfile.sh: line 4: ekle2: command not found
```

Gördüğünüz gibi okuma ve çalıştırma bir arada olduğunda dosyanın
çalıştırılması mümkün oluyor.

Klasörler Üzerindeki Etkisi
---------------------------

Yetkilerin klasörler üzerindeki etkilerini gözlemlemeden önce kısaca
sıralayacak olursak:

**Okuma**(`r`): dizin içeriğini listelemesine izin verir.

**Yazma**(`w`): dizin içindeki dosyaları oluşturmasına, yeniden
adlandırmasına veya silmesine ve dizinin özniteliklerini değiştirmesine
izin verir.

**Çalıştırma**(`x`): dizine geçiş yapılmasına ve içindeki dosyalara ve
dizinlere erişmesine izin verir.

Etkilerini daha iyi anlamak için birkaç test gerçekleştirebiliriz.

Testlerden önce, klasör içerisindeki dosya ve dizinlerin yetkileri
konusunda sorun yaşamamak için ben `sudo chmod -R g=rwx testfolder/`
komutuyla klasör içindeki içeriklerin tamamına tüm yetkiyi veriyorum.

``` {.diff}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chmod -R g=rwx testfolder/
[sudo] password for taylan: 
                                 
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -lR testfolder/                       
testfolder/:
total 8
-rwxrwxr-x 1 taylan taylan 38 Jul  8 03:56 dosya1                                           
-rwxrwxr-x 1 taylan taylan  0 Jul  7 07:39 dosya2                                           
-rwxrwxr-x 1 taylan taylan  0 Jul  7 07:39 dosya3                                           
-rwxrwxr-x 1 taylan taylan  0 Jul  7 07:39 dosya4                                           
-rw-rwxr-- 1 ali    ali    59 Jul  8 03:48 yeni-belge
```

Normalde işlem yaparken hem klasör hem de klasör içindeki dosya ve
dizinlerin yetkileri önemli. Fakat biz öncelikle klasörün etkilerini
görmek için, içerisindekilere tam yetki verelim. Anlatımın devamında
aksi durumlardan da bahsedeceğiz zaten.

### `r—` \| Okuma

Yetki tanımlayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=r testfolder/
                                              
┌──(taylan㉿linuxdersleri)-[~]                
└─$ ls -ld testfolder/                        
drwxr--r-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cd testfolder/
bash: cd: testfolder/: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls testfolder/
ls: cannot access 'testfolder/dosya4': Permission denied
ls: cannot access 'testfolder/dosya1': Permission denied
ls: cannot access 'testfolder/dosya2': Permission denied
ls: cannot access 'testfolder/yeni-belge': Permission denied
ls: cannot access 'testfolder/dosya3': Permission denied
dosya1  dosya3  yeni-belge
dosya2  dosya4

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
cat: testfolder/dosya1: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "son ekleme" >> testfolder/dosya1
bash: testfolder/dosya1: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cp deneme testfolder/          
cp: cannot stat 'testfolder/deneme': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ mv deneme testfolder/          
mv: cannot stat 'testfolder/deneme': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ rm testfolder/dosya2
rm: cannot remove 'testfolder/dosya2': Permission denied
```

Yalnızca okuma yetkimiz varken, dizin içeriğindeki dosyaları, listeleme,
taşıma ve geçiş yapma gibi işlemlerde "erişim yetkisi" hatası aldık.
Burada küçük bir nüans var. Esasen okuma yetkisi bize dizin içeriklerini
listeleme yetkisi veriyor. Fakat `ls` aracı `alias ls` komutunun
çıktısından bizzat görebileceğimiz gibi yalın halde çalışmıyor.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ alias ls                       
alias ls='ls --color=auto'
```

Gördüğünüz gibi biz `ls` komutunu kullandığımızda çıktıları
renklendirmek üzere `ls --color=auto` komutu çalıştırılıyor. `ls`
komutunun harici bir parametresinin çalışabilmesi için de o dizinde
çalıştırma(x) yetkisine ihtiyacı var. Dolayısıyla biz bu takma isimli
komutu girdiğimizde dizin içeriğini listeleyemiyoruz. Bunun yerine
`command ls` komutu ile `ls` aracının yalın haliyle çalışmasını
sağlayabiliriz. `command` komutu takma isimlerin görmezden gelinmesini
sağladığı için yalnızca `ls` komutunun çalışmasını sağlıyor.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ command ls testfolder/
dosya1  dosya2  dosya3  dosya4
```

Bu kez dizin içeriğini listeleyebildik. Okuma yetkisi yalnızca klasör
içindeki dosya ve dizinlerin isimlerini okuma yetkisi veriyor. Örneğin
detaylı çıktı almak üzere `command ls -l` komutunu girersek yine hata
alacağız çünkü detaylı bilgi almaya yetkimiz bulunmuyor.

``` {.ruby}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ command ls -l testfolder/      
ls: cannot access 'testfolder/dosya4': Permission denied
ls: cannot access 'testfolder/dosya1': Permission denied
ls: cannot access 'testfolder/dosya2': Permission denied
ls: cannot access 'testfolder/dosya3': Permission denied
total 0
-????????? ? ? ? ?            ? dosya1
-????????? ? ? ? ?            ? dosya2
-????????? ? ? ? ?            ? dosya3
-????????? ? ? ? ?            ? dosya4
```

Gördüğünüz gibi dosya isimleri hariç detaylı bilgi almaya yetkimiz
olmadığı için bu şekilde çıktı aldık. Dosya isimlerini listeleme
dışındaki tüm işlemler için çalıştırma yetkisine ihtiyacımız var.

### `rw-` \| Okuma Yazma

Yetki tanımlayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rw testfolder/
                                              
┌──(taylan㉿linuxdersleri)-[~]                
└─$ ls -ld testfolder/                        
drwxrw-r-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cd testfolder/
bash: cd: testfolder/: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls testfolder/
ls: cannot access 'testfolder/dosya4': Permission denied
ls: cannot access 'testfolder/dosya1': Permission denied
ls: cannot access 'testfolder/dosya2': Permission denied
ls: cannot access 'testfolder/dosya3': Permission denied
dosya1  dosya2  dosya3  dosya4

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ command ls testfolder/
dosya1  dosya2  dosya3  dosya4

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cp deneme testfolder/
cp: cannot stat 'testfolder/deneme': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
cat: testfolder/dosya1: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "deneme" > testfolder/yeni
bash: testfolder/yeni: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ mv testfolder/dosya1 testfolder/yeni
mv: failed to access 'testfolder/yeni': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ rm testfolder/dosya3
rm: cannot remove 'testfolder/dosya3': Permission denied
```

Çalıştırma yetkisi olmadan okuma ve yazma yetkisi de fark oluşturmuyor.
Yalnızca dizin içerisindeki dosya isimlerini listeleyebiliyoruz.

### `rwx` \| Okuma Yazma Çalıştırma

Test etmeye gerek yok çünkü dizin üstünde tüm yetkilere sahip olduğumuz
için okuma, yazma, kopyalama taşıma, silme çalıştırma gibi işlemleri
yapabiliyoruz.

### `r-x` \| Okuma Çalıştırma

Yetki tanımlayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rx testfolder/                  

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/
drwxr-xr-x 2 taylan taylan 4096 Jul  7 07:39 testfolder/
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls testfolder/
dosya1  dosya2  dosya3  dosya4  yeni-belge

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls -l testfolder/
total 12
-rwxrwxr-x 1 taylan taylan 38 Jul  8 03:56 dosya1
-rwxrwxr-x 1 taylan taylan 11 Jul  8 05:42 dosya2
-rwxrwxr-x 1 taylan taylan  0 Jul  7 07:39 dosya3
-rwxrwxr-x 1 taylan taylan  0 Jul  7 07:39 dosya4
-rw-rwxr-- 1 ali    ali    59 Jul  8 03:48 yeni-belge

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "son ekleme" >> testfolder/dosya2

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya2
son ekleme

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ mv testfolder/dosya2 testfolder/yeni-dosya
mv: cannot move 'testfolder/dosya2' to 'testfolder/yeni-dosya': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cp deneme testfolder/
cp: cannot create regular file 'testfolder/deneme': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ rm testfolder/dosya2
rm: cannot remove 'testfolder/dosya2': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cd testfolder/
```

Okuma, listeleme dizine geçiş gibi işlevlerini yerine getirip, dosya
içeriklerinde değişiklik yapabiliyorken, taşıma silme kopyalama veya
değiştirme gibi işlevleri yerine getiremiyoruz. Klasör üzerinde yazma
yetkimiz olmadığında, klasör içindeki dosya ve klasörleri kopyalama,
silme veya değiştirme gibi işlemleri yapamıyoruz.

### `-wx` \| Yazma Çalıştırma

Yetkiyi verelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=wx testfolder/            

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                
drwx-wxr-x 2 taylan taylan 4096 Jul  8 03:40 testfolder/
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cd testfolder/

┌──(ali㉿linuxdersleri)-[/home/taylan/testfolder]
└─$ cd ..

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls testfolder/
ls: cannot open directory 'testfolder/': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ command ls testfolder/
ls: cannot open directory 'testfolder/': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "son" >> testfolder/dosya1

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme
son

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ mv testfolder/dosya2 testfolder/yeni-dosya

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cp testfolder/yeni-dosya testfolder/dosya

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ rm testfolder/dosya
```

Gördüğünüz gibi okuma yetkisi olmadığı için klasör içeriğini
listeleyemedik ama diğer işlemleri yerine getirebiliyoruz.

### `—x` \| Çalıştırma

Yetkimizi tanımlayalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]                                             
└─$ chmod g=x testfolder/
                                                                           
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                     
drwx--xr-x 2 taylan taylan 4096 Jul  8 05:50 testfolder/
```

Test edelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cd testfolder/

┌──(ali㉿linuxdersleri)-[/home/taylan/testfolder]
└─$ cd ..

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls testfolder/
ls: cannot open directory 'testfolder/': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ command ls testfolder/
ls: cannot open directory 'testfolder/': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme
son

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "son ekleme" >> testfolder/dosya1

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme
son
son ekleme

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ mv testfolder/dosya3 testfolder/dosya
mv: cannot move 'testfolder/dosya3' to 'testfolder/dosya': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cp deneme testfolder/
cp: cannot create regular file 'testfolder/deneme': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ rm testfolder/dosya3
rm: cannot remove 'testfolder/dosya3': Permission denied
```

Yalnızca çalıştırma yetkisi varken, dizine geçiş ve dosya içeriğinde
düzenleme gibi işlevleri yerine getirebiliyoruz.

Tabii ki şimdiye kadar ele aldığımız tüm örneklerde, klasör içindeki
dosyanın tüm yetkileri vardı. Bu sayede dosya üzerinde tüm işlemleri
yapabilme özgürlüğüne sahiptik. Eğer dosyanın erişim yetkileri
kısıtlanmışsa klasörün yetkileri önemini yitiriyor.

Yani esasen klasörün yetkileri; klasöre geçiş, klasör içeriğini
listeleme ve klasör içeriğini düzenleme kapsamında.

Dosyaların yetkileri ise; dosyaları çalıştırma veya içeriklerinde
düzenleme yapma kapsamında.

Bu bağlamda yapmak istediğiniz işlemler için her iki yetki düzeyinin de
uygun olması şart.

Örneğin klasör üzerinde tüm yetkileriniz olsa, ama dosyada yazma
yetkiniz bulunmasa bu dosyanın içeriğini düzenleyemezsiniz. Hemen
deneyelim. Öncelikle klasöre tüm yetkileri verip, dosyanın yazma
yetkisini kaldıralım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rwx testfolder/                                                

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                
drwxrwxr-x 2 taylan taylan 4096 Jul  8 05:50 testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g=rx testfolder/dosya1 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfolder/dosya1                                                
-rwxr-xr-x 1 taylan taylan 53 Jul  8 05:55 testfolder/dosya1
```

Şimdi ali kullanıcısı üzerinden bu dosyayı okumayı ve içerisine veri
eklemeyi deneyelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya1
metin belgesi
yeni ekleme
yeni ekleme
son
son ekleme

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "deneme" >> testfolder/dosya1
bash: testfolder/dosya1: Permission denied
```

Gördüğünüz gibi klasörün tüm yetkileri olmasına rağmen, dosyanın yazma
yetkisi olmadığı için dosyaya yeni veri girişi yapamadık. Sanırım bu
örnek klasör ve dosya düzeyindeki erişim yetkilerini anlamak için basit
ama yeterli.

Ayrıca tüm bunların dışına eğer anlatım sırasında fark ettiyseniz, dosya
ve klasörlerin yetkilerini yalnızca o dosya veya klasörün sahibi
değiştirebiliyor. Örneğin gruptaki kullanıcılara tüm izinler verilmiş
olsa bile, gruptaki kullanıcılar ilgili dosya veya dizinin yetkilerini
değiştiremez.

Ben bu durumu da teyit etmek için öncelikle taylan kullanıcı hesabı
üzerinden `chmod g+rwx testfile.sh` komutuyla bu dosyanın gruba tüm
yetkileri veriyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod g+rwx testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                      
-rwxrwxr-x 1 taylan taylan 44 Jul  8 01:40 testfile.sh
```

Tüm yetkileri verdim. Şimdi bu gruba dahil olan ali kullanıcı hesabı
üzerinden mesela tüm kullanıcılara tüm yetkileri vermek üzere
`chmod a+rwx testfile.sh` şeklinde komutumuzu girmeyi deneyebiliriz.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ chmod a+rwx testfile.sh                                       
chmod: changing permissions of 'testfile.sh': Operation not permitted
```

Yetki hatası aldık çünkü ali kullanıcısının okuma yazma ve çalıştırma
yetkisi olsa da bu dosyanın izinlerini değiştirme yetkisi yok. Dosya ve
dizinlerin yetkilerini yalnızca sahipler değiştirebiliyor. Zaten böyle
olmasaydı erişim yetkilerinin hiç bir anlamı kalmazdı. Çünkü örneğin
dosyanın sahibi dışındaki herhangi bir kullanıcıya dosyayı okuması
çalıştırması ve yeni veriler yazması için yetki verdiğimizde bu
kullanıcı diğer herkesin yetkilerini düşürüp dosyanın tüm yetkilerini
devralabilirdi.

Bu sebeple dosya ve dizinlerin yetkilerini yalnızca sahiplerinin
değiştirebileceğini unutmayın. Tabii ki sistem üzerindeki en yetkili
olan root kullanıcısı da değiştirebilir fakat bu bir istisna ve root
kullanıcısı zaten süper yetkilere sahip.

Biz şimdi dosya ve dizinlerin sahibini ve grubunu değiştirmekten
bahsedelim.

Dosya ve Dizinlerin Sahiplerini ve Gruplarını Değiştirmek
---------------------------------------------------------

Burada değiştirmek istediğimiz, dosya ve dizinlerin sahipliği olduğu
için "**own**er" yani "sahip" ifadesinin kısaltmasından gelen `chown`
aracından faydalanabiliyoruz. İsmi işlevini temsil ettiği için zaten
ihtiyacımız olduğunda aracın ismini hatırlamamız da çok kolay oluyor.
Ayrıca kullanımı da çok kolay zaten.

Sahibini Değiştirmek
--------------------

Ben örnek olarak taylan kullanıcısına ait olan ***testfile.sh*** isimli
dosyanın sahipliğini değiştirmek istiyorum. İstersek hem dosya sahibini
hem de grubunu aynı anda değiştirebileceğimiz gibi, ayrı ayrı sahibini
ve grubunu da değiştirebiliriz.

Ben öncelikle yalnızca bu dosya sahibini **nil** olarak değiştirmek için
`chown nil testfile.sh` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ chown nil testfile.sh 
chown: changing ownership of 'testfile.sh': Operation not permitted
```

Ben bu dosyanın sahibi de olsam bu işlemi yapmak için yetkim yok. Bu
işlemi yapmak için yönetici ayrıcalıklarına sahip olmamız gerekiyor. Ben
komutun başında `sudo` yazıp tekrar giriyorum. Buradaki `sudo` komutu
sayesinde bu işlemi root yetkileriyle yerine getirebiliyor olacağım.
taylan kullanıcısı **sudo** grubuna dahil olduğu için `sudo` aracını
kullanarak geçici olarak yetkilerini yükseltebiliyor. İleride bu konudan
da ayrıca bahsediyor olacağız.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown nil testfile.sh 
[sudo] password for taylan:
```

Şimdi mevcut kullanıcı hesabımın yani taylan kullanıcısının parolasını
girip onaylıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown nil testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Bu kez herhangi bir hata almadık. Şimdi `ls -l` ile listeleyip dosyanın
izinlerine bakalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                      
-rwxrwxr-x 1 nil taylan 44 Jul  8 01:40 testfile.sh
```

Dosyanın sahibi olarak **nil** kullanıcısı gözüküyor. Yani artık
buradaki izinler **nil** kullanıcısında geçerli ve nil kullanıcısı bu
dosyanın izinleri değiştirebilir çünkü nil artık dosyanın sahibi.

Grubunu Değiştirmek
-------------------

Yalnızca grubu değiştirmek için `:grup` parametresini kullanabiliyoruz.
Ben örnek olarak taylan kullanıcısı üzerinden
`sudo chown :ali testfile.sh` şeklinde giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown :ali testfile.sh 
[sudo] password for taylan: 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                                        
-rwxrwxr-x 1 nil ali 44 Jul  8 01:40 testfile.sh
```

Dosyanın grubunu artık "ali" olarak geçiyor. Yani ali grubundakiler
buradaki yetkiler dahilinde bu dosya üzerinde işlemler yapabiliyor
olacak.

Sahibi ve Grubu Değiştirmek
---------------------------

Tek seferde hem sahibini hem de grubunu değiştirmek istersek
`chown sahibi:grubu dosya-dizin-adı` şeklinde girebiliriz. Ben
***testfile.sh*** dosyasının sahibini ve grubunu "ali" olarak
değiştirmek için taylan hesabı üzerinden
`sudo chown ali:ali testfile.sh` komutunu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown ali:ali testfile.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l testfile.sh                                           
-rwxrwxr-x 1 ali ali 44 Jul  8 01:40 testfile.sh
```

**ℹ️ Not:** `sudo` grubuna dahil olduğu için tüm işlemleri taylan
kullanıcı hesabı üzerinden root yetkileri ile gerçekleştiriyoruz.

Dosyanın sahibi ve grubunu tek seferde yine "ali" olarak ayarlamış
oldum.

İşte neticede sahiplik ve grup değiştirme işlemi bu şekilde. Örneğin ben
yalnızca tek bir dosya üzerinde ele aldım ancak isterseniz birden fazla
dosya veya klasör üzerinde de aynen kullanabilirsiniz. Hatta daha önce
yetki işlemlerinde ele aldığımız gibi klasörün altındaki içeriklerde
geçerli olacak sahiplik ve grup değişimi için büyük `R` karakteri ile
"recursive" yani "özyinelemeli" şekilde değişiklik de yapabiliriz.

Ben denemek için "***testfolder***" klasörümün altındaki tüm içeriğin
grubunu **nil** grubu ile değiştirmek için
`sudo chown -R :nil testfolder/` şeklinde komutumu yazıyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo chown -R :nil testfolder/

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -lR testfolder/                                                       
testfolder/:
total 12
-rwxr-xr-x 1 taylan nil 53 Jul  8 05:55 dosya1
-rwxrwxr-x 1 taylan nil  0 Jul  7 07:39 dosya3
-rwxrwxr-x 1 taylan nil  0 Jul  7 07:39 dosya4
-rw-rwxr-- 1 ali    nil 59 Jul  8 03:48 yeni-belge
-rwxrwxr-x 1 taylan nil 11 Jul  8 05:42 yeni-dosya
```

Bu dizin içindeki tüm dosya ve klasörlerin grubu nil olarak değişmiş.
Yani artık tüm bu içeriklerin grup bölümündeki yetkileri nil isimli
grubdaki kullanıcılar için geçerli olacak.

Ayrıca tabii ki bir tek alt dizinlerdeki gruplar değil, bizzat
***testfolder*** dizininin grubu da değişti. Teyit etmek için `ls -ld`
komutunu kullanabiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -ld testfolder/                                                       
drwxrwxr-x 2 taylan nil 4096 Jul  8 05:50 testfolder/
```

Bu klasörün grubu da nil olarak değişmiş.

Örneğin bu dosyaların grubu nil olarak değiştiği için ali kullanıcısı
artık bu gruba dahil değil. Dolayısıyla bu dizin içindeki dosyalara veri
eklemesi de mümkün değil. Hemen deneyelim.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ echo "veri ekleme" >> testfolder/dosya2
bash: testfolder/dosya2: Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ su nil
Password: 
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ echo "veri ekleme" >> testfolder/dosya2

┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ cat testfolder/dosya2
veri ekleme
```

Gördüğünüz gibi ali kullanıcısı "diğerleri" gruba dahil olduğu için
yazma yetkisi bulunmuyor, dolayısıyla veri de ekleyemiyor. Fakat nil
kullanıcısı nil grubunda olduğu için dosya üzerinde yazma yetkisi
bulunuyor. Yani dosya içeriğini istediği gibi düzenleyebiliyor.

Bu yaklaşım sayesinde ilgili dosya ve klasörlere erişmesini istediğiniz
kullanıcılar için bir grup oluşturup o grubu bu dosya veya klasörün
grubu olarak ayarlayabilirsiniz. Dosya veya klasörün grup yetkilerini
düzenleyerek de aynı anda bu gruptaki tüm kullanıcılar için ortak olarak
yetki tanımlaması da yapmış olursunuz.

En nihayetinde böylelikle yetkiler hakkında temel işleyişten bahsetmiş
olduk. Yine de henüz yetkilendirmenin önemli bir yapısı olan `sudo`'dan
bahsetmedik. Gelin anlatımlarımıza `sudo` yapısından bahsederek devam
edelim.

`sudo` \| ***sudoers*** Dosyasını Düzenlemek
--------------------------------------------

`sudo` aracı, komutlarımızı sistem üzerindeki başka bir kullanıcı gibi
çalıştırmamızı sağlıyor. Peki bu ne demek oluyor ?

Daha önce yetkilerden bahsederken, dosya ve dizinler üzerindeki
yetkilerin, sahibi ve grubuna göre belirlendiğini bizzat deneyimledik.
Yani örneğin düzenlemek istediğiniz dosya üzerinde yetkisi olan bir
kullanıcı hesabını yönetmiyorsanız o dosyayı düzenleyemezsiniz. Bu güzel
bir güvenlik önlemi fakat, sistem üzerinde birden fazla kullanıcı hesabı
ve grup oluşturulabileceğini biliyoruz. Dolayısıyla özellikle sistem
yöneticisi olarak kimi zaman başka bir kullanıcının veya grubun
sahipliğindeki dosya ve klasörler üzerinde işlem yapmamız da
gerekebiliyor.

Bu durumda düzenlemeyi yapmak için temelde üç alternatifimiz var.

Öncelikle sistemdeki süper kullanıcı olan yani en yetkili kullanıcı olan
root hesabına geçiş yapıp ilgili düzenlemeyi yapabiliriz. Fakat pek çok
sistemde root hesabı varsayılan olarak aktif olmayabiliyor. Çünkü root
en yetkili kullanıcı olduğu için gerekmedikçe bu yetkiyle çalışılması
hiç güvenli değil. Ayrıca root hesabını aktifleştirip kullansak bile
yetkili şekilde işlem yapması gereken tek kişi biz de olmayabiliriz.
Sistem üzerindeki diğer kullanıcıların da yetkili şekilde işlem yapması
gerekebilir. Bu durumda sistemdeki en yetkili kullanıcı olan root
kullanıcısının parolasını herkesle paylaşmamız sizce mantıklı olur mu ?
Kesinlikle olmaz. Çünkü herkes sistem üzerindeki tüm kontrole sahip olur
ve güvenlikten söz edemeyiz.

root hesabında oturum açmak istemiyorsak dosya veya dizinin sahibi olan
kullanıcı olarak oturum açıp ilgili düzenlemeyi de yapabiliriz. Fakat
tabii ki ilk yaklaşım da hem verimlilik hem de güvenlik açısından
mantıklı bir yok değil. Düşünsenize yöneticisi olduğunuz bir sistemde 10
farklı kullanıcı bile olsa, 10 farklı hesap bilgisini hatırlayıp
gerektikçe sürekli bu 10 farklı hesapta oturum açmanız gerekir. Bu
kesinlikle mantıklı bir yaklaşım değil. Ayrıca yetkili şekilde işlem
yapmaya bir tek sizin de ihtiyacınız olmayacak. Kimi kullanıcıların bazı
başka kullanıcıların yetkilerini gerektiren işlemler yapması da
gerekecek. Bu durumda tüm kullanıcıların birbiri ile parola bilgilerini
paylaşmaları gerekir ki bu tamamen korkunç yaklaşım.

Bu yöntemler dışında üçüncü alternatifimiz ise komutlarımızı
çalıştırırken ilgili kullanıcı gibi davranmamızı sağlayan `sudo`
yapısından faydalanmak.

Başkası gibi komut çalıştırabilme yaklaşımı sayesinde, konfigürasyon
dosyasında bu kullanıcılar gibi komutları çalıştırmak için kendimize
yetki verdiysek, bu kullanıcıların şifresini bilmeden yani bu kullanıcı
hesaplarında oturum açmamıza gerek kalmadan komutlarımızı tıpkı bu
kullanıcılarmış gibi çalıştırabiliyoruz.

Bu sayede biz başka bir kullanıcı gibi komut çalıştırdığımızda, aslında
kendi hesabımızı kullanarak bu işlemi yaptığımız için bu işlemin kim
tarafından yapıldığı da loglara kaydediliyor. Yani bu yaklaşım sayesinde
yetkimiz olsa bile bu yetkileri hangi amaçla kullandığımız kayıt altında
oluyor. Ayrıca tüm kullanıcılar kendi hesabını kullandığı için kullanıcı
özelinde izin ve kısıtlama da tanımlayabiliyoruz. Yani "başkası gibi
davranma" yetkilerini sınırlamamız da mümkün oluyor.

İşte `sudo` aracının en temel çalışma yapısı aslında bu şekilde. Eğer
söylediklerim sizin için henüz anlamlı gelmiyorsa merak etmeyin bölüm
sonunda tüm anlatımlar netleşmiş olacak.

Şimdiye kadar yetki gerektiren çeşitli işlerimiz için pek çok kez `sudo`
yapısını kullandık. Şimdi daha yakından bakıp temel çalışma yapısı
hakkında konuşmak istiyorum.

`sudo` Aracını Anlamak
----------------------

`sudo` geçici olarak yetkilerimizi yükseltmemize olanak tanıyan bir
araç. Biz herhangi bir komuttan önce `sudo` komutunu kullandığımızda,
`sudo` aracının yapılandırma dosyası olan ***/etc/sudoers*** dosyasına
bakılıyor. Eğer bu konfigürasyon dosyasında bize bu komutu çalıştırmak
için özel ayrıcalık verildiyse komutu yetkili şekilde
çalıştırabiliyoruz.

Bu durumu daha iyi anlamak için root parolasını bilmeye gerek kalmadan
root olarak işlem yapmaya basit bir örnek verebiliriz.

Örneğin ben konsola `whoami` şeklinde yazacak olursam;

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ whoami
taylan
```

Çıktı olarak kendi kullanıcı adımı aldım.

Çünkü bu komutu taylan kullanıcı olarak ben çalıştırdım. Şimdi bir de
yetkili şekilde çalıştırmak için `sudo whoami` şeklinde komutumuzu
girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo whoami
[sudo] password for taylan:
```

Kendi kullanıcı hesabımızın parolasını girmemiz isteniyor. Girelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo whoami
[sudo] password for taylan: 
root
```

Bu sefer `whoami` sorgusunun yanıtı olarak **root** çıktısını aldık.
Çünkü aslında biz burada `sudo` komutunu kullandığımızda `whoami` komutu
root yetkileriyle çalıştırıldı. Dolayısıyla `whoami` aracı da komutu
giren kişinin root olduğunu belirten çıktıyı bastırdı.

Komutumuzu root yetkileri ile çalıştırmış olmamızın yanında eğer
dikkatinizi çektiyse bu işlem için root hesabının parolasına ihtiyacımız
olmadı, yalnızca kendi hesabımızın parolasını girdik. Kendi hesabımızın
parolasını girmemiz yeterli oldu çünkü mevcut hesabımız `sudo` üzerinden
root yetkilerini kullanabilecek şekilde konfigürasyon dosyasında
tanımlanmış.

İşte bizzat bu basit örnekle teyit ettiğimiz gibi `sudo` aracı bizlere
güvenli yoldan root yetkileri ile çalışabilmeyi sağlayan bir çözüm
aslında.

***sudoers*** Dosyasını Düzenlemek
----------------------------------

`sudo` aracını kimlerin ne şekilde kullanabileceğini düzenlemek için
***/etc/sudoers*** dosyasını metin editöründe açıp düzenleyebiliriz.
Düzenleme işlemi için de `visudo` komutunu aracını kullanmamız
gerekiyor. Aslında normalde herhangi bir metin editörünü de
kullanabiliriz fakat `visudo` aracı sayesinde dosyadaki yeni tanımların
hata kontrolü yapıldığı için olası yanlış konfigürasyonların önüne
geçmemiz de mümkün oluyor.

Konfigürasyon dosyasını açmak için `sudo visudo` komutuyla dosyamızı
yetkili şekilde açabiliriz.

![visudo.webp](https://www.linuxdersleri.net/egitim/temel-linux/kullanici/visudo.webp)

Dosyam şu anda template(***sudoers.tmp***) şablon halinde olduğu için
burada ***.tmp*** uzantısı var. Eğer değişiklik yapıp kaydedecek olursak
asıl dosya olan ***/etc*** dizini atlındaki ***sudoers*** dosyasına
kaydolmuş olacak.

Şimdi dosya içeriğine bakacak olursak. Dosyanın en başında bulunan bu
tanımlar güvenlik amaçlı. Ayrıntılar için ***suoders*** dosyasının
manual sayfalarına bakabilirsiniz. Ben detaylar üzerinde durmayacağım
ama örneğin ilk satır tanımlanmış olabilecek zararlı değişkenleri
sıfırlıyor. Üçüncü satır ise zararlı dosyaları içerebilecek ek PATH
yollarının tanımlanmış olma ihtimaline karşı standart olan PATH yolunu
tekrar tanımlıyor. Dediğim gibi bunlar güvenlik önlemi bunlara müdahale
etmeden devam edeceğiz. Daha fazla bilgi almak için manual sayfasına göz
atabilirsiniz.

Diyez `#` sembolü olan satırlar da zaten yorum satırları. Bunlar işleme
alınmıyor. Gördüğünüz gibi tanımlı seçenekler hakkında kısa açıklamalar
yazmak için kullanılıyor. Ayrıca sayfayı inceleyecek olursanız bazı
tanımlamaların başında diyez işareti olduğu için pasif durumda
olduklarını görebilirsiniz. Ben şimdi en temel işlem olan yetki
tanımlamalarından bahsetmek için dosyanın alt satırlarına geliyorum.

``` {.sql}
# User privilege specification
#root   ALL=(ALL:ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on "@include" directives:

@includedir /etc/sudoers.d
```

Buradaki ilk tanımlama ile başlayacak olursak, bu satır root
kullanıcısının **sudo** ayrıcalıklarını belirtiyor.

``` {.sql}
# User privilege specification
#root   ALL=(ALL:ALL) ALL
```

Daha net anlaşılabilmesi için renklendirelim.

Bu tanımlamadaki ilk kısım bu kuralın geçerli olacağı kullanıcının
ismini belirtiyor. Yani bu kural **root** kullanıcısı için tanımlanmış.

İkinci kısımdaki **ALL** ifadesi bu kuralın **tüm hostlarda** yani ağ
üzerindeki tüm ana makinelerde geçerli olmasını sağlıyor. İleride ağ
bölümünde "host" kavramına değindiğimizde buradaki tüm hostlardan
kastımızın ne olduğunu net biçimde anlamış olacaksınız.

Eşittir işaretinden sonra parantez içinde yazılan ilk **ALL**, komutları
tüm kullanıcılar gibi çalıştırabileceğini gösteriyor.

İkinci **ALL** ise root kullanıcısının komutları tüm gruplar gibi
çalıştırabileceğini belirtiyor.\
Dosya ve dizinlerin sahibini ve grubunu değiştirirken **sahibi:grubu**
şeklinde tanımlama yapmıştık. İşte buradaki tanımlama da aynı aslında.
Burada **ALL:ALL** şeklinde yazdığı için komutlarını istediği bir
kullanıcı veya grup ayrıcalıkları ile çalıştırabiliyor. Tüm
kullanıcıları kapsayan bu **ALL** seçeneği, biz aksini belirtmediğimiz
sürece en yetkili olan "root" kullanıcı yetkileri ile çalıştırılmasını
sağlıyor. Fakat istersek, dilediğimiz bir kullanıcı veya grup yetkileri
ile çalıştırmamız da mümkün.

En sondaki **ALL** ise bu kuralların tüm komutlar üzerinde geçerli
olmasını sağlıyor.

Şimdi muhtemelen, "*root kullanıcısı zaten sistemde en yetkili kullanıcı
o zaman niye burada root kullanıcısı için bir daha yetki tanımlaması
yapılıyor?*" diye düşünmüş olabilirsiniz.

Normalde biz root hesabını kullanıyorken girdiğimiz tüm komutlarımızı en
yetkili şekilde çalıştırabiliyoruz. Fakat biz root hesabındayken
alışkanlık gereği yine `sudo` komutunu kullanırsak, `sudo` aracı
konfigürasyon dosyasında root kullanıcısı için yetki tanımlaması
olmadığı için en yetkili kullanıcı da olsa hata verir. Ne demek
istediğimi daha net anlamak için hemen yeni bir konsol başlatalım.

Ben bu konsol üzerinden root hesabına geçiş yapmak istiyorum fakat benim
sistemimde root hesabı şu anda pasif durumda. Aktifleştirmek için root
hesabına bir parola belirlemem gerekiyor. Bunun için de
`sudo passwd root` şeklinde komutumu girebilirim.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo passwd root
New password: 
Retype new password: 
passwd: password updated successfully
```

Tamamdır, artık root hesabının bir parolası olduğu için root hesabına
geçiş yapabiliriz. Ben `su root` komutuyla geçiş yapıyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su root
Password: 
┌──(root㉿linuxdersleri)-[/home/taylan]
└─#
```

Şimdi denemek için yine yalnızca `whoami` şeklinde komutumuzu
girebiliriz.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# whoami
root
```

root çıktısını aldık. Şimdi bir de `sudo whoami` şeklinde girelim.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# sudo whoami
root is not in the sudoers file.  This incident will be reported.
```

Bu kez root hesabının sudoers dosyasında olmadığı belirtilerek
çalıştırma işlemi reddedildi. Yani bizzat gördüğümüz gibi root
kullanıcısı da olsa, `sudo` aracını kullanabilmesi için ***sudoers***
konfigürasyon dosyasında tanımlanmış olması gerekiyor.

Şimdi konfigürasyonu yaptığımız pencereye geri dönüp root hesabı için
tanımlı olan satırın başındaki diyez işaretini kaydırıp dosyamızı
kaydedelim. Kaydetme işlemi, klasik `nano` aracında olduğu gibi Ctrl + o
ile yapılabilir.

``` {.sql}
# User privilege specification
root    ALL=(ALL:ALL) ALL
```

Kayıt işleminden sonra tekrar root hesabının oturum açtığı konsola dönüp
`sudo whoami` komutunu girebiliriz.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# sudo whoami
root
```

root hesabı için geçerli olan tanımlamayı ***sudoers*** dosyasında
aktifleştirmiş olduğumuz için bu kez "root" çıktısını almış olduk.

Eğer yetki gerektiren işler için `sudo` aracını kullanmaya alıştıysanız
root hesabına geçiş yapıp root olarak çalışıyor olsanız da alışkanlık
gereği `sudo` komutunu kullanmaya devam edebilirsiniz. Bu durumda `sudo`
dosyasında root hesabı için tanımlama yoksa hata almanız da kaçınılmaz.

Ayrıca etkileşimli şekilde root hesabını kullanmak dışında örneğin
sistemin işleyişi için kullanılan bir betik dosyası içerisinde `sudo`
komutu bulunuyor olabilir. Ve bu betik dosyasını root hesabı üzerinden
çalıştıracak olursak, tıpkı buradaki gibi ***sudoers*** dosyasında root
için tanımlama olmadığından dolayı en yetkili kullanıcı da olsa hata
alırız. Yani içerisinde `sudo` komutu bulunan betik dosyamız doğru
şekilde çalışmaz.

Özetle bizzat teyit ettiğimiz gibi, root kullanıcısı en yetkili
kullanıcı da olsa `sudo` komutunun işleyişi dolayısıyla stabil bir
sistem yönetimi için ***sudoers*** dosyası içinde bulunması gerekiyor.

Şimdi ben konfigürasyon dosyasından biraz daha bahsetmek üzere dosyanın
açık olduğu konsola dönüyorum. Açıklamalara devam etmek için tekrar alt
satırlara gelelim.

``` {.sql}
# User privilege specification
root    ALL=(ALL:ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on "@include" directives:

@includedir /etc/sudoers.d
```

Başında yüzde işareti olanlar **yetki gruplarını** temsil ediyor.
Örneğin **sudo** grubu için burada tüm yetkiler tanımlanmış, dolayısıyla
bu gruba dahil olan tüm kullanıcılar bu yetkiler dahilinde hareket
edebiliyor.

Hatırlıyorsanız gruplardan bahsederken taylan kullanıcısının **sudo**
grubuna dahil olduğunu da görmüştük. Hatta tekrar teyit etmek istersek,
yeni bir konsol açıp `groups taylan` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ groups taylan
taylan : taylan adm dialout cdrom floppy sudo audio dip video plugdev netdev wireshark bluetooth scanner kaboxer
```

**taylan** kullanıcısı **sudo** grubuna da dahil. Bu sayede biz taylan
kullanıcısını yönetiyorken, `sudo` aracını kullandığımızda buradaki
**sudo** grubu için tanımlı olan bu yetkiler dahilinde işlerimizi
yürütebiliyoruz.

Dolayısıyla örneğin tıpkı taylan kullanıcısında olduğu gibi aynı
yetkilere sahip olmasını istediğimiz kullanıcılar olursa onları da
**sudo** grubuna ekleyip bu yetkiler dahilinde hareket etmelerini
sağlayabiliriz. Ya da yeni bir grup oluşturup, burada bu gruba özel
olarak izin tanımlaması da yapabiliriz.

Ayrıca bu noktada dikkatinizi çekmek istediğim bir husus var. Sizin
kullandığınız dağıtımdaki ***sudoers*** dosyasında buradaki gibi
**sudo** isimli bir grup varsayılan olarak tanımlı olmayabilir. Farklı
isimde örneğin "**admin**" veya "**wheel**" isimlerinde gruplar da
tanımlı olabilir. Hatta hiç bir grup tanımlanmamış da olabilir. Burada
asıl mesele, istersek tek bir kullanıcı için veya daha fazla kişiyi
etkilemesi için bir gruba özel yetki tanımlaması yapabiliyor olmamız. Bu
tanımlamalar varsayılan olarak bu dosyada bulunmasa bile biz
ihtiyaçlarımıza göre kendimiz ekleyebiliriz.

Gruplar dışında burada **@includedir** tanımının ardından bir dizin
adresi belirtilmiş.

``` {.ruby}
# See sudoers(5) for more information on "@include" directives:

@includedir /etc/sudoers.d
```

Bu tanımlama sayesinde yalnızca mevcut ***sudoers*** dosyası değil, bu
dizin altında yer alan diğer konfigürasyon dosyaları da okunup geçerli
oluyor. Bu yaklaşım sayesinde ***/etc*** dizini altındaki ana
***sudoers*** dosyasında yani şu an görüntülediğimiz dosyada değişiklik
yapmadan bu dizindeki dosyalarda güvenli şekilde tanımlamalar
yapabiliyoruz. Şu an incelediğimiz bu ***sudoers*** dosyası ana
konfigürasyon dosyası olduğu için genellikle en temel tanımlamalar
burada oluyor. Özellikle çok fazla tanımlama yapılacaksa bu
tanımlamaları burada belirtilen dizin altındaki konfigürasyon
dosyalarında yapmak, sistemi düzenli kullanmak adına çok daha doğru bir
yaklaşım. Zaten pek çok aracın konfigürasyon dosyasında da aslında bu
yaklaşım kullanılıyor. Ana konfigürasyon dosyasını sade tutmak ve mevcut
yapısını bozmamak için konfigürasyon dosyasının isminin sonuna ***.d***
eklenmiş bir dizinde harici konfigürasyonlar tanımlanıp
kullanılabiliyor. Buradaki ***.d*** ifadesi "**d**irectory" yani "dizin"
ifadesinin kısaltmasından geliyor. Özetle şimdiden haberiniz olsun,
tıpkı burada ***sudoers*** dosyasında olduğu gibi sistem üzerindeki
diğer çeşitli konfigürasyonlarda da bu şekilde harici konfigürasyonların
alt dizinde tutulduğuna şahit olacaksınız.

Şimdi tekrar ***sudoers*** dosyasına dönecek olursak, buraya dahil
edilen dizin içeriğine bakmak için öncelikle mevcut konfigürasyon
dosyamızı kapatalım. Şimdi ls ***/etc/sudoers.d/*** komutuyla dizin
içeriğini listeleyebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /etc/sudoers.d/
kali-grant-root  README
```

Örneğin benim sistemimde "kali-grant-root" isimli bir konfigürasyon
dosyası var. Okumak için `visudo` komutunun ardından bu dosyanın tam
konumu yazabiliriz.

``` {.bash}
sudo visudo /etc/sudoers.d/kali-grant-root
```

Burada **kali-tursted** isimli bir grup tanımlanmış ve bu gruba tüm
komutları parola olmadan çalıştırabilme yetkisi tanımlanmış.

``` {.sql}
# Allow members of group kali-trusted to execute any command without a
# password prompt
%kali-trusted   ALL=(ALL:ALL) NOPASSWD: ALL
```

Buradaki **NOPASSWD** ifadesi parola sorulmadan buradaki yetkilerin
uygulanabilmesini sağlıyor.

Dolayısıyla bu **kali-trusted** grubundaki tüm kullanıcılar tüm
komutları kendi parolaları dahi sorulmadan sorunsuzca çalıştırabilirler.
Hatta buradaki yetki tanımlamasının etkisini bizzat görmek için bu gruba
bir kullanıcı ekli mi diye kontrol edip, varsa o kullanıcı üzerinden
testimizi gerçekleştirebiliriz.

Yeni bir konsol üzerinden bu gruptaki kullanıcıları listelemek için
`grep “kali-trusted” /etc/group` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ grep "kali-trusted" /etc/group
kali-trusted:x:123:
```

Bu grup hakkında bilgi sunan satır filtrelendi ama buradaki tanımlamanın
sonunda, yani gruba dahil olan kullanıcıların bulunması gereken sütunda
herhangi bir kullanıcının ekli olmadığını görebiliyoruz. Eğer testi yine
de gerçekleştirmek istersek bu gruba kullanıcı ekleyip deneyebiliriz.
Ben **nil** isimli kullanıcı hesabını bu gruba dahil etmek üzere
`sudo gpasswd -a nil kali-trusted` komutunu giriyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo gpasswd -a nil kali-trusted 
[sudo] password for taylan: 
Adding user nil to group kali-trusted
```

**taylan** kullanıcısı **sudo** grubunda olduğu için ve sudo
grubundakilere parola sorulmaması gibi özel bir tanımlama olmadığı için
taylan kullanıcısı yetkili şekilde bir işlem yapmadan önce buraya
parolasını girmesi gerekti. Neticede nil kullanıcısını "kali-trusted"
grubuna eklemiş olduk. Kontrol etmek için yine
`grep “kali-trusted” /etc/group` komutunu geçmişten çağırıp
kullanabiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ grep "kali-trusted" /etc/group                 
kali-trusted:x:123:nil
```

Bu kez son sütunda nil kullanıcısının ismi gözüküyor. Yani gruba ekleme
işlemi başarılı. Şimdi yetki işlemini teyit etmek için hemen `su nil`
komutuyla nil kullanıcı hesabına geçiş yapalım.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su nil                                                                   
Password: 
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$
```

Tamamdır. Şimdi tekrar ***sudoers.d*** dizini altındaki konfigürasyon
dosyasına dönecek olursak, burada bu gruba dahil olan tüm kullanıcıların
tüm komutları parola olmadan çalıştırabileceği belirtiliyor.

``` {.sql}
# Allow members of group kali-trusted to execute any command without a
# password prompt
%kali-trusted   ALL=(ALL:ALL) NOPASSWD: ALL
```

Şimdi bu durumu teyit etmek için nil kullanıcısı üzerinden `sudo whoami`
komutunu girebiliriz.

``` {.bash}
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ sudo whoami
root
```

Bana yani "nil" kullanıcısına, parola sorulmadan anında `whoami` komutu
en yetkili kullanıcı olan root kullanıcısının yetkileriyle çalıştırdı.
İşte bu basit örnek, konfigürasyon dosyasındaki parola sorulmadan tüm
yetkileri veren "**NOPASSWD**" tanımlamasının geçerli olduğunun kanıtı.

Eğer süper kullanıcı yetkilerine kendi hesabının şifresini bile girmeden
erişmesini istediğimiz kullanıcılar varsa bu gruba ekleyebiliriz. Ya da
örneğin sizde böyle bir grup tanımlaması yoksa, buradaki tanımlamanın
aynısını yazarak aynı konfigürasyonların geçerli olmasını da
sağlayabilirsiniz. Fakat tabii ki buradaki gibi sınırsız yetkiyi kime
vermek istediğinize de iyi karar vermeniz gerekiyor çünkü bu durum
sistem güvenliği için tehlikeli olabilir. Bu mevcut tanımlamalarla tüm
yetkileri vermek yerine eğer istersek ihtiyaçlarımıza göre farklı
kısıtlamalar içeren bir grup da ya da kullanıcı özelinde tanımlamalar da
oluşturabiliriz.

Şimdi gelin çok kısaca bu tanımlamalardan bahsederek devam edelim.

Özel Kural Tanımlama
--------------------

`sudo` aracılığı ile spesifik bir kullanıcı gibi komut yürütmek istersek
`sudo -u kullanıcı-adı komut` şeklinde komutumuzu girebiliyoruz. Benzer
şekilde spesifik bir grubun yetkileri dahilinde bir komutu çalıştırmak
istediğimizde de `sudo -g grup-adı komut` şeklinde `sudo` aracını
kullanabiliyoruz.

Daha önce ***sudoers*** konfigürasyonlarında bizzat gördüğümüz gibi
**sudo** grubundaki kullanıcılara "**ALL:ALL**" yani **tüm kullanıcı ve
grupların yetkileri ile hareket etme** imkanı tanındığını biliyoruz.
Tekrar hatırlayalım:

``` {.sql}
# User privilege specification
root    ALL=(ALL:ALL) ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL 

# See sudoers(5) for more information on "@include" directives:

@includedir /etc/sudoers.d
```

**taylan** kullanıcısı da **sudo** grubunda olduğu için ben taylan
kullanıcı hesabı üzerinden istediğim kullanıcı veya grubun yetkileri ile
komutlar çalıştırabilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo whoami
[sudo] password for taylan: 
root

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo -u nil whoami
nil

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo -u ali whoami
ali

┌──(taylan㉿linuxdersleri)-[~]
└─$ whoami
taylan
```

Gördüğünüz gibi tüm kullanıcı ve grup yetkileri ile çalıştırma hakkımız
olduğunda; biz **özellikle belirtmediğimiz zaman** `sudo` aracını
kullandığımızda, komutlarımız **varsayılan olarak "root" yetkileri** ile
çalıştırılıyor. Fakat `sudo` aracının `-u` veya `-g` seçenekleri ile
kullanıcı veya istediğimiz grup yetkileri de komutlarımızı çalıştırmamız
mümkün oluyor.

Örneğin ali kullanıcısı sudo grubununda olmadığı için bu işlemleri
gerçekleştiremez.

``` {.bash}
┌──(ali㉿linuxdersleri)-[~]
└─$ whoami
ali

┌──(ali㉿linuxdersleri)-[~]
└─$ sudo whoami
[sudo] password for ali: 
ali is not in the sudoers file.  This incident will be reported.

┌──(ali㉿linuxdersleri)-[~]
└─$ sudo -u nil whoami
[sudo] password for ali: 
ali is not in the sudoers file.  This incident will be reported.
```

Yani tekrar özetleyecek olursak "**ALL=(ALL:ALL) ALL**" tanımlaması
aslında tüm hostlardaki tüm kullanıcı ve grupların yetkileri ile tüm
komutların çalıştırılabileceğini belirten en geniş yetki tanımlamasıdır.

Artık ***sudoers*** dosyasının genel sözdizimine aşina olduğumuza göre,
ihtiyaçlarımıza göre bazı yeni kurallar tanımlayabiliriz. Tanımlama
yaparken ***/etc/sudoers*** dosyası içinde veya ***/etc/sudoers.d***
dizini altındaki dosyalarda tanımlama yapmamız mümkün. Ben bu dizin
altında yeni konfigürasyon dosyası oluşturmak için
`sudo visudo /etc/sudoers.d/yeni-tanim` şeklinde komutumu giriyorum.

### Kullanıcıya Özel Tanımlama

Ben öncelikle tek bir kullanıcı için özel tanımla yapmak istiyorum. İlk
olarak tanımlamayı yapıp, daha sonra üzerine konuşalım.

``` {.ruby}
#ali kullanıcısı için yetki tanımlaması
ali ALL= /usr/bin/ls, /usr/bin/whoami
```

Dosyaya sonradan baktığımızda bu tanımlamayı neden yaptığımızı daha net
anlayabilmek için ilk olarak diyez **\#** işaretinden sonra kısaca
açıklama ekledik. Örneğin ben ali kullanıcısı için tanımlama yapmak
istediğim için buraya "ali kullanıcısı için yetki tanımlaması" şeklinde
yazdım.

Tanımlama tek bir kullanıcıyı etkileyecekse, doğrudan kullanıcının
ismini yazmamız gerekiyor. Ben de **ali** şeklinde yazdım.

Tanımladığım bu yetkinin tüm hostlarda geçerli olmasını istediğim için
kullanıcı ismini yazdıktan sonra boşluk bırakıp **ALL** yazıp eşittir
işaretini koydum. Yetki tanımlamasını bu eşittir işaretinden sonra
yazabiliyoruz.

Ben ali kullanıcısının herhangi bir kullanıcı veya grup olarak komut
çalıştırmasını **istemediğim için** parantez açıp, içine hangi
kullanıcılar veya gruplar olarak komut çalıştırabileceğini
**belirtmedim**. Biz özellikle kullanıcı adı veya grup belirtmediğimizde
komutlar **root** yetkileriyle çalıştırılıyor olacak. Eğer siz **tüm
kullanıcı hesapları ve grupları gibi** komut yürütebilmesini isterseniz
(**ALL:ALL)** şeklinde belirtebilirsiniz.

``` {.sql}
ali ALL=(ALL:ALL) /usr/bin/ls, /usr/bin/whoami
```

İleride komutlarımızı nasıl farklı kullanıcılar veya gruplar gibi
çalıştırabileceğimizden bahsettiğimizde buradaki tanımlama sizin için
çok daha anlaşılır olacak. Ayrıca isterseniz tüm kullanıcılar gibi
çalıştırma yetkisi yerine spesifik olarak istediğiniz kişi veya grupları
da, aralarına virgüller ile ayırarak belirtebilirsiniz.

``` {.r}
ali ALL=(akullanıcı, bkullanıcı, ckullanıcı:agrubu, bgrubu) /usr/bin/ls, /usr/bin/whoami
```

Ben hiç birini istemediğim için parantez açmadım. Parantez açmadığım
için ali kullanıcısı komutlarını yalnızca **root** olarak
çalıştırabiliyor olacak.

Son olarak eğer ali kullanıcısının **tüm komutları** root yetkileriyle
çalıştırabilmesini istersem sonda **ALL** şeklinde yazabilirdim.

Ancak ben size kısıtlı yetkiyi göstermek için ali kullanıcısının
yalnızca `ls` ve `whoami` araçlarını kullanmasına izin vermek istiyorum.
Bunun için de `ls` ve `whoami` araçlarının tam dosya konumlarını buraya
yazdım.

``` {.ruby}
ali ALL= /usr/bin/ls /usr/bin/whoami
```

Araçların konumlarını `which` komutu ile öğrenebilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ which ls
/usr/bin/ls

┌──(taylan㉿linuxdersleri)-[~]
└─$ which whoami
/usr/bin/whoami
```

İşte bu şekilde istediğimiz kullanıcı hesabına istediğimiz araçları root
olarak çalıştırabilme yetkisi verebiliyoruz. Kuralı kendi ihtiyacınıza
göre istediğiniz şekilde özelleştirebilirsiniz. Kuralı denemek için
öncelikle konfigürasyon dosyamızı kaydedip kapatalım.

Ben ali kullanıcısı için tanımladığım için `su ali` komutu ile bu
kullanıcı hesabına geçiş yapıyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su ali
Password: 
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$
```

Şimdi yetkilerimizi deneyebiliriz.

``` {.bash}
┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ ls /root
ls: cannot open directory '/root': Permission denied

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ sudo ls /root
[sudo] password for ali: 
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  test  Videos

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ whoami
ali

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ sudo whoami
root

┌──(ali㉿linuxdersleri)-[/home/taylan]
└─$ sudo echo "deneme"
Sorry, user ali is not allowed to execute '/usr/bin/echo deneme' as root on linuxdersleri.net.
```

Gördüğünüz gibi ali kullanıcısı tam olarak benim izin verdiğim şekilde
yalnızca `ls` ve `whoami` komutlarını `sudo` sayesinde root yetkileriyle
çalıştırabiliyor. Örneğin `echo` aracı için **sudo** kuralı
belirtmediğim için bu aracı `sudo` komutu ile root yetkileriyle
çalıştıramadım.

Ayrıca root dışında, diğer kullanıcı hesapları üzerinden çalıştırmayı da
deneyebiliriz.

``` {.swift}
┌──(ali㉿linuxdersleri)-[/]
└─$ sudo -u nil whoami
Sorry, user ali is not allowed to execute '/usr/bin/whoami' as nil on linuxdersleri.net.
```

Bakın ben "nil" kullanıcı yetkileri ile çalıştırmayı denedim ama
konfigürasyonlarda bunu belirtmediğim için çalıştıramadım. Ben
konfigürasyonlarda hiç bir kullanıcı veya grubu belirtmediğim için
yalnızca "root" yetkileri ile çalıştırmam mümkün oldu. O da yalnızca
izin verdiğim araçları çalıştırabildim. Yani ali kullanıcısı için
tanımladığımız konfigürasyonun geçerli olduğunu bizzat teyit etmiş
olduk.

Esasen benzer şekilde spesifik olarak izin verip, kısıtlayabileceğimiz
ve başka parametreler ile kapsamını değiştirebileceğimiz pek çok
tanımlama mevcut. Fakat temel işleyişten haberiniz olduğu için manual
sayfaları üzerinden bu tanımlara bakmanız çok daha etkili olacaktır.
Zira aksi takdirde manual sayfalarının tekrarı gibi biraz uzun ve
kendini tekrar eden tanımlama açıklamaları yapmam kaçınılmaz olacak. Ben
de ihtiyaç duyduğumda manual sayfalarına bakıp tanımlama kurallarını
hatırlıyorum.

Tanımlama yaparken önemli olan, kime hangi yetkiyi verdiğinizdir.
Gereksiz ve hatalı yetki tanımlamaları çok büyük güvenlik zafiyetlerin
sebebiyet verebileceği için tanımlamalarınızı yaparken lütfen dikkatli
davranın.

Neyse bence artık `sudo` aracı hakkında gerekli olan temel bilgilerden
bahsetmiş olduk. Artık tek ihtiyacınız pratik yaparak öğrendiklerinizi
pekiştirmek ve merak ettiğiniz soruları kendi kendinize araştırıp
uygulama yaparak kavramak.

`su` Komutu Hakkında
--------------------

Şimdiye kadar özellikle ele almamış olsak da aslında kullanıcı hesapları
arasında geçiş yapmak için `su` komutunu defalarca kez kullandık. `su`
komutunun ismi de "**s**witch **u**ser" yani "kullanıcı değiştir"
ifadesinin kısaltmasından geliyor.

Bildiğiniz gibi `su` komutu kendisinden sonra belirtilmiş olan kullanıcı
hesabında, mevcut konsol üzerinden oturum açmayı sağlıyor. Fakat bu
komutu kullanırken aslında temelde iki alternatif kullanım yönetimine
sahibiz. Eğer `su` komutundan sonra yalnızca geçiş yapılması gereken
kullanıcı ismini girersek, bu kullanıcı hesabı mevcut bulunduğumuz
kabuğun altında yeni başlatılan kabukta bizim bu komutu girdiğimiz
konumdan çalışmaya başlayacak. Mevcut kabuğun altında yeni bir kabuk
başlatıldığı için de mevcut kabuk üzerinde geçerli olan global ortam
değişkenleri gibi çeşitli bilgiler de bu yeni başlatılan kabuğa
aktarılıyor olacak. Ne demek istediğimi en iyi örnek üzerinden
açıklayabilirim.

Şimdi ben farklı bir kullanıcı hesabına geçiş yapmadan önce
`export test=”bu bir testtir”` komutuyla, mevcut kabuk ortamımda
**test** isimli yeni bir global değişken tanımlamak istiyorum. Bu sayede
bu değişken mevcut kabuk altında başlatılan tüm alt kabuklarda da aynen
geçerli olacak.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ export test="bu bir testtir"

┌──(taylan㉿linuxdersleri)-[~]
└─$ echo $test
bu bir testtir

┌──(taylan㉿linuxdersleri)-[~]
└─$ bash
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo $test
bu bir testtir
```

Tanımadığım değere şu an ulaşabiliyorum. Son olarak bir de mevcut
bulunduğumuz dizini `pwd` komutu ile öğrenelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ pwd
/home/taylan
```

Gördüğünüz gibi ben şu anda bu kabukta taylan kullanıcısının ev
dizininde yani ***/home/taylan*** dizininde çalışıyorum.

Şimdi `su root` komutu ile **root** kullanıcısına geçiş yapmayı
deneyebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su root
Password:
```

Ben daha önce root hesabı için parola tanımladığım için burada
tanımadığım parolayı giriyorum. Tabii siz root hesabını
aktifleştirmediyseniz örnek için farklı bir kullanıcıya da geçiş yapmayı
deneyebilirsiniz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su root
Password: 
┌──(root㉿linuxdersleri)-[/home/taylan]
└─#
```

Tamamdır root hesabı için tanımlı olan varsayılan kabuğa geçişimi yapmış
oldum. Hatta kabuğu sorgulamak için `echo $SHELL` komutunu girebiliriz.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# echo $SHELL
/usr/bin/zsh
```

Benim kullandığım sistemde root hesabının varsayılan kabuğu `zsh` kabuğu
olduğu için bu şekilde çıktı aldım.

Şimdi esas konumuza dönecek olursak ben taylan kullanıcısının kabuğu
üzerinde tanımlamış olduğum değişkene bu kabuk üzerinden ulaşıp
ulaşamayacağımı merak ediyorum. Öğrenmek için `echo $test` şeklinde
komutumuzu girelim.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# echo $test 
bu bir testtir
```

taylan kullanıcısının kabuğunda tanımlı olan değişken burada da geçerli.
Üstelik farklı kabuk olsalar bile değişken değeri aktarılmış. Bir de
mevcut bulunduğumuz dizini de `pwd` komutuyla bastıralım.

``` {.bash}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# pwd               
/home/taylan
```

Bakın, hala taylan kullanıcısının ev dizinde(***/home/taylan***)
çalışıyorum.

`su` ile `su -` Arasındaki Fark
-------------------------------

Burada hala aynı dizinde çalışma ve diğer kullanıcının kabuğunda
tanımlanmış global değişkene ulaşabiliyor olma nedenim `su` komutunda
sonra doğrudan yalnızca kullanıcı ismi girmiş olmam. Bu şekilde komut
girdiğimizde `su` aracı, ilgili kullanıcı hesabına geçiş yaparken mevcut
kabuğun çalışma ortamındaki mevcut dizinini ve ortam değişkenleri gibi
çeşitli özellikleri koruyarak geçiş yapılan kullanıcının kabuğunu alt
kabukta başlatıyor. Yani aslında sıfırdan temiz bir kabuk ortamı
başlatılmıyor.

Eğer biz mevcut kabuktan etkilenmeyecek temiz bir kabuk başlatılsın
istersek komutumuz `su - kullanıcı-adı` şeklinde girebiliriz. Ben
denemek için mevcut root oturumunu kapatmak üzere `exit` komutunu
giriyorum.

``` {.scss}
┌──(root㉿linuxdersleri)-[/home/taylan]
└─# exit      

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Tamamdır. Şimdi oturum açtığımız kullanıcın, temiz bir kabuğunu
başlatmak için `su - root` şeklinde komutumuzu girelim.

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su - root
Password: 
┌──(root㉿linuxdersleri)-[~]
└─#
```

Tamamdır. Hemen bulunduğumuz dizini bastıralım.

``` {.bash}
┌──(root㉿linuxdersleri)-[~]
└─# pwd       
/root
```

Bu kez root kullanıcısının ev dizininde yani ***/root*** dizininde
çalışmaya başladım. Bir de taylan kullanıcısının kabuğunda tanımlı
**test** isimli global değişkeni sorgulamak için `echo $test` şeklinde
komutumuzu girelim.

``` {.scss}
┌──(root㉿linuxdersleri)-[~]
└─# echo $test 

                                                                                                                                                            
┌──(root㉿linuxdersleri)-[~]
└─#
```

Herhangi bir çıktı almadık çünkü bu değişken, başlatılan yeni kabuğa
aktarılmadı. Biz `su` komutunda sonra tire `-` işaretini girdiğimiz için
geçiş yaptığımız kullanıcının varsayılan kabuğu, standart ortam
özellikleriyle birlikte tahsis edilmiş oldu.

Bu kullanım yani `su - kullanıcı-adı` kullanımı özellikle güvenlik
gerekçesiyle sistem yöneticileri tarafından sıklıkla tercih ediliyor.
Çünkü farklı bir kullanıcı hesabına geçiş yapılmadan önce, o anda
üzerinde çalışılmakta olan mevcut kabuk üzerinde istenmeyen ortam
değişkenleri tanımlanmış olabilir. Bu gibi güvenlik riski
oluşturabilecek durumlardan kaçınmak için temiz bir kabuk başlatan
`su - kullanıcı-adı` şeklinde komut girmek çok daha makul bir yaklaşım.

Mevcut Kullanıcı Hesabını Silmek
--------------------------------

Oluşturduğumuz yeni kullanıcı hesaplarını anlatımlar sırasında
kullandığımız için nasıl silineceklerini en son ele almanın daha makul
olacağını düşündüm. Bu sebeple bu açıklamalar en sonda bulunuyor.

`userdel` Komutu
----------------

Mevcut bir kullanıcıyı silmek için `userdel` komutuna silinmesini
istediğimiz kullanıcı hesabının ismini girmemiz yeterli oluyor. Fakat bu
şekilde kullandığımızda kullanıcı hesabının ev dizini silinmediği için
ek olarak `-r` seçeneğini de eklememiz gerekiyor.

Örneğin **ali** isimli kullanıcı hesabını silmek istersem
`sudo userdel -r ali` şeklinde komutumu girebilirim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo userdel -r ali
[sudo] password for taylan:
```

Parolamızı girip onaylayalım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo userdel -r ali
[sudo] password for taylan: 
userdel: user ali is currently used by process 13099
```

Bende olduğu şekilde eğer sizin de silmek istediğiniz kullanıcının
oturumu hala aktifse ve çalışmakta olan işlemler dolayısıyla silme
işlemi başarısız olur. Bu durumda bu işlemleri sonlandırıp silme
işlemini tekrar deneyebiliriz. İleride işlemleri nasıl
sonlandırabileceğimizden bahsedeceğimiz için şimdi bunun yerine ben bu
silme işlemini zorlayarak yapmak istiyorum. Bunun için `force` yani
zorlama seçeneğini kullanabiliriz. Bu seçenek sayesinde, silmek
istediğimiz kullanıcıya ait aktif işlemler olsa bile silme işlemi
gerçekleştiriliyor.

Ben komutumu bu kez `sudo userdel -rf ali` şeklinde giriyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo userdel -rf ali
userdel: user ali is currently used by process 13099
userdel: ali mail spool (/var/mail/ali) not found
```

Kullanıcının silindiğini teyit etmek için `su ali` komutu ile geçiş
yapmayı deneyebiliriz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su ali
su: user ali does not exist or the user entry does not contain all the required fields
```

Böyle bir kullanıcının var olmadığına dair uyarı aldık. Bunun dışında
dilerseniz `ls /home` komutuyla ev dizinin silindiğini de teyit
edebilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /home
kali  nil  taylan
```

Gördüğünüz gibi **ali** için bir ev dizini artık mevcut değil.

Tabii ki biz buradaki işlemle kullanıcının ev dizinini ve kullanıcı
kaydını sildik. Eğer sistemin farklı konumlarında bu kullanıcıya ait bu
kullanıcın oluşturduğu dosya ve dizinler varsa onlar silinmedi. Eğer ne
yaptığınızdan eminseniz ve gerçekten bu kullanıcının oluşturduğu
dosyaları silmek istiyorsanız `find` aracından yararlanabilirsiniz.
Geçmişte `find` **pipe** ve `xargs` araçlarından bahsettiğimiz için
nasıl yapabileceğinizi kısa bir araştırma ile keşfedebileceğinizi
düşünüyorum. **Yine de kullanıcıların oluşturdukları dosyaları
kontrolsüzce silmek, sistemin işleyişine beklenmedik şekilde zarar
verebilir.** Bu sebeple uygulamaya geçmeden önce ne yaptığınızın
farkında olun lütfen.

Benim temel seviye kullanıcı ve grup yönetimi için söylemek istediklerim
bu kadardı. Bir sonraki bölümde disk yönetiminden bahsederek devam
edeceğiz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 20. Ders 80 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Log Kayıtları
-------------

Sistemde meydana gelen hatalar, değişiklikler ve neredeyse her faaliyet
kayıt altına alınarak saklanır. Kayıt altına alınan
bilgilere "**log**" deniyor. Kontrol etmesi kolay olabilmesi için de
elbette farklı türdeki bilgileri barındırmak için ayrı ayrı kayıtlar
yani loglar tutuluyor.

Bu sayede sistemle ilgili bir sorunu gidermeye çalışmak veya sistemde
yetkisiz oturum açma girişimlerini kontrol etmek için elimizde veriler
bulunabiliyor. Bu bölümde, log dosyalarının nerede tutulduğundan ve
hangi bilgileri nasıl alabileceğimizden çok kısaca bahsediyor olacağız.

Günümüzde modern Linux sistemlerinde log tutmak için `rsyslogd` isimli
yapı kullanılıyor. Ayrıca bu yapıya ek olarak **systemd**'nin
kapsayıcılık ilkesi dolayısıyla sunulan **systemd-journald** loglama
çözümü de mevcut. Fakat bizim bu bölümdeki asıl odak noktamız, temel
seviyede bilgi edinebilmek için standart log kayıtları olacak. Yine de
bölümün sonunda çok kısaca **journald** `journalctl`'den de
bashedeceğiz.

Log Dosyalarının Konumu
-----------------------

`rsyslogd` tarafından üretilen ve yönetilen log dosyaları, kategorize
şekilde ***/var/log/*** dizini altında tutuluyor. Ayrıca sistem
üzerindeki diğer çeşitli araçlar da genellikle kendi amaçları
doğrultusunda yine ***/var/log/*** dizini altında log kayıtlarını
barındırabiliyorlar.

Hemen `ls /var/log/` komutu ile dizin içeriğine göz atalım.

``` {.lua}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /var/log/
alternatives.log       boot.log         daemon.log.3.gz  dpkg.log.6.gz   lastlog              nginx              syslog.4.gz
alternatives.log.1     boot.log.1       daemon.log.4.gz  dpkg.log.7.gz   lightdm              openvpn            sysstat
alternatives.log.2.gz  boot.log.2       debug            dpkg.log.8.gz   macchanger.log       postgresql         user.log
alternatives.log.3.gz  boot.log.3       debug.1          faillog         macchanger.log.1.gz  private            user.log.1
alternatives.log.4.gz  boot.log.4       debug.2.gz       fontconfig.log  macchanger.log.2.gz  README             user.log.2.gz
alternatives.log.5.gz  boot.log.5       debug.3.gz       inetsim         macchanger.log.3.gz  runit              user.log.3.gz
apache2                boot.log.6       debug.4.gz       installer       macchanger.log.4.gz  samba              user.log.4.gz
apt                    boot.log.7       dpkg.log         journal         messages             speech-dispatcher  wtmp
auth.log               btmp             dpkg.log.1       kern.log        messages.1           stunnel4           Xorg.0.log
auth.log.1             btmp.1           dpkg.log.2.gz    kern.log.1      messages.2.gz        syslog             Xorg.0.log.old
auth.log.2.gz          daemon.log       dpkg.log.3.gz    kern.log.2.gz   messages.3.gz        syslog.1           Xorg.1.log
auth.log.3.gz          daemon.log.1     dpkg.log.4.gz    kern.log.3.gz   messages.4.gz        syslog.2.gz        Xorg.1.log.old
auth.log.4.gz          daemon.log.2.gz  dpkg.log.5.gz    kern.log.4.gz   mysql                syslog.3.gz
```

Kullanmakta olduğunuz sistemde mevcut bulunan araçlar ve bu araçların
ürettiği log kayıtlarına göre sizin aldığınız çıktı benimkinden biraz
farklı olabilir. Biz bu bölümde `rsyslogd` aracılığı ile sistem
tarafından üretilen başlıca kayıtlara odaklanacağız.

Kayıtlar, standart dosya biçiminde tutulduğu için `cat` `grep` `head`
`tail` gibi araçlar yardımıyla tüm kayıtları okuyup filtreleyebiliyoruz.
Önceki bölümlerde, metinsel verileri nasıl işleyeceğimizi ele aldığımız
için zaten ihtiyaç duyduğunuz tüm araçların kullanım bilgisine şu an
sahipsiniz. Tek ihtiyacınız kayıtları okumak için yönetici
ayrıcalıklarına sahip olmak. Zira standart kullanıcıların tüm logları
okuması güvenlik gereği mümkün değildir.

Ayrıca kayıt dosyaları, Redhat ve Debian tabanlı dağıtımlarda farklı
isimlerde tutulabildiği için ben başlıklara her ikisini de eklemiş
olacağım. Başlıklardaki dosya isim sıralaması da **Debian - Redhat**
şeklinde olacak.

syslog \| messages
------------------

Uygulamalar, hizmetler ve sistem bileşenlerinin ürettiği bilgi ve hata
mesajları ***/var/log/*** dizini altında ***syslog*** veya
***messages*** dosyalarında tutuluyor. Debian tabanlı dağıtımlar
"**syslog**" ismi ile kayıt tutuyorken, Redhat tabanlı dağıtımlarda
"**messages**" ismiyle aynı kayıtlar tutuluyor.

Ben Debian dağıtımı üzerinden çalıştığım için en son 5 kayıt satırını
okumak için `tail -n 5 /var/log/syslog` komutunu giriyorum. Siz Redhat
üzerinde ***messages*** dosyasını okuyabilirsiniz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail -n 5 /var/log/syslog
Jul 27 12:49:12 linuxdersleri systemd[1]: run-user-130.mount: Deactivated successfully.
Jul 27 12:49:12 linuxdersleri systemd[1]: user-runtime-dir@130.service: Deactivated successfully.
Jul 27 12:49:12 linuxdersleri systemd[1]: Stopped User Runtime Directory /run/user/130.
Jul 27 12:49:12 linuxdersleri systemd[1]: Removed slice User Slice of UID 130.
Jul 27 12:49:12 linuxdersleri systemd[1]: user-130.slice: Consumed 1.983s CPU time.
```

Örneğin NetworkManager hakkında sorun yaşamaya başladıysam,
NetworkManager tarafından veya bu birim hakkında üretilmiş olan son 10
mesaj kaydını görmek için
`grep -i “networkmanager” /var/log/syslog | tail` komutunu girebilirim.

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~]
└─$ grep -i  networkmanager /var/log/syslog | tail                                                                                    
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.4240] policy: set 'Wired connection 1' (eth0) as default for IPv4 routing and DNS
Jul 27 07:14:35 linuxdersleri dbus-daemon[527]: [system] Activating via systemd: service name='org.freedesktop.resolve1' unit='dbus-org.freedesktop.resolve1.service' requested by ':1.4' (uid=0 pid=528 comm="/usr/sbin/NetworkManager --no-daemon ")
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6018] device (eth0): state change: ip-check -> secondaries (reason 'none', sys-iface-state: 'managed')
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6019] device (eth0): state change: secondaries -> activated (reason 'none', sys-iface-state: 'managed')
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6022] manager: NetworkManager state is now CONNECTED_SITE
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6023] device (eth0): Activation: successful, device activated.
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6028] manager: NetworkManager state is now CONNECTED_GLOBAL
Jul 27 07:14:35 linuxdersleri NetworkManager[528]: <info>  [1690456475.6031] manager: startup complete
Jul 27 07:14:45 linuxdersleri systemd[1]: NetworkManager-dispatcher.service: Deactivated successfully.
Jul 27 07:56:36 linuxdersleri NetworkManager[528]: <info>  [1690458996.1981] agent-manager: agent[47b5561f98f13db4,:1.46/org.freedesktop.nm-applet/1000]: agent registered
```

Tarih bilgisine ve olay bilgisine bakarak, varsa bir değişim ya da hata
kaynağını fark etmem mümkün olabilir. Benzer şekilde servisler,
uygulamalar, çekirdek ve sistem geneli için bu dosya içeriğini kontrol
etmemiz mümkün.

En son kayıtlara ulaşmak için ***syslog*** dosyasını okudum. Fakat tüm
kayıtlar yalnızca bu dosyadan ibaret değil elbette. Geçmişten günümüzde
tüm kayıtlar sıralı şekilde numaralandırılıp arşivleniyor. Bu durumu
teyit etmek için `ls -l /var/log/syslog*` komutunu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls -l /var/log/syslog*
-rw-r----- 1 root adm 717817 Jul 27 12:49 /var/log/syslog
-rw-r----- 1 root adm 500455 Jul 24 09:04 /var/log/syslog.1
-rw-r----- 1 root adm 295719 Jul 16 06:56 /var/log/syslog.2.gz
-rw-r----- 1 root adm 437888 Jul  9 05:05 /var/log/syslog.3.gz
-rw-r----- 1 root adm 428440 Jul  2 09:15 /var/log/syslog.4.gz
```

Gördüğünüz gibi sırasıyla isimlendirilmiş ***syslog.1***
***syslog2.gz*** ... şeklinde kayıtlar mevcut. Eğer daha önceki
tarihlerde yer alan bir kayda bakmanız gerekiyorsa en yeniden eskiye
doğru kayıtları inceleyebilirsiniz. Bu yaklaşım sayesinde kayıtların
sistem üzerindeki dağınıklığı ve fazladan alan kullanımı önlenmiş
oluyor.

auth.log \| secure
------------------

Oturum açma ve kimlik doğrulama hakkında tutulan kayıtlardır. Örneğin
Debian tabanlı dağıtımda en sonra oturum açma kayıtlarını görmek için
`tail /var/log/auth.log` komutunu girebiliriz.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail /var/log/auth.log                                                                                                            
Jul 27 13:35:01 linuxdersleri CRON[68832]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:35:01 linuxdersleri CRON[68832]: pam_unix(cron:session): session closed for user root
Jul 27 13:36:42 linuxdersleri lightdm: gkr-pam: unable to locate daemon control file
Jul 27 13:36:42 linuxdersleri lightdm: gkr-pam: stashed password to try later in open session
Jul 27 13:36:42 linuxdersleri lightdm: pam_unix(lightdm-greeter:session): session closed for user lightdm
Jul 27 13:36:42 linuxdersleri systemd-logind[532]: Removed session c7.
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session closed for user root
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session closed for user root
```

Buradaki çıktılar oturum açma ve kimlik doğrulama hakkında sunulan
bilgilerdir. Değişimi gözlemlemek için `sudo echo deneme` komutunu
girip, parolamız ile onay verip daha sonra log kayıtlarını kontrol
edebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo echo deneme                                                                                                                  
[sudo] password for taylan: 
deneme

┌──(taylan㉿linuxdersleri)-[~]
└─$ tail /var/log/auth.log                                                                                                            
Jul 27 13:36:42 linuxdersleri lightdm: gkr-pam: stashed password to try later in open session
Jul 27 13:36:42 linuxdersleri lightdm: pam_unix(lightdm-greeter:session): session closed for user lightdm
Jul 27 13:36:42 linuxdersleri systemd-logind[532]: Removed session c7.
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session closed for user root
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session closed for user root
Jul 27 13:48:16 linuxdersleri sudo:   taylan : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/echo deneme
Jul 27 13:48:16 linuxdersleri sudo: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)
Jul 27 13:48:16 linuxdersleri sudo: pam_unix(sudo:session): session closed for user root
```

Bakın **taylan** kullanıcısının **pts/0** konsolunda, ***/home/taylan***
dizinindeyken **root** kullanıcısı olarak `/usr/bin/echo deneme`
komutunu çalıştırmak istediği buradaki çıktılarda açıkça görülebiliyor.

Parola doğru girildiği için **sudo** üzerinden **root** yetkileri
kazanılmış ve root erişimi açılmış. İşlem tamamlandıktan sonra da root
erişimi sonlandırılmış.

Yani bizzat teyit ettiğimiz gibi, yetkilendirme işlemlerini takip etmek
için log kayıtlarını kolaylıkla kontrol edebiliyoruz.

Benzer şekilde farklı bir kullanıcı hesabında oturum açıp değişimi
gözlemleyebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ su nil
Password: 
┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ tail /var/log/auth.log
tail: cannot open '/var/log/auth.log' for reading: Permission denied

┌──(nil㉿linuxdersleri)-[/home/taylan]
└─$ sudo tail /var/log/auth.log                                                                                                   
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:39:01 linuxdersleri CRON[69797]: pam_unix(cron:session): session closed for user root
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Jul 27 13:45:01 linuxdersleri CRON[71281]: pam_unix(cron:session): session closed for user root
Jul 27 13:48:16 linuxdersleri sudo:   taylan : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/echo deneme
Jul 27 13:48:16 linuxdersleri sudo: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)
Jul 27 13:48:16 linuxdersleri sudo: pam_unix(sudo:session): session closed for user root
Jul 27 13:50:04 linuxdersleri su: (to nil) taylan on pts/0
Jul 27 13:50:04 linuxdersleri su: pam_unix(su:session): session opened for user nil(uid=1001) by (uid=1000)
Jul 27 13:54:01 linuxdersleri sudo:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/tail /var/log/auth.log
```

Gördüğünüz gibi **taylan** kullanıcısının `su` ile **nil** kullanıcı
hesabında oturum açtığını ve daha sonra yetkili şekilde log kayıtlarını
incelediğini buradaki kayıtlardan işlem tarihiyle birlikte kontrol
edebiliyoruz. **nil** kullanıcısını daha önce sistem yöneticisi grubuna
eklediğim için `sudo` üzerinden log kayıtlarını okuyabildi. Fakat
standart kullanıcılar bu kayıtları okuyamazlar.

**Özetle**; Debian üzerinde "***auth.log***", Redhat üzerinde ise
"***secure***" dosyaları üzerinden, oturum açma, kimlik doğrulama gibi
işlemlerin kayıtlarını öğrenebiliyoruz. Örneğin bir kullanıcı `sudo` ile
bir komut çalıştırmayı dener ama başarısız olursa yani parolayı yanlış
girer veya yetkisi olmadığı halde işlemi yapmaya çalışırsa bu durum da
kayıt ediliyor. Ben denemek için taylan kullanıcısı üzerinden `sudo`
komutundan sonra sorulan parolayı bilerek 3 kez yanlış giriyorum.

``` {.bash}
──(taylan㉿linuxdersleri)-[~]
└─$ sudo echo deneme
[sudo] password for taylan: 
Sorry, try again.
[sudo] password for taylan: 
Sorry, try again.
[sudo] password for taylan: 
sudo: 3 incorrect password attempts

┌──(taylan㉿linuxdersleri)-[~]
└─$ tail -3 /var/log/auth.log
Jul 27 14:00:30 linuxdersleri sudo: pam_unix(sudo:session): session closed for user root
Jul 27 14:00:55 linuxdersleri sudo: pam_unix(sudo:auth): authentication failure; logname= uid=1000 euid=0 tty=/dev/pts/0 ruser=taylan rhost=  user=taylan
Jul 27 14:01:06 linuxdersleri sudo:   taylan : 3 incorrect password attempts ; TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/echo deneme
```

Çıktıları dikkatlice inceleyecek olursanız, taylan kullanıcısının 3 kez
hatalı parola denemesi yaptığı burada açıkça yazıyor. Bu kayıtlara
bakarak olası şüpheli durumlar ve davranışları anlamlandırmaya
çalışabilirsiniz.

boot.log
--------

Sistem başlangıcında gerçekleştirilen "önyükleme" yani "boot" aşamasının
kayıtlarına ulaşmak için ***/var/log/boot.log*** dosyasını kontrol
edebilirsiniz. Boot işlemi çok hızlı gerçekleştiği için, sistem
başlangıcında tüm kayıtları gözümüzle takip etmemiz imkansız. Bu sebeple
gerektiğinde sistem başlangıcına dair kayıtlara göz atmak için
***/var/log/boot*** dosyalarına bakıyoruz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo cat /var/log/boot.log                                                                                                       
[  OK  ] Finished Rotate log files.
[  OK  ] Finished Raise network interfaces.
[  OK  ] Started User Login Management.
[  OK  ] Started Virtualbox guest utils.
[  OK  ] Started Authorization Manager.
         Starting Modem Manager...
[  OK  ] Started Network Manager.
[  OK  ] Reached target Network.
         Starting The Apache HTTP Server...
         Starting Permit User Sessions...
[  OK  ] Finished Permit User Sessions.
         Starting Light Display Manager...
         Starting Hold until boot process finishes up...
         Starting Hostname Service...
[  OK  ] Started Hostname Service.
[  OK  ] Listening on Load/Save RF Kill Switch Status /dev/rfkill Watch.
```

Dosyadaki kayıtlar belirli bir doluluk oranına ulaştığı için son
önyüklemenin tamamını bu son ***boot.log*** dosyasında göremedim. Eğer
geri kalanına bakmak istersem önceki kayıt olan ***boot.log.1***
dosyasına gözatabilirim.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo cat /var/log/boot.log.1 
[  OK  ] Finished Rotate log files.
[  OK  ] Started User Login Management.
[  OK  ] Started Virtualbox guest utils.
[  OK  ] Finished Raise network interfaces.
[  OK  ] Started Authorization Manager.
         Starting Modem Manager...
[  OK  ] Started Network Manager.
[  OK  ] Reached target Network.
         Starting The Apache HTTP Server...
         Starting Permit User Sessions...
[  OK  ] Finished Permit User Sessions.
         Starting Light Display Manager...
         Starting Hold until boot process finishes up...
         Starting Hostname Service...
[  OK  ] Started Hostname Service.
------------ Thu Jul 27 07:14:17 EDT 2023 ------------
/dev/sda1: recovering journal
/dev/sda1: Clearing orphaned inode 4457265 (uid=1000, gid=1000, mode=0100600, size=1574)
/dev/sda1: Clearing orphaned inode 4457264 (uid=1000, gid=1000, mode=0100600, size=1897296)
/dev/sda1: Clearing orphaned inode 4457261 (uid=1000, gid=1000, mode=0100600, size=6296)
/dev/sda1: Clearing orphaned inode 4456488 (uid=0, gid=0, mode=0100666, size=0)
/dev/sda1: clean, 338151/5185536 files, 3546889/20721152 blocks
[  OK  ] Finished Tell Plymouth To Write Out Runtime Data.
[  OK  ] Started Rule-based Manager for Device Events and Files.
         Starting Show Plymouth Boot Screen...
[  OK  ] Started Show Plymouth Boot Screen.
[  OK  ] Started Forward Password Requests to Plymouth Directory Watch.
[  OK  ] Reached target Local Encrypted Volumes.
[  OK  ] Reached target Path Units.
[  OK  ] Reached target Sound Card.
[  OK  ] Found device VBOX_HARDDISK 5.
         Activating swap /dev/disk/by-uuid/00253fba-ff78-4f04-b189-fbc974082345...
[  OK  ] Activated swap /dev/disk/by-uuid/00253fba-ff78-4f04-b189-fbc974082345.
[  OK  ] Reached target Swaps.
[  OK  ] Finished Flush Journal to Persistent Storage.
         Starting Create Volatile Files and Directories...
[  OK  ] Finished Create Volatile Files and Directories.
[  OK  ] Started Entropy Daemon based on the HAVEGE algorithm.
         Starting Record System Boot/Shutdown in UTMP...
[  OK  ] Finished Record System Boot/Shutdown in UTMP.
[  OK  ] Reached target System Initialization.
[  OK  ] Started Daily dpkg database backup timer.
[  OK  ] Started Periodic ext4 Online Metadata Check for All Filesystems.
[  OK  ] Started Discard unused blocks once a week.
[  OK  ] Started Daily rotation of log files.
[  OK  ] Started Daily man-db regeneration.
[  OK  ] Started Clean PHP session files every 30 mins.
[  OK  ] Started Update the plocate database daily.
[  OK  ] Started Daily Cleanup of Temporary Directories.
[  OK  ] Started zaman.service için zamanlanmış görev tanımı.
[  OK  ] Reached target Timer Units.
[  OK  ] Listening on D-Bus System Message Bus Socket.
[  OK  ] Reached target Socket Units.
[  OK  ] Reached target Basic System.
[  OK  ] Started Regular background program processing daemon.
[  OK  ] Started D-Bus System Message Bus.
         Starting Network Manager...
         Starting Remove Stale Online ext4 Metadata Check Snapshots...
         Starting Authorization Manager...
         Starting System Logging Service...
         Starting User Login Management...
         Starting Virtualbox guest utils...
[  OK  ] Started zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır..
         Starting Clean php session files...
         Starting Rotate log files...
         Starting Daily man-db regeneration...
[  OK  ] Finished Remove Stale Online ext4 Metadata Check Snapshots.
[  OK  ] Started System Logging Service.
```

Gördüğünüz gibi kayıtlar sırasında önyükleme tarihi tam olarak satır
arasında belirtiliyor. Bu sayede, ilgili tarihteki önyükleme aşamasında
üretilen çıktıları kontrol edebiliyoruz.

kern.log
--------

Çekirdek yani "**kernel**" kayıtlarını incelemek için
***/var/log/kern.log*** dosyasını inceleyebiliriz.

Üretilen hata çıktılarını görmek için "**error**" tanımıyla filtreleme
yapmak istiyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ grep -i "error" /var/log/kern.log                                                                                                
Jul 24 15:11:11 linuxdersleri kernel: [22035.572938] A fatal guest X Window error occurred.  This may just mean that the Window system was shut down while the client was still runn
Jul 24 15:11:11 linuxdersleri kernel: [22035.575718] A fatal guest X Window error occurred.  This may just mean that the Window system was shut down while the client was still runn
Jul 24 15:11:11 linuxdersleri kernel: [22035.579149] A fatal guest X Window error occurred.  This may just mean that the Window system was shut down while the client was still runn
Jul 24 15:11:11 linuxdersleri kernel: [22035.582138] A fatal guest X Window error occurred.  This may just mean that the Window system was shut down while the client was still runn
Jul 24 15:11:11 linuxdersleri kernel: [22035.593373] Error waiting for HGCM thread to terminate: VERR_CANCELLED
Jul 24 15:11:11 linuxdersleri kernel: [22035.692454] pulseaudio[829]: segfault at 55b9150c179f ip 00007fda70630b47 sp 00007fffc3f2b7e0 error 4 in libICE.so.6.3.0[7fda7062b000+e000]
Jul 24 15:11:11 linuxdersleri kernel: [22035.820171] Error waiting for X11 thread to terminate: VERR_TIMEOUT
Jul 24 13:46:34 linuxdersleri kernel: [    3.979912] [drm:vmw_host_printf [vmwgfx]] *ERROR* Failed to send host log message.
Jul 24 13:46:34 linuxdersleri kernel: [   11.738757] EXT4-fs (sdb1): re-mounted. Opts: errors=remount-ro. Quota mode: none.
Jul 26 10:01:56 linuxdersleri kernel: [    4.765035] [drm:vmw_host_printf [vmwgfx]] *ERROR* Failed to send host log message.
Jul 26 10:01:56 linuxdersleri kernel: [   14.378637] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro. Quota mode: none.
Jul 27 07:14:26 linuxdersleri kernel: [    4.788743] [drm:vmw_host_printf [vmwgfx]] *ERROR* Failed to send host log message.
Jul 27 07:14:26 linuxdersleri kernel: [   15.806339] EXT4-fs (sda1): re-mounted. Opts: errors=remount-ro. Quota mode: none.
```

Eşleşen tüm çıktılar getirildi. Bunlar çekirdeğin ürettiği mesajlar.
Gerektiğinde, çekirdeğin verdiği reaksiyonları kontrol etmek için bu
dosyayı inceleyebiliyoruz.

apt
---

Debian tabanlı bir dağıtımda `apt` aracının kullanımı hakkındaki
kayıtlara ulaşmak için ***/var/log/apt/*** dizinini kontrol
edebiliyoruz. Örneğin dizin altında, `apt` aracının kullanım geçmişi
hakkındaki kayıtlar ***history*** isimli dosyada tutuluyor.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail /var/log/apt/history.log                                           
Install: libidn2-dev:amd64 (2.3.3-1+b1, automatic), libgnutls28-dev:amd64 (3.7.9-2), libtasn1-doc:amd64 (4.19.0-2, automatic), libp11-kit-dev:amd64 (0.24.1-2, automatic), libtasn1-6-dev:amd64 (4.19.0-2, automatic), nettle-dev:amd64 (3.8.1-2, automatic), libgnutls-openssl27:amd64 (3.7.9-2, automatic), libgnutlsxx30:amd64 (3.7.9-2, automatic)
Upgrade: libnettle8:amd64 (3.7.3-1, 3.8.1-2), libidn2-0:amd64 (2.3.2-2, 2.3.3-1+b1), libtasn1-6:amd64 (4.18.0-4, 4.19.0-2), libp11-kit0:amd64 (0.24.0-6, 0.24.1-2), p11-kit-modules:amd64 (0.24.0-6, 0.24.1-2), libhogweed6:amd64 (3.7.3-1, 3.8.1-2)
End-Date: 2023-07-05  09:47:58

Start-Date: 2023-07-10  11:42:01
Commandline: apt install lvm2
Requested-By: taylan (1000)
Install: dmeventd:amd64 (2:1.02.185-2, automatic), liblvm2cmd2.03:amd64 (2.03.16-2, automatic), lvm2:amd64 (2.03.16-2), libdevmapper-event1.02.1:amd64 (2:1.02.185-2, automatic), thin-provisioning-tools:amd64 (0.9.0-2, automatic)
Upgrade: dmsetup:amd64 (2:1.02.175-2.1, 2:1.02.185-2), libdevmapper1.02.1:amd64 (2:1.02.175-2.1, 2:1.02.185-2)
End-Date: 2023-07-10  11:43:29
```

Gördüğünüz gibi `apt` aracı ile gerçekleştirilen son yükleme işlemi
hakkında bilgi almış olduk. Yani bu kayıt sayesinde, kullanıcıların
paket yükleme davranışlarını takip etmemiz mümkün oluyor.

dpkg
----

`dpkg` paket yöneticisi kullanılarak gerçekleştirilmiş olan tüm işlemler
hakkında bilgi almak için ***/var/log/dpkg*** dosyasını
inceleyebiliyoruz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ tail /var/log/dpkg.log                                                  
2023-07-10 11:42:15 status installed kali-menu:all 2021.4.2
2023-07-10 11:42:15 trigproc initramfs-tools:all 0.140 <none>
2023-07-10 11:42:15 status half-configured initramfs-tools:all 0.140
2023-07-10 11:43:12 status installed initramfs-tools:all 0.140
2023-07-10 11:43:12 trigproc libc-bin:amd64 2.36-9 <none>
2023-07-10 11:43:12 status half-configured libc-bin:amd64 2.36-9
2023-07-10 11:43:26 status installed libc-bin:amd64 2.36-9
2023-07-10 11:43:26 trigproc man-db:amd64 2.9.4-4 <none>
2023-07-10 11:43:26 status half-configured man-db:amd64 2.9.4-4
2023-07-10 11:43:29 status installed man-db:amd64 2.9.4-4
```

Tarih bilgisiyle birlikte, sırasıyla `dpkg` aracı kullanılarak
gerçekleştirilen işlemler burada açıkça belirtiliyor.

dnf
---

Red Hat tabanlı dağıtımlarda gördüğümüz `dnf` paket yöneticisinin
kullanımı hakkında tutulmuş olan kayıtlara ***/var/log/dnf*** konumundan
ulaşabiliyoruz. Ben Rocky Linux üzerindeki kayıtlarımı kontrol ediyorum.

``` {.yaml}
[taylan@linuxdersleri ~]$ tail /var/log/dnf.log

2023 - 07 -06T18:55:31+0300 DEBUG countme: no event for appstream: window already counted

2023 - 07 -06T18:55:42+0300 DEBUG reviving: ‘appstream' can be revived - repomd matches.

2023 -07-06T18:55:42+0300 DEBUG appstream: using metadata from Mon 63 Jul 2023 11:12:60 PM +03.
2023 - 07 -06T18:55:42+0300 DEBUG countme: no event for extras: window already counted

2023 - 07 -06T18:55:52+0300 DEBUG reviving: ‘extras' can be revived - repomd matches.

2023 -07-06T18:55:52+0300 DEBUG extras: using metadata from Mon 05 Jun 2023 09:56:04 PM +03.
2023 - 07 -06T18:55:52+0300 DEBUG User-Agent: constructed: ‘libdnf (Rocky Linux 9.1; generic; Linux.x
86 64) '

2023 - 07 -06T18:55:52+0300 DDEBUG timer: sack setup: 37973 ms

2023 -07-06T18:55:52+0300 INFO Metadata cache created.

2023-07 -06T18:55:52+0300 DDEBUG Cleaning up.
```

Bu dosyada "hata", "bilgi" ve "yükleme" gibi, `dnf` ile ilişkili olan
tüm kayıtlar tutuluyor. Bu sayede aracın kullanım geçmişini sorgulamamız
da mümkün oluyor.

wtmp
----

Kullanıcıların sisteme ne zaman giriş, ne zaman çıkış yaptığını ve hangi
terminalleri(oturumları) kullandığı ***/var/log/wtmp*** dosyasında
tutuluyor. Fakat bu kayıtlar düz metin olarak değil, binary biçiminde
tutulduğu için `cat` `grep` `tail` gibi düz metinleri işlediğimiz
araçları kullanarak bu kayıtları okuyamıyoruz. Hemen deneyelim. Ben
`cat /var/log/wtmp` komutu ile okumayı deniyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /var/log/wtmp 
~~~reboot5.15.0-kali3-amd64^�bh�5~~~runlevel5.15.0-kali3-amd64f�bk�
                                                                   tty1tty1
                                                                           f�b=U
                                                                                tty1tty1LOGIN
                                                                                             f�b=U�tty7:0kali:0��b�
```

Bakın dosya içeriği okunamaz halde. Bu dosyayı okumak için `last`
aracını kullanmamız gerekiyor.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ last                                                                                                                                                    
taylan   tty7         :0               Sat Aug 19 01:05   still logged in
reboot   system boot  5.15.0-kali3-amd Sat Aug 19 01:01   still running
taylan   tty7         :0               Fri Aug 18 13:31 - crash  (11:30)
..
.
reboot   system boot  5.15.0-kali3-amd Mon Apr 11 01:23 - 05:24 (69+04:00)
kali     tty7         :0               Wed Apr  6 05:42 - crash (4+19:41)
reboot   system boot  5.15.0-kali3-amd Wed Apr  6 05:41 - 05:24 (73+23:42)
kali     tty7         :0               Wed Apr  6 03:00 - crash  (02:41)
reboot   system boot  5.15.0-kali3-amd Wed Apr  6 02:55 - 05:24 (74+02:29)
kali     tty7         :0               Tue Apr  5 02:48 - crash (1+00:06)
kali     tty7         :0               Tue Apr  5 02:44 - 02:48  (00:04)
reboot   system boot  5.15.0-kali3-amd Tue Apr  5 02:43 - 05:24 (75+02:40)
kali     tty7         :0               Fri Feb 11 19:21 - 19:22  (00:00)
reboot   system boot  5.15.0-kali3-amd Fri Feb 11 19:21 - 19:22  (00:01)
kali     tty7         :0               Fri Feb 11 18:41 - crash  (00:39)
reboot   system boot  5.15.0-kali3-amd Fri Feb 11 18:41 - 19:22  (00:41)
kali     tty7         :0               Fri Feb 11 18:25 - 18:29  (00:03)
reboot   system boot  5.15.0-kali3-amd Fri Feb 11 18:25 - 18:29  (00:04)

wtmp begins Fri Feb 11 18:25:18 2022
```

Gördüğünüz gibi geçmişten günümüze tüm oturum açma detaylarını
***wtmp*** dosyasından, `last` komutu sayesinde çekmiş olduk.

btmp
----

Hatalı oturum açma girişimlerinin kaydedildiği dosyadır. Bu dosyayı
okumak için yetkili olmak gerekiyor Ayrıca bu dosya da düz metin olarak
kayıt tutmuyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo cat /var/log/btmp
�tty6tty6UNKNOWN��d e~�
```

Dosya içeriğini görüntülemek için `lastb` komutunu kullanıyoruz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lastb
UNKNOWN  tty6                          Fri Oct  6 15:50 - 15:50  (00:00)
ali      pts/2                         Wed Oct  4 17:47 - 17:47  (00:00)

btmp begins Wed Oct  4 17:47:24 2023
```

Buradaki "**b**" ifadesi "**bad**" ifadesinden geliyor. **B**ad login
attemps yani "hatalı giriş" denemelerini ifade eden bir kısaltma.

Normalde biz ek bir argüman belirtmediğimizde `last` komutu
***/var/log/wtmp*** dosyasını okurken, `lastb` ise ***/var/log/btmp***
dosyasını okuyor. Eğer `last` ve `lastb` komutları ile en son oturum
bilgilerini görmek yerine daha önceki kayıtlara da ulaşmak isterseniz
`-f` seçeneği ile daha önceki kayıtların konumunu argüman olarak
belirtmeniz yeterli.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lastb
[sudo] password for taylan: 
UNKNOWN  tty6                          Fri Oct  6 15:50 - 15:50  (00:00)
ali      pts/2                         Wed Oct  4 17:47 - 17:47  (00:00)

btmp begins Wed Oct  4 17:47:24 2023

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo lastb -f /var/log/btmp.1
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:50 - 13:50  (00:00)
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:50 - 13:50  (00:00)
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:49 - 13:49  (00:00)
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:49 - 13:49  (00:00)
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:23 - 13:23  (00:00)
pc       ssh:notty    192.168.1.13     Sun Sep 17 13:23 - 13:23  (00:00)

btmp.1 begins Sun Sep 17 13:23:09 2023

┌──(taylan㉿linuxdersleri)-[~]
└─$
```

Bakın ben bu örnekte, önceki kayıtları görmek için ***/var/log/btmp.1***
dosyasını argüman olarak belirtip `lastb` aracı ile okumuş oldum. Ayrıca
`last` ve `lastb` aracının diğer seçeneklerini görmek için yardım
sayfasına göz atmanız yeterli.

cron
----

Eğer **cron-crontab** ile zamanlanmış görevler tanımlıysa, bu görevlerin
çalışma kayıtlarına ***/var/log/cron*** dosyası üzerinden
ulaşabiliyoruz. Benim kullandığım Debian dağıtımında log kayıtlarını
tutan rsyslog aracının konfigürasyon dosyasında cron için kayıt tutma
devedışı olduğu için ***/var/log/*** dizini altında `cron` için bir
kayıt bulunmuyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /var/log/cron                                                                                                                  
cat: /var/log/cron: No such file or directory
```

Eğer rsyslog aracının cron için kayıt tutmasını istersem
***/etc/rsyslog.conf*** dosyasında cron kaydı için gerekli olan kayıt
satırını ekleyebilirim. Ben `sudo nano /etc/rsyslog.conf` dosyasını
açıp, log kaydı için gereken satıra `cron.* /var/log/cron.log` ifadesini
ekleyip dosyayı kaydediyorum.

``` {.swift}
#
# First some standard log files.  Log by facility.
#
auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          -/var/log/mail.log
user.*                          -/var/log/user.log
```

Değişikliklerin geçerli olabilmesi için
`sudo systemctl restart rsyslog.service` komutu ile **rsyslog**
servisini yeninden başlatalım.

Test etmek için yeni bir **crontab** görevi tanımlayabiliriz. Bunun için
`crontab -e` komutunun ardından açılan konfigürasyon dosyasında,
istdiğimiz görevi istediğimiz sıklıkta çalışacak şekilde tanımlayalım.

Örnek olarak, her dakika `echo "bu bir zamanlanmıs gorev"` komutunu
çalıştıracak çok basit bir görev tanımlıyorum.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ crontab -e
# Edit this file to introduce tasks to be run by cron.
# 
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
# 
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
# 
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
# 
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
# 
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# 
# For more information see the manual pages of crontab(5) and cron(8)
# 
# m h  dom mon dow   command
* * * * * taylan echo "bu bir zamanlanmıs gorev"
```

Her dakika çalışacak bir cron servisi tanımladığım için 1 dakika kadar
bekliyorum. Tanımladığım cron işlemini görmek için `crontab -l` komutunu
girebiliriz.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ crontab -l
# Edit this file to introduce tasks to be run by cron.
# 
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
# 
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
# 
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
# 
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
# 
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# 
# For more information see the manual pages of crontab(5) and cron(8)
# 
# m h  dom mon dow   command
* * * * * taylan echo "bu bir zamanlanmıs gorev"
```

Süre geçti şimdi `cat /var/log/cron.log` komutu ile tekrar okumayı
deneyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /var/log/cron.log                                                                                                                                   
Aug 19 06:02:01 linuxdersleri CRON[33418]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:02:01 linuxdersleri CRON[33419]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:02:01 linuxdersleri CRON[33416]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:02:01 linuxdersleri CRON[33417]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:03:01 linuxdersleri CRON[33665]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:03:01 linuxdersleri CRON[33666]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:03:01 linuxdersleri CRON[33663]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:03:01 linuxdersleri CRON[33664]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:04:01 linuxdersleri CRON[33932]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:04:01 linuxdersleri CRON[33933]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:04:01 linuxdersleri CRON[33931]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:04:01 linuxdersleri CRON[33930]: (CRON) info (No MTA installed, discarding output)
```

Gördüğünüz gibi artık rsyslog servisi cron için de log kaydı tutmaya
başlamış oldu. Esasen rsyslog servisinin konfigürasyonu için pek çok
detay mevcut. Örneğin birden fazla sunucunun log kayıtlarını tek bir log
sunucusunda toplamak üzere konfigüre edilmesi mümkün. Ben detaylara bu
eğitimde değinmeyeceğim ancak kısa bir araştırma ile ek konfigürasyon
detaylarına ulaşabilirsiniz.

**ℹ️ Not:** Tanımladığınız cron görevi, `crontab -e` komutu ile
konfigürasyon dosyasını açıp bu görevi silmediğiniz sürece devam
edecektir. Eğer istemiyorsanız eklediğiniz konfigürasyon satırını silip
dosyayı kaydetmeniz yeterli.

`dmesg` \| Aygıt Kayıtları
--------------------------

Sistem başlangıcından itibaren çekirdeğin, aygıtlarla ilgili ürettiği
log kayıtlarına göz atmak için `dmesg` aracını kullanabiliyoruz.

Ben örnek olarak "**Intel**" aygıtlarını listelemek istiyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo dmesg | grep -i "Intel"                                                                                              
[    0.841976] smpboot: CPU0: Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz (family: 0x6, model: 0x5e, stepping: 0x3)
[    1.508334] intel_pstate: CPU model not supported
[    4.617000] e1000: Intel(R) PRO/1000 Network Driver
[    4.617002] e1000: Copyright (c) 1999-2006 Intel Corporation.
[    5.447805] e1000 0000:00:03.0 eth0: Intel(R) PRO/1000 Network Connection
[   22.138338] intel_pmc_core intel_pmc_core.0:  initialized
[   22.890967] snd_intel8x0 0000:00:05.0: allow list rate for 1028:0177 is 48000
```

Bu çıktılar sisteme hangi aygıtların bağlı olduğundan ziyade, bu
aygıtların davranış kayıtlarıdır. Yani bu aygıtlar üzerinden gerçekleşen
olayların kayıtlarıdır.

Örneğin ben sisteme yeni bir USB flash disk bağladıktan sonra tekrar
`dmesg` komutu çalıştırıyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo dmesg
..
..
[  572.176951] No guest source window
[ 1862.053939] usb 1-2: new full-speed USB device number 3 using ohci-pci
[ 1862.537550] usb 1-2: config 1 interface 0 altsetting 0 endpoint 0x81 has invalid maxpacket 512, setting to 64
[ 1862.537555] usb 1-2: config 1 interface 0 altsetting 0 endpoint 0x2 has invalid maxpacket 512, setting to 64
[ 1862.561003] usb 1-2: New USB device found, idVendor=090c, idProduct=1000, bcdDevice=11.00
[ 1862.561007] usb 1-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[ 1862.561009] usb 1-2: Product: USB DISK
[ 1862.561010] usb 1-2: Manufacturer: SMI Corporation
[ 1862.561011] usb 1-2: SerialNumber: AA00000000004572
[ 1862.670071] usb-storage 1-2:1.0: USB Mass Storage device detected
[ 1862.670878] usb-storage 1-2:1.0: Quirks match for vid 090c pid 1000: 400
[ 1862.671640] scsi host6: usb-storage 1-2:1.0
[ 1862.676014] usbcore: registered new interface driver usb-storage
[ 1862.699317] usbcore: registered new interface driver uas
[ 1864.213095] scsi 6:0:0:0: Direct-Access     SMI      USB DISK         1100 PQ: 0 ANSI: 4
[ 1864.214550] sd 6:0:0:0: Attached scsi generic sg5 type 0
[ 1864.236335] sd 6:0:0:0: [sde] 31653888 512-byte logical blocks: (16.2 GB/15.1 GiB)
[ 1864.248774] sd 6:0:0:0: [sde] Write Protect is off
[ 1864.248779] sd 6:0:0:0: [sde] Mode Sense: 43 00 00 00
[ 1864.267388] sd 6:0:0:0: [sde] No Caching mode page found
[ 1864.267394] sd 6:0:0:0: [sde] Assuming drive cache: write through
[ 1864.364485]  sde: sde1
[ 1864.441900] sd 6:0:0:0: [sde] Attached SCSI removable disk
```

Gördüğünüz gibi USB disk hakkında çekirdeğin ürettiği çıktıları `dmesg`
ile görüntülemiş olduk.

Diğer Log Kayıtları Hakkına
---------------------------

Elbette burada bahsettiklerim dışında bizzat `ls /var/log/` komutunun
çıktısında görebileceğiniz gibi pek çok farklı log dosyası mevcuttur.
Biz yalnızca temel olarak bilmemiz gerekenlerden bahsetmiş olduk. Diğer
kayıtlar için kısa bir araştırma yaparak ilgili kayıtların tutulma
amaçlarını keşfedebilirsiniz. Örneğin **apache2** servisinin verdiği
hata kayıtlarını kontrol etmek için `cat /var/log/apache2/error.log`
komutunu girebilirim.

``` {.lua}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /var/log/apache2/error.log
[Thu Jul 27 07:14:41.404012 2023] [mpm_prefork:notice] [pid 730] AH00163: Apache/2.4.52 (Debian) configured -- resuming normal operations
[Thu Jul 27 07:14:41.404338 2023] [core:notice] [pid 730] AH00094: Command line: '/usr/sbin/apache2'
```

Burada dikkatiniz çekmek istediğim nokta; apache aracının kayıtlarını
nerede tuttuğunu ezberden bilmem gerekmiyor. Kısa bir araştırma ile bu
aracın dokümanlarının da yardımıyla ilgili bilgiye istediğim zaman
ulaşabilirim. Yine de pek çok kayıtın ***/var/log*** dizini altında
tutulduğunun bilincinde olduğumuzda ilk kontrol edeceğimiz yer burası
oluyor. Nitekim pek çok araç, genellikle log dosyalarını ***/var/log***
dizini içerisinde kendi isminde bir klasör altında sunuyor zaten.

İşte benzer şekilde sistem üzerindeki araçların kayıtlarını kontrol
etmeniz mümkün.

journald \| journalctl
----------------------

Systemd barındıran modern sistemlerde, kayıt tutmak için systemd'nin
sunduğu **journald** servisi de mevcuttur. **systemd** aracının
yönetiminde olan birimler dışında, çekirdek, oturum açma, cron ve
benzeri pek çok konuda **journald** tarafından özel bir formatta kayıt
tutuluyor. Bu kayıtlar düz metin şeklinde tutulmadığı için, bunları
işlemek üzere `journalctl` isimli aracı kullanabiliyoruz.

En temel kullanımı `journalctl` komutunu girmektir. Bu komut eskiden
yeniye doğru tutulan tüm kayıtların sayfa sayfa listelenmesini sağlar.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl                                                                                                                                              
Jul 04 11:33:56 kali nologin[465551]: Attempted login by kali (UID: 1002) on /dev/pts/0
Jul 04 17:24:36 kali nologin[530342]: Attempted login by kali (UID: 1002) on /dev/pts/0
Jul 05 10:47:08 kali nologin[598878]: Attempted login by kali (UID: 1002) on /dev/pts/1
Jul 06 23:57:13 kali sudo[714206]:      nil : TTY=pts/7 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 06 23:57:13 kali sudo[714206]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1001)
Jul 06 23:57:13 kali sudo[714206]: pam_unix(sudo:session): session closed for user root
Jul 07 02:57:59 kali sudo[757542]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 02:59:18 kali sudo[757889]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:02:23 kali sudo[758635]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:02:37 kali su[758684]: (to ali) ali on pts/4
Jul 07 03:02:37 kali su[758684]: pam_unix(su-l:session): session opened for user ali(uid=1002) by (uid=1002)
Jul 07 03:03:03 kali su[758684]: pam_unix(su-l:session): session closed for user ali
Jul 07 03:03:35 kali sudo[758941]:      ali : TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:03:35 kali sudo[758941]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 03:03:35 kali sudo[758941]: pam_unix(sudo:session): session closed for user root
Jul 07 03:03:58 kali sudo[759044]:      ali : TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:03:58 kali sudo[759044]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 03:03:58 kali sudo[759044]: pam_unix(sudo:session): session closed for user root
Jul 07 03:04:24 kali sudo[759158]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:04:48 kali sudo[759262]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:08:29 kali sudo[760134]:      ali : TTY=pts/4 ; PWD=/home/kali ; USER=kali ; COMMAND=/usr/bin/whoami
Jul 07 03:08:29 kali sudo[760134]: pam_unix(sudo:session): session opened for user kali(uid=1000) by (uid=1002)
Jul 07 03:08:29 kali sudo[760134]: pam_unix(sudo:session): session closed for user kali
Jul 07 03:08:38 kali sudo[760174]:      ali : TTY=pts/4 ; PWD=/home/kali ; USER=kali ; COMMAND=/usr/bin/whoami
Jul 07 03:08:38 kali sudo[760174]: pam_unix(sudo:session): session opened for user kali(uid=1000) by (uid=1002)
Jul 07 03:08:38 kali sudo[760174]: pam_unix(sudo:session): session closed for user kali
Jul 07 03:08:42 kali sudo[760193]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=ali ; COMMAND=/usr/bin/whoami
Jul 07 03:08:47 kali sudo[760214]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=nil ; COMMAND=/usr/bin/whoami
Jul 07 03:10:19 kali sudo[760628]:      ali : command not allowed ; TTY=pts/4 ; PWD=/home/kali ; USER=nil ; COMMAND=/usr/bin/sudo whoami
Jul 07 03:10:24 kali sudo[760649]:      ali : TTY=pts/4 ; PWD=/home/kali ; USER=kali ; COMMAND=/usr/bin/sudo whoami
Jul 07 03:10:24 kali sudo[760649]: pam_unix(sudo:session): session opened for user kali(uid=1000) by (uid=1002)
Jul 07 03:10:39 kali sudo[760649]: pam_unix(sudo:session): session closed for user kali
Jul 07 03:38:37 kali sudo[767462]:      ali : command not allowed ; TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 03:38:54 kali sudo[767547]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=kali ; COMMAND=/usr/bin/whoami
Jul 07 03:38:54 kali sudo[767547]: pam_unix(sudo:session): session opened for user kali(uid=1000) by (uid=1002)
Jul 07 03:38:54 kali sudo[767547]: pam_unix(sudo:session): session closed for user kali
Jul 07 03:39:03 kali sudo[767593]:      ali : command not allowed ; TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 10:12:56 kali sudo[834413]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/ls
Jul 07 10:12:56 kali sudo[834413]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 10:12:56 kali sudo[834413]: pam_unix(sudo:session): session closed for user root
Jul 07 10:13:00 kali sudo[834444]:      ali : command not allowed ; TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 10:21:01 kali sudo[836366]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/ls
Jul 07 10:21:01 kali sudo[836366]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 10:21:01 kali sudo[836366]: pam_unix(sudo:session): session closed for user root
Jul 07 10:22:00 kali sudo[836604]:      ali : command not allowed ; TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 07 10:38:04 kali sudo[840520]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/mkdir
Jul 07 10:38:04 kali sudo[840520]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 10:38:04 kali sudo[840520]: pam_unix(sudo:session): session closed for user root
Jul 07 11:02:59 kali sudo[846550]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/ls
Jul 07 11:02:59 kali sudo[846550]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1002)
Jul 07 11:02:59 kali sudo[846550]: pam_unix(sudo:session): session closed for user root
Jul 07 11:05:31 kali sudo[847178]:      ali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/cat /etc/sudoers.d/kali-grant-root
lines 1-52
```

Fakat bu kayıtlar, sistemin ne kadar süredir çalışmakta olduğuna da
bağlı olarak inanılmaz uzunluklarda olabilir. Bu listeden çıkmak için q
tuşlaması yapmanız yeterli.

Eskiden yeninde doğru görmek yerine en son yaşanmış olan değişimleri
listenin başlarında görmek için bu listeyi tersten sıralamak üzere
`journalctl -r` komutunu girebiliyoruz.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -r
Aug 19 06:33:10 linuxdersleri.net sudo[41372]: pam_unix(sudo:session): session closed for user root
Aug 19 06:33:09 linuxdersleri.net sudo[41372]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)
Aug 19 06:33:09 linuxdersleri.net sudo[41372]:   taylan : TTY=pts/1 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/systemctl -r
Aug 19 06:33:01 linuxdersleri.net CRON[41343]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:33:01 linuxdersleri.net CRON[41343]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:33:01 linuxdersleri.net CRON[41342]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:33:01 linuxdersleri.net CRON[41342]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:33:01 linuxdersleri.net CRON[41345]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:33:01 linuxdersleri.net CRON[41344]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:33:01 linuxdersleri.net CRON[41343]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:33:01 linuxdersleri.net CRON[41342]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:32:01 linuxdersleri.net CRON[41093]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:32:01 linuxdersleri.net CRON[41093]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:32:01 linuxdersleri.net CRON[41092]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:32:01 linuxdersleri.net CRON[41092]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:32:01 linuxdersleri.net CRON[41095]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:32:01 linuxdersleri.net CRON[41094]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:32:01 linuxdersleri.net CRON[41092]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:32:01 linuxdersleri.net CRON[41093]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:31:01 linuxdersleri.net CRON[40845]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:31:01 linuxdersleri.net CRON[40845]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:31:01 linuxdersleri.net CRON[40846]: pam_unix(cron:session): session closed for user taylan
Aug 19 06:31:01 linuxdersleri.net CRON[40846]: (CRON) info (No MTA installed, discarding output)
Aug 19 06:31:01 linuxdersleri.net CRON[40848]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:31:01 linuxdersleri.net CRON[40847]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 06:31:01 linuxdersleri.net CRON[40846]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:31:01 linuxdersleri.net CRON[40845]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 06:30:24 linuxdersleri.net systemd[1]: user-130.slice: Consumed 1.889s CPU time.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: Removed slice User Slice of UID 130.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: Stopped User Runtime Directory /run/user/130.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: user-runtime-dir@130.service: Deactivated successfully.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: run-user-130.mount: Deactivated successfully.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: Stopping User Runtime Directory /run/user/130...
Aug 19 06:30:24 linuxdersleri.net systemd[1]: Stopped User Manager for UID 130.
Aug 19 06:30:24 linuxdersleri.net systemd[1]: user@130.service: Deactivated successfully.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Reached target Exit the Session.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Finished Exit the Session.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Reached target Shutdown.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Removed slice User Application Slice.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed Sound System.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed PipeWire Multimedia System Socket.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed GnuPG cryptographic agent and passphrase cache.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed GnuPG cryptographic agent (ssh-agent emulation).
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed GnuPG cryptographic agent and passphrase cache (restricted).
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed GnuPG cryptographic agent and passphrase cache (access for web browsers).
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed GnuPG network certificate management daemon.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Closed D-Bus User Message Bus Socket.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Stopped target Timers.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Stopped target Sockets.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Stopped target Paths.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Stopped target Basic System.
Aug 19 06:30:24 linuxdersleri.net systemd[39681]: Removed slice User Core Session Slice.
```

Çıktılara dikkat edecek olursanız, systemd tarafından yönetilen
birimlere ek olarak, yetkilendirme ve cron gibi ek yapılar hakkında da
pek çok kayıt bilgisine bu araç vasıtası ile tek elden ulaşabildiğimizi
görebilirsiniz.

Bu çıktıları filtrelemek üzere `journalctl` aracının pek çok seçeneği
var. Ne kadar çok seçenek olduğunu görmek isterseniz `journalctl —help`
komutunu girebilirsiniz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --help                                                                                                                                      
journalctl [OPTIONS...] [MATCHES...]

Query the journal.

Options:
     --system                Show the system journal
     --user                  Show the user journal for the current user
  -M --machine=CONTAINER     Operate on local container
  -S --since=DATE            Show entries not older than the specified date
  -U --until=DATE            Show entries not newer than the specified date
  -c --cursor=CURSOR         Show entries starting at the specified cursor
     --after-cursor=CURSOR   Show entries after the specified cursor
     --show-cursor           Print the cursor after all the entries
     --cursor-file=FILE      Show entries after cursor in FILE and update FILE
  -b --boot[=ID]             Show current boot or the specified boot
     --list-boots            Show terse information about recorded boots
  -k --dmesg                 Show kernel message log from the current boot
  -u --unit=UNIT             Show logs from the specified unit
     --user-unit=UNIT        Show logs from the specified user unit
  -t --identifier=STRING     Show entries with the specified syslog identifier
  -p --priority=RANGE        Show entries with the specified priority
     --facility=FACILITY...  Show entries with the specified facilities
  -g --grep=PATTERN          Show entries with MESSAGE matching PATTERN
     --case-sensitive[=BOOL] Force case sensitive or insensitive matching
  -e --pager-end             Immediately jump to the end in the pager
  -f --follow                Follow the journal
  -n --lines[=INTEGER]       Number of journal entries to show
     --no-tail               Show all lines, even in follow mode
  -r --reverse               Show the newest entries first
  -o --output=STRING         Change journal output mode (short, short-precise,
                               short-iso, short-iso-precise, short-full,
                               short-monotonic, short-unix, verbose, export,
                               json, json-pretty, json-sse, json-seq, cat,
                               with-unit)
     --output-fields=LIST    Select fields to print in verbose/export/json modes
     --utc                   Express time in Coordinated Universal Time (UTC)
  -x --catalog               Add message explanations where available
     --no-full               Ellipsize fields
  -a --all                   Show all fields, including long and unprintable
  -q --quiet                 Do not show info messages and privilege warning
     --no-pager              Do not pipe output into a pager
     --no-hostname           Suppress output of hostname field
  -m --merge                 Show entries from all available journals
  -D --directory=PATH        Show journal files from directory
     --file=PATH             Show journal file
     --root=ROOT             Operate on files below a root directory
     --image=IMAGE           Operate on files in filesystem image
     --namespace=NAMESPACE   Show journal data from specified namespace
     --interval=TIME         Time interval for changing the FSS sealing key
     --verify-key=KEY        Specify FSS verification key
     --force                 Override of the FSS key pair with --setup-keys

Commands:
  -h --help                  Show this help text
     --version               Show package version
  -N --fields                List all field names currently used
  -F --field=FIELD           List all values that a specified field takes
     --disk-usage            Show total disk usage of all journal files
     --vacuum-size=BYTES     Reduce disk usage below specified size
     --vacuum-files=INT      Leave only the specified number of journal files
     --vacuum-time=TIME      Remove journal files older than specified time
     --verify                Verify journal file consistency
     --sync                  Synchronize unwritten journal messages to disk
     --relinquish-var        Stop logging to disk, log to temporary file system
     --smart-relinquish-var  Similar, but NOP if log directory is on root mount
     --flush                 Flush all journal data from /run into /var
     --rotate                Request immediate rotation of the journal files
     --header                Show journal header information
     --list-catalog          Show all message IDs in the catalog
     --dump-catalog          Show entries in the message catalog
     --update-catalog        Update the message catalog database
     --setup-keys            Generate a new FSS key pair
```

Hepsini tek tek ele almayacak olsak da, örnek olarak birkaç temel
seçenekten bahsedebiliriz.

Spesifik olarak bir birim hakkında bilgi almak için `-u` seçeneğini
kullanabiliyoruz. Örneğin **NetworkManager.service** birimi hakkındaki
log kayıtlarına göz atabiliriz.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -u NetworkManager.service 
Jul 14 16:22:22 kali systemd[1]: Starting Network Manager...
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830145.9808] NetworkManager (version 1.34.0) is starting... (for the first time)
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.0211] Read config: /etc/NetworkManager/NetworkManager.conf (lib: no-mac-addr-change.conf)
Jul 14 16:22:26 kali systemd[1]: Started Network Manager.
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.0556] bus-manager: acquired D-Bus service "org.freedesktop.NetworkManager"
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.1816] manager[0x55a088d47030]: monitoring kernel firmware directory '/lib/firmware'.
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.1819] monitoring ifupdown state file '/run/network/ifstate'.
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.3614] hostname: hostname: using hostnamed
Jul 14 16:22:26 kali NetworkManager[478]: <info>  [1657830146.3615] hostname: hostname changed from (none) to "kali"
...
..
.
```

Bunlar eskiden yeniden doğru sıralı, dilersek `-r` seçeneğini ekleyip en
yeniden eskiye sıralayabiliriz.

``` {.php-template}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -ru NetworkManager.service                                                                                                                   
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed timeout -> terminated
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): canceled DHCP transaction
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed unknown -> timeout
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <warn>  [1692441811.7186] dhcp6 (eth0): request timed out
..
.
.
```

Bunlar dışında tıpkı `tail -f` komutunda olduğu gibi log kayıtlarındaki
anlık değişimleri görmek üzere `-f` seçeneğini de kullanabiliriz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -fu NetworkManager.service                                                                                                                   
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5587] device (eth0): state change: secondaries -> activated (reason 'none', sys-iface-state: 'managed')
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5590] manager: NetworkManager state is now CONNECTED_SITE
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5601] device (eth0): Activation: successful, device activated.
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5607] manager: NetworkManager state is now CONNECTED_GLOBAL
Aug 19 06:42:46 linuxdersleri.net NetworkManager[526]: <info>  [1692441766.5321] dhcp6 (eth0): activation: beginning transaction (timeout in 45 seconds)
Aug 19 06:42:46 linuxdersleri.net NetworkManager[526]: <info>  [1692441766.5331] policy: set 'Wired connection 1' (eth0) as default for IPv6 routing and DNS
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <warn>  [1692441811.7186] dhcp6 (eth0): request timed out
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed unknown -> timeout
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): canceled DHCP transaction
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed timeout -> terminated
```

Ben denemek için ağ bağlantısını kesip, tekrar bağlayarak değişimi
gözlemlemek istiyorum.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -fu NetworkManager.service                                                                                                                   
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5587] device (eth0): state change: secondaries -> activated (reason 'none', sys-iface-state: 'managed')
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5590] manager: NetworkManager state is now CONNECTED_SITE
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5601] device (eth0): Activation: successful, device activated.
Aug 19 06:42:44 linuxdersleri.net NetworkManager[526]: <info>  [1692441764.5607] manager: NetworkManager state is now CONNECTED_GLOBAL
Aug 19 06:42:46 linuxdersleri.net NetworkManager[526]: <info>  [1692441766.5321] dhcp6 (eth0): activation: beginning transaction (timeout in 45 seconds)
Aug 19 06:42:46 linuxdersleri.net NetworkManager[526]: <info>  [1692441766.5331] policy: set 'Wired connection 1' (eth0) as default for IPv6 routing and DNS
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <warn>  [1692441811.7186] dhcp6 (eth0): request timed out
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed unknown -> timeout
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): canceled DHCP transaction
Aug 19 06:43:31 linuxdersleri.net NetworkManager[526]: <info>  [1692441811.7187] dhcp6 (eth0): state changed timeout -> terminated
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.4724] device (eth0): state change: activated -> deactivating (reason 'user-requested', sys-iface-state: 'managed')
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.4726] manager: NetworkManager state is now DISCONNECTING
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.4733] audit: op="device-disconnect" interface="eth0" ifindex=2 pid=1165 uid=1000 result="success"
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.5168] device (eth0): state change: deactivating -> disconnected (reason 'user-requested', sys-iface-state: 'managed')
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.5582] dhcp4 (eth0): canceled DHCP transaction
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.5583] dhcp4 (eth0): state changed bound -> terminated
Aug 19 06:46:04 linuxdersleri.net NetworkManager[526]: <info>  [1692441964.5710] manager: NetworkManager state is now DISCONNECTED
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4528] device (eth0): Activation: starting connection 'Wired connection 1' (0eb3f4f0-778f-4d93-b434-61106d908c49)
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4530] audit: op="connection-activate" uuid="0eb3f4f0-778f-4d93-b434-61106d908c49" name="Wired connection 1" pid=1165 uid=1000 result="success"
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4532] device (eth0): state change: disconnected -> prepare (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4534] manager: NetworkManager state is now CONNECTING
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4534] device (eth0): state change: prepare -> config (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4628] device (eth0): state change: config -> ip-config (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.4630] dhcp4 (eth0): activation: beginning transaction (timeout in 45 seconds)
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.5922] dhcp4 (eth0): state changed unknown -> bound, address=192.168.1.11
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.5947] device (eth0): state change: ip-config -> ip-check (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.5961] policy: set 'Wired connection 1' (eth0) as default for IPv4 routing and DNS
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.6083] device (eth0): state change: ip-check -> secondaries (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.6084] device (eth0): state change: secondaries -> activated (reason 'none', sys-iface-state: 'managed')
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.6088] manager: NetworkManager state is now CONNECTED_SITE
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.6090] device (eth0): Activation: successful, device activated.
Aug 19 06:46:07 linuxdersleri.net NetworkManager[526]: <info>  [1692441967.6101] manager: NetworkManager state is now CONNECTED_GLOBAL
Aug 19 06:46:09 linuxdersleri.net NetworkManager[526]: <info>  [1692441969.2667] dhcp6 (eth0): activation: beginning transaction (timeout in 45 seconds)
Aug 19 06:46:09 linuxdersleri.net NetworkManager[526]: <info>  [1692441969.2677] policy: set 'Wired connection 1' (eth0) as default for IPv6 routing and DNS
```

Ağ bağlantısının durumu değiştiği anda, ilgili kayıtlar eklenmiş oldu
gördüğünüz gibi. Takip işlemini sonlandırmak üzere Ctrl + C komutu ile
işlemi sonlandırabilirsiniz.

Eğer filtrelemek istediğini kayıt yalnızca systemd birimi değilse,
`grep` gibi harici bir araç da kullanabilirsiniz. Örneğin ben "**nil**"
kullanıcısının oturum açma ve yetkilendirmeyle ilgili tüm kayıtlarına
göz atmak istiyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -r | grep nil
Aug 19 04:55:00 linuxdersleri.net su[16535]: FAILED SU (to nil) taylan on pts/2
Aug 19 04:54:58 linuxdersleri.net su[16535]: pam_unix(su-l:auth): authentication failure; logname= uid=1000 euid=0 tty=/dev/pts/2 ruser=taylan rhost=  user=nil
..
..
Aug 19 02:55:02 linuxdersleri.net su[1542]: (to nil) taylan on pts/1
Aug 19 02:47:23 linuxdersleri.net systemd[25153]: pam_unix(systemd-user:session): session closed for user nil
Aug 19 02:47:23 linuxdersleri.net systemd[1]: Stopped Session 226 of User nil.
Aug 19 02:47:23 linuxdersleri.net systemd[1]: Stopping Session 226 of User nil...
Aug 19 02:47:23 linuxdersleri.net su[24937]: pam_unix(su:session): session closed for user nil
Aug 19 02:43:40 linuxdersleri.net systemd[1]: Started Session 226 of User nil.
Aug 19 02:43:39 linuxdersleri.net systemd[25152]: pam_unix(systemd-user:session): session opened for user nil(uid=1001) by (uid=0)
Aug 19 02:43:39 linuxdersleri.net systemd-logind[532]: New session 226 of user nil.
Aug 19 02:43:39 linuxdersleri.net login[25137]: pam_unix(login:session): session opened for user nil(uid=1001) by LOGIN(uid=0)
Aug 19 02:42:48 linuxdersleri.net su[24937]: pam_unix(su:session): session opened for user nil(uid=1001) by (uid=1000)
Aug 19 02:42:48 linuxdersleri.net su[24937]: (to nil) taylan on pts/1
Jul 27 14:00:19 linuxdersleri.net su[74969]: FAILED SU (to nil) taylan on pts/0
Jul 27 14:00:17 linuxdersleri.net su[74969]: pam_unix(su:auth): authentication failure; logname= uid=1000 euid=0 tty=/dev/pts/0 ruser=taylan rhost=  user=nil
Jul 27 14:00:10 linuxdersleri.net su[72487]: pam_unix(su:session): session closed for user nil
Jul 27 14:00:03 linuxdersleri.net sudo[74906]:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/cat /etc/sudoers.d/kali-grant-root
Jul 27 13:57:42 linuxdersleri.net sudo[74358]:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/cat /etc/sudoers.d/yeni-tanim
Jul 27 13:57:32 linuxdersleri.net sudo[74305]:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/cat /etc/sudoers.d/kali-grant-root
Jul 27 13:56:42 linuxdersleri.net sudo[74068]:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/info
Jul 27 13:54:01 linuxdersleri.net sudo[73410]:      nil : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/tail /var/log/auth.log
Jul 27 13:50:04 linuxdersleri.net su[72487]: pam_unix(su:session): session opened for user nil(uid=1001) by (uid=1000)
Jul 27 13:50:04 linuxdersleri.net su[72487]: (to nil) taylan on pts/0
Jul 14 10:13:09 linuxdersleri.net sudo[62989]:   taylan : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/killall -u nil sleep
Jul 14 10:09:55 linuxdersleri.net sudo[62205]:   taylan : TTY=pts/0 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/killall -u nil sleep
Jul 14 10:08:20 linuxdersleri.net su[61793]: pam_unix(su:session): session opened for user nil(uid=1001) by (uid=1000)
Jul 14 10:08:20 linuxdersleri.net su[61793]: (to nil) taylan on pts/1
Jul 08 08:36:02 linuxdersleri.net sudo[45984]:      nil : TTY=pts/5 ; PWD=/home/taylan ; USER=root ; COMMAND=/usr/bin/whoami
Jul 08 08:34:21 linuxdersleri.net su[45588]: pam_unix(su:session): session opened for user nil(uid=1001) by (uid=1000)
Jul 08 08:34:21 linuxdersleri.net su[45588]: (to nil) taylan on pts/5
Jul 08 08:32:01 linuxdersleri.net gpasswd[45023]: user nil added by root to group kali-trusted
..
..
```

Ben çıktıları kısaltarak ekliyorum ama neticede istediğim filtrelemeyi
`grep` yardımıyla gerçekleştirdim.

Kayıtlara, sistemin önyüklenme(boot) tarihlerine göre erişme imkanımız
da var. Öncelikle sistemde hangi önyüklemelerin kaydedildiğini görmek
için `—list-boots` seçeneğini kullanalım.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --list-boots 
-127 9144b98ccd0a4f6c93836b0a477783be Mon 2022-07-04 11:33:56 EDT—Thu 2022-07-07 15:52:41 EDT
-126 99a9c907b79c4f17adbaf819098bbe5e Thu 2022-07-14 16:22:16 EDT—Thu 2022-07-14 16:25:12 EDT
-125 af9c16efaed1401ca71166c64c7a487b Fri 2022-07-15 00:30:16 EDT—Sat 2023-01-14 10:35:01 EST
-124 574a8635a4cb4da9ae261774df6fb4c1 Thu 2023-01-19 08:36:27 EST—Tue 2023-01-24 11:55:01 EST
-123 9da82cff7edc4e6f9f915560e8765b52 Wed 2023-01-25 03:23:40 EST—Wed 2023-01-25 10:25:01 EST
-122 688cd44f28a44499ba565d1f586cbb41 Sun 2023-02-12 01:47:07 EST—Sun 2023-02-12 06:25:05 EST
-121 f9d92adcb57446d89a5bf277281cefe3 Sun 2023-02-12 10:42:03 EST—Sun 2023-02-12 11:35:01 EST
-120 3dbcb9fae3a44cac9e4caed6c87c04f0 Fri 2023-03-17 05:26:46 EDT—Fri 2023-03-17 07:17:01 EDT
-119 61f4ea93824d4aa3a5e6ae2747170b33 Sun 2023-04-23 12:00:13 EDT—Sun 2023-04-23 13:25:01 EDT
-118 db43fb69d35e4441864d4235eb71d467 Mon 2023-04-24 02:34:04 EDT—Mon 2023-04-24 02:42:07 EDT
-117 2a9ebf568fb8473f8e25e939a0d56191 Mon 2023-04-24 08:24:39 EDT—Fri 2023-04-28 10:17:01 EDT
```

Liste normalde çok daha uzun fakat ben kısaca ekledim. Burada sistemin
tüm boot edildiği zamanlara ait log kayıtları ayrı ayrı mevcut. Örneğin
ben **118** numaralı **boot** kaydına ulaşmak istersem `-b boot_sırası`
şeklinde komutumu girebilirim.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl -b 118
Aug 17 00:46:24 linuxdersleri.net kernel: Linux version 5.15.0-kali3-amd64 (devel@kali.org) (gcc-11 (Debian 11.2.0-14) 11.2.0, GNU ld (GNU Binutils for Deb>
Aug 17 00:46:24 linuxdersleri.net kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-kali3-amd64 root=UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd ro nouve>
Aug 17 00:46:24 linuxdersleri.net kernel: x86/fpu: x87 FPU will use FXSAVE
Aug 17 00:46:24 linuxdersleri.net kernel: signal: max sigframe size: 1440
Aug 17 00:46:24 linuxdersleri.net kernel: BIOS-provided physical RAM map:
Aug 17 00:46:24 linuxdersleri.net kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable
Aug 17 00:46:24 linuxdersleri.net kernel: BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved
Aug 17 00:46:24 linuxdersleri.net kernel: BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved
```

Bu şekilde spesifik olarak boot edilme tarihlerine göre filtreleme
yapmamız mümkün oluyor.

Ayrıca doğrudan tarih aralığı belirtme imkanına da sahibiz. Bunun için
`—since` ve `—until` seçeneklerini kullanabiliyoruz. Örneğin
"**2023-08-05**" tarihinden beri gerçekleşenleri görmek istiyorum.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --since "2023-08-05"
Aug 08 04:38:48 linuxdersleri.net kernel: Linux version 5.15.0-kali3-amd64 (devel@kali.org) (gcc-11 (Debian 11.2.0-14) 11.2.0, GNU ld (GNU Binutils for Deb>
Aug 08 04:38:48 linuxdersleri.net kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-kali3-amd64 root=UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd ro nouve>
Aug 08 04:38:48 linuxdersleri.net kernel: x86/fpu: x87 FPU will use FXSAVE
Aug 08 04:38:48 linuxdersleri.net kernel: signal: max sigframe size: 1440
Aug 08 04:38:48 linuxdersleri.net kernel: BIOS-provided physical RAM map:
```

Bu liste günümüze kadar uzanıyor.

Eğer belirli bir tarihe kadar olacaksa `—until` seçeneğini
kullanabiliyoruz. Ben bu kez de "**2023-08-05**" tarihine kadar olanları
görmek istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --until "2023-08-05"                                                                                                                    
Jul 04 11:33:56 kali nologin[465551]: Attempted login by kali (UID: 1002) on /dev/pts/0
Jul 04 17:24:36 kali nologin[530342]: Attempted login by kali (UID: 1002) on /dev/pts/0
Jul 05 10:47:08 kali nologin[598878]: Attempted login by kali (UID: 1002) on /dev/pts/1
Jul 06 23:57:13 kali sudo[714206]:      nil : TTY=pts/7 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/whoami
Jul 06 23:57:13 kali sudo[714206]: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1001)
```

Eskiden yeniye doğru "**2023-08-05**" tarihine kadar olanlar listelenmiş
oldu. Dilersek spesifik olarak bir aralık belirtmek için de her ikisini
birden kullanabiliriz. Ben **2023-08-05** tarihi le **2023-08-12**
tarihleri arasındaki kayıtları görmek istediğimi belirtiyorum.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --since "2023-08-05" --until "2023-08-12"                                                                                               
Aug 08 04:38:48 linuxdersleri.net kernel: Linux version 5.15.0-kali3-amd64 (devel@kali.org) (gcc-11 (Debian 11.2.0-14) 11.2.0, GNU ld (GNU Binutils for Deb>
Aug 08 04:38:48 linuxdersleri.net kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-kali3-amd64 root=UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd ro nouve>
Aug 08 04:38:48 linuxdersleri.net kernel: x86/fpu: x87 FPU will use FXSAVE
Aug 08 04:38:48 linuxdersleri.net kernel: signal: max sigframe size: 1440
Aug 08 04:38:48 linuxdersleri.net kernel: BIOS-provided physical RAM map:
```

Tüm çıktıları eklememiş olsam da tam olarak belirttiğim aralıktaki tüm
kayıtları görebiliyorum.

Dilersek saat dakika saniye cinsinden filtreleme yapmamız da mümkün.
Örneğin bu gün **05.30.00** saatine kadar olan kayıtları listeleyelim.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --since "05:30:00"                                                                                                                          
Aug 19 05:30:01 linuxdersleri.net CRON[25344]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 05:30:01 linuxdersleri.net CRON[25345]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
Aug 19 05:30:01 linuxdersleri.net CRON[25343]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 05:30:01 linuxdersleri.net CRON[25346]: (taylan) CMD (echo "bu bir zamanlanm\304\261s gorev")
Aug 19 05:30:01 linuxdersleri.net CRON[25344]: (CRON) info (No MTA installed, discarding output)
Aug 19 05:30:01 linuxdersleri.net CRON[25344]: pam_unix(cron:session): session closed for user taylan
Aug 19 05:30:01 linuxdersleri.net CRON[25343]: (CRON) info (No MTA installed, discarding output)
Aug 19 05:30:01 linuxdersleri.net CRON[25343]: pam_unix(cron:session): session closed for user taylan
Aug 19 05:31:01 linuxdersleri.net CRON[25591]: pam_unix(cron:session): session opened for user taylan(uid=1000) by (uid=0)
Aug 19 05:31:01 linuxdersleri.net CRON[25593]: (taylan) CMD (taylan echo "bu bir zamanlanm\304\261s gorev")
```

Eğer yalnızca saat değil, tarih de belirtirseniz tam olarak ilgili
tarihteki ilgili saatte kaydı tutulanlar size getirilecektir. Örneğin
**2023-08-18 13:30:00** ile **2023-08-18 14:00:00** arasındaki tüm
kayıtları getiriyorum.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --since "2023-08-18 13:30:00" --until "2023-08-18 14:00:00"
Aug 18 13:30:10 linuxdersleri.net kernel: Linux version 5.15.0-kali3-amd64 (devel@kali.org) (gcc-11 (Debian 11.2.0-14) 11.2.0, GNU ld (GNU Binutils for Deb>
Aug 18 13:30:10 linuxdersleri.net kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-kali3-amd64 root=UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd ro nouve>
Aug 18 13:30:10 linuxdersleri.net kernel: x86/fpu: x87 FPU will use FXSAVE
Aug 18 13:30:10 linuxdersleri.net kernel: signal: max sigframe size: 1440
Aug 18 13:30:10 linuxdersleri.net kernel: BIOS-provided physical RAM map:
...
..
.
```

Çıktı çok uzun olduğu için ben kısaltarak ekledim. Siz dilerseniz çıktı
uzunluğunu `-n` seçeneği ile sınırlayabilirsiniz. Örneğin aynı çıktıyı
yalnızca 5 satır basacak şekilde sınırlayalım.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ journalctl --since "2023-08-18 13:30:00" --until "2023-08-18 14:00:00" -n 5
Aug 18 13:30:10 linuxdersleri.net kernel: Linux version 5.15.0-kali3-amd64 (devel@kali.org) (gcc-11 (Debian 11.2.0-14) 11.2.0, GNU ld (GNU Binutils for Deb>
Aug 18 13:30:10 linuxdersleri.net kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-kali3-amd64 root=UUID=491d3534-b3d9-47af-ad63-66b0e72fe8dd ro nouve>
Aug 18 13:30:10 linuxdersleri.net kernel: x86/fpu: x87 FPU will use FXSAVE
Aug 18 13:30:10 linuxdersleri.net kernel: signal: max sigframe size: 1440
Aug 18 13:30:10 linuxdersleri.net kernel: BIOS-provided physical RAM map:
lines 1-5/5 (END)
```

**journald** servisinin en temel kullanımı bu şekilde. Yardım
sayfasından bizzat teyit edebileceğiniz gibi esasen çok fazla ek
seçeneği mevcut fakat temel seviye için bahsetmiş olduklarımız yeterli.
Daha fazlasını merak ediyorsanız elbette araştırmakta özgürsünüz.

Böylelikle Linux üzerindeki loglara nasıl ulaşabileceğimizi temel
düzeyde görmüş olduk.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 12. Ders 25 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Konsol üzerinden dosya içeriklerini görüntüleyebileceğimiz ve farklı
biçimlerde manipüle edebileceğimiz pek çok araçtan söz ettik. Şimdi de
konsol üzerinden kullanabileceğimiz metin editörlerinden söz edelim.

Grafiksel arayüzde çalışırken kullanabileceğimiz bir çok metin editörü
bulunuyor. Zaten hepsinin kullanımı da hemen hemen benzer. Neticede
bunlar grafiksel arayüzlü araçlar, yani üzerine ekstra konuşmamızı
gerektirecek bir durum yok. Kullanmakta olduğunuz sistemde hangisi
varsa, ya da siz özellikle hangisini tercih ediyorsanız onu
kullanabilirsiniz.

Bizim asıl ihtiyacımız olan, grafiksel arayüzün bulunmadığı komut satırı
arayüzündeyken de metinlerimizi görüntüleyip gerektiğinde
düzenleyebileceğimiz bir araç. Aslında komut satırı arayüzü için de pek
çok alternatif araç bulunuyor ama bizler en yaygın kullanıma sahip iki
araçtan bahsedeceğiz. Bu sayede farklı sistemlerde de bu metin
editörleri kuvvetle muhtemel yüklü olacağı için işlerinizi aksamadan
yerine getirme yetkinliğine sahip olacaksınız. Bu durumu, tıpkı pek çok
kabuk içinden bash kabuğunu tercih etmemiz gibi düşünebilirsiniz. Yaygın
kullanıma sahip olması ilgili aracı öğrenmek için geçerli bir sebep.

Anlatımın devamında sırasıyla `nano` ve `vi`-`vim` araçlarının
kullanımlarına kısaca değineceğiz. Ama fark ettiyseniz kısaca diyorum,
çünkü özellikle `vim` aracının tüm özelliklerinden bahsetmek için ayrıca
bir eğitim hazırlamamız gerekir. Ki ben de yalnızca temel düzeyde
biliyorum. Yani anlatımlar sırasında çok kısaca temel kullanımlarından
ve bilmemiz gerekenlerden bahsedeceğiz.

Anlatımlara başlamadan önce temel düzeyde metin editörlerini
kullanabilmenin gerçekten çok önemli olduğunu vurgulamak istiyorum.
Belki metin editörü kullanımını pek önemli bulmuyor olabilirsiniz ancak
aslında metin editörleri, söz konusu sistemi komut satırından yönetmek
olduğunda, komut satırındaki işlerimizi etkili şekilde halledebilmemiz
için gereken en temel araçların başında geliyor. Çünkü şimdiye kadar
açıkça fark ettiğimiz gibi, sistemi komut satırından yönetirken metinsel
tabanlı bir arayüzde çalışıyoruz ve yönetim esnasında da sürekli olarak
metinsel verileri yazıp, düzenleyip kullanıyoruz. Bu bağlamda metin
editörü anlatımlarına da gereken özeni göstermenizi rica ediyorum. Zira
sıklıkla ihtiyaç duyacaksınız.

Tamamdır artık lafı daha fazla uzatmadan öncelikle `nano` aracını ele
alarak başlayabiliriz.

Nano
----

Nano aracı ileride ele alacağımız "`vi`" aracına oranla yeni başlayan
kullanıcılar için çok daha kolay kullanıma sahip olan popüler bir metin
editörüdür. Temel olarak bir metin editöründen beklediğimiz ve metin
editörü ile yapmak istediğimiz işlemleri sorunsuzca yerine getiriyor.
Zaten bu sebeple son derece yaygın kullanıma sahip.

Bir dosyayı `nano` metin editöründe açmak için `nano dosya_adı` şeklinde
komut girmemiz yeterli. Ben denemek için `nano yeni-metin` şeklinde
komutumu giriyorum. Eğer çalışmakta olduğumuz dizinde bu isimde bir
dosya yoksa, yeni bir metin editörü penceresi açılacak. Eğer bu isimde
bir dosya varsa da o dosya içeriği karşımıza gelecek.

``` {.scss}
GNU nano 6.0                yeni-metin









                          [ New File ]
^G Help      ^O Write Out ^W Where Is  ^K Cut       ^T Execute
^X Exit      ^R Read File ^\\ Replace   ^U Paste     ^J Justify
```

Bakın bu isimde bir dosya olmadığı için anında yeni bir sayfa `nano`
metin editörü içinde açıldı. Ve bakın başlık olarak da açtığımız
dosyanın ismi burada yer alıyor. İşte `nano` metin aracı bu. Bizler bu
araç üzerinden kolayca dosya oluşturup, var olan dosya içeriklerini
düzenleyebiliyoruz.

Şimdi kısaca editörü tanıyacak olursak, pencerenin altında,
kullanabileceğimiz en temel kısayollar açıkça yazıyor.

![nano-shortcuts](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-shortcuts.webp)

Pencere boyutuna göre ekran sığacak kadar olan kısayollar burada
gözüküyor olacak. Yani aslında nano aracının tüm kısayolları bunlardan
ibaret değil ancak pencere boyutuna göre hatırlatma amaçlı bunlar
gösteriliyor. Örneğin ben pencereyi biraz daha genişletip tekrar alt
çubuğa bakıyorum.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-shortcuts2.webp)

Buradaki kısayol açıklamalarına bakarak yani bu alt çubuğa bakarak
`nano` metin editöründe yapabileceklerimizi kolayca takip ediyor
olacağız.

Hepsini olmasa da en temel kısayollarından bahsederek devam edecek
olursak. Buralarda bulunan şapka **\^** sembolleri Ctrl tuşunu temsil
ediyor. Kısayolların kullanımı da son derece kolay. Tek yapmanız gereken
alt çubuğu okuyup yönergeler göre hareket etmek. Zaten size sorular
sorulup, yapmak istediğiniz işlemler için onay alınacaktır.

Nano Aracını Kapatmak
---------------------

Metin editöründen çıkıp komut satırına dönmek istersek burada da
belirtildiği şekilde Ctrl + X kısayolunu uygulayabiliriz. Zaten dosya
içerisine herhangi bir ekleme yapmadığım için editörü kapatırken bana
dosyayı kaydetmekle ilgili hiç bir soru sorulmadan `nano` aracı
kapanacaktır.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-close.gif)

Normalde dosya içerisine yeni veri eklendiğinde çıkmadan önce kaydetmek
istiyor muyuz diye soruyor. Denemek için yine aynı dosyamızı açıp
içerisine yeni veriler ekleyelim ve Ctrl + X kısayolu ile çıkış yapalım.
Çıkarken bize "değişiklikler kaydedilsin mi?" diye soracak "**y**" ile
onay verip enter ile işlemi bitirelim.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-save.gif)

Böylelikle `nano` aracı ile istediğimiz isimde yeni bir dosya açıp
içerisine istediğimiz verileri ekledik ve başarıyla kaydettik.

Değişiklikleri Kaydetmek
------------------------

Gerçekleştirdiğimiz değişiklikleri kaydetmek için Ctrl + O kısayolunu
kullanıp "y" tuşu ile kaydetmeyi onaylayabiliriz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-save.webp)

Kaydetme kısayolunu kullandıktan sonra bu verilerin mevcut dosya üzerine
mi yoksa başka bir dosya olarak mı kaydedilmesi gerektiğini soruluyor.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-save2.webp)

Eğer başka bir dosya olarak kaydetmek isterseniz buradaki dosya ismini
değiştirip enter ile onaylayabilirsiniz. Eğer değiştirmeyecekseniz de
dosya ismini aynen bırakıp enter ile üzerine yazmayı onaylayabilirsiniz.
Ben değiştirmeden enter ile onaylıyorum.

### Farklı Dosya Olarak Kaydetmek

Farklı bir dosya olarak kaydetmeye örnek vermek için öncelikle dosyama
"bu farklı bir dosya" verisini ekliyorum ve Ctrl + O ile dosyayı
kaydediyorum. Şimdi bana sorulan dosya ismini dilediğim gibi
belirtebilirim. Ben örnek olması için ***Documents*** dizini altında
farklı-dosya ismi şeklinde kaydetmek istiyorum.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/save-different.webp)

Farklı kaydetme işlemini de "y" ile onaylayalım.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/save-different2.webp)

Tamamdır, en son eklemiş olduğum verilerin farklı bir dosya olarak
kaydedildiğini teyit etmek için `paste` komutunu kullanabilirim.

``` {.bash}
└─$ paste yeni-metin ~/Documents/farklı-dosya
bu bir metindir bu bir metindir
ekleme  ekleme
ekleme2 ekleme2
        bu farklı bir dosya
```

Gördüğünüz gibi farklı olarak kaydettiğim dosya tam olarak istediğim
dizinde ilgili değişikliklerle birlikte kaydedilmiş.

Dizinlerde Gezinmek
-------------------

Nano aracından çıkmadan dosyayı kaydedeceğimiz dizini belirlemek için
dosya sistemi hiyerarşisinde Ctrl + T tuşuna basıp gezinebiliriz. Bunun
için öncelikle dosyayı kaydetmek istediğimizi Ctrl + O tuşu ile
belirtmemiz gerek.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-save2.webp)

Bize dosyayı hangi isimde kaydetmek istediğimiz sorulurken, Ctrl + T
tuşu ile dosya sistemi üzerinde gezinebiliriz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-browse.webp)

Bu sayede özellikle komut satırı arayüzünde çalışıyorken `nano`
aracından çıkmadan dosya sisteminde nerede hangi dosya ve klasör var
diye kontrol edip, mevcut dosyayı hangi isimde nereye kaydetmemiz
gerektiğine karar verebiliyoruz.

Alt çubuğa bakacak olursanız gezinme işlemi sırasında da bu iş için
kullanabileceğimiz özel kısayolların mevcut olduğunu görebilirsiniz.
İşlevlerini anlamak için kısa açıklamalarına bakmanız yeterli.

Şu anda benden dosyayı nereye kaydetmem gerektiğini belirtmem isteniyor.
Eğer ben herhangi bir dosyanın üzerine gelip enter ile onaylarsam
gördüğünüz gibi bu dizindeki bu dosya zaten mevcut üzerine yazılmasını
istiyor musunuz diye soruluyor.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/save-different2.webp)

Eğer "y" tuşuna basarsam şu an bu dosyada yazıklarım bu dizindeki bu
dosyanın içeriğini silip üzerine yazılacak. Eğer istemezseniz Ctrl + C
ile işlemi iptal edebilirsiniz.

Neticede dosya oluşturma, mevcut dosya içeriğini düzenleyip başka bir
dosya olarak kaydetme ve `nano` üzerinden dizinlerde gezinme ve
gerektiğinde var olan dosyaların üzerine yazma gibi ihtiyaç
duyabileceğimiz temel kısayollardan bahsettik. Zaten bu alt çubuğa
baktığınız sürece tüm işlemleri rahatlıkla yerine getirebilirsiniz.
Çünkü tüm adımlarda burada temel işlemlerin kısayolları açıkça
belirtiliyor. Şimdi editörün kullanımıyla ilgili diğer kısayollardan
bahsederek devam edebiliriz.

Dosya Okuyup İçeriğini Eklemek
------------------------------

Eğer mevcut dosyaya başka bir dosyanın içeriğini eklemek istersek Ctrl +
R kısayolunu kullanabiliriz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-insert.webp)

Bakın bize hangi dosyanın ekleneceğini soruyor. İçeri aktarmak
istediğimiz dosyanın tam dizin adresini buraya eklememiz gerekiyor.
Gördüğünüz gibi ilgili dosyanın tüm içeriği buraya kopyalandı. Bence
yerine göre gayet kullanışlı bir kısayol.

Dosya İçeriğinde Araştırma
--------------------------

Mevcut dosya içinde kelimeleri araştırmak için Ctrl + W kısayolunu
kullanabiliyoruz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-search.webp)

Ben örneğin içeri aktardığım bu kullanıcı listesinde yer alan "kali"
ismini araştırmak istiyorum.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-search2.webp)

Bakın imlecim doğrudan ilgili kelimenin üstüne atlamış oldu. Özellikle
büyük dosya içeriklerinde çalışıyorken bu arama özelliği kullanışlı
olabiliyor.

Bulup Değiştirme İşlemi
-----------------------

Eşleşme sağlanan kelimelerin değiştirilmesini sağlamak için Ctrl + \\
kısayolunu kullanabiliyoruz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-replace.webp)

Bakın bana hangi kelimeyi değiştirmek istediğimi soruyor ben örnek
olması için "**kali**" yazıyorum. Şimdi de bu kelimenin yerine hangi
kelimenin yazılması gerektiğini soruyor örnek olarak "**taylan**" yazıp
onaylayabiliriz mesela.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-replace2.webp)

Eğer değişimleri tek tek yapmak istiyorsanız her bir eşleşmede sizden
onay istenecektir. "**yes**" ile onayabilir "**no**" ile değişimi
reddedebilirsiniz. Ayrıca "**all**" seçeneği ile tüm eşleşmelerin tek
seferde değiştirilmesini de sağlayabilirsiniz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-replace3.webp)

Metinleri Kesip Yapıştırmak
---------------------------

İmlecimizin üzerinde bulunduğu satırı kesmek için Ctrl + K yapıştırmak
için de Ctrl + U kısayollarını kullanabiliyoruz. Ben örnek olarak birden
fazla satırı Ctrl + K kısayolu ile kesip birden fazla kez Ctrl + U
kısayolu ile yapıştırıyorum.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-copy-paste.gif)

Değişiklikleri Geri ve İleri Sarmak
-----------------------------------

Şimdiye kadar dosya üzerinde pek çok değişiklik yaptık. Eğer yaptığımız
değişiklikleri geri almak istersek Alt + U kısayolunu kullanabiliyoruz.
Hatta geri aldığımız bir değişikliği tekrar ileri almak için Alt + E
kısayoluna da sahibiz. Ben denemek için yaptığım tüm değişikleri geri
alıp sonra geri aldıklarımı da tekrar ileri sarmak istiyorum.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-undo-redo.gif)

İmlecin Konumun Öğrenmek
------------------------

Eğer büyük dosyalarda çalışıyorsanız imlecin mevcut bulunduğu konum
dosyanın tam olarak hangi satırında hangi sütununda hangi karakterinde
gibi çeşitli bilgileri öğrenebilirsiniz. Bakın Ctrl + C kısayolunu
kullandığımda benim imlecimin bulunduğu konum hakkında tüm bilgiler alt
tarafta sırasıyla yazıyor.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-learn-line.webp)

Bu şekilde büyük dosya içeriklerinde kaybolmadan düzenlemelerinizi
kontrollü şekilde yerine getirebilirsiniz.

Satırlara Hızlı Geçiş
---------------------

Ayrıca isterseniz dosya içerisindeki herhangi bir satıra atlamak için
Ctrl + \_ kısayolunu kullanıp atlamak istediğiniz satır numarasını
girebilirsiniz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-jump-line.webp)

Bakın doğrudan istediğim satıra atlayabiliyorum.

Satırları Numaralandırmak
-------------------------

Hangi satırda olduğumuzu teyit etmek istersek Alt + N kısayolu ile satır
numaralarının gözükmesini de sağlayabiliriz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-line-number.webp)

Sayfada Hızlı Gezinti
---------------------

Ctrl tuşuna basıp yukarı yön tuşuna basarsanız sayfanın en başına, aşağı
yön tuşuna basarsanız da sayfanın en sonuna atlayabilirsiniz. Ya da
kelime kelime atlamak için Ctrl tuşuna bastıktan sonra sağ sol yön
tuşları ile hızlıca kelimler arasında atlayış yapabilirsiniz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-navigate.gif)

Aslında yön tuşları yerine bu işlemler için 10 parmak klavyede daha
ulaşılabilir kısayollar da bulunuyor. Örneğin bir üst satıra dönmek için
"**p**revious" kısayolundan gelen Ctrl + P bir sonraki satıra geçmek
için de "**n**ext" ifadesinden gelen Ctrl + N kısayolunu
kullanabiliyoruz. Bunlar dışında bir kelime "ileri gitmek için
"**f**orward" ifadesinden gelen Ctrl + F veya bir karakter geri gitmek
için de "**b**ackward" ifadesinden gelen Ctrl + B kısayolunu
kullanabiliyoruz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-navigate2.gif)

Evet tüm bu bahsettiğimiz özellikler ve kısayollar konsol üzerinden
metin düzenleme işlerinizde `nano` aracını rahatlıkla kullanabilmenizi
sağlayacak temel kullanım bilgileridir. Tüm bunlar dışında aslında nano
aracının pek çok ek özelliği yani dolayısıyla pek çok kısayolu
bulunuyor. Ancak tabii ki hepsine değinmeyeceğiz. Tüm özelliklerini
görmek için yardım sayfasına geçiş yapmak üzere Ctrl + g kısayolunu
kullanabilirsiniz.

![](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/nano-help.webp)

Bakın burada pek çok özellik kısayol kullanımlarıyla birlikte gayet net
biçimde izah edilmiş. Temelde benim bahsettiklerim neredeyse tüm temel
metin düzenleme işlerinizi yapmanızı sağlayacağı için buradaki ek
kısayolları ben ele almayacağım. Yine de sizler göz atıp kullanışlı
bulduklarınızı uygulayarak test edebilirsiniz.

Evet `nano` aracından yeterince bahsettik. Nano aracı temel metin
düzenleme işlerimizde kullanabileceğimiz yaygın kullanım sahip olan bir
metin editörü. Kullanımı da son derece kolay. Özellikle alt çubukta
sürekli olarak bize hangi işlem için hangi kısayolu kullanabileceğimizin
bilgisi sunulduğu için kısayolları unutmak gibi bir endişemiz olmuyor.
Tek yapmamız gereken yapmak istediğimiz işlemi temsil eden alt çubuktaki
kısayolu kullanmak.

Nano editörü elbette çok sık kullanılan çok kullanışlı bir editör ancak
yaygınlık ve sunulan güçlü özellikler bakımından vi kadar geniş kapsamlı
değil. Nano editörü de hemen her dağıtımda varsayılan olarak yüklü
bulunuyor veya kolayca yüklenebilir ancak vi editörü istisnalar hariç
neredeyse tüm dağıtımlarda varsayılan olarak yüklü gelen yegane editör
aslında. Bu sebeple söz konusu sistem yönetimi olduğunda siz yalnızca
nano aracını kullanmayı tercih etseniz bile vi editörünü temel düzeyde
kullanabilmeniz kesinlikle önemli bir yetkinlik.

Elbette biz bu eğitimde kapsamlı şekilde vi editörünü ele almayacağız
ancak vi editörü son derece güçlü bir metin editörüdür. Yeni başlayan
kullanıcılar pek sevmese de yaygınlığı ve sağladığı işlevler bakımından
kesinlikle öğrenilmeye değerdir ve aslında ilk başta göründüğü kadar da
zor değildir. Kullanmak istemeseniz bile en azından temel düzeyde
tanımanız, kullanmak zorunda kaldığınızda yararınıza olacaktır. Zaten
biz yalnızca en temel özelliklerinden bahsedeceğiz. Hadi anlatımlarımıza
temel seviye vi editöründen bahsederek devam edelim.

Vi
--

Vi editörü istisnai durumlar hariç kullanacağınız tüm Linux
dağıtımlarında varsayılan olarak yüklü bulunan yegane metin editörüdür.
Zaten ben de evrenselliği dolayısıyla `vi` editöründen haberdar olmanızı
istiyorum. Bu sayede hangi Linux sistemini kullanırsanız kullanın en
azından temel düzeyde metin düzenleme işleriniz için `vi` editörünü
kullanabilme kabiliyetine sahip olacaksınız.

Aslında günümüzde doğrudan `vi` editörü yerine `vi` editörünün gelişmiş
hali olan "**v**i **im**proved" yani kısaca `vim` editörü kullanılıyor.
Dolayısıyla pek çok dağıtımda `vi` yerine `vim` editörünün çeşitli
sürümleri bulunuyor. Fakat bizim için yalın kullanımda temel
yaklaşımları öğrenmek kâfi gelecek. Öncelikle yalın `vim` editöründen
yani `vi` editöründen bahsedelim ki, daha sonra herhangi bir sistemde
karşımıza çıktığında en yalın halde bile olsa metin görüntüleme ve
düzenleme işlerimizi sorunsuzca halledebilelim.

Lafı daha fazla uzatmadan temelde bilmemiz gerekenlerden bahsederek
başlayabiliriz.

Şimdiden belirteyim, vi editörü daha önce kullandığınız diğer standart
editörlerden biraz farklı çalışıyor ancak kullanımı kesinlikle zor
değil. Zaten biz de temel işlevlerden bahsedip ihtiyacımız kadarlık
kısmıyla ilgileneceğiz. Bazı kullanıcılar doğru şekilde öğrenmedikleri
için `vi` editörünü pek sevmeyebiliyor hatta editörle ilk kez
karşılaşıyorlarsa editörden çıkmak bile zor geldiği için nefret edip
`vi` editörüne karşı bir önyargı geliştirebiliyor. Ancak editörü doğru
şekilde tanıyıp biraz pratik yaparsanız hiç de zor olmadığını kendiniz
de göreceksiniz.

**Letitia E. Landon'**ın da dediği gibi**, *"İnsanlar, anlamadıkları
şeylerden nefret etmeye hazırdırlar."***

Bu sebeple önce anlamaya çalışalım sonra nefret edip etmeyeceğimize
karar veririz :)

Vi editörünün "**komut**" ve "**ekleme**(**insert**)" olmak üzere
temelde iki farklı çalışma modu bulunuyor. İlk kez vi editörünü
açtığımızda "**komut modunda**" çalışmaya başlıyoruz. Bu moddayken yeni
bir veri eklememiz yani metin dosyasına veri girişi yapmamız mümkün
olmuyor. Veri girişi için "**insert**" olarak geçen "**ekleme**" moduna
geçiş yapmamız gerekiyor. Merak etmeyin ne denemek istediğimi örnekler
üzerinden net biçimde anlamış olacaksınız.

Komut Modu
----------

Hemen örnek üzerinden görmek için daha önce oluşturduğumuz bir metin
dosyasını açmayı deneyebiliriz. İstediğimiz metin dosyasını vi editörü
ile açmak için tek yapmamız gereken `vi` komutundan sonra açmak
istediğimiz dosyasının ismini girmek. Ben `vi isimler.txt` komutuyla
dosyamı açıyorum.

![vi](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi.webp)

Bakın dosya içeriği karşımıza geldi. Komut modundayken dosya içeriğinde
gezinmek için kullanabileceğimiz bazı kısayollara sahibiz. Temel gezinti
için imleci hareket ettirmek üzere aşağıdaki tuşlamaları bilmeniz
yeterli.

h sola

l sağa

k yukarı

j aşağı

\^ satır başına

\$ satır sonuna

gg dosyanın en başına

shift + g dosyanın sonuna

Özellikle 10 parmak klavye kullanımında bu tuşları kullanarak komut
modundayken dosya içeriğinde rahatlıkla gezinebiliyoruz. Elbette tüm
kısayollar bunlar ile sınırlı değil ancak temel kullanım için bunlar
yeterli.

Komut modundayken dikkat etmeniz gereken detay, dosya içeriğine yeni
veri girişi yapamıyor olmamız. Bu durumu bizzat test etmek için komut
moduna açılmış olan dosyanıza "deneme" yazabilirsiniz.

![vi-command](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-command.gif)

Eğer bu durumu test ettiyseniz, denemenizin ardından herhangi bir veri
girişi yapamadığınızı hatta veri girişinin aksine bastığınız tuşların
bazı kelimelerin silinmesine ve kelimeler arasında atlamanıza sebep
olduğunu bizzat deneyimlemişsinizdir.

Veri girişi yerine mevcut veriler üzerinde değişiklik gerçekleşti çünkü
biz şu anda `vi` editörünü komut modunda kullanıyoruz. Komut modunda
olduğumuz için klavyemizden bastığımız tuşlar `vi` editörü tarafından
çeşitli işlevleri yerine getiren komut kısayolları olarak algılanıyor.
Dolayısıyla bu kısayollara göre mevcut metinde düzenlemeler yapılıyor.
Peki metin içerisine yeni veri eklemek için ne yapmamız gerekiyor ?

Tabii ki daha önce de bahsettiğim gibi "insert" yani "ekleme moduna"
geçiş yapmalıyız. Ekleme modu İngilizce olarak "**i**nsert mod" olarak
geçtiği için bu moda geçiş yapmak için de `i` tuşuna basmamız yeterli
oluyor. Zaten şu anda komut modunda olduğumuz için `i` tuşuna
bastığımızda bu `i` karakteri insert moduna geçmek için kullandığımız
bir komut olarak algılanacak.

Ekleme Modu \| Insert Mode
--------------------------

Insert moduna geçiş yapmak için Komut modundayken `i` tuşuna basmamız
yeterli.

![vi-insert](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-insert.webp)

Bakın "ekleme-insert" moduna geçiş yaptığım sol alt köşede açıkça
belirtiliyor. Ekleme modunda olduğum için artık istediğim ifadeyi veri
olarak metin dosyama ekleyebilirim. Ben denemek için "Linux bir
çekirdektir" yazıyorum.

![vi-insert2](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-insert2.webp)

Veri girişimiz sonlandığında ekleme modundan çıkmamız gerek. Çünkü bu
moddayken birkaç kısayol hariç bastığımız tüm tuşlar veri girişi olarak
algılanacak. Yani imleci sağa sola veya yukarı aşağı hareket ettirmek
için kullanacağımız bazı kısayollar da veri girişi olacak görülecektir.
Denemek isterseniz bir üst bölümde bahsettiğimiz klavye kısayollarını
tekrar kullanmayı deneyebilirsiniz.

Yön tuşları bile yeni karakterler olarak ekleniyor çünkü şu anda ekleme
modunda çalışıyoruz. Dolayısıyla istisnai birkaç tuş dışında bastığımız
tüm tuşlar veri girişi olarak algılanıyor.

Komut Moduna Geçiş
------------------

Eğer veri girişi yerine mevcut karakterler arasında gezinmek istersek
bunun için komut moduna geçmemiz gerekiyor. Bunun için de esc tuşunu
kullanmamız gerek. esc tuşuna bastıktan sonra, vi editörünün ilk
açıldığında olduğu gibi komut moduna geçiş yaptığını ve burada kısayol
tuşlarını kullanabileceğinizi görebilirsiniz.

Hatta ekleme modundan komut moduna geçmek için esc tuşu uzak kaldığı
için alt tuşuna basılı tutup h l j k gibi tuşları kullanarak da hızlıca
komut moduna geçebiliyoruz. Komut modunda işimiz bittiğinde de i tuşuna
basıp tekrar ekleme moduna dönebiliyoruz.

Sayfa Sayfa Gezinti
-------------------

Şimdiye kadar bahsettiğimiz kısayollar dosya içeriği kısa olduğunda
gezinti için yeterli. Fakat kimi zaman çok uzun içeriğe sahip dosya
içeriklerinde gezinmemiz gerekebiliyor. Bu durumda dosya içeriğini sayfa
sayfa atlamak için kullanabileceğimiz kısayollar da mevcut.

İmlecimizin bulunduğu satırdan itibaren ekranımıza sığacak kadarlık
dosya içeriğinin devamına atlamak için yani bir sayfa ileri atlamak için
"**f**orward" yani "ileri" ifadesinin kısaltmasından gelen Ctrl + f
kısayolunu kullanabiliyoruz. Benzer şekilde birer sayfa geri atlamak
için de "**b**ackward" yani "geri" ifadesinin kısaltmasından gelen Ctrl
+ b kısayolunu kullanabiliyoruz.

Silme, Kesme, Kopyalama, Yapıştırma
-----------------------------------

Silme, kopyalama, kesme ve yapıştırma gibi işlemleri komu modundayken
gerçekleştiriyoruz.

### Silmek

İmlecin üzerinde bulunduğu tek bir karakteri silmek için x
![vi-x](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-x.gif)

İmlecin sağında kalan kelimeyi veya kelime parçası silmek için
"**d**elete **w**ord" ifadesinin kısalmasından gelen dw
![vi-dw](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-dw.gif)

İmlecin üzerinde durduğu satırın tamamını silmek istersek dd kısayolunu
kullanabiliyoruz.
![vi-dd](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-dd.gif)

Ayrıca silinme sınırını belirtmemiz de mümkün. Örneğin imleçten sonraki
3 satırın silinmesi için 3dd

İmleçten itibaren 5 karakterin silinmesi için 5x
![vi-5x](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-5x.gif)

İmleçten sonraki 2 kelimenin silinmesi için 2dw şeklinde yazabiliriz.
![vi-2dw](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-2dw.gif)

### Kopyalama Yapıştırma

Silme işleminden yeterince bahsettik. Şimdi kopyalama kesme ve
yapıştırma işlemlerinden de bahsedelim.

Vi editörü üzerinde kopyalama ve yapıştırma işlemi için "**copy paste**"
kavramları yerine "**yank put**" kavramları kullanıldığı için bir satırı
kopyalamak için "**y**ank" ifadesinden gelen y kısayolu kullanılıyorken,
kopyalanan veya kesilen satırın yapıştırılması için de "**p**ut"
ifadesinin kısalmasından gelen p kısayolu kullanılıyor.
![vi-yp](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-yp.gif)

### Kesme Yapıştırma

Kopyalama işlemi yerine kes yapıştır işlemi için de ilgili satırı önce
dw veya dd ile silip daha sonra p ile istediğimiz yere
yapıştırabiliyoruz.
![vi-dd-dw-p](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-dd-dw-p.gif)

Tabii ki yapıştırma işleminde de istediğimiz sayıda kopyanın
yapıştırılmasını spesifik olarak belirtebiliyoruz. Örneğin en son
kestiğim satırın 3 kez yapıştırılmasını istersem 3p şeklinde yazmam
yeterli.
![vi-3p](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-3p.gif)

### Spesifik Aralığı Kopyalama ve Kesme

Ben kopyalama veya kesme işleminde tek satır üzerinden gösterdim ancak
istediğiniz kadar karakter veya kelimeyi nasıl kesebileceğinizi veya
kopyalayabileceğinizi zaten biliyorsunuz. Örneğin ben imlecimden sonraki
3 kelimenin kopyalanmasını istersem 3yw şeklinde komutumu girebilirim.
Yani bu örnekler üzerinden de bizzat gördüğümüz gibi, öğrendiğimiz tüm
kısayolları bir arada kullanabiliyoruz. Mesela 2 karakteri kesip başka
bir yere 5 kez yapıştırmak istersek: öncelikle 2x ile kesip daha sonra
5p ile 5 kez yapıştırabiliyoruz.

Araştırma
---------

Dosya içeriğinde araştırma yapmak için komut modundayken /aranacak-veri
yazıp enter ile araştırma yapabiliyoruz. Bulunan eşleşmelerde ileri geri
geçiş yapmak için de n ve shift + N tuşlarını kullanıyoruz.
![vi-search](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-search.gif)

Örnekleri inanılmaz esneklikte çoğaltmamız mümkün ama bence gerek yok.
Çünkü temel kısayolları bildiğinizde geriye yalnızca pratik yapmak
kalıyor. Size bahsettiğim manipülasyon kısayolları ile metin editöründe
10 parmak klavye kullanımı ile hızlıca tüm işlerinizi yerine
getirebilirsiniz. Burada önemli olan bu kısayollara alışmak. Alışmak
için de bir süre kullanmanız gerekiyor. Mesela 2 hafta boyunca her gün
düzenli olarak kendi kendinize kısa kısa çalışırsanız ne kadar
hızlandığınızı siz de fark edeceksiniz. Tabii ki ben tüm kısayollardan
da bahsetmedim ancak zaten temel metin görüntüleme ve düzenleme
işlemleriniz için öğrendiklerimiz fazlasıyla yeterli. Daha fazlası için
çok kısa bir araştırma yapabilirsiniz. İnternette "[Vim Cheat
Sheet](https://vim.rtorr.com/)" şeklinde araştırdığınızda neredeyse tüm
kısayollar hakkında pratik bilgiler sunan yerli ve yabancı pek çok
rehberi kolayca bulabilirsiniz.

Kaydetme ve Çıkış
-----------------

Mevcut dosyadaki değişiklikleri kaydetmek isterseniz komut modundayken
"**w**rite" ifadesinden gelen :w yazıp enter ile onaylamanız yeterli.

Eğer değişiklikleri kaydedip editörden çıkış yapmak isterseniz
"**w**rite **q**uit" ifadesinden gelen de :wq yazıp enter ile kaydedip
çıkabilirsiniz.

Eğer değişiklikleri kaydetmeden çıkmak isterseniz :q! yazıp enter ile
editörü kapatabilirsiniz.

![vi-save-exit](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vi-save-exit.gif)

Vi editöründen çıkmak son derece kolay ancak bilmeyenler için kesinlikle
bir eziyete dönüşüyor. Biraz araştırırsanız, insanların "**vi**" veya
"**vim**" hakkında en çok sorduğu sorunun, editörden nasıl çıkılacağı
olduğunu görebilirsiniz. Dolayısıyla vi editörünü temel düzeyde
bilmenin, hiç değilse çıkış yapabilmenin bir itibar meselesi olduğunu
düşünüyorum :)

![vim--exit](https://www.linuxdersleri.net/egitim/temel-linux/metin-editoru/vim.png)

İşin şakası bir yana, eğer "vi" editörüne gereken fırsatı tanır ve
özveriyi gösterirseniz ne kadar işlevsel olabileceğine kendiniz de
şaşıracaksınız.

Benim vi editörü hakkında bahsetmek istediklerim bu kadar. Ancak elbette
vi editörü benim anlattıklarımla kesinlikle sınırlı değil. Biraz
araştırırsanız ne kadar çok özelliği olduğunu bizzat görebilirsiniz.

Ayrıca anlatımın başında **vi** editörü dışında "**vim**" ve "**gvim**"
gibi alternatifler olduğundan kısaca bahsetmiştim. Hatta bunlar dışında
"**neovim**" gibi alternatifler de var. Bu alternatiflerin hepsi, **vi**
editörüne daha fazla fonksiyon ekleyen alternatiflerdir. Yani temelde
burada vi hakkında konuştuklarımız aynen bu editörlerde de geçerli ancak
bu editörlerde vi editöründen daha fazla özellik sunuyor. Biraz
araştırırsanız ne gibi artıları olduğunu ve aralarındaki farkları
kolayca öğrenebilirsiniz. Araştırdığınızda aslında ne kadar geniş çaplı
ve esnek bir editör yapısı olduğuna eminim şaşıracaksınız. Hatta
yaygınlığı dolayısıyla kullanmakta olduğunuz sistemde vim veya gvim
araçları varsayılan olarak yüklü olabilir. Yüklü değilse bile zaten
kolayca kurulumlarını yapabilirsiniz çünkü çok yaygın editörler. Mutlaka
sizin kullandığınız işletim sisteminin paket depolarında da mevcuttur.

Vi editörü anlatımının burada sonuna geliyoruz. Ancak dediğim gibi zaten
"vi" ve özellikle "vim" editörü başlı başına bir dokümantasyon konusu ki
bu bilgileri burada izah etsem bile fazlaca gereksiz ayrıntıya değinmiş,
sizlere ve kendimi boş yere yormuş olurdum. Daha fazla bilgi için
gerektiğinde ben de yardım sayfalarını kullanıyorum. Yani ben de
yalnızca en temel işlevleri biliyorum.

İnternette yer alan tüm zengin kaynaklar ile birlikte man kılavuz
sayfasından veya doğrudan vim editörü içerisinde iken `:help` komutundan
kolayca bilgi edinip öğrendiklerinizi pratiğe geçirebilirsiniz.

Ve unutmayın bu araç ancak ve ancak, öğrenmek isteyen kişinin kendi
kendine kurcalaması ve bolca alıştırmalar yapmasıyla öğrenilebilir. Tek
ihtiyacınız pratiklik kazanmak için vi editörünü bir süre boyunca
kullanmak. Örneğin 1-2 hafta boyunca tüm metin düzenlemelerinizi "vi"
üzerinden gerçekleştirmeye çalışırsanız zaten kısayollara kolayca
alıştığınızı ve aslında editörün ne kadar etkili kullanılabileceğini
bizzat görmüş olacaksınız. Hatta benim bahsettiğim kısayollar yetmediği
durumda ekstra araştırma ile işlevsel olan kısayolları kendi kendinize
keyfedebilirsiniz. Temel kısayolları öğrenmek için kendinize biraz
fırsat tanıyın.

Ben yalnızca en temelde ihtiyaç duyabileceklerimizden bahsetmiş oldum.
Benden şimdilik bu kadar. Geri kalan araştırma işini size bırakıyorum.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 10. Ders 117 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

pipe Hakkında
-------------

Şimdiye kadar sistem üzerindeki yapıların dosya olarak ele alındığından
ve dolayısıyla dosya içeriklerini yani baytları istediğimiz gibi
manipüle edilip yönlendirebilmenin neden çok önemli olduğundan pek çok
kez söz ettik. Her şeyin aslında bir bayt akışı olduğunu vurguladık hep.
Vurgulamaya da devam edeceğiz. Özetle sistemi komut satırı üzerinden
yöneten kişi olarak bizim işimiz gücümüz hep bayt akışlarını kontrol
etmek.

Şimdiye kadarki anlatımlarımızda dosya içeriklerinde birtakım
değişiklikler yapabileceğimiz bazı araçları tanıdık. Başka araçlardan da
bahsedeceğiz ancak devam etmeden önce birden fazla aracı birbirine
bağlayarak çalıştırmamıza yardımcı olan "**pipe**" yani "boru"
mekanizmasından bahsetmem gerekiyor.

Yönlendirme işlemleri sırasında girdileri ve çıktıları istediğimiz
şekilde nasıl aktarabileceğimizi öğrendik. Sizlerin de bildiği üzere
yönlendirme sırasında bir aracın çıktıları bir dosyaya veya bir
dosyadaki verileri de bir araca girdi olarak aktarabiliyoruz.

Pipe yapısına ihtiyaç duymamızdaki en temel iki sebep; hızlı çalışması
ve aynı anda paralel şekilde işlemler arasında aktarım yapılabilmesi.

Burada bahsi geçen pipe mekanizmasını dik çizgi `|` operatörü sayesinde
kullanabiliyoruz. Pipe mekanizmasında, bu dik çizgi işaretinden önceki
komutun çıktıları üretildikleri sıralamaya uygun şekilde bu çizgiden
sonraki komuta girdi olarak aktarılıyor.

Yani veriler, ilk işlemin ürettiği sıraya uygun şekilde tek yönlü olarak
bir sonraki işleme aktarılıyor. Daha iyi anlamak adına çalışma yapısına
daha yakından bakalım.

Basit bir örnek üzerinden gidecek olursak; Diyelim ki ben `find` komutu
ile ***/etc*** dizini altında sonu "***.sh***" uzantısıyla biten
dosyaları araştırmak, bulunan dosyaları isimlerine göre alfanümerik
olarak sıralamak ve daha sonra numaralandırmak istiyorum. Bu işi yapacak
**tek bir araç** var mı varsa da hangi seçenekleri kullanmalıyım tam
olarak bilmiyorum. Ancak her birini yapan ayrı ayrı üç araç biliyorum.
`find` `sort` ve `nl` araçları ilk aklıma gelenler. Sizin şu anda `find`
aracını bilmediğinizin farkındayım, ancak merak etmeyin ileride bu
aracımızı da ayrıca ele alacağız. Şimdi pipe yapısının çalışma
mekanizmasını ele alabilmek için vereceğim örneğe odaklanmanız yeterli.
Neticede ihtiyacım olan sonuca ulaşabilmek için bu üç aracı bir arada
kullanabilirim.

Öncelikle sonu "***.sh***" uzantısı ile biten dosyaların bulunabilmesi
için `find /etc -name *.sh -type f` komutunu giriyorum.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.sh" -type f                             
/etc/init.d/keyboard-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/console-setup.sh
find: ‘/etc/ipsec.d/private’: Permission denied
find: ‘/etc/vpnc’: Permission denied
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/macchanger/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
find: ‘/etc/ssl/private’: Permission denied
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/vte-2.91.sh
/etc/profile.d/bash_completion.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_font.sh
find: ‘/etc/polkit-1/localauthority’: Permission denied
```

Bakın "***/etc***" dizini altında dosya ismi "***.sh***" ile biten tüm
dosyalar listelenmiş oldu. Hatta daha temiz bir çıktı almak istersek,
yetki hatalarını "***/dev/null***" dosyası aracılığı ile yok edebiliriz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.sh" -type f 2>/dev/null                 
/etc/init.d/keyboard-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/console-setup.sh
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/macchanger/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/vte-2.91.sh
/etc/profile.d/bash_completion.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_font.sh
```

Şimdi bu çıktıları alfabetik olarak sıralamak istediğim için `sort`
aracına aktarmam gerekiyor. Aktarmak için pipe kullanabilirim. Pipe
çubuk `|` simgesi ile kullanılıyor.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.sh" -type f 2>/dev/null | sort
/etc/console-setup/cached_setup_font.sh
/etc/console-setup/cached_setup_keyboard.sh
/etc/console-setup/cached_setup_terminal.sh
/etc/init.d/console-setup.sh
/etc/init.d/hwclock.sh
/etc/init.d/keyboard-setup.sh
/etc/macchanger/ifupdown.sh
/etc/profile.d/bash_completion.sh
/etc/profile.d/dotnet-cli-tools-bin-path.sh
/etc/profile.d/gawk.sh
/etc/profile.d/taylan.sh
/etc/profile.d/vte-2.91.sh
/etc/wpa_supplicant/action_wpa.sh
/etc/wpa_supplicant/functions.sh
/etc/wpa_supplicant/ifupdown.sh
/etc/xdg/plasma-workspace/env/taylan-themes.sh
```

Bakın `find` aracının üretmiş olduğu çıktılar `sort` aracına aktarılıp
`sort` aracının sıralama yapıp sonuçlarını konsola yönlendirmesi ile
sonuçlanmış oldu. Sıralama işleminden sonra da, sıralanmış çıktıları
numaralandırmak için de `sort` aracının çıktılarını `nl` aracına
aktarabilirim.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.sh" -type f 2>/dev/null | sort | nl      
     1  /etc/console-setup/cached_setup_font.sh
     2  /etc/console-setup/cached_setup_keyboard.sh
     3  /etc/console-setup/cached_setup_terminal.sh
     4  /etc/init.d/console-setup.sh
     5  /etc/init.d/hwclock.sh
     6  /etc/init.d/keyboard-setup.sh
     7  /etc/macchanger/ifupdown.sh
     8  /etc/profile.d/bash_completion.sh
     9  /etc/profile.d/dotnet-cli-tools-bin-path.sh
    10  /etc/profile.d/gawk.sh
    11  /etc/profile.d/taylan.sh
    12  /etc/profile.d/vte-2.91.sh
    13  /etc/wpa_supplicant/action_wpa.sh
    14  /etc/wpa_supplicant/functions.sh
    15  /etc/wpa_supplicant/ifupdown.sh
    16  /etc/xdg/plasma-workspace/env/taylan-themes.sh
```

Neticede gördüğünüz gibi tam olarak istediğim işlevi yerine getirmek
için birden fazla aracı pipe ile birbirine bağlamış oldum.

Peki bu çıktıyı tam olarak nasıl elde ettik yani pipe tam olarak nasıl
çalışıyor ?

Bizim girdiğimiz komutta bulunan üç farklı araç aynı anda üç ayrı işlem
olarak başlatıldı. İlk aracın standart çıktısı ikinci aracın standart
girdisine bağlandı. İkinci aracın standart çıktısı da üçüncü aracın
standart girdisine bağlandı. Üçüncüsü de özellikle başka bir yere
yönlendirilmediği için çıktılarını konsola(***/dev/tty*** olarak temsil
edildi) bastırmış oldu.

![9.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/9.webp)

Elbette bu işlemi her bir komutun çıktılarını bir dosyaya aktarıp ilgili
dosyadan diğer araçların verileri okumasını sağlayarak da yapabilirdik
fakat bu komutu yazmak hem daha uğraştırıcı olacaktı hem de araçlarımız
pipe kullanımına oranla daha verimsiz çalışacaktı. Hemen bu durumu
gözlemleyelim.

Aynı işlemi bu kez dosyalara yönlendirme ile deneyelim. Öncelikle komutu
yazalım, daha sonra açıklayacağım.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.sh" -type f 2> /dev/null > bul ; sort < bul > sırala ; nl < sırala
     1  /etc/console-setup/cached_setup_font.sh
     2  /etc/console-setup/cached_setup_keyboard.sh
     3  /etc/console-setup/cached_setup_terminal.sh
     4  /etc/init.d/console-setup.sh
     5  /etc/init.d/hwclock.sh
     6  /etc/init.d/keyboard-setup.sh
     7  /etc/macchanger/ifupdown.sh
     8  /etc/profile.d/bash_completion.sh
     9  /etc/profile.d/dotnet-cli-tools-bin-path.sh
    10  /etc/profile.d/gawk.sh
    11  /etc/profile.d/taylan.sh
    12  /etc/profile.d/vte-2.91.sh
    13  /etc/wpa_supplicant/action_wpa.sh
    14  /etc/wpa_supplicant/functions.sh
    15  /etc/wpa_supplicant/ifupdown.sh
    16  /etc/xdg/plasma-workspace/env/taylan-themes.sh
```

Bu girdiğimiz komutta önce `find` komutu çalıştırılacak ve işini
tamamladığında, çıktılarını "***bul***" isimli dosyaya aktaracak. Daha
sonra `sort` komutu, "***bul***" isimli dosyayı okuyacak ve içeriğindeki
verileri sıraladıktan sonra "***sırala***" isimli dosyaya aktaracak. En
son `nl` komutu "***sırala***" isimli dosyadaki içeriği okuyup
numaralandıracak ve çıktısını konsolumuza basacak. İşte girdiğimiz
komutun çalışma yapısı tam olarak bu. Komutların arasında girmiş
olduğumuz noktalı virgül karakterleri tek satırda belirtmiş olduğumuz bu
komutların sırasıyla çalıştırılmasını sağlıyor. İleride bu konudan da
ayrıca bahsedeceğiz.

![10.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/10.webp)

Bakın pipe yerine kullandığımız bu yönlendirme alternatifini yazması ve
açıklaması dahi uzun sürdü.

Çalışma hızı ise pipe'a oranla daha yavaş olacak çünkü bu kullanımda
komutlar sırasıyla tek tek ve disk üzerindeki dosyalara veri yazıp
okuyarak çalıştırılıyor. Dolayısıyla soldan sağa doğru bir komut
çalışmasını tamamlamadan, bir sonraki komut çalıştırılmıyor. Ve disk
üzerinde okuma yazma yapıldığı için disk hızına bağlı bir çalışma hızı
söz konusu.

Pipe kullanımında ise tüm komutlar ayrı işlem olarak aynı anda paralel
şekilde çalıştırılıyor. Her bir aracın ürettiği çıktı da üretilir
üretilmez boru hattındaki diğer işlemlere disk üzerine veri yazılıp
okunmasına gerek kalmadan sanal dosya sistemi(bellek üzerinden)
aktarıldığı için veriler çok daha hızlı işlenmiş oluyor. Bir komut çıktı
üretir üretmez, çıktının üretilme sıralaması korunarak bir sonraki işlem
aktarıyor, bu sayede tüm veriler sırasıyla işlenmiş oluyor. Tabii ki
bizim örneğimizde ilk aracın ürettiği çıktıların hepsinin alındıktan
sonra sıralaması gerektiği için `sort` aracı `find` aracının çıktılarını
bitirmesini bekledi aslında. Yani araçlar paralel çalışıyor olsalar da
çıktıların gönderilme ve okunma durumlarına bağlı olarak birbirlerini de
bekleyebiliyorlar. Yine de pipe mekanizması disk üzerindeki dosyalara
okuma yazma yapmadığı ve araçları paralel olarak aynı anda
çalıştırabildiği için çok daha verimli bir yaklaşım. Üstelik basit örnek
üzerinden de görebildiğiniz gibi birden fazla aracı birbirine bağlayarak
çalıştırmak istediğimizde pipe ile komut girmek çok da daha kolay ve
kısa.

Ayrıca örnek üzerinde peşi sıra pipe kullandığımız bu komutun bütününe
de "**pipeline**" yani "boru hattı" deniyor. Neticede birden fazla pipe
yani boru kullanarak ikiden fazla aracı birbirine bağladığımız için boru
hattı oluşturmuş oluyoruz.

Tıpkı buradaki örneğimizde olduğu gibi ihtiyacımıza yönelik spesifik
çözüm için bildiğimiz birden fazla aracın basit özelliklerini pipe
yardımıyla bir arada kullanabiliyoruz. Bu yaklaşım sayesinde pek çok
işlevi olan tek bir karmaşık araç yerine, basit işlevleri olan pek çok
aracı farklı kombinasyonlar ile birlikte kullanıp sınırsız çeşitlilikte
çözüm üretebiliyoruz. Zaten zaman içinde pipe yapısını ister istemez ne
kadar sık kullandığınıza bizzat şahit olacaksınız.

`xargs` Komutu
--------------

Pipe yapısından bahsederken, pipe'ın önceki işlemden gelen standart
çıktıları sonraki işleme standart girdi olarak aktardığını söylemiştim.
Eğer pipe ile veri yönlendirmek istediğiniz araç yalnızca argüman alarak
çalışıyorsa yani standart girdiden veri kabul etmiyorsa tabii ki ilgili
veriler araç tarafından alınıp işlenmiyor. Dolayısıyla pipeline olarak
ifade ettiğimiz boru hattı tıkanmış oluyor.

İşte bu duruma çözüm olarak da `xargs` isimli aracı kullanabiliyoruz.

`xargs` aracı, standart girdiden okuduğu verileri kendisinden sonraki
komutun argümanı olarak iletebiliyor. Bu sayede standart girdiden veri
kabul etmeyen araçları, tıpkı biz elle o araca argümanlar girmişiz gibi
çalıştırabiliyoruz. `xargs` aracının isminin açılımı da zaten
"e**X**tended **ARG**ument**S**" yani "genişletilmiş argümanlar"
ifadesinden geliyor.

Bu aracın çok fazla seçeneği var ama şimdilik temel kullanımı hakkında
bilgi sahibi olmamız yeterli.

Ben çok basit bir örnek vermek istiyorum. Bunun için öncelikle
içerisinde veri bulunan dosyamı oluşturmak üzere
`echo “dosya1 dosya2 dosya3” > oku-beni` şeklinde komutumu giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "dosya1 dosya2 dosys3" > oku-beni

┌──(taylan@linuxdersleri)-[~]
└─$ cat oku-beni 
dosya1 dosya2 dosys3
```

Bakın buraya yazmış olduğum ifadeler dosyama kaydolmuş. Şimdi ben bu
dosyada geçen ifadelerin kullanılarak yeni dosyalar oluşturulması için
`touch` aracına bu dosyadan veri yönlendirmek istiyorum.

Bunun için `cat oku-beni` komutuyla dosyanın okunup pipe ile bu
çıktıların `touch` aracına yönlendirilmesini sağlayabiliriz.

``` {.bash}
└─$ cat oku-beni | touch
touch: missing file operand
Try 'touch --help' for more information.
```

Gördüğünüz gibi `touch` komutu oluşturulacak dosya isimleri argüman
olarak iletilmediği için hata verdi. Bu hatanın argüman eksikliğinden
kaynaklandığını teyit etmek istersek tekrar yalnızca `touch` komutunu
girebiliriz.

``` {.bash}
└─$ touch
touch: missing file operand
Try 'touch --help' for more information.
```

Bakın yine aynı hatayı aldık çünkü `touch` aracına herhangi bir dosya
ismini argüman olarak iletmedik.

`touch` aracı yalnızca kendisine argüman olarak iletilen verileri
işleyip standart girdiden veri okumadığı için pipe ile ilettiğimiz
"***oku-beni"*** dosyasının içeriği `touch` aracı tarafından işlenmedi.
Bu durumda bu çıktıları önce `xargs` aracına yönlendirip oradan da
`touch` aracına argüman olarak iletilmelerini sağlayabiliriz. Ben bunun
için komutumu bu kez `cat oku-beni | xargs touch` şeklinde yazıyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat oku-beni | xargs touch 

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ ls                                                           
dosya1  dosya2  dosys3  oku-beni
```

Bakın tam olarak dosyada bulunan veriler ile aynı isimde yeni dosyalar
oluşturulmuş. Yani `xargs` aracının standart girdiden okuduğu verileri
hemen yanındaki komutun argümanı olarak çalıştırdığını bizzat teyit
etmiş olduk.

![11.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/11.webp)

`xargs` aracı kendisine girdi olarak verilerin tüm verileri standart
şekilde boşluklarından parçalara ayırıp bunların her birini hemen
yanındaki komuta ayrı ayrı argüman olarak iletiyor. Zaten bu sebeple
benim bu dosyada aralarında boşluk bırakarak yazdığım tüm verilerim
argüman olarak `touch` aracına iletildi.

İşte bu yaklaşım sayesinde standart girdiden veri kabul etmeyen yani
yalnızca argüman olarak çalışan araçlara kolaylıkla veri yönlendirmesi
yapabiliyoruz. Neticede `xargs` aracının en temel kullanımı bu şekilde.
Artık en temel kullanım amacını bildiğiniz için geri kalan tüm detaylar
için yardım sayfalarına göz atmanız yeterli.

`tee` Komutu
------------

Biz pipe yapısını kullandığımızda verilerimiz yalnızca tek yönlü şekilde
aktarılıyor. Eğer biz hem bir sonraki işleme hem de bir dosyaya aynı
verilerin yazılmasını istiyorsak, bu işlem için `tee` aracını
kullanmamız gerekiyor. Çünkü pipe mekanizması tek başına bunu
desteklemiyor. Pipe mekanizmasını düz boru `|` olarak düşünecek olursak
buradaki `tee` aracı da bildiğiniz `T` boru görevi görüyor. İlk işlemden
aldığı çıktıyı okuyor, istenilen dosyaya ve aynı zamanda bir sonraki
işlemin standart girdisine yönlendiriyor.

Basit bir örnek üzerinden ele alabiliriz. Örneğin `ls /` komutu ile
"***/***" yani ana dizin altındaki dosyaları listeleyecek olursak uzun
bir liste alırız.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls /                                                         
bin   home            lib32       media  root  sys  vmlinuz
boot  initrd.img      lib64       mnt    run   tmp  vmlinuz.old
dev   initrd.img.old  libx32      opt    sbin  usr
etc   lib             lost+found  proc   srv   var
```

Ben uzun bir liste istemiyorum. Eğer yalnızca ilk 10 satırı listelemek
istersem pipe ile verileri `head` komutuna aktarabilirim. Buradaki
`head` aracı, aldığı verilerin yalnızca ilk 10 satını çıktı olarak
iletildiği için kullandık. İleride bu araçtan ayrıca bahsediyor
olacağız. Şimdi komutumuzu girip deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ls / | head
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
```

Bakın yalnızca ilk 10 içerik listelenmiş oldu. Ben `ls` komutunun tüm
çıktılarının bir dosyaya kaydedilmesini hem de `head` komutu ile
yalnızca ilk 10 satırını okumak istiyor da olabilirim. Bunun için `tee`
komutunu kullanabilirim. Yani komutumuzu `ls / | tee liste.txt | head`
şeklinde yazabiliriz. Bu komut sayesinde ilk olarak `ls` aracı "***/***"
dizini altındaki tüm içeriği listeleyip pipe ile `tee` aracına
aktaracak. `tee` aracı da aldığı çıktıyı "***liste.txt***" isimlide
dosyaya kaydedecek ve ayrıca aynı verileri `head` aracına pipe ile
yönlendirecek. `head` aracı da aldığı verilerden yalnızca ilk 10 satırı
konsola çıktı olarak bastıracak.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ls / | tee liste.txt | head                                  
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın ilk 10 satır konsola basılmış oldu. Şimdi "***liste.txt***"
dosyasının içeriğine bakalım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste.txt                              
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
libx32
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
vmlinuz
vmlinuz.old
```

Gördüğünüz gibi `ls` komutunun tüm çıktıları da bu listeye kaydedilmiş.
Yani `tee` komutu `ls` komutunun çıktılarını hem dosyaya hem de bir
sonraki işlem olan `head` işlemine iletmiş oldu. Burada fark ettiyseniz
`tee` aracı kendisine verilen tüm verileri hem dosyaya hem de bir
sonraki araca eksiksiz şekilde iletiyor. İşte `tee` komutu pipeline
üzerinde bu amaçla sıklıkla kullanılıyor.

![12.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/12.webp)

Mesela `ls / | head | tee liste.txt` şeklinde komut girecek olursak size
nasıl bir çıktı alırız ? Hemen girip deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls / | head | tee liste.txt
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64

┌──(taylan@linuxdersleri)-[~]
└─$ cat liste.txt                                                
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın `ls /` komutunun çıktıları pipe ile `head` aracına iletildi.
`head` aracı da ilk 10 satırı alıp `tee` aracına iletti. `tee` aracı da
kendisine iletilen bu 10 satırı hem "***liste.txt***" dosyasına hem de
konsola yönlendirdi. Bu sebeple hem konsol çıktısında hem de
"***liste.txt***" dosyasında ilk 10 satırı almış olduk.

![13.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/13.webp)

Bence buradaki iki örnek `tee` aracının nasıl çalıştığını gayet iyi
biçimde özetliyor.

Bu temel yaklaşım dışında, birden fazla dosyaya aynı veriyi kaydetmek
isterseniz, dosyaların isimlerini argüman olarak vermeniz yeterli. Ben
denemek için aynı komutu çağırıp, bir dosya ismi daha belirtiyorum ve
komutumu bu şekilde onaylıyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ls / | head | tee liste.txt liste2.txt          
bin
boot
dev
etc
home
initrd.img
initrd.img.old
lib
lib32
lib64
```

Şimdi `paste` komutu ile her iki dosyayı da yan yana bastırabiliriz.

``` {.python}
┌──(taylan@linuxdersleri)-[~]
└─$ paste liste.txt liste2.txt 
bin     bin
boot    boot
dev     dev
etc     etc
home    home
initrd.img      initrd.img
initrd.img.old  initrd.img.old
lib     lib
lib32   lib32
lib64   lib64
```

Gördüğünüz gibi aynı verileri birden fazla dosyaya da
yönlendirebiliyoruz.

`tee` yaklaşımı sayesinde dilersek standart(`<` `>` `&>` vs..)
yönlendirmelerin alternatifi olarak, yönlendirmelerin hem konsola hem de
dosyalara kaydolmasını da sağlayabiliriz. Normalde sizin de bildiğiniz
gibi eğer bir komutun çıktısını bir dosyaya yönlendirirsek konsola bir
çıktı basılmaz. Hemen teyit etmek için `ls > liste` şeklinde komutumuzu
girelim.

``` {.scss}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ ls > liste                                                   

┌──(taylan@linuxdersleri)-[~/klasor]
└─$
```

Bakın `ls` komutunun çıktısı konsola basılmadı çünkü `ls` komutunun
çıktıları belirttiğim dosyaya yönlendirildi. `cat` komutu ile de bu
durumu teyit edebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat liste                                                    
dosya1
dosya2
dosys3
liste
oku-beni
```

Şimdi aynı örneği `tee` komutunu ile tekrarlayalım. `ls | tee liste2`
şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ ls | tee liste2                                              
dosya1
dosya2
dosys3
liste
liste2
oku-beni

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat liste2                                                   
dosya1
dosya2
dosys3
liste
liste2
oku-beni
```

Bakın `tee` aracı sayesinde `ls` komutunun çıktıları konsola
bastırılmakla birlikte dosyaya da kaydedilmiş. Eğer ben `tee` aracından
sonra bir pipe daha kullanıp bir araç ismi yazsaydım `tee` aracının
elindeki veriler bu araca yönlendirilecekti. Fakat `tee` aracından sonra
bir araç ismi girmediğim için `tee` aracı elindeki verileri dosyaya
yazmasının yanı sıra standart çıktı adresi olan konsola da bastırmış
oldu.

![14.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/14.webp)

`tee` aracının kullanımı gördüğünüz gibi son derece kolay olduğu için
daha fazla örneğe gerek yok. Yine de son olarak birkaç kullanım detayını
daha bilmenizde fayda var.

Üzerine Ekleme
--------------

Normalde `tee` komutu aynı isimde bir dosya varsa onun üzerine yazar.
Yani o dosyanın içeriğini yok edip, elindeki verileri o dosyaya yazar.
Eğer aynı isimli dosya varsa dosya içeriğinin sonuna yeni verilerin
eklenmesini istersek "**a**ppend" yani "ekleme" ifadesinin kısaltması
olan `a` seçeneğini kullanabiliriz.

Ben denemek için `echo "deneme" | tee deneme.txt` komutunu giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ echo "deneme" | tee deneme.txt                               
deneme

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat deneme.txt                                
deneme
```

Bakın veri kaydolmuş. Şimdi aynı dosyaya bu kez farklı veri göndermek
için `echo “test” | tee deneme.txt` şeklinde aynı dosyanın ismini de
yazıp komutumuzu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ echo "test" | tee deneme.txt                               
test

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat deneme.txt                                               
test
```

Bakın dosyanın eski içeriği silinip `tee` aracının en son yönlendirdiği
veri eklenmiş. Bizzat gördüğümüz gibi `tee` aracına özellikle
belirtmediğimiz sürece tıpkı tek yönlendirme `>` operatörü
kullandığımızdaki gibi hedefteki dosya içeriğinin üzerine yazılıyor.

Ben verileri dosyanın sonuna eklemek istediğim için "**a**ppend" yani
"ekleme" ifadesinin kısaltmasından gelen `a` seçeneği ile komutumu
tekrar girmek istiyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ echo "test2" | tee -a deneme.txt                             
test2

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat deneme.txt                                               
test
test2
```

Bakın `tee` aracın `echo` aracından "**test2**" ifadesini aldığı için
bunu konsola bastırdı. Ayrıca `tee` aracına `a` seçeneğini de
eklediğimiz için bu veriyi "***deneme.txt***" dosyasının sonuna ekliyor.
Kısacası tıpkı yönlendirme operatörlerinde bir dosyanın sonuna yeni veri
eklemek için çift operatör `>>` kullandığımız gibi `tee` komutu için de
`a` seçeneğini kullanmamız gerekiyor. **Aksi halde `tee` aracı aynı
isimli dosyanın üzerine yeni verileri yazıp eskilerini yok ediyor.**

Son olarak hazır `tee` komutundan bahsetmişken pratik bir kullanımından
da bahsetmek istiyorum. Diyelim ki yetkimiz olmayan bir dosyaya örneğin
***/etc/apt/sources.list*** dosyasına ekleme yapmak istiyoruz.

Normalde yetki gerektiren bir görevi yerine getirmek için komutumuzun en
başına `sudo` ifadesini yazıp eğer yetkimiz uygunsa çalıştırabiliyoruz.
Normalde ***/etc/apt/sources.list*** dosyasını düzenlemek için yetkimiz
yok fakat en yetkili kullanıcı gibi davranmak için komutumuzun başına
`sudo` yazı işlemi yerine getirmeyi deneyebiliriz.

Yani örneğin `sudo echo "eklenecek veri" >> /etc/apt/sources.list`
şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ sudo echo "eklenecek veri" >> /etc/apt/sources.list
bash: /etc/apt/sources.list: Permission denied
```

Ancak gördüğünüz gibi yetki hatası aldık. Halbuki ileri de ayrıca ele
alacağımız `sudo` komutu bizim yetkili şekilde bu dosyaya veri
ekleyebilmemizi sağlamalıydı.

Burada `sudo` komutu işe yaramadı çünkü **yönlendirmeler üzerinde `sudo`
komutunun etkisi bulunmuyor**. Yani yönlendirmeyi yine mevcut yetkisiz
kullanıcımız yapmış oluyor. Dolayısıyla `sudo` komutunu kullansak dahi
yönlendirme operatörü ile, ilgili dosyaya veri yazma yetkisi
kazanamayız. Fakat bunun yerine `tee` komutunu `sudo` ile yetkili
şekilde çalıştırabiliriz. Hadi hemen deneyelim. Ben
`echo "####" | sudo tee -a /etc/apt/sources.list` şeklinde komutumu
yazıyorum. **Buradaki `a` seçeneğini unutmayın aksi halde bu çok önemli
dosyasının tüm içeriğinin silinmesine neden olabilirsiniz.**

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ echo "####" | sudo tee -a /etc/apt/sources.list
[sudo] password for taylan:       
yeni satır
```

Ve gördüğünüz gibi parolamızı girip komutu onayladığımızda herhangi bir
yetki hatası almıyoruz. `cat` komutuyla dosya içeriğine de bakalım.

``` {.perl}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat /etc/apt/sources.list
# See https://www.taylan.org/docs/general-use/taylan-linux-sources-list-repositories/
deb http://http.taylan.org/taylan taylan-rolling main contrib non-free

# Additional line for source packages
# deb-src http://http.taylan.org/taylan taylan-rolling main contrib non-free
yeni satır
```

Bakın dosyanın en sonuna "**\#\#\#\#**" ifadesi eklenmiş.

**❗Dikkat:** Düzenleme yaptığımız dosya önemli bir konfigürasyon dosyası
olduğu için dosya yapısını bozmamak adına yalnızca "**\#\#\#\#**"
ifadesini ekledim. Eğer siz farkı bir veri eklerseniz sistemi güncelleme
ve paket yükleme noktasında sorunlar yaşayabilirsiniz. Bu sebeple
"**\#**" hariç bir karakter eklemeyin veya eklediyseniz de
`sudo nano /etc/apt/sources.list` komutu ile dosyayı açıp ilgili satırı
silin ve Ctrl + x ile dosyayı kaydedip kapatın.

Böylelikle yönlendirme operatörlerinin `sudo` ile yetki kazanamadığından
ve alternatif olarak `tee` komutu sayesinde yetkili şekilde dosya
içeriğine veri yönlendirebileceğimizden de haberdar olduk. Ele aldığımız
örnekleri de dikkate aldığımızda `tee` aracını tıpkı `T` boru gibi
düşünmek bence oldukça mantıklı. Konsol üzerinde hem standart çıktıya
hem de bir dosyaya yönlendirme yapmak istediğinizde veya bir yönlendirme
işlemini yetkili şekilde yapmak istediğinizde `tee` aracını
kullanabiliyoruz. Mesela ben en son girmiş olduğum komutta konsola çıktı
bastırılmadan yalnızca dosyaya veri yönlendirmek isteseydim standart
çıktıları ***/dev/null*** dizinine de yönlendirebilirdim. Ben denemek
için en son komutumu çağırıp bu kez sonuna `> /dev/null` şeklinde
yazıyorum ve komutumu bu şekilde onaylıyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~/klasor]
└─$ echo "####" | sudo tee -a /etc/apt/sources.list > /dev/null  

┌──(taylan@linuxdersleri)-[~/klasor]
└─$ cat /etc/apt/sources.list                                    
# See https://www.taylan.org/docs/general-use/taylan-linux-sources-list-repositories/
deb http://http.taylan.org/taylan taylan-rolling main contrib non-free

# Additional line for source packages
# deb-src http://http.taylan.org/taylan taylan-rolling main contrib non-free

####
####
```

Bakın konsola herhangi bir çıktı bastırılmadı çünkü standart çıktıyı
***/dev/null*** dosyasına yönlendirerek yok etmiş oldum. Siz de bu
şekilde pipe üzerinden gelen verileri bir dosyaya yazmak istediğinizde
bu yaklaşımı kullanabilirsiniz.

**❗Dikkat:** Örneklerimiz sırasında kullandığımız bu
***/etc/apt/sources.list*** dosyası, sistemin paket yönetimi için önemli
bir dosya. O sebeple `sudo nano /etc/apt/sources.list` ile bu dosyayı
tekrar açıp, eklediğiniz gereksiz verileri silmenizi öneriyorum. Aksi
halde paket yönetimi konusunda sorun yaşayabilirsiniz.

`grep` Komutu
-------------

`grep` aracının ismi "**g**lobal **r**egular **e**xpression **p**rint"
ifadesinin kısaltmasından geliyor. Ve tam olarak isminde de olduğu
şekilde "regex" sayesinde verileri filtreleme konusunda çok yetenekli
bir araç.

`grep` aracı standart girdiden veya kendisine argüman olarak verilmiş
olan dosyadan veri okuyup filtreleyebiliyor. Hemen bizzat görmek için en
temel kullanımıyla başlayabiliriz.

Ben denemek için ***/etc/passwd*** dosyasında kaç kez "**false**"
ifadesinin geçtiğini öğrenmek üzere `grep` komutundan sonra araştırmak
istediğim kelimeyi ve daha sonra da hangi dosyada araştırılacağını
`grep "false" /etc/passwd` şeklinde giriyorum.

![15.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/15.webp)

Bakın içerisinde "**false**" ifadesi bulunan tüm satırlar listelendi.
Benzer şekilde aslında standart girdiden alınan veriler de `grep`
tarafından işlendiği için komutumuzu `cat /etc/passwd | grep false`
şeklinde de girebilirdik.

![16.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/16.webp)

Bakın yine aynı sonucu elde ettik çünkü `cat` aracı ***/etc/passwd***
dosyasının içeriğini pipe ile `grep` aracına aktardı, `grep` de benim
istediğim doğrultusunda içinde "**false**" ifadesi geçen satıları
filtreleyip standart çıktıya yani konsola yönlendirdi. İşte `grep`
aracının en temel kullanımı bu şekilde. İster dosyadan isterseniz de
standart girdiden `grep` aracına veri yönlendirip verilerin okunmasını
sağlayabilirsiniz.

Şimdi ben `grep` aracının birkaç farklı kullanım özelliğinden daha
bahsetmek istiyorum.

Ters Arama \| Hariç Tutmak
--------------------------

Aradığımız kelime ile eşleşen verileri nasıl filtreleyebileceğimizi ele
aldık. Eğer tersi şekilde aradığımız ifadenin geçmediği bölümleri
istersek bulun için `grep` aracının hariç tutma özelliğini
kullanabiliriz. Hariç tutma özelliğini kullanmak için de kısaca `v`
seçeneğini kullanabiliyoruz.

Yani örneğin ben ***/etc/passwd*** dosyasının içinde "false" ifadesinin
geçmediği satırları listelemek istersem `grep -v "false" /etc/passwd`
şeklinde komutumu girebilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -v "false" /etc/passwd                                                            
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
_apt:x:102:65534::/nonexistent:/usr/sbin/nologin
strongswan:x:105:65534::/var/lib/strongswan:/usr/sbin/nologin
systemd-timesync:x:106:112:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
redsocks:x:107:113::/var/run/redsocks:/usr/sbin/nologin
rwhod:x:108:65534::/var/spool/rwho:/usr/sbin/nologin
iodine:x:109:65534::/run/iodine:/usr/sbin/nologin
messagebus:x:110:114::/nonexistent:/usr/sbin/nologin
miredo:x:111:65534::/var/run/miredo:/usr/sbin/nologin
_rpc:x:112:65534::/run/rpcbind:/usr/sbin/nologin
usbmux:x:113:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
tcpdump:x:114:120::/nonexistent:/usr/sbin/nologin
rtkit:x:115:121:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:116:65534::/run/sshd:/usr/sbin/nologin
dnsmasq:x:117:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
statd:x:118:65534::/var/lib/nfs:/usr/sbin/nologin
avahi:x:119:125:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
nm-openvpn:x:120:126:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
stunnel4:x:121:127::/var/run/stunnel4:/usr/sbin/nologin
nm-openconnect:x:122:128:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologin
sslh:x:125:130::/nonexistent:/usr/sbin/nologin
postgres:x:126:131:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:128:135::/var/lib/saned:/usr/sbin/nologin
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
```

Bakın "false" ifadesinin geçtiği satırlar hariç tüm içerikler konsola
bastırıldı.

Ben yalnızca tek bir dosya üzerinde filtreleme yaptım ancak istersek
birden fazla dosyanın tüm içeriğinde de filtreleme yapabiliriz. Ben
denemek için ***/etc/passwd*** ve ***/etc/group*** dosya içeriklerinde
"**root**" ifadesinin aranmasını istiyorum. Bunun için
`grep “root” /etc/passwd /etc/group` şeklinde komutumu giriyorum.

![17.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/17.webp)

Bakın eşleşmiş olan satırlar hangi dosyada bulundukları da belirtilerek
filtrelenmiş oldu. Yani gördüğünüz gibi istersek aynı anda çoklu şekilde
dosyalar üzerinde de çalışabiliyoruz. Çoklu dosyalarla çalışmanın
yanında dilersek alt dizinlerdekiler de dahil bir dizin içindeki tüm
içeriklerin `grep` aracı tarafından filtrelenmesini sağlayabiliriz.
Bunun için özyineleme yani "**r**ecursive" seçeneğinin kısalması olan
`r` seçeneğini kullanabiliyoruz.

Özyinelemeli Araştırma
----------------------

Örnek olarak "***/etc/***" dizini içinde, içinde "bashrc" ifadesi geçen
tüm dosyaları filtrelemeyi deneyebiliriz. Bunun için
`grep -r “bashrc” /etc/ 2> /dev/null` şeklinde komutumu giriyorum.
Buradaki `-r` seçeneği benim hedef gösterdiğim bu dizinden başlayıp tüm
alt dizinler de dahil olmak üzere tüm dosyalarda "test" ifadesinin
geçtiği yerleri filtreleyip bana sunacak. Ayrıca yetki gibi nedenlerle
oluşacak olan hatalı çıktıları yok etmek için `2> /dev/null` komutunu da
ekledim.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -r "bashrc" /etc/ 2> /dev/null
/etc/skel/.bashrc.original:# ~/.bashrc: executed by bash(1) for non-login shells.
/etc/skel/.bashrc.original:# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
/etc/skel/.bashrc.original:# sources /etc/bash.bashrc).
/etc/skel/.profile:    # include .bashrc if it exists
/etc/skel/.profile:    if [ -f "$HOME/.bashrc" ]; then
/etc/skel/.profile:     . "$HOME/.bashrc"
/etc/skel/.bashrc:# ~/.bashrc: executed by bash(1) for non-login shells.
/etc/skel/.bashrc:# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
/etc/skel/.bashrc:# sources /etc/bash.bashrc).
/etc/apparmor.d/abstractions/bash:  @{HOME}/.bashrc                  r,
/etc/apparmor.d/abstractions/bash:  /etc/bashrc                      r,
/etc/apparmor.d/abstractions/bash:  /etc/bash.bashrc                 r,
/etc/apparmor.d/abstractions/bash:  /etc/bash.bashrc.local           r,
/etc/apparmor.d/abstractions/bash:  # run out of /etc/bash.bashrc
/etc/bash.bashrc:# System-wide .bashrc file for interactive bash(1) shells.
/etc/bash.bashrc.save.1:# System-wide .bashrc file for interactive bash(1) shells.
/etc/bash.bashrc.save:# System-wide .bashrc file for interactive bash(1) shells.
/etc/profile:    # The file bash.bashrc already sets the default PS1.
/etc/profile:    if [ -f /etc/bash.bashrc ]; then
/etc/profile:      . /etc/bash.bashrc
```

Bakın sırasıyla tüm dizinlerde gezildi ve "bashrc" ifadesi eşleşen
satırlar ilgili dosyanın ismi de başta olacak şekilde bize sunuldu. Bu
sayede kapsamlı şekilde istediğimiz spesifik kelime ile eşleşen
dosyaları bulmamız mümkün oluyor. Buradaki `r` seçeneğinin fonksiyonunu
teyit etmek isterseniz `r` seçeneği olmadan komutu tekrar girmeyi
deneyebilirsiniz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "bashrc" /etc/
grep: /etc/: Is a directory
```

Bakın ***/etc/*** adresinin bir dizin olduğu, yani dosya olmadığı için
"**bashrc**" ifadesi geçen bir eşleşme bulunamayacağı konusunda
uyarıldık. Bu sebeple alt dizinler de dahil, dizin içeriklerinde
araştırma yapılabilmesi için "özyinelemeli" araştırma yapmak üzere `r`
seçeneğini kullanmamız gerek.

Yalnızca Dizin İsimlerini Bastırmak
-----------------------------------

Eğer aradığımız ifadeyle eşleşen verilerin tam olarak hangi satırda
olduğunu görmek yerine yalnızca dosya isimlerinin bastırılmasını
istersek `l` seçeneğini de kullanabiliriz. Ben denemek için girmiş
olduğum komuta `l` seçeneğini ekleyeceğim.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -rl "bashrc" /etc/ 2> /dev/null
/etc/skel/.bashrc.original
/etc/skel/.profile
/etc/skel/.bashrc
/etc/apparmor.d/abstractions/bash
/etc/bash.bashrc
/etc/bash.bashrc.save.1
/etc/bash.bashrc.save
/etc/profile
```

Bakın bu kez yalnızca içerisinde benim aradığım ifadeyi bulunduran
dosyaların isimleri bastırılmış oldu. Çok daha derli toplu bir çıktı
elde etmiş olduk.

Şimdi ben `grep` aracının diğer özelliklerinden bahsetmek için uzun bir
isim listesi kullanmak istiyorum. Dilerseniz siz de
[buradan](https://www.linuxdersleri.net/egitim/temel-linux/metin/isimler.txt)
dosyayı indirip, anlatımları bu dosya üzerinden test edebilirsiniz.

[isimler.txt](https://www.linuxdersleri.net/egitim/temel-linux/metin/isimler.txt)

Tırnak Kullanımı
----------------

Mesela ben isimler.txt dosyasında tam olarak "**ahmet can**" ifadesinin
geçtiği satırları aramak istiyorum. Bunun için konsola
`grep ahmet can isimler.txt` şeklinde komut girmeyi deneyebiliriz.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ grep ahmet can isimler.txt                                                   
grep: can: No such file or directory
isimler.txt:ahmet
isimler.txt:ahmet kürşad
isimler.txt:ahmet ali
isimler.txt:kenan ahmet
isimler.txt:ahmet
isimler.txt:ahmet can durmus
isimler.txt:can ahmet furkan
```

Bakın yalnızca başında "**ahmet**" olan satırlar getirildi ve "can"
isimli dosya veya dizin bulunamadı şeklinde hata verildi. Çünkü `grep`
aracı, araştırmak istediğimiz ifadeyi parantez içinde girmediğimiz zaman
ilk argümanın aranacak ifade olduğunu, diğer argümanların ise
araştırmanın yapılacağı dosya veya dizinler olduğunu düşünüyor.
Komutumuzu bu kez tırnak içinde tekrar girelim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "ahmet can" isimler.txt                                                   
ahmet can durmus
```

Bakın bu kez tam olarak tırnak içinde yazmış olduğum ifadeyi içeren
satır getirilmiş oldu. Bizzat bu basit örneğimiz üzerinden teyit
ettiğimiz gibi tırnak kullanımı önemli. Zaten hatırlıyorsanız daha önce
kabuk genişletmelerinden bahsederken, `grep` ile `regex` kullanmak için
de tırnak içinde yazmıştık. Tırnaklar sayesinde kesin olarak
isteklerimizi iletmemiz mümkün oluyor.

Küçük Büyük Harf Duyarlılığı
----------------------------

Fark ettiyseniz bir önceki örneğimizde aldığımız çıktıların hepsi küçük
büyük harf duyarlılığı dahilinde tam olarak yazdığımız ifade ile
eşleşenlerdi. Eğer filtreleme yapılırken küçük büyük harf duyarlılığının
görmezden gelinmesini istersek `i` seçeneğini kullanabiliyoruz. Buradaki
`i` seçeneği "**i**nsensitive" yani "duyarsız" ifadesinin kısaltmasından
geliyor. Pek çok araç da aynı şekilde küçük büyük harfin görmezden
gelinmesi için `i` seçeneğini kullanmamızı istiyor.

Şimdi ben test etmek için en son girmiş olduğum komutu tekrar çağırıp,
buraya `i` seçeneğini de ekliyorum.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -i "ahmet can" isimler.txt                                                
Ahmet can
Ahmet Can Yazar
ahmet can durmus
```

Bakın bu kez küçük büyük harf demeden "ahmet can" ifadesi ile eşleşen
tüm satırlar getirilmiş oldu. Neticede hepsi "ahmet can" ifadesiyle
eşleşiyor ama küçük büyük harf farkları var. Siz de `i` seçeneği
sayesinde bu şekilde filtreleme yapılırken küçük büyük harflerin
görmezden gelinmesini sağlayabilirsiniz.

Kelime Odaklı Filtreleme
------------------------

Tam olarak aradığımız kelime ile eşleşenleri filtrelemek için "**w**ord"
ifadesinin kısaltmasından gelen `w` seçeneğini kullanabiliyoruz.

Kullanımını daha net gözlemleyebilmek için öncelikle
`grep “ali” isimler.txt` komutunu girelim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "ali" isimler.txt                                                      
halil cansun
ali
Halil cansun
Mustafa alican
halime
Mehmet ali
ahmet ali
ali said
ali
```

Bakın çıktılarda yalnızca "ali" ifadesi değil, satırın herhangi bir
noktasında "ali" ifadesi geçenler de bastırılmış oldu. Eğer ben bu
şekilde herhangi bir noktada değil de tek başına "ali" ifadesini
arıyorsam aynı komutumu bu kez `w` seçeneğiyle birlikte kullanabilirim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -w "ali" isimler.txt                                                      
ali
Mehmet ali
ahmet ali
ali said
ali
```

Bakın bu kez yalnızca tam olarak "ali" kelimesinin tek başına bulunduğu
satırlar filtrelenmiş oldu.

Okunaklı Çıktılar
-----------------

Aldığımız çıktıları daha okunaklı hale getirebiliriz. Mesela eğer `n`
seçeneğini eklersek, satır numaralarını da görmemiz mümkün.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -wn "ali" isimler.txt                                                     
43:ali
454:Mehmet ali
536:ahmet ali
554:ali said
598:ali
```

Bakın bu kez bu ifadelerin tam olarak hangi satırda geçtiği satırın en
başında yazıyor.

Ayrıca satır numarası yerine istersek toplamda kaç eşleşme olduğunu
öğrenmek için "**c**ount" ifadesinin kısaltmasından gelen `c` seçeneğini
de kullanabiliriz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -wc "ali" isimler.txt                                                     
5
```

Bakın toplam kaç eşleşme olduğu burada yazıyor. Benim dosyamda tam
olarak 5 kere tamamı küçük harfli "ali" kelimesi geçiyormuş.

Çoklu Filtre
------------

Dilersek verileri aşamalı olarak filtreleyip istediğimiz nihai verilere
ulaşabiliriz.

Örneğin ben /var/log/user.log dosyasında "kali" ve "error" ifadelerinin
geçtiği satırları filtrelemek istiyorum. Eğer komutumu
`cat /var/log/user.log | grep “kali”` şeklinde girecek olursam yalnızca
"kali" ifadesinin geçtiği satırlar getirilecek.

![25.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/25.webp)

Ama ben hem "kali" hem de küçük büyük harf fark etmeksizin "error"
ifadesinin geçtiği satırları filtrelemek istiyorum. Bunun için bir
önceki komutumuza bir `grep` filtresi daha ekleyebiliriz.

Pipe yardımıyla ilk `grep` aracının filtrelediği sonuçları alıp, ikinci
`grep` aracına filtrelemesi için iletelim.

![26.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/26.webp)

Bakın bu kez "kali" ve "error" ifadelerinin bulunduğu satırları
filtrelemiş olduk. Yani bu basit örneğimiz üzerinden pipe mekanizması
sayesinde aslında ne kadar esnekliğe sahip olduğumuzu bir kez daha
bizzat teyit etmiş olduk. Siz de benzer çözümler için dilediğiniz kadar
aracı uygun şekilde birbirine bağlayıp çalıştırabilirsiniz.

Tamamdır bence temel `grep` kullanımı için bu kadar bilgi yeterli.

Ben son olarak `grep` ile temel düzeyde **regex** kullanımından da
bahsedip anlatımı noktalamak istiyorum.

`grep` Üzerinde Regex Kullanımı
-------------------------------

`grep` aracı; "basit", "genişletilmiş" ve "perl uyumlu" olmak üzere üç
tür genişletme özelliğini destekliyor olmasına karşın varsayılan olarak
"basit" genişletmeyi kullanıyor.

Biz öncelikle basit Regex'in temel karakterlerini tanıyarak başlayalım.

`.` - Herhangi bir tek karakteri temsil eder (satır sonu karakteri
hariç).

`*` - Bir önceki karakterin sıfır veya daha fazla tekrarını temsil eder.

`+` - Bir önceki karakterin bir veya daha fazla tekrarını temsil eder.

`?` - Bir önceki karakterin sıfır veya bir kez tekrarını temsil eder.

`^` - Dizinin başlangıcını temsil eder.

`$` - Dizinin sonunu temsil eder.

`[]` - Bir karakter kümesini belirtir. Bu kümedeki herhangi bir
karakterle eşleşir.

`[a-z]` - Küçük harflerin olduğu bir karakter aralığını belirtir.

`[A-Z]` - Büyük harflerin olduğu bir karakter aralığını belirtir.

`[0-9]` - Rakamların olduğu bir karakter aralığını belirtir.

`\` - Özel karakterlerin (örneğin `.` ) özel anlamlarını iptal eder.

`|` - Alternatifler arasında bir seçenek yani "ya da" koşulu belirtir.

Ben örnek olması Regex kullanımını `grep` üzerinden çok kısaca ele
alıyor olacağım ancak Linux üzerinde Regex'i destekleyen diğer araçlar
üzerinde de aynı şekilde Regex kullanabilirsiniz. Bu konu hakkında daha
fazla detay almak için "[Linux Üzerinde Regex
Kullanımı](https://www.linuxdersleri.net/linux-regex)" blog yazısını
okuyabilirsiniz.

### Satır Başı: `^`

Spesifik olarak belirli bir ifadeyle başlayan satırları filtrelemek
istersek şapka ya da düzeltme işareti olarak da bilinen bu `^` işareti
kullanabiliyoruz.

Örneğin ben "**ay**" ifadesiyle başlayan satırları filtrelemek istersem
`grep “^ay” isimler.txt` şeklinde komutumu yazabilirim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "^ay" isimler.txt                                                     
aydin
ayşe fulya
ayşe gizem
aykut
aydin
ayşe
ayşegül
```

Bakın yalnızca başlangıcı "ay" olanlar bastırılmış oldu.

### Satır Sonu: `$`

Tersi şekilde eğer satır sonlarındaki karakterlere göre filtreleme
yapmak istersek de dolar `$` işaretini kullanabiliyoruz. Ben sonu
"**ay**" ifadesiyle bitenleri filtrelemek için `grep “ay$” isimler.txt`
şeklinde giriyorum.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "ay$" isimler.txt                                                         
Koray
Mehmet koray
Feray
Tümay
eray
Nuray
Ilkay
gökay
```

Bakın yalnızca satır sonunda "**ay**" ifadesi olanlar bastırıldı. Bu
tanımı yazarken dolar işaretini sona eklemiz gerektiğine dikkat edin
lütfen. Eğer dolar işaretini bu şekilde sonda değil de başta yazacak
olursanız ilgili eşleşme sağlanamaz.

### Nokta İşareti `.`

Nokta işareti sayesinde tek bir karakter ile eşleşecek şekilde tanımlama
yapmamız mümkün.

Denemek için `grep “ay.” isimler.txt` şeklinde komutumuzu girelim.

![18.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/18.webp)

Bakın "**ay**" ifadesi ve devamında küçük büyük olması fark etmeksizin
**herhangi bir karakteri** barındıran tüm veriler filtrelenmiş oldu.
Örneğin bir nokta daha eklersek, herhangi bir karakter daha ekleneceği
için "**ay**" ile başlayıp devamında herhangi iki karakteri
barındıranlar filtrelenecek.

![19.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/19.webp)

Bakın tam olarak beklediğimiz gibi "ay" ile başlayan ve devamında
herhangi iki karakteri barındıran tüm satırılar filtrelendi.

### Köşeli Parantez `[]`

Eğer rastgele karakterler yerine spesifik olarak bizim istediğimiz bazı
karakterlerin bulunduğu verileri filtrelemek istersek köşeli parantez
kullanabiliriz. Köşeli parantez içinde karakter kümelerini liste
şeklinde verebiliyoruz.

Örneğin ben "a" karakterinden sonra yalnızca "k" "l" ve "r"
karakterlerinden birini barındıran verileri filtrelemek istediğim için
`grep “a[klr]” isimler.txt` şeklinde komutumu giriyorum.

![20.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/20.webp)

Bakın tam olarak "a" karakterinden sonra köşeli parantez içinde
belirttiğimiz karakterlerden birini barındıran tüm veriler filtrelendi.
Tersi şekilde eğer köşeli parantez içindeki karakteri hariç tutup bunlar
dışındaki herhangi karakterleri kapsamak istersek de köşeli parantezin
en başında şapka `^` işaretini kullanabiliyoruz.

![21.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/21.webp)

Yani gördüğünüz gibi şapka işareti sayesinde buradaki karakterleri hariç
tutarak filtreleme yapabiliyoruz.

Burada dikkat ettiyseniz bizim köşeli parantez içinde yazdığımız
karakterler yalnızca tek bir karakter ile eşleşme sağlıyor. Örneğin ben
"a" karakterinden sonra "k" "l" "r" karakterlerini bulundurmayan ama "a"
"b" ve "c" karakterinden birini bulunduran veriyi filtrelemek istersem
komutumu `grep a[^klr][abc] isimler.txt` şeklinde girebilirim.

![22.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/22.webp)

Bakın tam olarak "a" karakterinde sonra "k" "l" "r" karakterini
barındırmayan ama üçüncü karakterinde "a" "b" ve "c" karakterlerinden
herhangi birini barındıran tüm veriler filtrelenerek renklendirilmiş
oldu.

Yani gördüğünüz gibi köşeli parantez sayesinde spesifik olarak tek bir
karakterin nasıl olması veya olmaması gerektiğini belirtebiliyoruz. Ve
tabii ki peş peşe burada olduğu gibi köşeli parantez kullanarak da hangi
karakterin ne şekilde olabileceğini de spesifik olarak
sınırlayabiliyoruz.

İşte basit regex genişletmeleri bu şekilde. Ben hepsine tek tek değinmek
istemiyorum. Daha fazla bilgi almak için mutlaka buradaki
[blog](https://www.linuxdersleri.net/linux-regex) yazısını baştan sonra
okuyup öyle devam edin. Bu sayede Linux üzerinde Regex'i çok daha etkili
şekilde kullanabiliyor olacaksınız.

`grep` Üzerinde Genişletilmiş Regex Kullanımı
---------------------------------------------

Ayrıca basit regex dışında, genişletilmiş regex kalıplarını kullanmamız
da mümkün. Fakat ben bu eğitimde bunların detaylarına girmek
istemiyorum. Daha fazla bilgi almak için blog yazısını okuyabilirsiniz.

Ben yalnızca örnek olması için genişletilmiş regex kullanımına bir tane
örnek vermek istiyorum.

Örneğin regex için "ya da" anlamına gelen dik çizgi `|` işaretini
kullanarak filtreleme yapmayı deneyebiliriz.

Ben "ahmet" "can" "ayse" isimlerinden birini barındıran satırları
filtrelemek istersem `grep “ahmet|can|ayse” isimler.txt` şeklinde
komutumu girebilirim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "ahmet|can|ayse" isimler.txt
```

Bakın bu şekilde girince bir çıktı almadık çünkü buradaki kullandığımız
dikey çizgi `|` karakteri regex'in "ya da" anlamında kullandığı karakter
olarak temsil edilmedi. Bunun yerine komutumuza `E` seçeneğini eklersek
bu karakter beklendiği şekilde çalışacak. Hemen denemek için komutumuzu
çağırıp büyük `E` seçeneğini ekleyelim.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep -E "ahmet|can|ayse" isimler.txt                                           
ahmet
halil cansun
yiğit can
Halil cansun
Mustafa alican
ahmet kürşad
cansu
ahmet ali
kenan ahmet
Ahmet can
ahmet
can yıldırım
ahmet can durmus
can ahmet furkan
```

Bakın bu kez "ahmet" "can" veya "ayse" ifadelerini barındıran satırların
filtrelenmesini sağlamış olduk. Buradaki büyük `E` seçeneği
"**E**xtended**"** yani "genişletilmiş" ifadesinin kısaltmasından gelen
seçeneğimiz. Bu seçenek sayesinde tıpkı buradaki dikey çizgi `|` gibi,
doğrudan genişletilmiş regex karakteri olarak algılanmayan regex
karakterlerinin kullanılabilmesi de mümkün oluyor.

Linux üzerinde `?` `+` `{}` ve `|` metakarakterleri genişletilmiş regex
dahilinde ele alındığı için bunları kullanırken ilgili araca bu durumu
`grep` aracının `-E` seçeneğinde olduğu gibi açıkça ifade etmemiz gerek.
Ayrıca bu karakterleri genişletilmiş regex yerine basit regex
kurallarıyla birlikte kullanırken bu karakterlerden önce ters slash `\`
koyarak bu karakterlerin özel anlamları ile ele alınmasını da
sağlayabiliriz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ grep "ahmet\|can\|ayse" isimler.txt                                  
ahmet
halil cansun
yiğit can
Halil cansun
Mustafa alican
ahmet kürşad
cansu
ahmet ali
kenan ahmet
Ahmet can
ahmet
can yıldırım
ahmet can durmus
can ahmet furkan
```

Bakın basit regex üzerinden genişletilmiş regex metakarakterlerini
kullanmak için bu karakterlerden önce ters slash kullanabileceğimizi
bizzat görmüş olduk. Birden fazla kez tekrarladığım gibi Linux üzerinde
Regex kullanımını daha net anlamak için mutlaka buradaki blog içeriğine
göz atın. Ben bu blog yazısını okuduğunuzu yani regex kullanımını
bildiğinizi varsayarak eğitime devam ediyor olacağım.

Benim şimdilik regex ve `grep` aracı hakkında bahsetmek istediklerim bu
kadar. Zaten temelde bilmemiz gerekenlerden bahsettik. Daha fazlası için
hem `grep` aracının yardım sayfasına hem de regex için harici kaynaklara
bakmanız yeterli.

`find` Komutu
-------------

`find` aracı, açıkça isminden de anlaşılabileceği gibi sistem üzerindeki
dosya ve klasörleri arayıp, konumlarını bulmamıza yardımcı olan bir
araç. En yalın kullanımı `find` komutundan sonra hangi dizinde
araştırıma yapılacağını belirtip daha sonra `-name` seçeneğinin ardından
araştırılacak olan dosya ya da klasör isminin girilmesi şeklinde.

Ben aranacak dosya ve klasörleri kendim oluşturmak için
`touch ~/Documents/bulbeni` ve `mkdir ~/Pictures/bulbeni` komutlarını
giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ touch ~/Documents/bulbeni
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir ~/Pictures/bulbeni
```

Böylelikle aynı isimli dosya ve klasörümüzü farklı dizinlerde oluşturmuş
olduk.

Şimdi `find` komutumuzu bu dosya ve klasörleri bulmak için
kullanabiliriz. Ben şu an ev dizinimdeyim, bulunduğum dizinden itibaren
tüm alt dizinlere bakılıp aradığım kelime ile eşleşen dosya ya da klasör
ismi var mı diye bakmak için `find .` yazıyorum buradaki nokta `.`
bulunduğum dizini temsil ediyor. Aslında nokta yazmasam bile `find`
komutu ekstra bir hedef belirtmediğimiz sürece mevcut dizinimizde
araştırma yapıyor ama biz daha anlaşılır olması için mevcut dizinimizi
nokta ile hedef gösterebiliriz. Yazacağım kelimeyle eşleşen dosya ve
klasörleri bulmak için de `-name` seçeneğinin ardından aradığım kelimeyi
giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find . -name "bulbeni"                                    
./Documents/bulbeni
./Pictures/bulbeni
```

Bakın isimle eşleşen hem klasör hem de dosya, tam konumlarıyla birlikte
listelenmiş oldu.

`find` komutunun en yalın kullanımı bu şekilde. Tabii ki tüm kullanım
imkanı bundan ibaret değil. Araştırma yapılırken filtreleme
yapılabilmesi için aranacak dosya veya klasörün özelliklerine göre
kullanabileceğimiz birden fazla seçenekler bulunuyor. Hemen kısaca
bunlardan söz edelim.

Tipine Göre Filtreleme \| Dosya - Dizin
---------------------------------------

Eğer **yalnızca dosyaları** filtrelemek istiyorsak `type` seçeneğinin
ardından "**f**ile" yani "dosya" ifadesinin kısaltmasından gelen `f`
parametresini yazmamız gerekiyor. Eğer **klasörleri filtrelemek**
istersek de "**d**irectory" yani "klasör" ifadesinin kısaltmasından
gelen `d` ifadesini kullanabiliyoruz. Hemen örneğimiz üzerinden
deneyelim.

Ben öncelikle "bulbeni" isimli **dosyayı** araştırmak istediğim için
`find . -name “bulbeni” -type f` şeklinde yazıyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find . -name "bulbeni" -type f                               
./Documents/bulbeni
```

Bakın burada aldığımız çıktı yalnızca dosyanın konumunu veriyor.

Benzer şekilde yalnızca klasörü bulmak için `d` parametresi ile
araştırma yapabiliriz.

`find . -name “bulbeni” -type d` şeklinde araştıralım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find . -name "bulbeni" -type d
./Pictures/bulbeni
```

Bakın bu çıktı da klasörün konumuna işaret ediyor.

Yani bakın bizzat teyit ettiğimiz gibi `find` ile araştırma yapılırken
bu şekilde dosya ve klasör olma durumuna göre yani tipine göre
filtreleme yapabiliyoruz.

Mesela ben yalnızca mevcut bulunduğum dizinde araştırma yaptım ama
aslında istediğim bir dizin altında araştırma yapılmasını
sağlayabilirim. Denemek için bu kez "***/etc/***" dizini atlında sonu
"**.conf**" ile biten tüm içerikleri bastırmak istiyorum. Bunun için
`find /etc/ -name “*.conf”` komutunu girebiliriz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find /etc/ -name "*.conf"                                    
/etc/inetsim/inetsim.conf
/etc/initramfs-tools/initramfs.conf
/etc/initramfs-tools/update-initramfs.conf
/etc/pulse/daemon.conf
/etc/pulse/client.conf.d/01-enable-autospawn.conf
/etc/pulse/client.conf
/etc/apparmor/parser.conf
...
..
.
```

**ℹ️ Not:** Çıktı çok uzun olduğu için kısaltarak ekledim.

Bakın "***/etc/***" dizini atlında isminin sonu ".conf" ile biten tüm
dosya ve dizinler filtrelenmiş oldu. Eğer yalnızca "***/etc/***" dizini
altında değil de tüm sistem genelinde araştırma yapmak istersek
araştırılacak dizin olarak yalnızca slash `/` karakterini yazmamız da
yeterli.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find / -name "*.conf"                                    
/home/taylan/.config/qt5ct/qt5ct.conf
find: ‘/root’: Permission denied
/usr/lib32/gconv/gconv-modules.d/gconv-modules-extra.conf
/usr/lib/kernel/install.conf
/usr/lib/python3/dist-packages/cme/data/cme.conf
/usr/lib/python3/dist-packages/binwalk/config/extract.conf
/usr/lib/NetworkManager/conf.d/no-mac-addr-change.conf
/usr/lib/sysctl.d/50-bubblewrap.conf
/usr/lib/sysctl.d/50-pid-max.conf
/usr/lib/sysctl.d/99-protect-links.conf
/usr/lib/sysusers.d/systemd-journal.conf
/usr/lib/sysusers.d/systemd-resolve.conf
/usr/lib/sysusers.d/dbus.conf
...
..
.
```

Tabii ki bu işlem tüm sistem hiyerarşisinin kontrol edilmesini
gerektirdiği için biraz vakit alabilir. Ancak neticede gördüğünüz gibi
istediğimiz bir dizin altında aradığımız isimle eşleşen dosya ve
dizinleri belirtebiliyoruz.

Boyutlarına Göre Filtreleme
---------------------------

Boyuta göre filtreleme yapmak için `size` seçeneğini kullanmamız
gerekiyor. Örneğin bulunduğumuz dizin altındaki 1 megabayttan büyük olan
tüm dosyaları getirmek için `find . -type f -size +1M` şeklinde
komutumuzu kullanabiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find . -type f -size +1M
./.mozilla/firefox/d5n1etpa.default-esr/storage/permanent/chrome/idb/3870112724rsegmnoittet-es.sqlite
./.mozilla/firefox/d5n1etpa.default-esr/places.sqlite
./.mozilla/firefox/d5n1etpa.default-esr/security_state/data.safe.bin
./.mozilla/firefox/d5n1etpa.default-esr/favicons.sqlite
...
..
.
```

Bakın buradaki tüm dosyalar 1 megabayttan büyük olan dosyalar. Eğer
küçük olanları istersek artı yerine eksi `-` işaretini girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find . -type f -size -1M                                    
./dosya1
./dosya2
./klasor/dosya1
./klasor/dosya2
./klasor/dosys3
./.mozilla/firefox/d5n1etpa.default-esr/.parentlock
./.cache/go-build/e3/e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855-d
./.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/ce_T151c2VyQ29udGV4dElkPTUsYSw=
./.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/ce_T151c2VyQ29udGV4dElkPTUs
./.ICEauthority
./Documents/bulbeni
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
./Desktop/test.txt
./dosys3
./calısma/y5t.webp
```

Bakın bu aldığımız çıktılar da 1 megabayttan küçük olanlar.

Boyutu farklı girmek isterseniz;

**bayt** için **b,**

**kilobayt** için **k**

**megabayt** için büyük **M**

**gigabayt** için büyük **G** kullanabilirsiniz.

Örneğin ben kök dizin altında 1 gigabayttan büyük olan dosyaları bulmak
istiyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ find / -type f -size +1G 2>/dev/null
/proc/kcore
```

**ℹ️ Not:** Kök dizin altında yetki hatası aldığımız için hatalı
çıktıları `2> /dev/null` komutu ile yok ettim.

Gördüğünüz gibi 1 gigabayttan büyük olan dosyam bulunmuş oldu. Siz de
istediğiniz büyüklük birimine göre filtreleme yapabilirsiniz.

Tarihlerine Göre Filtreleme
---------------------------

Ayrıca erişim, değişim ve düzenleme tarihlerine göre de filtrelemeniz de
mümkün. Zaten bu tarihlerin neyi ifade ettiğini daha önce açıklamıştık.

Örneğin düzenlenme(modify) tarihi için `mtime` kullanılıyorken,
değişim(change) tarihi için `ctime`, erişim(access) tarihi için de
`atime` parametrelerini kullanabiliyoruz.

Daha azı için eksi `-`

Daha fazlası için artı `+`

Tam tarih için doğrudan günü belirtebiliyoruz.

Eğer ben mevcut bulunduğum dizinde **tam olarak 10 gün önce**
düzenlenmiş içerikleri görmek istersem `find -mtime 10` şeklinde
komutumu girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mtime 10
./Documents/belgeler
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
```

Bakın buradaki içerikler tam olarak 10 gün önce düzenlenmiş dosya ve
klasörler.

Eğer 2 günden daha kısa bir süre önce düzenlenmişleri öğrenmek istersek
`-2` ile iki günden öncesini belirtebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mtime -2
.
./.wget-hsts
./.vboxclient-draganddrop.pid
./dosya1
./dosya2
./liste.txt
./klasor
./klasor/oku-beni
./klasor/dosya1
./klasor/dosya2
./klasor/liste2
./klasor/deneme.txt
./klasor/liste
./klasor/dosys3
./isimler.txt
./.vboxclient-clipboard.pid
./.bash_history
./.xsession-errors
./.Xauthority
./liste
./Documents
./Documents/bulbeni
./sırala
./.vboxclient-display-svga-x11.pid
./dosys3
./Downloads
./.vboxclient-seamless.pid
./Pictures
./Pictures/bulbeni
./bul
./liste2.txt
```

Bakın bunlar bu gün veya dün düzenlenmiş olan içerikler.

Eğer düzenleme süresi 5 günden daha önceki tarihler olan içerikleri
görmek istersek de `find -mtime +5` şeklinde düzenlenme tarihinden 5
günden daha fazla zaman geçmiş olacağını belirtebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mtime +5
./.bashrc.original
./dosya.txt
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
...
..
.
```

Bakın buradaki dosyalarım tamamı, en yakın 6 gün önce düzenlemiş
olanlar. Kimisi 100 gün önce de düzenlemiş olabilir. Neticede düzenleme
tarihi **son 5 günden öncesi** olanları filtrelemek için `+5`
parametresini kullandık.

Örneğin son 24 saatte düzenlenmiş olanları filtrelemek için
`find -mtime -1` şeklinde girebiliriz. Buradaki `-1` bir günden daha
kısa bir süre öncesinin zaman aralığını belirttiği için son 24 saatten
şu ana kadar düzenlenmiş içerikler filtreleniyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mtime -1
.
./.wget-hsts
./.vboxclient-draganddrop.pid
./dosya1
./dosya2
./liste.txt
./klasor
./klasor/oku-beni
./klasor/dosya1
./klasor/dosya2
./klasor/liste2
./klasor/deneme.txt
./klasor/liste
./klasor/dosys3
./isimler.txt
./.vboxclient-clipboard.pid
./.bash_history
./.xsession-errors
./.Xauthority
./liste
./Documents
./Documents/bulbeni
./sırala
./.vboxclient-display-svga-x11.pid
./dosys3
./Downloads
./.vboxclient-seamless.pid
./Pictures
./Pictures/bulbeni
./bul
./liste2.txt
```

Ben örnekler sırasında düzenlenme tarihleri için `mtime` seçeneğini
kullandım ama siz değişim tarihleri için `ctime`, erişim tarihleri için
de aynı şekilde `atime` seçeneklerini kullanarak arama sonuçlarını
filtreleyebilirsiniz.

Ayrıca ben hep günler üzerinden ele aldım ancak aslında `min`
parametresi sayesinde dakika üzerinden de bu filtrelemeyi yapmamız
mümkün. Örneğin son 50 dakika içinde düzenlenmiş(modify) olanları
filtrelemek için `find -mmin -50` şeklinde komutumu girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mmin -50                                               
.
./.bash_history
./Documents
./Documents/bulbeni
./.config/xfce4/panel
./.config/xfce4/panel/genmon-15.rc
./.config/qterminal.org
./.config/qterminal.org/qterminal.ini
./Pictures
./Pictures/bulbeni
```

Bakın bunlar son 50 dakika içerisine düzenlenmiş olanlar. **Günleri**
belirtirken **time** şeklinde yazıyorken, dakikaları belirtmek için
"**min**utes" ifadesinin kısaltmasından gelen "**min**" seçeneğini
kullanıyoruz. Yani düzenlenme(modify) dakikası için `mmin`,
değişim(change) dakikası için `cmin`, erişim(access) dakikası için de
`amin`, seçeneklerinin ardından dakikayı belirtebiliyoruz. Ben burada
`-50` şeklinde yazdığım için **son 50 dakika içerisindekileri**
kapsadım. Örneğin `+50` yazacak olursam, düzenlenme tarihi son 50
dakikayı geçmiş olan tüm içerikleri kastetmiş oluyorum.

Örneğin ben son 1 saat içerisinde hiç açmadığım yani erişmediğim
içerikleri listelemek istersem, `find -amin +60` şeklinde komutumu
girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -amin +60
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
```

Bakın burada listelenmiş olan içeriklerin hiç birisine son 1 saat
içerisinde erişim sağlamamışım. Tersi şekilde son bir saat içerisinde
erişim sağladıklarımı görmek için de `-60` parametresini girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -amin -60                                              
.
./.gnupg/private-keys-v1.d
./.local/state/pipewire/media-session.d
./.bash_history
./.cache/gstreamer-1.0
./Documents
./Documents/bulbeni
./.config/xfce4/panel
./.config/xfce4/panel/genmon-15.rc
./.config/gtk-3.0
./.config/qterminal.org
./.config/qterminal.org/qterminal.ini
./Pictures
./Pictures/bulbeni
```

Bakın bunlar da son bir saat içerisinde erişim sağlanmış olanlar. Bence
kullanımı son derece kolay. Biraz pratik yaparsanız tam olarak
kullanımına alışırsınız zaten.

Ayrıca tüm bu bahsettiklerimiz dışında eğer `man find` şeklinde
yazarsanız, aslında ne kadar çok filtreleme seçeneği olduğunu kendiniz
de görebilirsiniz. Ancak ben hepsine değinmeyeceğim. İhtiyacınız
olduğunda manuel sayfasından açıp bakabilirsiniz.

Henüz daha öğrenmediğimiz için yetkilere ve sahipliğe göre filtrelemeden
bahsetmek istemiyorum. Ama zaten aynı şekilde `find` aracının yardım
bilgilerinde belirtilen tüm seçenekleri ihtiyacınıza göre
kullanabilirsiniz. Örneğin içerikleri yetkilerine göre filtrelemek için
`perm` seçeneğini kullanıyorken, sahipliğine göre filtrelemek için de
`user` seçeneğini kullanabiliyoruz. Ve bunlar gibi yardım sayfasında
görebileceğiniz çeşitli filtreleme seçenekleri mevcut. İhtiyaç
duyduğunuzda açıp yardım bilgisinden hangi seçeneği kullanmanız
gerektiğini öğrenebilirsiniz.

Ben dediğim gibi yetki ve sahip kavramlarından henüz bahsetmediğimiz
için kafanızın karşımasını istemiyorum, zaten aynı şekilde tek
yaptığımız bu özelliklere göre filtreleme yapmak. Bu konuları
öğrendiğinizde dönüp `find` ile bu kriterlere göre filtreleme yapmakta
özgürsünüz.

Olumsuzlama Seçeneği \| `-not`
------------------------------

İlgili seçenekten önce `-not` seçeneğini kullanarak, ilgili
filtrelemenin tam tersini elde edebiliriz.

Örneğin ben `find -name “*.webp”` komutuyla mevcut dizinim altındaki
sonu "**.webp**" ile biten tüm içerikleri filtrelersem, gördüğünüz gibi
tam istediğim gibi bu adresleri öğrenebiliyoruz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find -name "*.webp"                                           
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.webp
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.webp
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.webp
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.webp
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.webp
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.webp
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.webp
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.webp
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.webp
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.webp
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.webp
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.webp
./.cache/sessions/thumbs-taylan:0/Default.webp
./Pictures/Screenshot_2023-05-30_10_28_23.webp
./Pictures/Screenshot_2023-05-24_11_11_16.webp
./Pictures/Screenshot_2022-07-03_06_45_05.webp
./Pictures/Screenshot_2023-05-30_13_21_21.webp
./Pictures/Screenshot_2022-07-03_06_45_04.webp
./Pictures/Screenshot_2022-07-03_06_45_03.webp
./Pictures/Screenshot_2022-06-30_03_23_40.webp
./Pictures/Screenshot_2023-05-30_10_28_26.webp
./Pictures/Screenshot_2023-05-30_10_28_19.webp
./Pictures/Screenshot_2022-06-17_13_15_28.webp
./Pictures/Screenshot_2022-07-03_06_45_02.webp
./Pictures/Screenshot_2022-06-17_13_15_26.webp
./Pictures/Screenshot_2023-05-28_10_42_36.webp
./Pictures/Screenshot_2022-07-03_06_45_24.webp
```

Eğer ben bu komutumu tekrar çağırıp, tersini kullanmak istediğim
seçenekten hemen önce `-not` seçeneğini ekleyecek olursam yani
`find -not -name “*.webp”` şeklinde komut girersem bu kez sonunda
"***.webp***" ismi olanlar **hariç** tüm içerikler bulunup konsola
bastırılacak.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -not -name "*.webp"
.
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
...
..
.
```

İşte burada benim yalnızca isim seçeneği üzerinden gösterdiğim bu `-not`
seçeneği sayesinde tüm filtrelerin tersi şekilde çalışmasını
sağlayabilirsiniz. Örneğin ben tam olarak 10 gün önce düzenlenmiş
içerikleri filtrelemek için `find -mtime 10` şeklinde komut girersem,
tam olarak 10 gün önce düzenlenmiş içerikler listeleniyor.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -mtime 10
./Documents/belgeler
./.config/xfce4/desktop/icons.screen0-1263x957.rc
./.config/xfce4/desktop/icons.screen0-2544x966.rc
```

Eğer buradaki `mtime` seçeneğinden önce `-not` seçeneğini ekleyecek
olursak, bu kez tam tersi şekilde yani 10 gün önce oluşturulmamış olan
tüm içerikler bastırılacaktır.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -not -mtime 10
.
./yepyenidosya
./.bashrc.original
./dosya.txt
./sonuc
./.gnupg
./.gnupg/private-keys-v1.d
./.java
./.java/.userPrefs
./.java/.userPrefs/burp
./.java/.userPrefs/burp/prefs.xml
```

Bu şekilde tüm filtreleme seçeneklerinden önce `-not` kullanarak ilgili
filtrelemeyi tersine çevirmeniz mümkün.

Ve - Ya Da Koşulları \| `-and` `-or`
------------------------------------

Filtrelemeyi tek bir kritere göre değil de birden fazla kritere göre
yapmak istersek koşul belirten "`-and`" "`-or`" gibi seçenekleri
kullanabiliyoruz. Örneğin ben sonu ".txt" ile veya ".webp" ile bitenleri
filtrelemek istersem `find -name “*.txt” -or -name “*.webp”` komutunu
girebilirim.

Bakın burada isim filtrelemesi için iki özel isim belirtip, bu isimlerin
arasına da `-or` seçeneği ile "veya" koşulu eklemiş olduk. Bu sayede
sonu ".txt" ile veya ".webp" biten tüm içerikler filtrelenecek.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ find -name "*.txt" -or -name "*.webp"                         
./dosya.txt
./hatasız.txt
./metin1.txt
./harf.txt
./.local/lib/python3.9/site-packages/uro-1.0.0.dist-info/entry_points.txt
./.local/lib/python3.9/site-packages/uro-1.0.0.dist-info/top_level.txt
./.local/share/powershell/PSReadLine/ConsoleHost_history.txt
./.local/share/sqlmap/output/en.trendyol.com/target.txt
./.local/share/sqlmap/output/tech.trello.com/target.txt
./.local/share/sqlmap/output/blog.trello.com/target.txt
./.local/share/sqlmap/output/link2.trendyol.com/target.txt
./.local/share/sqlmap/output/api.trello.com/target.txt
./.local/share/sqlmap/output/api-gateway.trello.com/target.txt
./.local/share/sqlmap/output/help.trello.com/target.txt
./.local/share/sqlmap/output/br.blog.trello.com/target.txt
./.local/share/sqlmap/output/c.trello.com/target.txt
./.local/share/sqlmap/output/info.trello.com/target.txt
./.local/share/sqlmap/output/akademi.trendyol.com/target.txt
./.local/share/sqlmap/output/m.trendyol.com/target.txt
./liste.txt
./klasor/deneme.txt
./Public/metin1.txt
./Public/sonuc.txt
./Public/metin2.txt
./isimler.txt
./hatalı.txt
./.mozilla/firefox/d5n1etpa.default-esr/AlternateServices.txt
./.mozilla/firefox/d5n1etpa.default-esr/SiteSecurityServiceState.txt
./.mozilla/firefox/d5n1etpa.default-esr/pkcs11.txt
./hatasız2.txt
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.webp
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.webp
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.webp
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.webp
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.webp
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.webp
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.webp
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.webp
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.webp
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.webp
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.webp
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.webp
./.cache/sessions/thumbs-taylan:0/Default.webp
./Documents/metin.txt
./sayi.txt
./metin2.txt
./hello.txt
./Desktop/test.txt
./Pictures/Screenshot_2023-05-30_10_28_23.webp
./Pictures/Screenshot_2023-05-24_11_11_16.webp
./Pictures/Screenshot_2022-07-03_06_45_05.webp
./Pictures/Screenshot_2023-05-30_13_21_21.webp
./Pictures/Screenshot_2022-07-03_06_45_04.webp
./Pictures/Screenshot_2022-07-03_06_45_03.webp
./Pictures/Screenshot_2022-06-30_03_23_40.webp
./Pictures/Screenshot_2023-05-30_10_28_26.webp
./Pictures/Screenshot_2023-05-30_10_28_19.webp
./Pictures/Screenshot_2022-06-17_13_15_28.webp
./Pictures/Screenshot_2022-07-03_06_45_02.webp
./Pictures/Screenshot_2022-06-17_13_15_26.webp
./Pictures/Screenshot_2023-05-28_10_42_36.webp
./Pictures/Screenshot_2022-07-03_06_45_24.webp
./karisik.txt
./liste2.txt
```

Bakın tam da beklediğimiz gibi koşul çalıştı ve "**.txt**" ile **veya**
"**.webp**" biten dosyaları aldık.

`-and` koşuluna bir örnek vermemiz gerekirse örneğin sonu "**.webp**"
ile biten **ve** 100 kilobayttan büyük olanları filtrelemeyi
deneyebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ find -name "*.webp" -and -size +100k                          
./Pictures/Screenshot_2023-05-30_10_28_23.webp
./Pictures/Screenshot_2023-05-24_11_11_16.webp
./Pictures/Screenshot_2022-07-03_06_45_05.webp
./Pictures/Screenshot_2023-05-30_13_21_21.webp
./Pictures/Screenshot_2022-07-03_06_45_04.webp
./Pictures/Screenshot_2022-07-03_06_45_03.webp
./Pictures/Screenshot_2022-06-30_03_23_40.webp
./Pictures/Screenshot_2023-05-30_10_28_26.webp
./Pictures/Screenshot_2023-05-30_10_28_19.webp
./Pictures/Screenshot_2022-06-17_13_15_28.webp
./Pictures/Screenshot_2022-07-03_06_45_02.webp
./Pictures/Screenshot_2022-06-17_13_15_26.webp
./Pictures/Screenshot_2022-07-03_06_45_24.webp
```

Bakın isim ve boyut filtreleri arasında kullanmış olduğumuz `-and`
seçeneği sayesinde bu iki filtreyi birbirine bağlayıp hem ".webp" ile
biten hem de boyutu 100 kilobayttan büyük olanları filtrelemiş olduk.

İşte siz de bu şekilde spesifik olarak aradığınız özelliklere uyan
filtremeler yapmak için bu koşul seçeneklerini kullanabilirsiniz.

`find` Üzerinde Regex Kullanımı
-------------------------------

Normalde `find` komutu biz aksini `-regex` seçeneği ile belirtmediğimiz
sürece daha önce kabuk genişletmeleri bölümünde ele aldığımız
"wildcards" yaklaşımını kullanıyor. Yani biz `-name` seçeneğini
kullandığımızda isimler aslında "wildcards" kuralları dahilinde
değerlendiriliyor.

Örneğin `find -name "*.webp"` komutunu kullandığımda, mevcut bulunduğum
dizin altında başında herhangi bir karakter olan devamındaki ".webp"
ifadesi yer alan tüm dosya ve klasörler getiriliyor. Dosya ismi
genişletmesinden bahsederken benzer örnekler yapmıştık hatırlarsanız.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find -name "*.webp" 
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.webp
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.webp
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.webp
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.webp
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.webp
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.webp
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.webp
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.webp
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.webp
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.webp
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.webp
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.webp
./.cache/sessions/thumbs-taylan:0/Default.webp
./Pictures/Screenshot_2023-05-30_10_28_23.webp
./Pictures/Screenshot_2023-05-24_11_11_16.webp
./Pictures/Screenshot_2022-07-03_06_45_05.webp
./Pictures/Screenshot_2023-05-30_13_21_21.webp
./Pictures/Screenshot_2022-07-03_06_45_04.webp
./Pictures/Screenshot_2022-07-03_06_45_03.webp
./Pictures/Screenshot_2022-06-30_03_23_40.webp
./Pictures/Screenshot_2023-06-17_06_27_08.webp
./Pictures/Screenshot_2023-05-30_10_28_26.webp
./Pictures/Screenshot_2023-05-30_10_28_19.webp
./Pictures/Screenshot_2022-06-17_13_15_28.webp
./Pictures/Screenshot_2022-07-03_06_45_02.webp
./Pictures/Screenshot_2022-06-17_13_15_26.webp
./Pictures/Screenshot_2023-05-28_10_42_36.webp
./Pictures/Screenshot_2022-07-03_06_45_24.webp
```

Eğer buradaki "`*.webp`" ifadesi wildcards olarak ele alınmıyor olsaydı
bu çıktıyı alamayacaktık. Denemek için aynı ifadeyi bu kez `-regex`
seçeneği ile deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ find -name "*.webp" 

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın herhangi bir çıktı alamadık çünkü regex kuralları gereği yıldız
işareti kendisinden önceki karakteri sıfır veya daha fazla kez tekrar
ediyor. Fakat burada yıldız karakterinden önce bir karakter bulunmadığı
için regex kurallarına göre tekrar eden bir örüntü tanımlaması da
yapılmamış oluyor. Regex ile bu filtrelemeyi yapmak için "`.*.webp`"
ifadesini kullanabiliriz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ find -regex ".*.webp"                                         
./.cache/thumbnails/large/3ab698ceca6c7925eb3d1b884a26e75d.webp
./.cache/thumbnails/large/c338c09e4cee3d0a205c77d2888f0fc0.webp
./.cache/thumbnails/large/52e5c5b7a8eaeca56e0bf2634080a8f3.webp
./.cache/thumbnails/large/b3fe8ef292b398b5ff2b48953a2dcaa3.webp
./.cache/thumbnails/large/601fa98430e31526893c2cd4c497fb77.webp
./.cache/thumbnails/large/e0142d1bb7807691d1f3c6fbef0db9d6.webp
./.cache/thumbnails/large/4d47671573280bf1e30ef346ecd154ed.webp
./.cache/thumbnails/normal/4ef1aeb4f74b05b642089a3fa725f6ff.webp
./.cache/thumbnails/normal/fd024d11882b348b20550093e6339f54.webp
./.cache/thumbnails/normal/ce9a4aafaf687c2389abce167751da5e.webp
./.cache/thumbnails/normal/b229cfc54c3672c84da5bfb87f3c7ec9.webp
./.cache/mozilla/firefox/d5n1etpa.default-esr/thumbnails/b8d33cbd34677070b8b70079044c40aa.webp
./.cache/sessions/thumbs-taylan:0/Default.webp
./Pictures/Screenshot_2023-05-30_10_28_23.webp
./Pictures/Screenshot_2023-05-24_11_11_16.webp
./Pictures/Screenshot_2022-07-03_06_45_05.webp
./Pictures/Screenshot_2023-05-30_13_21_21.webp
./Pictures/Screenshot_2022-07-03_06_45_04.webp
./Pictures/Screenshot_2022-07-03_06_45_03.webp
./Pictures/Screenshot_2022-06-30_03_23_40.webp
./Pictures/Screenshot_2023-06-17_06_27_08.webp
./Pictures/Screenshot_2023-05-30_10_28_26.webp
./Pictures/Screenshot_2023-05-30_10_28_19.webp
./Pictures/Screenshot_2022-06-17_13_15_28.webp
./Pictures/Screenshot_2022-07-03_06_45_02.webp
./Pictures/Screenshot_2022-06-17_13_15_26.webp
./Pictures/Screenshot_2023-05-28_10_42_36.webp
./Pictures/Screenshot_2022-07-03_06_45_24.webp
```

Bakın bu kez ".webp" uzantılı dosyaları bulabildik. Çünkü yıldız
işaretinden önce kullandığımız nokta işareti herhangi bir tek karakteri
temsil ediyor, dolayısıyla yıldız işareti de sıfır veya daha fazla
sayıda herhangi bir karakteri barındıran ifadeleri kapsamış oluyor.

**Wildcards ve Regex farkını özetleyecek olursak;**

**Dosya ismi genişletmesi kuralına göre yıldız karakteri:** sıfır veya
sıfırdan daha fazla sayıda herhangi bir karakter ile eşleşebiliyor.

**Regex kuralına göre yıldız karakteri:** kendisinden önceki karakteri
sıfır veya daha fazla sayıda tekrar eden örüntüler ile eşleşebiliyor.

Aldığımız çıktılardaki değişimler de tam olarak bu farklardan
kaynaklanıyor.

Örnekler üzerinden bizzat teyit ettiğimiz gibi biz aksini `-regex`
seçeneği ile belirtmediğimiz sürece `-name` seçeneği wildcards kuralları
dahilinde filtreleme yapılmasını sağlıyor.

Tamamdır, benim `find` komutu hakkında bahsetmek istediğim tüm temel
bilgiler bu şekilde. Tabii ki yardım sayfasından da görebileceğimiz gibi
aslında `find` aracının çok daha fazla özelliği mevcut ancak temel
seviye için ilk aşamada bunların hepsi fazla gelebilir. Ayrıca tüm
seçeneklere sürekli ihtiyacınız da olmayacak. İhtiyaç duydukça yardım
sayfalarını açıp bakmakta özgürsünüz.

Ben şimdi araştırma yapma konusunda bir diğer alternatifimiz olan
`locate` aracından bahsederek devam etmek istiyorum.

`locate` Komutu
---------------

`locate` komutu sayesinde sistemdeki dosya ve dizinleri isimleriyle
araştırabiliyoruz.

`locate` komutu daha önce ele aldığımız `find` aracından farklı olarak
araştırma işlemi sırasında tüm dosya sistemine değil daha önceden
oluşturulmuş veri tabanını kullanıyor. Bu sayede veri tabanı üzerinden
yaptığımız araştırmada, `find` aracından çok daha hızlı şekilde sonuç
verebiliyor.

Aracımızın en temel kullanımı `locate aranacak-isim` şeklinde. Fakat
dediğim gibi `locate` aracı kendisine ait olan veritabanı üzerinden
araştırma yaptığı için araştırmalarımız sırasında daha sağlıklı çıktılar
elde edebilmek adına bu veritabanını güncellememiz gerekiyor.

Ben hemen test etmek için bir önceki derste `find` aracıyla bulmak için
oluşturduğum farklı konumlardaki "***bulbeni***" isimli dosya ve
klasörleri `locate bulbeni` komutuyla sorgulamak istiyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ locate bulbeni
┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın herhangi bir çıktı almadık. Biz bu dosya ve klasörü yeni
oluşturduğumuz için `locate` aracının kullandığı veritabanına bu dosya
ve klasörün dizin adresi eklenmedi. Dolayısıyla bu isimde bir eşleşme
olmadı.

`locate` Veritabanını Güncellemek \| `updatedb`
-----------------------------------------------

`locate` veritabanını güncellemek için `sudo updatedb` şeklinde
komutumuzu girebiliriz. İşlemi yetkili olarak gerçekleştirdiğimiz için
parolamızı girip anlayamamız gerek. Ayrıca yeni dizinlerin eklenmesini
de bir süre beklememiz gerek.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sudo updatedb
[sudo] password for taylan:
┌──(taylan@linuxdersleri)-[~]
└─$
```

Şimdi dosya sistemindeki en son değişikliklerin veritabanına eklenmiş
olması gerekiyor. Tekrar etmek için `locate bulbeni` şeklinde komutumuzu
girebiliriz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ locate bulbeni
/home/taylan/Documents/bulbeni
/home/taylan/Pictures/bulbeni

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın bu kez anında aradığım kelimeyle eşleşen dosya ve dizinlerin
adresi konsola bastırıldı. Bizzat sizin de deneyimleyebileceğiniz gibi
`locate` aracı hızlı çalışıyor olmasına rağmen, veritabanı `updatedb`
komutu ile güncellenmediyse sistemde mevcut olan yeni dosya ve dizinleri
bulamıyor. Dolayısıyla `locate` aracını kullanmadan önce sağlıklı
çıktılar almak istiyorsanız mutlaka `updatedb` komutuyla güncelleme
yapın. Normalde her gün düzenli olarak bu veritabanı otomatik olarak
güncelleniyor ancak dediğim gibi kullanmadan önce stabil çıktılar
istiyorsanız `updatedb` komutunu çalıştırmanız şart.

Harf Duyarlılığını Kaldırmak
----------------------------

Eğer aradığınız dosya isminde küçük büyük harf duyarlığının görmezden
gelinmesini isterseniz komutunuza `i` seçeneğini de ekleyebilirsiniz.

Ben denemek için `locate ABC` şeklinde yazıp içerisinde tamamı büyük
harflerden oluşan **ABC** karakterlerini barından dosya ve klasör
isimlerini listelemek istiyorum.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ locate ABC                                                   
/home/taylan/ABC
/home/taylan/.cache/mozilla/firefox/d5n1etpa.default-esr/cache2/entries/1F001ABC732598300E8297AC686A75B32E5186EB
```

Bakın buradaki çıktıların hepsinde yalnızca tamamı büyük olan ABC
ifadesi geçiyor. Eğer küçük büyük harf duyarlılığını kaldırmak istersek
komutumuzu tekrar çağırıp `i` seçeneğini ekleyebiliriz.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ locate -i ABC
/home/taylan/ABC
/home/taylan/AbC
/home/taylan/aBc
/home/taylan/abc
/home/taylan/.cache/go-build/0d/0d0abc24b077b8fe4a2db64ca931edc2ed3107a8d4c35f0e230f762e70514359-a
```

**ℹ️ Not:** Çıktılar kısaltılarak verilmiştir.

Bakın bu kez küçük büyük harf fark etmeksizin tüm dosya ve klasörler
listelenmiş oldu.

Eşleşme Sayısını Öğrenmek
-------------------------

Kaç eşleşme olduğun saymak istersek "**c**ount" yani "saymak" ifadesinin
kısaltmasından gelen `c` seçeneğini ekleyebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ locate -ic ABC                                               
142

┌──(taylan@linuxdersleri)-[~]
└─$ locate -c ABC                                           
17
```

Gördüğünüz gibi harf duyarlılığı olamadan arma yaptığımızda 142 eşleşme
olurken, harf duyarlılığı varken yalnızca 17 eşleşme bulunmuş.

`locate` Üzerinde Regex Kullanımı
---------------------------------

`locate` aracında regex kullanmak istediğimizde bunu özellikle `—regex`
seçeneğiyle belirtmemiz gerekiyor. Ben denemek için öncelikle
`locate "(\.rar|\.zip)”` şeklinde regex tanımıyla eşleşme sağlamak üzere
komutumu giriyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ locate "(\.rar|\.zip)"

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın herhangi bir çıktı almadık çünkü regex çalışmadı. Bu girmiş
olduğumuz tanımın özellikle genişletilmiş regex kuralları dahilinde
değerlendirilmesi için `—regex` seçeneğini eklememiz gerekiyor.

``` {.swift}
┌──(taylan@linuxdersleri)-[~]
└─$ locate --regex "(\.rar|\.zip)"                               
/home/taylan/Downloads/linux.zip
/usr/lib/jvm/java-11-openjdk-amd64/legal/jdk.zipfs
/usr/lib/jvm/java-11-openjdk-amd64/legal/jdk.zipfs/ASSEMBLY_EXCEPTION
/usr/share/exploitdb/exploits/windows/remote/17419.zip
/usr/share/icons/Flat-Remix-Blue-Dark/mimetypes/scalable/application-vnd.rar.svg
/usr/share/mime/application/vnd.rar.xml
/usr/share/powershell-empire/empire/server/csharp/Covenant/Data/EmbeddedResources/Lib.zip
/usr/share/powershell-empire/empire/server/data/misc/python_modules/keyboard.zip
/usr/share/powershell-empire/empire/server/data/misc/python_modules/mss.zip
/usr/share/set/src/teensy/x10/libraries.zip
```

Bakın bu kez tam olarak isminin herhangi bir noktasında ".rar" veya
".zip" geçen tüm içerikler bastırılmış oldu. Ayrıca mesela
`locate —help` komutuyla bir bakacak olursak:

![23.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/23.webp)

Bakın genişletilmiş regex kuralları için `—regex` kullanırken, **basit
regex** kuralları için de `-r` veya `—regexp` seçeneğini
kullanabileceğimiz belirtilmiş. Ben aynı örneği basit regex üzerinden
denemek istiyorum

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ locate -r "(\.rar\|\.zip)"                            

┌──(taylan@linuxdersleri)-[~]
└─$
```

Komutu doğru girmiş olmama karşın herhangi bir çıktı almadım. Bunun
sebebi `locate` aracının yalnızca Posix regex kurallarını destekliyor
olması. Posix basit regex tanımında `|` metakarakteri bulunmadığı için
`locate` aracını bu karakteri tanımadı. Dolayısıyla bir eşleşme de
sağlanamadı. İşte tıpkı bu örneğimizde gördüğümüz gibi araçların regex
kurallarını tanıma ve işleme noktasında bu gibi farklara sahip
olabileceğinin farkında olmanız gerekiyor.

Tamamdır en nihayetinde benim `locate` aracı hakkında bahsetmek
istediklerim bunlar. Son olarak `locate` ile `find` arasındaki farkı
vurgulamak istiyorum.

`locate` ve `find` Arasındaki Fark
----------------------------------

`find` komutu ile dosyaları özniteliklerine göre filtreleyebildiğiniz
için çok daha fazla seçeneğe sahibiz. Zaten `find` komutunu ele alırken
dosyaların çeşitli özelliklerine göre nasıl filtreleme yapabileceğimizi
ele aldık. `locate` komutu ise yalnızca kendi veritabanındaki dosya
isimleri ile eşleşme var mı diye kontrol ettiği için, `find` komutu ile
kullanabileceğiniz dosya özelliklerini filtreleme gibi işlevleri
`locate` aracında kullanamazsınız.

Yalnızca dosya isimleri üzerinden hızlıca araştırma yapmak istiyorsanız
`locate` aracını kullanabilirsiniz. Tabii ki araştırmadan önce
`updatedb` komutuyla veritabanını güncellemeyi de unutmamız gerekiyor.

Eğer o anda sistemdeki spesifik bir dosya veya klasör hakkında araştırma
yapmak istiyorsanız da `find` aracını kullanabilirsiniz. `find` aracı
mevcut dosya sistemi üzerinde araştırma yaptığı için `locate` gibi bir
statik veriler ile çalışmadan en güncel bilgileri filtreli şekilde
sunabiliyor.

`cut` Komutu
------------

`cut` komutu, satırların istenilen bölümlerinin kesilmesini sağlıyor.
Zaten isminde geçen "cut" ifadesi Türkçe olarak "kesmek" anlamına
geliyor. Ben örnekler sırasında basit bir metin dosyası üzerinde
çalışıyor olacağım ancak siz okunabilir formatta olan tüm metinsel
verilerinizi `cut` komutu ile kesip biçimlendirebilirsiniz.

Öncelikle dosya içeriğini `cat` komutu ile görüntüleyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat metin
satir1sutun1 satir1sutun2 satir1sutun3 satir1sutun4 satir1sutun5
satir2sutun1 satir2sutun2 satir2sutun3 satir2sutun4 satir2sutun5
satir3sutun1 satir3sutun2 satir3sutun3 satir3sutun4 satir3sutun5
satir4sutun1 satir4sutun2 satir4sutun3 satir4sutun4 satir4sutun5
satir5sutun1 satir5sutun2 satir5sutun3 satir5sutun4 satir5sutun5
satir6sutun1 satir6sutun2 satir6sutun3 satir6sutun4 satir6sutun5
satir7sutun1 satir7sutun2 satir7sutun3 satir7sutun4 satir7sutun5
satir8sutun1 satir8sutun2 satir8sutun3 satir8sutun4 satir8sutun5
```

Şimdi `cut` aracının kullanımına geçecek olursak, örneğin ben bu
dosyadaki tüm sütunları değil de yalnızca 1 ila 3. sütunları istiyorsam
`cut` komutuna bu durumu izah edebilirim. Bu işlem için `cut` komutuna
bu verileri neye bakarak ayıracağını bildirmemiz gerekiyor. Tıpkı
kabuğun komutları yorumlaması gibi `cut` aracı da elindeki verilerin
hangi parçalardan oluştuğunu anlamak için bir "delimiter" yani
"sınırlayıcı" karakter belirtmemizi istiyor. Bunun için `cut` komutundan
sonra `-d` seçeneğinin hemen ardından sınırlayıcı karakteri yazmamız
gerek.

Örneğin benim dosyamda boşluk karakteri sütunları birbirinden ayırdığı
için ben tırnak için `“ “` boşluk karakterinin sınırlayıcı olduğunu
belirteceğim. Şimdi son olarak hangi sütunların, yani aslında hangi
bölümlerin kalmasını istiyorsak, bunu "fields" yani "alanlar-bölümler"
seçeneğinin kısalması olan `-f` seçeneğinin hemen ardından
belirtebiliyoruz. Ben 1 ila 3. bölümleri almak istediğim için `1-3`
şeklinde yazıyorum ve işlenecek verilerin bulunduğu dosyanın ismini de
ekleyip komutumu onaylıyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cut -d " " -f 1-3 metin
satir1sutun1 satir1sutun2 satir1sutun3
satir2sutun1 satir2sutun2 satir2sutun3
satir3sutun1 satir3sutun2 satir3sutun3
satir4sutun1 satir4sutun2 satir4sutun3
satir5sutun1 satir5sutun2 satir5sutun3
satir6sutun1 satir6sutun2 satir6sutun3
satir7sutun1 satir7sutun2 satir7sutun3
satir8sutun1 satir8sutun2 satir8sutun3
```

Bakın yalnızca 1. den 3. bölüme kadar olan sütunlar bastırıldı. `cut`
komutu ona söylediğimiz gibi dosya içeriğini okuyup dosyadaki boşluk
karakterinin bulunduğu tüm bölümleri birbirinden ayırdı ve bizim
belirttiğimiz bölümleri de filtreleyip bize sundu. Burada önemli olan,
bölümleri birbirinden ayıran boşluk karakterinin `cut` komutuna
bildirilmesi. Hatta bu durumda emin olmak için ben aynı içeriğin boşluk
yerine virgüllerle ayrılmış sürümü üzerinden `cut` komutunu tekrar
kullanmak istiyorum. Öncelikle dosya içeriğini kontrol etmek için `cat`
komutu ile virgüllü dosyayı okuyalım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat metin2
satir1sutun1;satir1sutun2;satir1sutun3;satir1sutun4;satir1sutun5
satir2sutun1;satir2sutun2;satir2sutun3;satir2sutun4;satir2sutun5
satir3sutun1;satir3sutun2;satir3sutun3;satir3sutun4;satir3sutun5
satir4sutun1;satir4sutun2;satir4sutun3;satir4sutun4;satir4sutun5
satir5sutun1;satir5sutun2;satir5sutun3;satir5sutun4;satir5sutun5
satir6sutun1;satir6sutun2;satir6sutun3;satir6sutun4;satir6sutun5
satir7sutun1;satir7sutun2;satir7sutun3;satir7sutun4;satir7sutun5
satir8sutun1;satir8sutun2;satir8sutun3;satir8sutun4;satir8sutun5
```

Bakın buradaki tüm bölümler virgülle birbirinden ayrılmış durumda. Şimdi
biz bu verileri kesmek istersek virgüllerin sınırlayıcı değer olduğunu
özellikle belirtmemiz gerekiyor. Bu durumu bizzat teyit etmek için
virgülü belirtmeden önceki komutumuzu yani boşluk karakterini
sınırlayıcı olarak belirttiğimiz komutumuzu bu dosya üzerinde de
uygulamayı deneyebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cut -d " " -f 1-3 metin2                                    
satir1sutun1;satir1sutun2;satir1sutun3;satir1sutun4;satir1sutun5
satir2sutun1;satir2sutun2;satir2sutun3;satir2sutun4;satir2sutun5
satir3sutun1;satir3sutun2;satir3sutun3;satir3sutun4;satir3sutun5
satir4sutun1;satir4sutun2;satir4sutun3;satir4sutun4;satir4sutun5
satir5sutun1;satir5sutun2;satir5sutun3;satir5sutun4;satir5sutun5
satir6sutun1;satir6sutun2;satir6sutun3;satir6sutun4;satir6sutun5
satir7sutun1;satir7sutun2;satir7sutun3;satir7sutun4;satir7sutun5
satir8sutun1;satir8sutun2;satir8sutun3;satir8sutun4;satir8sutun5
```

Bakın herhangi bir kesme işlemi uygulanmadı. Şimdi buradaki "delimiter"
yani "sınırlayıcı" karakteri olarak tırnak içine noktalı virgül
karakterini ekleyip komutumuzu bu şekilde çalıştıralım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cut -d ";" -f 1-3 metin2                                      
satir1sutun1;satir1sutun2;satir1sutun3
satir2sutun1;satir2sutun2;satir2sutun3
satir3sutun1;satir3sutun2;satir3sutun3
satir4sutun1;satir4sutun2;satir4sutun3
satir5sutun1;satir5sutun2;satir5sutun3
satir6sutun1;satir6sutun2;satir6sutun3
satir7sutun1;satir7sutun2;satir7sutun3
satir8sutun1;satir8sutun2;satir8sutun3
```

Bakın noktalı virgül karakteri sayesinde birbirinden ayrıştırılan
bölümler `cut` komutu tarafından işlenip tam olarak istediğim bölüm
aralığı sunuldu. Bu örnek üzerinden de görebildiğimiz gibi elimizdeki
verinin türüne göre sınırlayıcı olan değeri doğru şekilde belirtmezsek,
kesme işlemi de uygulanamıyor.

Eğer bir aralığı değil de spesifik olarak listelemek istediğiniz
sütunlar varsa -f seçeneğinden sonra virgülle ayırarak
belirtebilirsiniz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cut -d ";" -f 1,4 metin2                                    
satir1sutun1;satir1sutun4
satir2sutun1;satir2sutun4
satir3sutun1;satir3sutun4
satir4sutun1;satir4sutun4
satir5sutun1;satir5sutun4
satir6sutun1;satir6sutun4
satir7sutun1;satir7sutun4
satir8sutun1;satir8sutun4

┌──(taylan@linuxdersleri)-[~]
└─$ cut -d ";" -f 4 metin2                                      
satir1sutun4
satir2sutun4
satir3sutun4
satir4sutun4
satir5sutun4
satir6sutun4
satir7sutun4
satir8sutun4
```

Bakın tam olarak belirttiğim bölümler karşıma getirildi.

Aslında `cut` komutun başka seçenekleri de bulunuyor ancak diğer
seçeneklerin detaylarına girmeyi düşünmüyorum. Zaten temel çalışma
yapısını anladığınız için `cut —help` komutu ile elde edeceğiniz
buradaki tüm açıklamaları rahatlıkla anlayıp uygulayarak test
edebilirsiniz.

``` {.sql}
┌──(taylan@linuxdersleri)-[~]
└─$ cut --help
Usage: cut OPTION... [FILE]...                                   
Print selected parts of lines from each FILE to standard output.         
                                                                         
With no FILE, or when FILE is -, read standard input.                              
                                                                                   
Mandatory arguments to long options are mandatory for short options too.           
  -b, --bytes=LIST        select only these bytes                                        
  -c, --characters=LIST   select only these characters                                   
  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter                          
  -f, --fields=LIST       select only these fields;  also print any line                        
                            that contains no delimiter character, unless                        
                            the -s option is specified                                          
  -n                      (ignored)                                                                     
      --complement        complement the set of selected bytes, characters
                            or fields
  -s, --only-delimited    do not print lines not containing delimiters
      --output-delimiter=STRING  use STRING as the output delimiter
                            the default is to use the input delimiter
  -z, --zero-terminated    line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit

Use one, and only one of -b, -c or -f.  Each LIST is made up of one
range, or many ranges separated by commas.  Selected input is written
in the same order that it is read, and is written exactly once.
Each range is one of:

  N     N'th byte, character or field, counted from 1
  N-    from N'th byte, character or field, to end of line
  N-M   from N'th to M'th (included) byte, character or field
  -M    from first to M'th (included) byte, character or field

GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
Full documentation <https://www.gnu.org/software/coreutils/cut>
or available locally via: info '(coreutils) cut invocation'
```

Örneğin bakın "complement" seçeneği, bizim belirttiğimiz bölümlerin
haricindeki bölümleri bastıran bir seçenekmiş. Bu durumu görmek için en
son girdiğimiz komutu tekrar girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cut -d ";" -f 1,4 metin2
satir1sutun1;satir1sutun4
satir2sutun1;satir2sutun4
satir3sutun1;satir3sutun4
satir4sutun1;satir4sutun4
satir5sutun1;satir5sutun4
satir6sutun1;satir6sutun4
satir7sutun1;satir7sutun4
satir8sutun1;satir8sutun4

┌──(taylan@linuxdersleri)-[~]
└─$ cut -d ";" -f 1,4 metin2 --complement                                                                
satir1sutun2;satir1sutun3;satir1sutun5
satir2sutun2;satir2sutun3;satir2sutun5
satir3sutun2;satir3sutun3;satir3sutun5
satir4sutun2;satir4sutun3;satir4sutun5
satir5sutun2;satir5sutun3;satir5sutun5
satir6sutun2;satir6sutun3;satir6sutun5
satir7sutun2;satir7sutun3;satir7sutun5
satir8sutun2;satir8sutun3;satir8sutun5
```

Bakın ilk komutta tam olarak belirttiğimiz bölümler bastırılırken,
"`—complement`" seçeneğini kullandığımızda belirttiğimiz bölümlerin
haricindekiler bastırıldı.

İşte bu şekilde sütunları filtrelemek istediğimizde yani istediğimiz
sütunları kesmek istediğimizde `cut` aracını kullanabiliyoruz. Diğer
özellikleri için aynen burada olduğu gibi yardım sayfasına ya da
internet üzerindeki harici kaynaklara bakabilirsiniz. Fakat temelde
sütunları kesmek için bizim bahsetmiş olduklarımız yeterli.

`tr` Komutu
-----------

`tr` komutunun ismi "**tr**anslate" yani "çevirmek-dönüştürmek"
ifadesinden geliyor. Temelde mevcut veriler içindeki karakterleri
değiştirmek veya silmek için bu aracımızı kullanabiliyoruz. Küçük ve
büyük harf değişimi, tekrar eden karakterlerin silinmesi, özel
karakterlerin silinmesi ve bulup değiştirme gibi pek çok işlevi var. Biz
temel birkaç işlevinden bahsediyor olacağız.

`tr` komutu standart girdiden veri okuduğu için pipe ile veri aktarmak
en sık tercih edilen kullanım yöntemidir. Ben kolay bir örnek olması
için küçük "i" ve küçük "e" karakterlerini büyükleri ile değiştirmek
üzere `echo "linux dersleri" | tr "ie" "IE"` şeklinde komutumu
giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "linux dersleri" | tr "ie" "IE"
lInux dErslErI
```

Burada girmiş olduğum argümanların sıralaması çok önemli. Çünkü `tr`
komutu sıralamaya uyarak yani ilk argümanın ilk karakterini, ikinci
argümanın ilk karakteri ile ve ilk argümanın ikinci karakterini de
ikinci argümanın ikinci karakteri ile değişecek şekilde işlem yapıyor.

Zaten aldığımız çıktı da, belirtmiş olduğumuz sırlamaya uyuyor. Şimdi
sıralamayı değiştirip deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "linux dersleri" | tr "ie" "EI"
lEnux dIrslIrE
```

Bakın bu çıktı da komutta belirttiğim sırlama dahilinde yani küçük "i"
için büyük "E" küçük "e" için de büyük "I" karakteri şeklinde oldu.

Örneğin tüm küçük harfleri büyük harflere dönüştürmek istersek aralık
belirterek komut girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "linux dersleri" | tr "a-z" "A-Z"
LINUX DERSLERI
```

Bakın tüm karakterler büyükleri ile otomatik olarak yer değiştirdi.

Ayrıca kullanabileceğimiz bazı özel kalıplar da bulunuyor. Bunları
görmek için `tr —help` komutunu kullanabiliriz.

``` {.sql}
┌──(taylan@linuxdersleri)-[~]
└─$ tr --help
Usage: tr [OPTION]... SET1 [SET2]
Translate, squeeze, and/or delete characters from standard input,
writing to standard output.

  -c, -C, --complement    use the complement of SET1
  -d, --delete            delete characters in SET1, do not translate
  -s, --squeeze-repeats   replace each sequence of a repeated character
                            that is listed in the last specified SET,
                            with a single occurrence of that character
  -t, --truncate-set1     first truncate SET1 to length of SET2
      --help     display this help and exit
      --version  output version information and exit

SETs are specified as strings of characters.  Most represent themselves.
Interpreted sequences are:

  \NNN            character with octal value NNN (1 to 3 octal digits)
  \\              backslash
  \a              audible BEL
  \b              backspace
  \f              form feed
  \n              new line
  \r              return
  \t              horizontal tab
  \v              vertical tab
  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order
  [CHAR*]         in SET2, copies of CHAR until length of SET1
  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0
  [:alnum:]       all letters and digits
  [:alpha:]       all letters
  [:blank:]       all horizontal whitespace
  [:cntrl:]       all control characters
  [:digit:]       all digits
  [:graph:]       all printable characters, not including space
  [:lower:]       all lower case letters
  [:print:]       all printable characters, including space
  [:punct:]       all punctuation characters
  [:space:]       all horizontal or vertical whitespace
  [:upper:]       all upper case letters
  [:xdigit:]      all hexadecimal digits
  [=CHAR=]        all characters which are equivalent to CHAR
```

Gördüğünüz gibi Linux üzerinde regex kullanımından bahsederken ele
aldığımız bazı sembolik ifadeler de dahil, kullanabileceğimiz çeşitli
özel karakterler yardım bilgisinde belirtilmiş. Örneğin bakın buradaki
`[:lower:]` kalıbı küçük harfli olan tüm karakterleri kapsıyor, benzer
şekilde `[:upper:]` da tüm büyük harfleri kapsıyor. Denemek için gelin
bu kalıpları kullanarak küçük harfleri tekrar büyüğe dönüştürelim.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "linux dersleri" | tr [:lower:] [:upper:]                                                      
LINUX DERSLERI
```

Gördüğünüz gibi tüm küçük harfli karakterler büyük harfler ile
değiştirilmiş oldu. Tabii ki istersek tersi şekilde komut girerek, büyük
harflerin küçük harfler ile değiştirilmesini de sağlayabiliriz. Sizler
de bu listeye göz atıp, ihtiyacınız olan kalıpları kolayca
kullanabilirsiniz.

Bir örnek daha yapalım ben PATH değişkenin çıktıların yer alan iki nokta
karakterini yeni satır karakteri ile değiştirmek istiyorum. Öncelikle
standart şekilde nasıl göründüğüne bakmak için `echo $PATH` komutu ile
değişkeni konsola bastıralım.

``` {.bash}
taylan@virtualbox:~/arsiv$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

Bakın PATH yoluna ekli olan her bir dizin birbirinden iki nokta üst üste
karakteri ayrılmış. Şimdi bu çıktı bana biraz karışık geldiği için her
bir PATH dizinini yeni bir satırda görmek istiyorum. Bunu yapmak için
iki nokta üst üste karakterini yeni satır karakteri ile yani yardım
listesinde de görülen `\n` karakteri ile değiştirebiliriz. Hemen
deneyelim. Ben komutumu `echo $PATH | tr “:” “\n”` şeklinde giriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo $PATH | tr ":" "\n"                                                                            
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/local/games
/usr/games
/home/taylan/Desktop/yeni-dizin
```

Bakın, her bir PATH dizinini ayrı ayrı satırlarda bastırmayı başardık.
Bu şekilde tam istediğim gibi daha okunaklı bir çıktı elde etmiş oldum.
Bence bu yaptığımız örnek, `tr` aracının kullanımına ve ayrıca yeni
satıra geçilmesini sağlayan `\n` gibi kalıplara da iyi bir örnek oldu.

Yardım çıktısında yer alan buradaki kalıplar üzerinde pratik yaptığınız
zaman zaten kolay hatırlanır isimleri dolayısıyla kolayca anımsayıp bu
kalıplardan faydalanabilirsiniz. Ayrıca hatırlamadığınız durumda tabii
ki yardım sayfası üzerinden de tekrar öğrenebilirsiniz. Zaten pek çok
araç zaten benzer standardı izlediği için zaman içinde bu tür kalıplar
aklınızda yer edecektir.

Bu ifadeler dışında biraz da seçeneklerinden bahsedebiliriz.

Peş Peşe Tekrar Eden Karakterlerin Sadeleştirilmesi
---------------------------------------------------

Eğer peş peşe tekrar eden karakterlerden yalnızca bir tane kalmasını
istersek, `-s` seçeneğini kullanabiliriz. Buradaki `s` seçeneği
"**s**queeze" yani "sıkmak", sıkıştırmaktan aklınıza gelebilir. Ben
denemek için [www.linuxdersleri.net](http://www.linuxdersleri.net/)
adresindeki "www" karakterlerini teke indirmek istiyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "www.linuxdersleri.net" | tr -s "w"                                                           
w.linuxdersleri.net
```

Bakın "w" karakteri teke düşürüldü.

Hatta istersem bastırılabilir olan tüm tekrar eden karakterlerin
otomatik olarak filtrelenmesi için bu tür karakterleri temsil eden
`[:graph:]` seçeneğini kullanabilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "bbu biirrr deneeeme33344 yazısı123" | tr -s [:graph:] 
bu bir deneme34 yazısı123
```

Gördüğünüz gibi `[:graph:]` seçeneği sayesinde bastırılabilir(boşluk
hariç, rakam, harf, sembol gibi) karakterleri kapsayıp, bunlar içinde
tekrar edenleri teke düşürmek için de `-s` seçeneğini kullanmış olduk.

Yani bu örnek üzerinden de gördüğümüz gibi aslında spesifik olarak
belirtmemiz gereken karakterler yoksa, `tr —help` komutunun çıktısında
yer alan ifadeler ve kalıplar zaten pek çok tanımı karşılıyor. Örneğin
yalnızca tekrar eden sayıları mı düzenlemek istiyorsunuz, `[:digit:]`
tanımı kullanılabilir.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "bbu biirrr deneeeme33344 yazısı123##" | tr -s [:digit:]                                       
bbu biirrr deneeeme34 yazısı123##
```

Bakın `[:digit:]` kalıbı sayesinde yalnızca peş peşe tekrar eden sayılar
teke indirilmiş oldu.

İşte sizler de gerektiğinde yardım sayfasından göz atıp, bu ifadeleri
kolayca kullanabilirsiniz.

Her neyse, neticede `s` seçeneğinin **art arda tekrar eden**
karakterleri teke düşürdüğünü teyit etmiş olduk. Tekrarların peşi sıra
gerçekleştiğine dikkat edin.

Karakterlerin Silinmesi
-----------------------

Doğrudan karakteri bulup silmek için de `tr` aracını kullanmamız mümkün.
Bunun için "`d`elete" yani "silme" ifadesinin kısaltması olan `d`
seçeneğini kullanabiliyoruz. Ben denemek için web adresindeki noktaları
silmek istiyorum. Tek yapmam gereken `tr` aracının `-d` seçeneğini
kullandıktan sonra silinmesini istediğim karakteri belirtmek.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo www.linuxdersleri.net | tr -d "."
wwwlinuxderslerinet
```

Bakın gördüğünüz gibi yalnızca belirttiğim şekilde nokta karakterleri
silinmiş. Bu şekilde metin içinde silinmesini istediğiniz tüm
karakterleri belirtebiliyoruz. Fakat burada yazdığını karakterlerin
yalnızca tek bir karakteri işaret ettiğini unutmayın lütfen. Yani
örneğin ben aynı komutta `-d` seçeneğinden sonra "`de`" yazarsam, "d" ve
"e" karakterinin hepsi bulunup silinecek. Yalnızca bütünleşik olan "de"
kalıbını silmeyecek yani. Komutumuzu onaylayalım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ echo www.linuxdersleri.net | tr -d "de"                                                            
www.linuxrslri.nt
```

Bakın yazdığım tüm karakterler ayrı ayrı ele alındı ve eşleşen
karakterler kaldırıldı. Yani doğrudan "de" ifadesini aranmadı, "d" ve
"e" karakterleri ayrı ayrı aranıp bulunduğunda teker teker silindiler.

Eğer bitişik yapıdaki birden fazla karakteri kapsayacak değişiklikler
istiyorsanız ileride ele alacağımız `sed` veya `awk` gibi araçlardan
yararlanabilirsiniz. `tr` aracı yalnızca bir karakter ile başka bir
tanesini değiştirme silme veya tekrar edenleri sadeleştirmek gibi işler
için kullanılıyor.

Ayrıca son olarak, örneklerimiz sırasında verileri hep pipe üzerinden
`tr` aracına yönlendirdik. İstersek yönlendirme operatörü ile de `tr`
aracının standart girdisine veri aktarmamız da mümkün. Ben peş peşe
tekrar eden karakterlerin `tr` komutu ile teke düşürülmesi için
yönlendirme operatörü ile dosyayı `tr` komutuna aktaracağım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "bbu biirrr deneeeme33344 yazısı123##" > test

┌──(taylan@linuxdersleri)-[~]
└─$ tr -s [:graph:] < test
bu bir deneme34 yazısı123#
```

Bakın gördüğünüz gibi yönlendirmiş olduğumuz dosyadaki veri `tr` komutu
tarafından okunup, filtrelenmiş oldu. Yani bizzat teyit ettiğimiz gibi
`tr` komutunu yalnızca pipe ile kullanmak zorunda değiliz. `tr` aracı
verilerini standart girdiden okuyor. Dolayısıyla standart girdisine
verileri yönlendirdiğimiz sürece `tr` aracı ilgili verileri işleyip
çıktıları standart çıktıya yani biz aksini belirtmediğimiz sürece
konsolumuza yönlendiriyor olacak.

Eğer bu çıktıları bir dosyaya kaydetmek istersek örneğin aynı komutun
sonuna `> kaydet` şeklinde yazabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ tr -s [:graph:] < test > kaydet

┌──(taylan@linuxdersleri)-[~]
└─$ cat kaydet                                                                                          
bu bir deneme34 yazısı123#
```

Bakın çıktıların "***kaydet***" isimli dosyaya sorunsuzca yönlendirilmiş
olduğunu `cat` komutu ile de teyit etmiş olduk.

Benim `tr` aracı hakkında bahsetmek istediklerim bu kadar.

`sed`
-----

`sed` komutu "**s**tream **ed**itor" ifadesinin kısaltmasından gelen
metin manipülasyon aracıdır. Daha önce, "her şey bir dosyadadır, her şey
bir bayt akışıdır" demiştik. İşte "stream" yani "akış-aktarım" ifadesi
de bu bayt akışının manipülasyonu dolayısıyla kullanılmış.

Basit ve genişletilmiş regex kurallarının da yardımıyla `sed` aracı
sayesinde, bulma değiştirme, ekleme, ve silme gibi işlemleri yerine
getirebiliyoruz.

Bulup Değiştirme
----------------

### Tüm Eşlemeler \| Global

Aradığımız ifade ile eşleşenlerin hepsinin değiştirilmesini istersek
`sed ‘s/bulunacak/degiştirilecek/g’ dosya_ismi` şeklinde komutumuzu
girmemiz gerek. Buradaki "`g`" seçeneği "**g**lobal" yani tüm
eşleşmeleri kapsıyor. Ben denemek için bir dosya oluşturup bu dosya
üzerinden örnekler vereceğim.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ cat veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri
```

Şimdi ben bu dosyada geçen "satır" ifadelerinin hepsini "bölüm" ifadesi
ile değiştirmek istiyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed 's/satır/bölüm/g' veri
bu ilk bölüm bu ikinci bölüm bu da son bölüm
bölüm iki ve bölüm sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
```

Gördüğünüz gibi "**satır**" ifadesini "**bölüm**" ile değiştirmiş oldum.

### Tüm Satırlardaki İlk Eşleşme

Eğer "`g`" parametresini kullanmazsak yalnızca ilk eşleşme
değiştirilecekti.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed 's/satır/bölüm/' veri
bu ilk bölüm bu ikinci satır bu da son satır
bölüm iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri
```

Bakın her bir satırdaki yalnızca ilk eşleşmeler değiştirildi.

### Satır Numarası Belirtmek

Özellikle hangi satırların dahil edileceğini `s` parametresinden önce
belirtebiliriz.

Örneğin ben yalnızca 3. satırı kapsamak istersem `3s` şeklinde
belirtebilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed '3s/satır/bölüm/' veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '3s/satır/bölüm/g' veri                                                                               
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
```

Ayrıca birden fazla belirtmemiz de mümkün. Ben 1'den 3. satıra kadar
olanları dahil etmek için `1,3s` şeklinde giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed '1,3s/satır/bölüm/' veri                                                                              
bu ilk bölüm bu ikinci satır bu da son satır
bölüm iki ve satır sonu
yeni bölüm ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '1,3s/satır/bölüm/g' veri                                                                             
bu ilk bölüm bu ikinci bölüm bu da son bölüm
bölüm iki ve bölüm sonu
yeni bölüm ve son bölüm
yeni veri ve son veri
```

Silme
-----

### Belirtilen Satırları Silme

Spesifik olarak silmek istediğimiz satırları `d` seçeneğinden önce
belirtebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '2d' veri
bu ilk satır bu ikinci satır bu da son satır
yeni satır ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '2,4d' veri                                                                                           
bu ilk satır bu ikinci satır bu da son satır
```

### Eşleşme Sağlanan Satırları Silmek

Eğer aradığımız ifade ile eşleşme sağlanan satırları silmek istersek
`sed ‘/aranan/d’` şeklinde komutumuzu girebiliriz. Ben denemek için
"yeni" ifadesinin geçtiği tüm satırları silmek istiyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '/yeni/d' veri
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
```

Bakın "yeni" ifadesi ile eşleşme sağlananlar silinmiş oldu.

### Eşleşme Haricindeki Satırları Silmek

Aradığımız ifade ile eşleşen satırlar hariç tüm satırları silmek
istersek `d` parametresinden önce `!` ünlem işaretini kullanabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat veri                                                                                        
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri

┌──(taylan@linuxdersleri)-[~]
└─$ sed '/yeni/!d' veri                                                                                       
yeni satır ve son satır
yeni veri ve son veri
```

Gördüğünüz gibi "yeni" ifadesiyle eşleşenler hariç tüm satırlar silinmiş
oldu.

Ekleme
------

### Eşleşmeden Önceki Satıra Ekleme

Eşleşmeden önceki satıra eklemek için `i` parametresini kullanıyoruz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed '/veri/i\oncesi' veri                                                                                
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
oncesi
yeni veri ve son veri
```

### Eşleşmeden Sonraki Satıra Ekleme

Eşleşmeden sonraki satıra eklemek için `a` parametresini kullanıyoruz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ sed '/veri/a\sonrası' veri                                                                                
bu ilk satır bu ikinci satır bu da son satır
satır iki ve satır sonu
yeni satır ve son satır
yeni veri ve son veri
sonrası
```

`sed` komutu kesinlikle burada bahsettiklerimle sınırlı değil fakat ilk
aşama için temelde bilmemiz gerekenler bu kadar. Eğer biraz araştırma
yapacak olursanız `sed` aracının aslında script olarak yazılıp metinsel
verileri ihtiyaca göre manipüle edebileceğini de göreceksiniz. Fakat ben
bu eğitimde daha fazla detaydan bahsetmeyi planlamıyorum. Günlük hayatta
da daha fazlasına ihtiyacım olmuyor. Olsa bile internet üzerinden ek
olarak ihtiyacıma yönelik araştırma yapıp çözümü uyguluyorum.

`awk` \| `gawk`
---------------

`awk` aracıyla metinsel veriler üzerinde çeşitli manipülasyonlar
yapmamız mümkün.

`awk` aracının pek çok farklı sürümü bulunuyor. Biz **GNU** `awk` yani
`gawk` aracını ele alacağız. Pek çok Linux dağıtımında `gawk` aracı
`awk` komutuna sembolik olarak bağlı. Yani biz `awk` komutunu giriyoruz
ama `gawk` aracını kullanıyoruz.

`awk` aracında veriler, kayıtlar(records) ve alanlar(fields) olmak üzere
iki parçaya ayrılıyorlar.

![awk1.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/awk1.webp)

`awk`, girişin sonuna ulaşılana kadar her seferinde bir kayıt üzerinde
çalışır. Kayıtlar(records) da, kayıt ayırıcı(**R**ecord **S**eparator)
adı verilen özel bir karakter sayesinde birbirinden ayrılıyor. Kayıtları
birbirinden ayırmak için kullanılan varsayılan karakter de yeni satıra
geçiş karakteridir. Dolayısıyla aslında varsayılan olarak `awk` aracı
her bir satırı bir kayıt olarak ele alıyor. Yani `awk` aracı her
seferinde sırasıyla tek bir satır üzerinde çalışıyor. Ben kabaca `awk`
aracının, verileri nasıl ele aldığını aşağıda temsil etmeye çalıştım.

![awk1.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/awk1.gif)

Alanalar(fields) ise boşluk karakteri ile birbirinden ayrılıp,
kayıtları(records) oluşturuyor. Her kayıttaki alanlara da dolar işareti
(`$`) ve ardından 1 den başlayan sıralı alan numarası veriliyor. Yani
ilk alan `$1` ile, ikincisi `$2` ile vb. temsil ediliyor. En sondaki
alana ise doğrudan `$NF` özel değişkeni ile ulaşılabiliyor. Tüm alanlara
yani aslında kaydın(ilgili satırın) tamamına da `$0` değişkeni ile
ulaşılabiliyor.

![awk-complete-record.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/awk-complete-record.webp)

Bu detaylar `awk` kullanımı için bilmemiz gereken birkaç temel bilgi
sadece. Birazdan uygulama yaptıkça buradaki açıklamalar sizin için çok
daha anlamlı hale gelecek.

`awk` Programı
--------------

`awk` aslında bir programlama dili gibi, işlenecek veriler için çeşitli
programlar yazabilmemize olanak tanıyor. Fakat biz çok temel düzeyde
birkaç işlevini ele alacağız. Nasıl programlanabileceğini öğrenmek için
kısa bir ek araştırma yapmanız yeterli.

`awk` aracını kullanmak için gireceğimiz komutlar aşağıdaki gibi olacak.

Eğer "desen", kayıt yani satırla eşleşme sağlarsa "aksiyon" olarak
belirtilen görev yerine getirilecek. Aksiyonlar, kıvırcık parantez
içinde "özel ifadeler" ile birlikte belirtiliyor. İfadeler sayesinde,
aksiyonun ne olması gerektiğini belirtebiliyoruz. Awk üzerinde en yaygın
kullanıma sahip olan ifade "***print***" ifadesidir.

`print`: Kayıtları, alanları, değişkenleri ve özel metni yazdırmamızı
sağlar.

Ben örnekler için aşağıdaki ***veri.txt*** dosyası üzerinde çalışıyor
olacağım.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat > veri.txt
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
32 mehmet KARA
naz 29 sabah
```

Her bir satırın ilk bölümünü bastırmak istediğim için
`awk ‘{ print $1}’ veri.txt` şeklinde komutumu giriyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $1}' veri.txt
Ahmet
hasan
aylin
32
naz
```

Bakın `awk` aracı her bir satırı ayrı ayrı ele aldığı ve `$1`
parametresi de ilk alanı temsil ettiği için ilk sütunlardaki tüm
verileri `print` ile bastırmış olduk. Burada tek tırnak kullanmamız
önemli, çünkü süslü parantezin kabuk tarafından yorumlanmasını
istemiyoruz.

Örneğin ben son yani 3. sütundakileri filtrelemek istersem `$3` yada
sonda olduğu için `$NF` değişkenini kullanabilirim.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $3}' veri.txt
33
19
24
KARA
sabah

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $NF}' veri.txt
33
19
24
KARA
sabah
```

Birden Fazla Sütunu Bastırmak
-----------------------------

Dilersek birden fazla sütun üzerinde de çalışabiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $1 $3}' veri.txt
Ahmet33
hasan19
aylin24
32KARA
nazsabah
```

Fakat bu şekilde gördüğünüz gibi sütunlar arasında boşluk bulunmuyor.
Eğer boşluk olmasını istiyorsak tırnak içinde bunu özellikle
belirtebiliriz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $1 " " $3}' veri                                 
Ahmet 33
hasan 19
aylin 24
32 KARA
naz sabah
```

Satır(record) Numarası Belirtmek
--------------------------------

Eğer spesifik bir satırda işlem yapılmasını istiyorsak bunu "NR"(number
record) değişkeni ile özellikle belirtebiliyoruz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]                                                                                                                              
└─$ awk 'NR==2 {print $1 " "  $3}' veri.txt                                                                                                                 
hasan 19

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk 'NR==4 {print $1 " "  $3}' veri.txt                                                                                                                 
32 KARA
```

Ayrıca `substr` tanımı ardından hangi karakterden sonrasının alınacağını
belirtebiliriz.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print $1 }' veri.txt                                                                                                                
Ahmet
hasan
aylin
32
naz
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print substr($1,1) }' veri.txt                                                                                                                    
Ahmet
hasan
aylin
32
naz

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print substr($1,2) }' veri.txt                                                                                                                    
hmet
asan
ylin
2
az

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '{print substr($1,1,3) }' veri.txt                                                                                                                  
Ahm
has
ayl
32
naz
```

Ayrıca varsayılan ayırıcı karakteri olan boşluk yerine
`-F'ayıcı-karakter'` tanımlaması sayesinde istediğimiz bir karakteri,
ayırıcı olarak belirtebiliyoruz. Örneğin ben denemek için iki nokta üst
üste karakterini ayırıcı olarak belirtmek üzere `-F':'` tanımlamasını
kullanabilirim. Denemek için PATH değişkeninde tanımlı olan 1. ve ikinci
dizinleri alt alta yazdırmak istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/home/taylan/Desktop/yeni-dizin

┌──(taylan㉿linuxdersleri)-[~]
└─$ echo $PATH | awk -F':' '{print $1 "\n" $2}'                                                                                                            
/usr/local/sbin
/usr/local/bin
```

`awk` aracının en temel kullanımı burada ele aldığımız şekilde. Ayrıca
daha geniş eşleşmeler için Regex kullanabiliyoruz.

Regex Kullanımı
---------------

`awk` üzerinde regex kullanmak için regex tanımlarını slash karakterleri
arasında `/regex/` şeklinde yazmamız gerek.

Örneğin ben satır sonunda sayı bulunanları filtreleyip, bu son sütunları
bastırmak istiyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat veri.txt 
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
32 mehmet KARA
naz 29 sabah

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '/[0-9]$/{print $NF}' veri.txt 
33
19
24
```

Gördüğünüz gibi `[0-9]$` regex tanımı sonunda sayısal veri bulunan
satırlar ile eşleşme sağladı, `{print $NF}` ise bu satırların yalnızca
son sütunlarının bastırılmasını sağladı. Benzer şekilde sonunda sayı
bulunan satırların hepsini bastırmak için `$NF` yerine `$0` değişkenini
kullanabilirdik.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '/[0-9]$/{print $0}' veri.txt 
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
```

Regex için Spesifik Bölüm Belirtmek
-----------------------------------

Eğer regex kalıbının tüm kayıt üzerinde değil de yalnızca belirli
alanlar üzerinde aranmasını istersek dolar işareti ile aranmasını
istediğimiz bölümü belirtip peşine tilde `~` işareti eklememiz yeterli.

Örneğin ben yalnızca 2. sütununda rakam bulunduran satırların 1.
sütunlarını bastırmak istiyorum.

``` {.swift}
└─$ awk '$2 ~ /[0-9]/{print $1}' veri                            
naz
```

Buradaki `$2 ~` tanımı `[0-9]` regex kalıbının yalnızca 2. alanda yani
ikinci sütunda eşleşme aramasını sağladı. `{print $1}` ise sağlanmış
olan bu eşleşmelerin 1. sütunlarını konsola bastırmış oldu. Yalnızca ilk
sütunu değil de tüm kaydı bastırırsak, zaten bu satırın 2. sütununda
rakam geçtiğini kendimiz de görebiliriz.

``` {.swift}
└─$ awk '$2 ~ /[0-9]/{print $0}' veri                            
naz 29 sabah
```

Regex için Kaçınılması Gereken Spesifik Bölüm Belirtmek
-------------------------------------------------------

Eğer spesifik olarak dahil edilmesini istemediğimiz alan varsa bunu
tilde işaretinden önce ünlem işareti ekleyerek `!~` belirtebiliriz.
Örneğin ben bir önceki örnekte olan 2. alandakilerin regex dahilinde
aranmasını, 2. alandakilerin hariç tutularak aranması olarak değiştirmek
istiyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '$2 ~ /[0-9]$/{print $0}' veri.txt 
naz 29 sabah

┌──(taylan㉿linuxdersleri)-[~]
└─$ awk '$2 !~ /[0-9]$/{print $0}' veri.txt 
Ahmet Yaz 33
hasan mert 19
aylin uzun 24
32 mehmet KARA
```

Gördüğünüz gibi 2. sütununda sayısal veri bulunduran hariç tüm sütunlar
regex genişletmesine dahil edilmiş oldu. Yani hariç tutmak istediğimiz
alanları tilde işaretinden önce ünlem işareti `!~` ile özellikle
belirtebiliyoruz.

`awk` aracı inanılmaz derecede esnek özellikle sahip olan süper
yetenekli bir araç. Fakat şahsen ben ihtiyacım olduğu kadarını
hatırlayıp, gerektiğinde ek detaylar için interneti kullandığım için
burada temel seviye için daha fazla özellikten bahsetmeyi makul
bulmuyorum. Daha fazlası için kısa bir araştırma yapmanız yeterli.

Konsolda Okunaklı Çıktılar Almak
--------------------------------

Şimdiye kadar nasıl dosya oluşturabileceğimizi, dosyaları nasıl okuyup,
içeriklerini istediğimiz gibi filtreleyip değiştirebileceğimizi
öğrendik. Şimdi de konsol üzerinden verileri okumak istediğimizde
bizlere kolay okuma imkanı sunan araçlardan bahsedelim istiyorum.

Komut satırı üzerinde çalışıyorken, araçların ürettiği çıktıları yine
komut satırımız üzerinde yazılı şekilde takip ediyoruz. Fakat sizin de
bildiğiniz gibi komut satırının da bir görüntüleme sınırı var. Eğer
grafiksel arayüzdeki bir komut satırında çalışıyorsak, zaten terminal
aracı çıktıların konsola sığmayan kadarını görebilmemizi sağlayan
kaydırma çubuğu gibi özellikler sunuyor.

![terminal-scroll.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/terminal-scroll.gif)

İşte bizzat test ettiğimiz gibi grafiksel arayüzdeki bu konsol aracımız,
çıktıların tamamını bu pencere içerisinde tek seferde gösteremiyor olsa
da, tamamını görebilmemiz için bize kolaylık sağlıyor. Fakat komut
satırı arayüzündeki tty konsollarında çalışırken, önceki çıktılara dönme
gibi bir imkanımız olmuyor. Dolayısıyla uzun çıktılar üreten araçların
tüm çıktılarını yalnız komut satırı arayüzünün bulunduğu tty
konsollarında tam şekilde görüntüleyemiyoruz.

Denemek isterseniz komut satırı arayüzüne geçip uzun bir dosya içeriğini
`cat` komutu ile okuyabilirsiniz. Ben denemek için daha önce
oluşturduğum "***isimler.txt***" dosyamı okumak için `cat isimler.txt`
komutunu giriyorum.

![tty-scroll.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/tty-scroll.webp)

Bakın yalnızca dosyanın sonunu görebiliyoruz. Faremizin scroll tuşu ile
daha önceki çıktıları görme imkanımız da yok.

İşte bu duruma çözüm olarak araçların çıktılarını bize parça parça
sunabilecek ek araçlara ihtiyacımız var. Ben de anlatımın devamında bize
bu imkanı tanıyan `more` `less` `head` ve `tail` araçlarından bahsedip,
komut satırı arayüzündeki hakimiyetimizi arttırmak istiyorum.

`more` Komutu
-------------

`more` aracı, kendisine yönlendirilmiş olan verilerin en başından
itibaren ekrana sığan kadarlık kısmını sırasıyla parça parça bize
sunuyor. Örneğin bir dosya içeriğinin ilk 10 satırı ekranımıza
sığıyorsa, ilk olarak 10 satırı daha sonra bir sonraki 10 satırı ve bir
sonraki 10 satırı gösterecek şekilde tüm içerik bitene kadar baştan
sonra tüm verileri parça parça bize sunuyor.

Zaten `more` ismi de "daha" anlamına geliyor. Biz istedikçe verilerin
geri kalanını yani daha fazlasını bize parça parça sunduğu için `more`
ismi verilmiş.

Ben örnek olması için ***/etc*** dizinin içeriğini listeleyip, tüm
listeye parça parça bakmak istiyorum. Örneğin `ls -l /etc` şeklinde
komutumuzu girdiğimizde tek seferde tüm çıktıları göremeyiz.

![without-more.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/without-more.webp)

Bu sorunu çözmek içim bu çıktıları pipe ile `more` aracına yönlendirip
çıktılara parça parça bakabiliriz.

![more.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/more.gif)

Gördüğünüz gibi bu kez, içerik listesinin en başından itibaren yalnızca
ekranıma sığan kadarlık kısmını görüyoruz ve altta "**more**" ifadesi
var. Bu ifade, ileride daha fazla verinin olduğuna işaret ediyor. Eğer
bir satır sonrasını görmek istersek enter tuşunu, eğer ekranımıza sığan
bir sonraki tüm bölümü görmek istersek de space tuşunu kullanabiliyoruz.

Gördüğünüz gibi tamamı konsol ekranımıza sığmayacak kadar olan tüm
verileri, `more` aracına yönlendirip, bu araç vasıtasıyla ekranımıza
sığan kadarlık kısmını parça parça veya satır satır **ileriye doğru**
görüntüleyebiliyoruz. Fark ettiyseniz özellikle "ileriye doğru" dedim
çünkü `more` aracı önceki çıktılara dönmemizi sağlamıyor. Tek yönlü
şekilde yani hep daha fazlası için en baştan en sona doğru verileri
görüntüleyebiliyoruz. Örneğin space ile geçtiğiniz önceki parçaya dönmek
isterseniz bu `more` aracı ile mümkün değil. Bunun için birazdan
bahsedeceğimiz `less` aracını kullanabiliriz.

Eğer yalnızca ileriye doğru okuma yapacaksanız dosyalar veya pipe
üzerinden `more` aracına okunacak verileri verebilirsiniz. Biz özellikle
ele almadık ama elbette `more` aracı ile doğrudan dosya içeriklerini de
okuyabiliyoruz.

![more-with-file.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/more-with-file.gif)

Yani bizzat test ettiğimiz gibi `more` aracı standart girdiden veri
almasına ek olarak, kendisine argüman olarak verilmiş olan dosya
içeriğini de parça parça konsol üzerinden görüntüleyebilmemize olanak
tanıyor.

Hatta dilerseniz `more` aracına aynı anda birden fazla dosya ismini
verip, birden fazla verinin de sırasıyla `more` aracı üzerinden
okunmasını sağlayabilirsiniz.

Tüm bunlar dışında eğer `more` aracını kullanırken içeriğin sonuna
gelmeyi beklemeden aracı sonlandırmak isterseniz q tuşuna basmanız
yeterli. Ben denemek için birden fazla dosyayı `more` ile açıp,
dosyaların sonuna gelmeden q tuşuna basıp `more` aracını kapatıyorum.

![quit-more.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/quit-more.gif)

Bakın q tuşuna bastığım anda araç kapatıldı.

`less` Komutu
-------------

`more` aracının çıktılarda geriye doğru kaydırma yapamamasından bıkan
başka bir geliştirici "less is more" yani "az çoktan fazladır" cümlesine
atıfta bulunarak `less` aracını geliştirmiştir.

`less` komutu `more` komutundan farklı olarak dosya içeriğinde aşağı
yukarı, sağa ve sola doğru kaydırma hareketlerine imkan tanıyor.

Test etmek için ***/etc/passwd*** dosyasını okumayı deneyebiliriz.

Eğer bir satır aşağı inmek istersem klavyemdeki aşağı yön tuşunu
kullanabilirim. Benzer şekilde bir üst satıra çıkmak için de klavyemdeki
yukarı yön tuşunu kullanmam yeterli. Ayrıca `more` komutunda olduğu
şekilde enter ile de bir satır aşağı inip, space ile birer sayfa ileriye
atlayabiliyoruz. Space tuşu haricinde bir sayfa ileri gitmek için
"**f**orward" yani "ileri" ifadesinin kısaltması olan f tuşunu da
kullanabiliyoruz. Bir sayfa geri gelmek için de "**b**ackward" yani
"geriye" ifadesinin kısaltması olan b tuşunu kullanabiliyoruz. Okuma
işimiz bittiğinde aracı kapatmak için q tuşuna basmamız yeterli.

![less.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/less.gif)

Ben doğrudan dosya ismini argüman olarak verdim ancak dilerseniz tabii
ki standart girdiden de istediğiniz veriyi yönlendirebilirsiniz. Örneğim
`ls -l /etc | less` komutu ile ***/etc*** dizininin ayrıntılı
çıktılarını parça parça inceleyebilirsiniz.

Bence `less` aracı hakkında bu kadarlık bilgi yeterli. Daha fazlasını
öğrenmek veya unuttuğunuzda hatırlamak için `less —help` komutunu
kullanıp `less` aracının yardım sayfasından faydalanabilirsiniz.

`head` Komutu
-------------

İsminin de çağrışım yaptığı gibi `head` komutu kendisine yönlendirilen
içeriğin başından itibaren okunabilmesini sağlıyor. Herhangi bir seçenek
belirtmediğimizde `head` aracı ilk 10 satırı konsola bastırıyor. Ben
denemek için `head /etc/passwd` komutu ile dosyamı okumak istiyorum.

``` {.ruby}
└─$ head /etc/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
```

Dosya içeriğinin yalnızca ilk 10 satırı bastırılmış oldu.

Birden fazla dosya okunmasını da sağlayabiliriz. Eğer aynı anda birden
fazla dosya okunuyorsa her bir dosyanın ilk 10 satırını bastırıyor.
Hemen deneyelim.

``` {.ruby}
└─$ head /etc/passwd /etc/group
==> /etc/passwd <==
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin

==> /etc/group <==
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root
tty:x:5:
disk:x:6:
lp:x:7:
mail:x:8:
news:x:9:
```

Bakın en başta hangi dosya olduğunu da açıkça belirtilerek her iki
dosyanın da ilk 10'ar satırı bastırılmış.

Bu temel kullanım dışında eğer kaç satır bastırılmasını gerektiğini
belirtmek istiyorsak, `-n` seçeneğinin ardından kaç satır basılacağını
da yazabiliyor. Ben denemek için dosyanın ilk 5 satırını bastırmak üzere
`head -n 5 dosya_adı` şeklinde komutumu giriyorum.

``` {.ruby}
└─$ head -n 5 /etc/passwd /etc/group                                   
==> /etc/passwd <==
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync

==> /etc/group <==
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root

┌──(taylan@linuxdersleri)-[~]
└─$ head -n 5 /etc/passwd                                    
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
```

Bakın dosyaların yalnızca ilk 5 satırı bastırıldı. Ayrıca bu kullanım
dışında doğrudan `head -5 dosya_adı` komutu ile de aynı şekilde ilk 5
satırın bastırılmasını sağlayabiliriz.

``` {.ruby}
└─$ head -5 /etc/passwd /etc/group                                    
==> /etc/passwd <==
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync

==> /etc/group <==
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:taylan,root
```

Yani bakın, `n` seçeneği olmadan doğrudan tire işaretinden sonra kaç
satır bastırılmasını gerektiğini de bu şekilde belirtebiliyoruz. Aynı
çıktıyı aldık.

Tahmin ettiğiniz gibi tabii ki yalnızca dosyalar üzerinde çalışmak
zorunda da değiliz. Örneğin `ls -l /etc` komutunu çıktılarını pipe ile
`head` aracına yönlendirip ilk 10 satırın bastırılmasını sağlayabiliriz.

``` {.yaml}
└─$ ls -l /etc/ | head
total 1320
-rw-r--r--  1 root     root      2981 Feb 11  2022 adduser.conf
-rw-r--r--  1 root     root        44 Feb 11  2022 adjtime
drwxr-xr-x  3 root     root      4096 Feb 11  2022 alsa
drwxr-xr-x  2 root     root     20480 Jun 28  2022 alternatives
drwxr-xr-x  8 root     root      4096 Feb 11  2022 apache2
drwxr-xr-x  2 root     root      4096 Feb 11  2022 apparmor
drwxr-xr-x  9 root     root      4096 Feb 11  2022 apparmor.d
drwxr-xr-x  7 root     root      4096 Jun 14 11:40 apt
drwxr-xr-x  3 root     root      4096 Feb 11  2022 avahi
```

Bakın yalnızca 10 satırı bastırıldı. Mesela bastırılan satır sayısını
teyit etmek için pipe ile `nl` aracını da kullanabiliriz.

``` {.yaml}
└─$ ls -l /etc/ | head | nl
     1  total 1320                                                         
     2  -rw-r--r--  1 root     root      2981 Feb 11  2022 adduser.conf    
     3  -rw-r--r--  1 root     root        44 Feb 11  2022 adjtime               
     4  drwxr-xr-x  3 root     root      4096 Feb 11  2022 alsa
     5  drwxr-xr-x  2 root     root     20480 Jun 28  2022 alternatives
     6  drwxr-xr-x  8 root     root      4096 Feb 11  2022 apache2
     7  drwxr-xr-x  2 root     root      4096 Feb 11  2022 apparmor
     8  drwxr-xr-x  9 root     root      4096 Feb 11  2022 apparmor.d
     9  drwxr-xr-x  7 root     root      4096 Jun 14 11:40 apt
    10  drwxr-xr-x  3 root     root      4096 Feb 11  2022 avahi
```

Bakın `ls` komutunun çıktıları `head` aracına iletildi ve 10 satırla
sınırlandıktan sonra bu çıktılar `nl` aracı sayesine numaralandırılmış
oldu.

Ayrıca `head` aracının başka seçenekleri de var fakat diğer
seçeneklerine neredeyse hiç ihtiyaç duymayacağınızı düşündüğüm için
bahsetmiyorum. Merak ediyorsanız, `head —help` komutunu
kullanabilirsiniz.

`tail` Komutu
-------------

`tail` ifadesi Türkçe "kuyruk" anlamına geliyor. İsminden de kolayca
anlaşılabileceği gibi `tail` komutu dosyaların **sondaki satırlarının**
bastırılmasını sağlıyor. Yani `tail` aracını `head` aracının tersten
çalışan versiyonu olarak düşünebilirsiniz. `tail`, ekstra bir seçenek
kullanılmadığında varsayılan olarak ilgili dosyanın **sondan 10**
satırını bastırıyor. Hemen denemek için ***/etc/passwd*** dosyasını
okumayı deneyelim.

``` {.ruby}
└─$ tail /etc/passwd                                                        
sslh:x:125:130::/nonexistent:/usr/sbin/nologin
postgres:x:126:131:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:128:135::/var/lib/saned:/usr/sbin/nologin
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
```

Bakın dosya içeriğinin sondan 10 satırı bastırıldı. Dilersek kaç satır
bastırılacağını `-n` seçeneğinin ardından belirtmemiz de mümkün. Ben son
6 satırı bastırmak için `tail -n 6 /etc/passwd` şeklinde komutumu
giriyorum.

``` {.ruby}
└─$ tail -n 6 /etc/passwd
inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin
lightdm:x:130:138:Light Display Manager:/var/lib/lightdm:/bin/false
colord:x:131:139:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash
```

Bakın yalnızca sondan 6 satır bastırılmış.

Ayrıca tıpkı `head` komutunda olduğu gibi elbette birden fazla dosyayı
da aynı anda açabiliriz. Ben ***passwd*** ve ***group*** dosyalarının
sondan 3 satırını bastırmak için `tail -n 3 /etc/passwd /etc/group`
komutunu giriyorum.

``` {.ruby}
└─$ tail -n3 /etc/passwd /etc/group                                              
==> /etc/passwd <==
geoclue:x:132:140::/var/lib/geoclue:/usr/sbin/nologin
king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin
taylan:x:1000:1000:taylan,,,:/home/taylan:/usr/bin/bash

==> /etc/group <==
kaboxer:x:143:taylan,root
yeni-grup:x:1003:
ali:x:1001:
```

Bakın sırasıyla her iki dosyanın da sondan 3 er satırı bastırıldı.

Dosya içeriklerinin okunması yerine standart girdiden alınan verilerin
kullanılması da mümkün. Ben `ls /etc/` komutu ile dizin içeriğinin
listelenip, pipe ile bu çıktıların `tail` aracına aktarılmasını
istiyorum.

``` {.bash}
└─$ ls /etc/ | tail                                                              
wgetrc
wireshark
wpa_supplicant
X11
xattr.conf
xdg
xfce4
xl2tpd
zsh
zsh_command_not_found
```

Bakın bu sayede gördüğünüz gibi ***/etc*** dizin içeriğinin sondan 10
satırı konsola bastırılmış oldu.

### Verilerin Anlık Takibi `-f`

Bu basit kullanımlar dışında, `tail` aracının `-f` seçeneği sayesinde
sürekli güncellenen verilerin takip etmemiz de mümkün oluyor. Bu `-f`
seçeneği, özellikle log dosyalarındaki en son değişikliklerin takibi
için sıklıkla kullanıyor. Seçeneğin kısaltması da "**f**ollow" yani
"takip etme" ifadesinin kısaltmasından geldiği için işlevinin
hatırlanması son derece kolay.

Ben test etmek için iki konsol üzerinden çalışacağım. İlk konsola
`cat > yeni.txt` komutu ile yeni bir dosya açıp veri girişi yapmak üzere
giriş yapıyorum. İkinci konsola da ***yeni.txt*** dosyasındaki
değişikliklerin anlık olarak takip edilmesi için `tail -f yeni.txt`
komutunu giriyorum. Bu sayede ben ***yeni.txt*** dosyasına veri
ekledikçe bunları `tail -f` komutu sayesinde anlık olarak takip
edebiliyor olacağız.

![tail-f.gif](https://www.linuxdersleri.net/egitim/temel-linux/metin/tail-f.gif)

Bakın ne kadar yeni veri girersem, `tail -f` komutu o kadar veriyi
bastırıyor. Bu komut özellikle anlık değişimlerin takibi için log
dosyalarını okumak için sıklıkla kullanılıyor.

İleride log kayıtları ile uğraşırken `tail -f` komutunu sizler de
sıklıkla kullanıyor olacaksınız. Eğer bu `tail` komutunun `f` seçeneğini
kullanmazsak, dosyalardaki en son değişiklikler yerine yalnızca o
dosyayı açtığımız andaki verilere ulaşabiliyoruz. `tail -f` komutu anlık
olarak dosya içeriğindeki verileri takip etmemizi sağlıyor. Ayrıca bu
şekilde sürekli yeni veri var mı diye beklendiği için aracı kapatmak
için ctrl + c ile durdurmamız gerekiyor.

Böylelikle temel olarak `tail` aracının işlevinden ve kullanımından da
haberdar olduk. Tabii diğer seçenekleri için yardım sayfalarına göz
atabilirsiniz.

Ayrıca ben özellikle ele almadım ancak pipe mekanizmasının da yardımıyla
ihtiyacınıza yönelik olarak bu bölümde öğrenmiş olduğunu uygun yapıdaki
tüm araçları birbirine bağlayarak çalıştırabileceğinizi zaten
biliyorsunuz. Ben yalnızca araçların temel kullanımlardan bahsettiğim
için özellikle birden fazla aracın birlikte kullanıldığı farklı
durumlara örnekler verme fırsatım olmadı ama siz kendiniz pratikler
yaparak deneyimleyebilirsiniz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 9. Ders 87 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Her Şey Bir Dosyadır \| Her Şey Bir Bayt Akışıdır
-------------------------------------------------

Artık sizin de çok iyi bildiğiniz gibi sistemimizi komut satırı
arayüzünden yönetiyorken iletişim dili için yazıyı diğer bir deyişle
metinsel verileri kullanıyoruz. Yani komutlarımızı yazılı şekilde girip,
sonuçlarını da yine yazılı şekilde takip ediyoruz. Dolayısıyla sistemi
etkili şekilde yönetebilmek için metinsel verileri rahatça görüntüleyip
gerektiğinde ihtiyaçlarımıza göre düzenleyip kullanabilmemiz şart.
Görüntüleme ve düzenleme işlemleri için komut satırı üzerinde
kullanabileceğimiz çok çeşitli araçlar mevcut. Bu bölümde temel bazı
araçlardan bahsediyor olacağız. Fakat bundan önce genel işleyişten
haberdar olmak için bahsetmemiz gereken birkaç temel konu var.

Eğer daha önce az çok Linux ile haşır neşir olduysanız ve biraz da
meraklıysanız "***Linux üzerinde her şey bir dosyadır***" sözünü mutlaka
duymuşsunuzdur.

Her şey bir dosyadır tanımı, klavyenizin, dosyaların, dizinlerin,
aygıtların ve benzeri tüm yapıların birer dosya olarak tanımlanıp,
çekirdekteki sanal dosya sistemi katmanı üzerinde soyutlanmış olan dosya
tanımlayıcılar ile temsil edildiğini belirtmek için kullanılıyor. Yani
"Her şey bir dosyadır" ifadesi, işletim sisteminin genel mimari
yaklaşımını özetliyor. Muhtemelen bu söylediklerim çok açık gelmedi,
çünkü henüz bahsetmediğimiz kavramları kullanarak açıklamış oldum. Ancak
merak etmeyin anlatımın devamında açıklamalarım sizin için de netleşmiş
olacak.

Linux çekirdeğinin yapısı gereği, sistem üzerindeki tüm yapıların dosya
gibi ele alındığından bahsettik. Bu yaklaşımın tercih edilme nedeni
dosyalar üzerinde işlem yapmanın herkes için çok kolay olması. Siz
standart bir kullanıcı olarak yetkiniz olan istediğiniz bir dosyayı
okuyabilir veya dosyaya yeni veriler ekleyebilirsiniz. Yani dosya okumak
veya dosyaya veri eklemek çok kolay. Tüm yapılar dosya gibi ele
alındığında da hepsini dosya yönetir gibi esnek ve kolay şekilde yönetme
imkanına sahip oluyoruz. Aslında bu yaklaşım sayesinde tüm sistemdeki
yapıları ve araçları yönetebileceğimiz ortak bir iletişim yolu da ortaya
çıkmış oluyor.

Yani özünde tüm mesele bayt akışını kontrol etmekten ibaret. Araçların
ürettiği çıktıları ve alacakları girdileri ihtiyaçlarımıza göre
yönettiğimizde işlerimizi komut satırı üzerinden yerine getirebiliyoruz.
Örneğin ben X isimli bir aracın ürettiği çıktıları Y isimli bir araca
girdi olarak kolaylıkla bağlayıp birden fazla aracı işimi yerine
getirmek için kullanabilirim. Ya da bir aracın talep ettiği girdileri
bir dosyadan yönlendirip, aracın bu dosyadaki verileri işlemesini
sağlayabilirim. Hatta daha deneyimli bir kullanıcıysam, sistem
üzerindeki çeşitli dosyaları inceleyerek sistemin mevcut durumu hakkında
bilgi almam da mümkün çünkü sistem üzerinde her şey bir dosya gibi
temsil ediliyor. Özetle Linux çekirdeğimiz donanımlar ile gereken alt
seviyeli iletişimi kendisi sağlayıp bize sade ve okunaklı şekilde sanal
dosyalar sunduğu için pek çok aracı ve yapıyı rahatlıkla denetleyip
yönetebiliyoruz.

Söz konusu dosya içeriklerini yönetmek olduğunda da her şey en temelde
bayt akışını nasıl kontrol ettiğimize kalıyor. Bir aracın çıktılarını
başka bir araca girdi olarak iletebilmek için bu bayt akışını ilgili
araca yönlendirebiliyor olmamız gerekiyor.

Yönlendirmeler
--------------

Linux üzerinde baytları bir kaynaktan diğerine iletmek için yönlendirme
mekanizmasından faydalanabiliyoruz.

Yönlendirme işlemi için Linux üzerinde standart şekilde her bir
dosyanın, girdileri okuduğu ve çıktılarını ilettiği uç noktaları
mevcuttur. Bu uç noktalara da "dosya tanımlayıcıları" deniyor. Ve
temelde 3 tür dosya tanımlayıcı bulunuyor. Normalde biz aksini
belirtmediğimiz sürece bu uçlar konsol aracına bağlı oluyor. Bu sebeple
veri girişini konsoldan yapıp, hatalı ve hatasız olan çıktıları yine
konsol üzerinde görüyoruz. Söylediklerim hala size anlamlı gelmiyorsa
lütfen biraz daha sabırlı olun çünkü aslında son derece basit bir yapı.

Bir dosyaya **veri girişi** yapmak istiyorsak o dosyanın standart
girdisi olarak temsil edilen **0** numaralı dosya tanımlayıcısına
verileri yönlendirmemiz gerekiyor.

Eğer bir dosyanın **hatasız standart çıktılarını** başka bir yere
yönlendirmek istiyorsak bu çıktıları **1** numaralı dosya tanımlayıcısı
üzerinden okumamız gerekiyor.

Eğer bir dosyanın yani örneğin bir aracın ürettiği **hatalı
çıktılarını** başka bir yere yönlendirmek istiyorsak da bunun için **2**
numaralı dosya tanımlayıcısını kullanmamız gerekiyor.

Linux üzerinde her şey dosya gibi ele alındığı için konsol aracı da
***/dev/tty*** isimli dosya ile temsil ediliyor. Yani veri girişi
yaparken ve hatalı-hatasız çıktıları alırken aşağıdaki gibi işleyiş
mevcut.

![1.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/1.webp)

Hemen somut bir örnek üzerinden görelim. Ben test edebilmek için aynı
anda hem hatalı hem de hatasız çıktılar üreten basit bir betik dosyası
oluşturmak istiyorum.

Bunun için `cat > test.sh` komutunu girip, sırasıyla hatasız ve hatalı
çıktıları üretecek olan komutları girip Ctrl + d kısayolu ile verilen
dosyaya yazılmasını sağlayalım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat > test.sh
echo "Bu hatasız bir çıktı"
asdf
┌──(taylan@linuxdersleri)-[~]
└─$
```

Şimdi bu dosyanın çalıştırabilmesi için `chmod +x test.sh` komutu ile
yetki verip, hemen `./test.sh` komutu ile betik dosyamızı çalıştırıp
test edelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ chmod +x test.sh 

┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh 
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın hem hatasız hem de hatalı çıktılar almış olduk. Betik dosyasındaki
`echo "Bu hatasız bir çıktı"` komutu hatasız çıktı üretirken, `asdf`
isimli bir komut olmadığı için bu komut da hatalı çıktı üretmiş oldu.
Biz bu çıktıları özellikle herhangi bir adrese yönlendirmediğimiz için
bu çıktılar konsolumuza bastırıldı. Konsola bastırmak yerine istediğimiz
isimde bir dosyaya yönlendirebiliriz. Öncelikle hatasız çıktıları
yönlendirmeyi deneyelim.

Hatasız Çıktıları Yönlendirmek \| Standart Output
-------------------------------------------------

Hatasız çıktılar "**standart çıktı**" olarak ifade ediliyor ve **1**
numaralı dosya tanımlayıcısı ile temsil ediliyor. Ben denemek için
`./test.sh 1> hatasız.txt` komutu ile hatasız çıktıları
"***hatasız.txt***" dosyasına yönlendiriyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh 1> hatasız.txt
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$
```

Gördüğünüz gibi konsola **yalnızca hatalı olan çıktılar** bastırıldı
çünkü ben hatasız olan çıktıları bu "***hatasız.txt***" dosyasına
yönlendirdim. Dolayısıyla konsola bastırılacak hatasız bir çıktı
kalmadı. Şimdi `cat` komutu ile hatasız dosyasını okuyup içeriğine
bakalım.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat hatasız.txt                                  
Bu hatasız bir çıktı
```

Bakın hatasız çıktı da bu dosyaya kaydolmuş. Şema üzerinden bakacak
olursak, girdiğimiz komuttaki yönlendirme aşağıdaki gibi temsil
edebilir.

![2.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/2.webp)

Burada hatasız olan çıktıları yönlendirmek için `1>` operatörünü
kullandık ama aslında standart çıktılar varsayılan olarak yalnızca tek
bir büyüktür `>` işareti ile de yönlendirilebiliyor. Hemen deneyelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh > hatasız2.txt                         
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$ cat hatasız2.txt 
Bu hatasız bir çıktı
```

Bakın yine yalnızca hatalı olan çıktılar konsola bastırıldı. Yani
standart çıktıları temsil eden 1 numaralı dosya tanımlayıcıyı özellikle
belirtmeden yalnızca büyüktür operatörü ile de standart çıktıları
istediğimiz yere yönlendirebiliyoruz.

Hatalı Çıktıları Yönlendirmek \| Standart Error
-----------------------------------------------

Nasıl ki üretilen "hatasız çıktılar" "standart çıktı" olarak
isimlendiriliyorsa, üretilen "**hatalı çıktılar**" da "**standart
hata**" çıktıları olarak ifade ediliyor ve **2** numaralı dosya
tanımlayıcı ile temsil ediliyor.

Yani örneğin ben betik dosyasının ürettiği hatalı çıktıları bir dosyaya
yönlendirmek istersem büyüktür yönlendirme operatörü ile `2>` şeklinde
özellikle belirtmem gerekiyor. Hemen denemek için
`./test.sh 2> hatalı.txt` şeklinde komutumuzu girelim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh 2> hatalı.txt               
Bu hatasız bir çıktı

┌──(taylan@linuxdersleri)-[~]
└─$ cat hatalı.txt                                   
./test.sh: line 2: asdf: command not found
```

Bakın hatalı çıktıları bu dosyaya yönlendirdiğimiz için bu kez da
konsola yalnızca hatasız olan çıktılar bastırıldı. Yönlendirme
yaptığımız dosyanın içeriğini ise yalnızca hatalı çıktı bulunuyor çünkü
ben betik dosyasının ürettiği hatalı çıktıları **2** numaralı dosya
tanımlayıcı ve buradaki büyüktür yönlendirme operatörü ile bu dosyaya
yönlendirdim. Şema üzerinden bakacak olursak, girdiğimiz komuttaki
yönlendirme aşağıdaki gibi temsil edebilir.

![3.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/3.webp)

İşte bu örneklerde ele aldığımız gibi ihtiyacımıza göre hatasız ve
hatalı olan çıktıları istediğimiz bir dosyaya yönlendirebiliyoruz.

Örneğin bir aracın ürettiği hatalı çıktıları görmek istemezseniz ,
yalnızca hatalı çıktıları yok etmek için bunları ***/dev/null***
dosyasına yönlendirebilirsiniz. ***/dev/*** dizini altındaki ***null***
dosyası, kendisine gönderilen tüm verileri yutmak için çekirdek
tarafından sağlanan sanal bir dosya. Biz buraya çıktı yönlendirdiğimizde
ilgili çıktı hiç bir yere kaydolmuyor, yani aslında çıktıları boşluğa
yönlendirmiş oluyoruz. Bu sayede araçların ürettiği hatalı çıktılardan
kolayca kurtulmamız da mümkün oluyor.

Denemek için `./test.sh 2> /dev/null` şeklinde komutumuzu girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh 2> /dev/null
Bu hatasız bir çıktı

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın konsola yalnızca hatasız olan çıktı bastırıldı çünkü hatalı
olanları ***/dev/*** dizini altındaki ***null*** dosyasına yönlendirdik.
Şimdi hatalı çıktılara ne olduğunu görmek için çıktıları
yönlendirdiğimiz ***/dev/null*** dosyasının içeriğini okumayı
deneyebiliriz.

``` {.graphql}
┌──(taylan@linuxdersleri)-[~]
└─$ cat /dev/null

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın herhangi bir çıktı almadık çünkü aslında bu dosya verileri boşluğa
göndermek için kullanılan sanal bir dosya. Biz yönlendirsek de
içerisinde hiç bir veri tutmuyor çünkü bu dosya bizim bildiğimiz
standart dosyalardan değil. Daha önce Linux üzerinde her şeyin bir dosya
gibi ele alından bahsetmiştik. İşte bu dosya da bu yaklaşımın bir
sonucu. Siz de istemediğiniz tüm verileri ***/dev/null*** dosyasına
yönlendirip onlardan kurtulabilirsiniz. Üstelik bu dosya disk üzerinde
yer alan gerçek bir dosya olmadığı için disk üzerinde okuma yazma yükü
oluşturmuyor. Bu ve benzeri dosyalar çekirdek tarafından sanal olarak
oluşturulan ve bellek yani geçici hafıza üzerinden çalıştırılan sözde
dosyalardır. Bu yaklaşım sayesinde disk üzerinde yük oluşturma
durumundan da endişe etmemize gerek kalmıyor.

Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme
aşağıdaki gibi temsil edebilir.

![4.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/4.webp)

Tekrar asıl konumuza dönecek olursak, hatalı ve hatasız çıktıları ayrı
ayrı nasıl yönlendirebileceğimizden açıkça bahsettim. Fakat kimi zaman
ayrı ayrı yönlendirmek yerine tüm çıktıları tek bir adrese yönlendirmek
de isteyebiliriz. Bu işlem için yönlendirme operatöründen önce "ve"
"`&`" işaretini yani "**ampersant**" işaretini ekleyip `&>` operatörünü
kullanabiliyoruz. Buradaki ampersant olarak da bilinen "`&`" işaretini
hem **hatalı** ve hem de **hatasız** çıktıları temsil ediyor gibi
düşünebilirsiniz. Denemek için `./test.sh &> sonuc` şeklinde komutumuzu
girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh &> sonuc

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın konsolumuza herhangi bir çıktı bastırılmadı çünkü tüm çıktılar bu
dosyaya yönlendirildi. Görmek için `cat` komutu ile okuyalım.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cat sonuc                                        
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın tüm çıktılar bu "***sonuc***" dosyasına eklenmiş. Yani **hatalı ve
hatasız** çıktıların `&>` operatörü sayesinde tek bir adrese
yönlendirilebildiğini bizzat teyit etmiş olduk.

Şema üzerinden bakacak olursak, girdiğimiz komuttaki yönlendirme
aşağıdaki gibi temsil edebilir.

![5.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/5.webp)

Esasen söz konusu yönlendirmeler olduğunda çok daha fazla detay ve
alternatif yaklaşım söz konusu. Örneğin yukarıdaki şemaya bakacak
olursanız aslında bu yönlendirmede, hatalı çıktıları hatasız olanlara
yönlendirip, hatasız olanlara birlikte bunları ilgili dosyaya
yönlendirmeyi sağlamış oluyoruz. Fakat temel düzey için hatalı ve
hatasız çıktıları yönlendirmek için `&>` operatörünü kullanabileceğinizi
bilmeniz yeterli. Zira bu eğitimde bu konunun detaylarına girmemiz kafa
karıştırıcı olabilir. Ben yalnızca basit düzeyde temel yaklaşımları ele
aldım. Daha fazlası için kısa bir araştırma yapmanız yeterli.

En nihayetinde hem ayrı ayrı hem de birleşik şekilde hatalı ve hatasız
çıktıları nasıl yönlendirebileceğimizi örnekler üzerinden ele aldık.
Anlatımın devamında girdileri nasıl yönlendirebileceğimizden de kısaca
bahsedeceğim ama öncelikle çıktıların yönlendirilmesiyle ilgili konuşmak
istediğim birkaç detay daha var.

Üzerine Yazma \| Tek Büyüktür Operatörü `>`
-------------------------------------------

Biz örneklerimiz sırasında hep tek büyüktür "`>`" karakterini kullanarak
yeni bir dosya oluşturulmasını ve içerisine ilgili verinin
yönlendirilmesini sağladık. Yönlendirme yapmak için tek büyüktür işareti
kullandığımızda aslında kabuğumuza, "*eğer bu yönlendirme işaretinden
sonra gelen bu dosya ile aynı isimde bir dosya yoksa yeni dosya oluştur,
eğer bu isimde bir dosya varsa da yönlendirilen verileri bu dosyanın
üzerine yaz*" demiş oluyoruz. Yani biz tek büyüktür operatörünü
kullandığımızda aynı isimli bir dosya varsa o dosyanın içeriği silinip
en son yönlendirilen veriler kaydediliyor. Dolayısıyla eski dosyanın tüm
içeriği yok edilmiş oluyor.

Denemek için içerisinde hatalı ve hatasız çıktılar olan sonuc isimli
dosyamıza tekrar yalnızca hatasız çıktımızı yönlendirmek üzere
`./test.sh > sonuc` şeklinde komutumuzu girebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh > sonuc                               
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$ cat sonuc                                        
Bu hatasız bir çıktı
```

Bakın önceki hatalı ve hatasız çıktılar silinmiş, bunlar yerine en son
yönlendirmiş olduğum hatasız çıktılar eklenmiş. İşte tıpkı bu örnekte
olduğu gibi biz tek büyüktür işaretini kullandığımızda hedefte aynı
isimli bir dosya varsa bu dosya içeriğinin üzerine yönlendirilmiş olan
veriler yazılıyor. Eğer amacınız tam olarak bu değilse, tek büyüktür
yönlendirme operatörünü kullanarak önemli dosyaların içeriklerinin yok
olmasına sebep olabilirsiniz.

Ekleme \| Çift Büyüktür Operatörü `>>`
--------------------------------------

Yönlendirilecek olan verileri, mevcut verilerin sonuna eklemek
istediğimizi belirtmek için de çift büyüktür `>>` işaretini
kullanabiliyoruz. Ben bir önceki komutumu çağırıp, bu kez çift büyüktür
ile yine hatasız çıktıların bu dosyanın sonuna eklenmesini istiyorum.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh >> sonuc                               
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$ cat sonuc                                        
Bu hatasız bir çıktı
Bu hatasız bir çıktı
```

Bakın dosyanın sonuna yani aynı hatasız çıktıların eklendiğini
görebiliyoruz çünkü çift büyüktür işareti sayesinde ekleme yapılması
gerektiğini belirtmiş olduk. Testi devam ettirmek içinin ben
`./test.sh 2>> sonuc` komutu ile **yalnızca hatalı** olan çıktıların da
dosyanın sonuna eklenmesini istiyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh 2>> sonuc                              
Bu hatasız bir çıktı

┌──(taylan@linuxdersleri)-[~]
└─$ cat sonuc                               
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found
┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın hatalı çıktılar da dosyanın sonuna eklendi. Son olarak tek seferde
hem hatalı hem de hatasız çıktıları dosyanın sonuna eklemek istersek
`./test.sh &>> sonuc` şeklinde komut girmeyi deneyebiliriz.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh &>> sonuc                              

┌──(taylan@linuxdersleri)-[~]
└─$ cat sonuc                               
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın bu çıktılar da dosyanın sonuna eklenmiş durumda.

Yani örneklerimizle birlikte **tek büyüktür işaretinin verilerin üzerine
yazdığını** ve **çift büyüktür işaretinin de var olanlara ekleme
yaptığını** bizzat teyit etmiş olduk.

Özelikle belirtmedim ancak istersek daha önce var olmayan bir dosyayı
oluşturmak için de çift büyüktür işaretini kullanabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ./test.sh &>> yepyenidosya

┌──(taylan@linuxdersleri)-[~]
└─$ cat yepyenidosya                                 
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found
┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın çift büyüktür işareti sayesinde belirttiğimiz isimde dosya
oluşturuldu ve bu çıktılar da bu dosyaya yönlendirildi. Tamamdır bence
çıktıları yönlendirmeyle ilgili temelde bilmemiz gerekenlerden
bahsettik.

Şimdi bir de girdileri yönlendirmek için kısaca standart girdiden
bahsedelim.

Veri Girişi \| Standart Input
-----------------------------

Standart girdiden veri kabul eden tüm araçlara "küçüktür" `<`
yönlendirme operatörü ile doğrudan veri girişinde bulunabiliyoruz.
Örneğin ben "***sonuc***" isimli dosyayı okumak için `cat < sonuc`
şeklinde komutumu girebilirim.

``` {.bash}
┌──(taylan@linuxdersleri)-[~]
└─$ cat < sonuc 
Bu hatasız bir çıktı
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found
Bu hatasız bir çıktı
./test.sh: line 2: asdf: command not found
```

Buradaki "küçüktür" `<` yönlendirme operatörü `cat` aracına bu dosyanın
içeriğini yönlendirip bunun konsola bastırılmasını sağlıyor. İşleyişe
şema üzerinden bakacak olursak aşağıdaki gibi temsil edebilir.

**ℹ️ Not:** `cat` aracı sistem üzerinde ***/usr/bin/cat*** konumunda
bulunduğu için temsil edilirken bu dosya ismini kullandım.

![6.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/6.webp)

Normalde doğrudan `cat sonuc` komutu ile de okuyabileceğimiz için belki
bu örneğimiz size çok mantıklı gelmemiş olabilir ancak merak etmeyin
ileride farklı araçlar üzerinde kullanırken daha anlamlı hale gelecek.
Fakat biraz önce de belirttiğim gibi bir araca bu şekilde yönlendirme
operatörü ile veri iletmek için **o aracın standart girdiden veri kabul
ediyor olması gerekiyor**. Eğer o araç standart girdiye bakmıyorsa yani
buradan veri kabul etmiyorsa yönlendirmiş olduğunuz hiç bir veri bu araç
tarafından işlenmez.

Bu duruma örnek olarak `echo` aracını ele alabiliriz mesela. `echo`
aracının tek görevi kendisinde sonra yazılmış olan argümanları
bastırmaktır. Yani `echo` aracı standart girdiden veri kabul etmiyor,
yalnızca kendisinden sonra yazılmış olan argümanları alıp konsola
bastırıyor. Dolayısıyla eğer biz `echo` aracının standart girdisine veri
gönderirsek `echo` aracı hiç bir tepki vermeyecek. Bizzat denemek için
"***sonuc***" isimli dosyanın içeriğini `echo` aracına yönlendirmek
üzere komutumuzu `echo < sonuc` şeklinde girebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo < sonuc                                     

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın herhangi bir çıktı almadık çünkü `echo` aracı standart girdiden
veri okumuyor. Dolayısıyla bizim veri yönlendirmiş olmamız `echo` için
hiç bir anlam ifade etmiyor. Yani aşağıdakine benzer bir işleyiş söz
konusu.

![7.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/7.webp)

Ek bir örnek daha vermemiz gerekirse örneğin tıpkı `echo` aracı gibi,
klasör oluşturmamızı sağlayan `mkdir` aracı da standart girdiden veri
okuması yapmıyor. Bu sebeple eğer biz klasör oluşturmak istiyorsak,
klasör ismini `mkdir` aracına argüman olarak vermemiz gerekiyor. Ben
denemek için `mkdir` aracına `mkdir < sonuc` komutu ile yine
"***sonuc***" dosyasının içeriğini girdi olarak yönlendirmeyi deniyorum.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ mkdir < sonuc                                    
mkdir: missing operand
Try 'mkdir --help' for more information.

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın komutumuz hata verdi çünkü `mkdir` aracı standart girdiye
bakmıyor. Yani ben `mkdir < sonuc` şeklinde yazdım ama `mkdir` aracına
oluşturması gereken klasör için hiç bir argüman iletilmedi.

İşte bizzat örnekler üzerinden de teyit ettiğimiz gibi standart girdiden
veri okumayan araçların standart girdilerine veri yönlendirmesi yapmamız
anlamsız çünkü standart girdilerini okumuyorlar. Örnekler sırasında ele
aldığımız araçlar gibi yalnızca argümanlarla çalışabilen araçlara
dosyalardan veri yönlendirmesi yapmak için alternatif çözüm var fakat bu
çözümden daha sonra ayrıca bahsediyor olacağız.

Şimdi burada odaklanmanız gereken tek detay standart girdi
yönlendirmesinin yalnızca standart girdiden veri kabul eden araçlar
üzerinde etkili olduğu. Peki hangi aracın standart girdiden veri alıp
hangisinin argümanlar üzerinden çalıştığını nerden bileceğiz diye
soracak olursanız.

Hangi araçların standart girdiden veri kabul ettiğini manual
sayfalarındaki açıklamalara göz atarak öğrenebileceğiniz gibi zaten
zaman içinde hangi aracın ne şekilde çalıştığını da anımsıyor
olacaksınız. Örneğin kullandığınız aracın yardım sayfasında bu duruma
dair bir açıklama yoksa standart girdiden veri yönlendirmeyi deneyip
bizzat kendiniz de test edebilirsiniz.

Benim yönlendirmelerle ilgili bahsetmek istediklerim şimdilik bu kadar.
Bence temel eğitim için bu kadarlık detay seviyesi yeterli. Tabii ki
eğer isterseniz daha fazlasını öğrenmek için araştırma yapmakta
özgürsünüz.

Biz şimdi metinsel veriler üzerinde çalışmamıza yardımcı olan temel
araçlardan bahsederek devam edelim.

`cat` Komutu
------------

`cat` aracının ismi "bağlamak, birleştirmek veya sıralamak" anlamlarında
olan İngilizce "concatenate" kelimesinden geliyor ve aracın görevini net
biçimde ifade ediyor aslında.

`cat` komutunun en temel işlevi, kendisine argüman olarak verilen
dosyaların içeriklerini konsola yönlendirerek bastırmaktır. Yani aslında
temelde `cat` aracı dosyaların içeriklerini konsol üzerinden
okuyabilmemize olanak tanıyan basit bir araçtır. Var olan bir dosyayı
okumak için tek yapmamız gereken, `cat` komutunun ardından dosyanın
ismini girmek. Ben örnekler sırasında kullanmak için mevcut bulunduğum
dizindeki dosya ve klasör isimlerini bir dosyaya kaydetmek istiyorum.
Bunun için `ls > liste` komutunu girebilirim. Buradaki büyüktür `>`
yönlendirme operatörü sayesinde `ls` komutunun çıktıları "***liste***"
dosyasına yönlendirilmiş olacak. Bir de `ls /usr > liste2` komutu ile
"***usr***" dizini altındakileri de "***liste2***" dosyasına kaydedelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ ls > liste                           

┌──(taylan@linuxdersleri)-[~]
└─$ ls /usr > liste2
```

Örneğin oluşturduğumuz ikinci dosyanın içeriğini konsola bastırmak
istersek `cat liste2` şeklinde komutumuzu girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste2                           
bin
games
include
lib
lib32
lib64
libexec
libx32
local
sbin
share
src
```

Bakın dosyanın içeriği konsola bastırıldı. Dilersek, aynı anda birden
fazla dosyayı da okuyabiliriz. Denemek için diğer dosyanın ismini de
girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste2 liste
bin
games
include
lib
lib32
lib64
libexec
libx32
local
sbin
share
src
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
```

Bakın komutta soldan sağa doğru verdiğim tüm dosyaların içerikleri,
sırasıyla yukarıdan aşağıya doğru konsola bastırılmış oldu. Yani aslında
isminde olduğu şekilde `cat` aracı birden fazla dosyanın içeriğini
sırasıyla birleşik şekilde konsolumuza bastırmış oldu. Bu şekilde
istediğimiz kadar dosyanın birleştirilmesini sağlayabiliyoruz.

Birden fazla dosya içeriğinin `cat` aracı sayesinde sıralı şekilde
birleştirilebiliyor olması size bir fikir verdi mi ?

Eğer istersek birden fazla dosyanın içeriğini tek bir dosyaya
yönlendirebiliriz. Yani birden fazla dosyayı tek bir dosyada
birleştirebiliriz. Denemek için "***liste***" ve "***liste2***"
dosyasını birleştirip "***nihai-liste***" isimli bir dosya oluşturmak
üzere `cat liste liste2 > nihai-liste` şeklinde komutumuzu girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste liste2 > nihai-liste

┌──(taylan@linuxdersleri)-[~]
└─$ cat nihai-liste                      
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
bin
games
include
lib
lib32
lib64
libexec
libx32
local
sbin
share
src
```

Bakın iki dosyanın içeriği, tam olarak komutta belirttiğim sıralama ile
yani ilk olarak "***liste***" dosyası daha sonra "***liste2***" dosyası
olacak şekilde birleştirilip tek bir dosya haline gelmiş oldu.

İşte `cat` komutunun en temel ve sık kullanılan özellikleri bunlar.
Zaten daha önce yönlendirmeleri kullanarak yeni dosyalar oluşturup
içerisine nasıl veri ekleyebileceğimizden defaatle uygulamalı olarak söz
ettiğimiz için `cat` komutu ile söyleyeceğim ek bir detay bulunmuyor.

Bu bölüme gelene kadar gerçekleştirdiğimiz anlatımlar sırasında kullanma
sıklığımızdan da tahmin edebileceğiniz gibi `cat` komutu en sık
kullanacağımız komutların başında geliyor. `cat` aracı hatırlanması ve
kullanımı basit ancak metinsel verileri okuma birleştirme ve yenilerini
oluşturma gibi en temel konularda etkili bir araç. `cat` komutunu
kullanarak ihtiyaçlarınıza uygun çözümler üretmek tamamen sizin
yönlendirmeleri ve `cat` komutunun çalışma yapısını ne kadar iyi
anladığınıza bağlı. Daha iyi anlamak adına birkaç örnek yapabiliriz.

Örneğin `cat` aracını bir dosyanın içeriğini kopyalamak için
kullanabiliriz mesela. Bunun için
`cat kopyalanacak_dosya > dosyanın_kopyası` şeklinde komut girmemiz
yeterli oluyor. "***liste***" dosyasını kopyalamak istersem
`cat liste > liste3` komutuyla bu dosya içeriğinin "***liste3***" isimli
dosyaya kopyalanmasını sağlayabilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste > liste3

┌──(taylan@linuxdersleri)-[~]
└─$ cat liste3                           
ada
calısma
Desktop
Documents
dosya.txt
Downloads
hatalı.txt
hatasız2.txt
hatasız.txt
klasor
liste
metin1.txt
metin2.txt
Music
Pictures
Public
sonuc
Templates
test.sh
Videos
yeni
yeni klasor
yepyenidosya
```

Bakın "***liste***" dosyasının içeriği kopyalanarak "***liste3***"
isimli dosya oluşturulup bu dosyaya aktarılmış.

Burada gerçekleşen işlemi temel olarak açıklamamız gerekirse; Girmiş
olduğumuz komut sayesinde `cat` aracı kopyalanacak dosyanın içeriğini
okuyor ve buradaki büyüktür `>` işareti sayesinde bu içeriği standart
çıktıya yönlendiriyor. Normalde biz özellikle belirtmediğimiz sürece
standart çıktı bizim konsolumuza bağlı olduğu için biz `cat` aracının
çıktılarını konsolda görüyoruz. Ama ben burada standart çıktıyı büyüktür
operatörü ile "***liste3***" isimli dosyaya yönlendirdiğim için çıktılar
bu dosyaya aktarılıyor. Bu sayede "***liste***" dosyasının içeriğiyle
aynı içeriğe sahip "***liste3***" isimli dosya oluşturuluyor. Yani bir
nevi "***liste***" dosyasını kopyalamış oluyoruz.

Elbette benim ele aldığım temel kullanımı dışında `cat` komutunun daha
birçok seçeneği mevcut. Bu seçeneklere göz atmak için `cat —help`
komutunu kullanabilirsiniz. Buradaki `help` çıktısındaki açıklamalar
yeterince açık gelmezse, internet üzerindeki rehber anlatımlara da
kolaylıkla ulaşabilirsiniz. Zaten tüm eğitim boyunca tekrar ettiğim ve
edeceğim gibi, bu eğitimdeki amacım temel kavramlardan bahsedip daha
fazlasını nasıl öğrenebileceğimiz üzerinde durmak. Dolayısıyla tüm
konulardan, tüm araçlardan veya araçların tüm seçeneklerinden bahsetmemi
bekliyorsanız, üzgünüm bu gerçekleşmeyecek. Nitekim anlatıcı tarafında
olmama karşın benim de henüz bilmediğim, hiç kullanmadığım için
unuttuğum veya hiç karşılaşmadığım pek çok konu, kavram, araç ve seçenek
bulunuyor. Bildiğimi sandıklarım, bilmediklerimin yanında bir hiç
sayılır. Ancak temel kavramların farkında olduğumuzda ve yeni bilgileri
nasıl araştırıp bulabileceğimizi bildikten sonra zaten zaman içinde
bilmemiz gereken kadarlık bilgi birikimini adım adım inşa edebiliyoruz.
Yani özetle önemli olan iyi bir temel ve bu temele dayandırılan
araştırma yetkinliği kazanabilmek. Zira öğrenmek sürecimiz hiç bir zaman
bitmeyecek.

Anlatımlarımıza gelin `cat` komutunu tersi şekilde çıktılar sunabilen
`tac` aracından bahsederek devam edelim.

`tac` Komutu
------------

Hatırlıyorsanız, `ls` komutunu ele alırken tüm çıktıları tersine
çevirebilen "**r**everse" yani "`r`" seçeneğinden bahsetmiştik. `cat`
komutu ile okuduğumuz dosya içerikleri için de benzer bir ihtiyacımız
olabilir. Örneğin `cat` komutu ile okuduğumuz bir dosya içindeki
alfabetik olarak sıralanmış satırlara, ters alfabetik olarak ihtiyaç
duyabiliriz. Bu durumda, `cat` aracının ismen de tersi olan `tac`
aracını kullanabiliyoruz.

`tac` komutunu test edebilmek için öncelikle yeni bir dosya oluşturalım.
Ben bulunduğum dizindeki tüm içerikleri ayrıntılarıyla birlikte büyükten
küçüğe doğru okunaklı şekilde sıralayıp, çıktıları "***liste.txt**"*
isimli bir dosyaya aktarmak istiyorum. Bunun için `ls -lhS > liste.txt`
şeklinde komutumu giriyorum.

``` {.sql}
┌──(taylan@linuxdersleri)-[~]
└─$ ls -lhS > liste.txt                  

┌──(taylan@linuxdersleri)-[~]
└─$ cat liste.txt                        
total 104K
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 07:41 ada
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 08:45 calısma
drwxr-xr-x 4 taylan taylan 4.0K Jun  5 13:33 Desktop
drwxr-xr-x 5 taylan taylan 4.0K Jun  4 07:06 Documents
drwxr-xr-x 3 taylan taylan 4.0K May 26 05:36 Downloads
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 klasor
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Music
drwxr-xr-x 4 taylan taylan 4.0K May 30 13:21 Pictures
drwxr-xr-x 3 taylan taylan 4.0K Jun 25  2022 Public
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Templates
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Videos
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 yeni
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:23 yeni klasor
-rw-r--r-- 1 taylan taylan  278 Jun 11 05:26 nihai-liste
-rw-r--r-- 1 taylan taylan  208 Jun 11 05:22 liste
-rw-r--r-- 1 taylan taylan  208 Jun 11 05:32 liste3
-rw-r--r-- 1 taylan taylan  161 Jun 10 11:57 sonuc
-rw-r--r-- 1 taylan taylan   70 Jun 11 05:23 liste2
-rw-r--r-- 1 taylan taylan   68 Jun 10 11:59 yepyenidosya
-rw-r--r-- 1 taylan taylan   43 Jun 10 11:37 hatalı.txt
-rwxr-xr-x 1 taylan taylan   37 Jun 10 11:23 test.sh
-rw-r--r-- 1 taylan taylan   25 Jun 10 11:34 hatasız2.txt
-rw-r--r-- 1 taylan taylan   25 Jun 10 11:31 hatasız.txt
-rw-r--r-- 1 taylan taylan   24 Jun  7 07:45 metin2.txt
-rw-r--r-- 1 taylan taylan   22 Jun  7 08:01 dosya.txt
-rw-r--r-- 1 taylan taylan   16 Jun  7 07:42 metin1.txt
-rw-r--r-- 1 taylan taylan    0 Jun 11 06:46 liste.txt

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın dosya ve dizinlerin büyükten küçüğe doğru sıralanmış listesini
görebiliyoruz. Eğer aynı dosyayı `tac` komutu ile okursak listenin tam
tersi şekilde olması gerekiyor.

``` {.sql}
┌──(taylan@linuxdersleri)-[~]
└─$ tac liste.txt                        
-rw-r--r-- 1 taylan taylan    0 Jun 11 06:46 liste.txt
-rw-r--r-- 1 taylan taylan   16 Jun  7 07:42 metin1.txt
-rw-r--r-- 1 taylan taylan   22 Jun  7 08:01 dosya.txt
-rw-r--r-- 1 taylan taylan   24 Jun  7 07:45 metin2.txt
-rw-r--r-- 1 taylan taylan   25 Jun 10 11:31 hatasız.txt
-rw-r--r-- 1 taylan taylan   25 Jun 10 11:34 hatasız2.txt
-rwxr-xr-x 1 taylan taylan   37 Jun 10 11:23 test.sh
-rw-r--r-- 1 taylan taylan   43 Jun 10 11:37 hatalı.txt
-rw-r--r-- 1 taylan taylan   68 Jun 10 11:59 yepyenidosya
-rw-r--r-- 1 taylan taylan   70 Jun 11 05:23 liste2
-rw-r--r-- 1 taylan taylan  161 Jun 10 11:57 sonuc
-rw-r--r-- 1 taylan taylan  208 Jun 11 05:32 liste3
-rw-r--r-- 1 taylan taylan  208 Jun 11 05:22 liste
-rw-r--r-- 1 taylan taylan  278 Jun 11 05:26 nihai-liste
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:23 yeni klasor
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 yeni
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Videos
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Templates
drwxr-xr-x 3 taylan taylan 4.0K Jun 25  2022 Public
drwxr-xr-x 4 taylan taylan 4.0K May 30 13:21 Pictures
drwxr-xr-x 2 taylan taylan 4.0K Feb 11  2022 Music
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 06:22 klasor
drwxr-xr-x 3 taylan taylan 4.0K May 26 05:36 Downloads
drwxr-xr-x 5 taylan taylan 4.0K Jun  4 07:06 Documents
drwxr-xr-x 4 taylan taylan 4.0K Jun  5 13:33 Desktop
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 08:45 calısma
drwxr-xr-x 2 taylan taylan 4.0K Jun  7 07:41 ada
total 104K

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın tam olarak beklediğimiz gibi tüm çıktılar tam tersi şekilde oldu.
Yani tüm satırları ters sıralama ile küçükten büyüye olacak şekilde
görüntüleyebildik. İşte `tac` komutu tam olarak bu amaçla kullanılıyor.
Satırları sondan başa doğru bastırmak istediğimizde `tac` aracını
kullanabiliyoruz.

Belki bu örnekte kullandığımız `ls` komutunun zaten kendine ait terse
çevirme işlevi yani `-r` seçeneği olduğu için, `tac` komutunun kullanımı
size çok gerekli gibi gelmemiş olabilir ancak lütfen buradaki `ls`
komutuna takılmayın. `ls` sadece kolay gözlemlenebilir dosya içeriği
oluşturmak için kullandığımız basit bir örnek. Komut satırını
kullanırken, sürekli metinsel veriler üzerinde çalıştığımız için,
herhangi bir dosyadaki verilerin tersten sıralamasına ihtiyaç
duyacağımız durumlar ile karşılaşmamız kaçınılmaz. Komut satırında
çalışırken temelde her şeyi bayt akışından ibaret olduğunu unutmayın
lütfen. Dosya içeriklerinden veya çeşitli araçlardan gelen verileri yani
üzerinde çalıştığımız baytları istediğimiz doğrultuda manipüle
edebildiğimiz sürece komut satırının gücünden faydalanabiliriz. Verileri
manipüle etmenin önemini ileride daha iyi anlayacaksınız. Çünkü eğitimin
devamında, **pipe** mekanizmasını kullanarak bir aracın ürettiği
çıktıları başka bir araca yönlendirerek kompleks sorunlara basit
çözümler sağlamış olacağız. Araçların bir arada çalışabilmesi için de
gerektiğine akış halindeki verilerin bir sonraki araca uygun şekilde
değiştirilerek aktarılması gerekecek. Özetle, verileri istediğimiz
şekilde değiştirebiliyor olmanın önemini ileride daha net
anlayacaksınız.

Ayrıca ben tek bir dosya ile örnek yaptım ama `cat` komutunda olduğu
gibi `tac` komutuyla da birden fazla dosyayı aynı anda ters sıralama ile
okuyabiliriz. Ben örnek olarak sırala harfler ve sayılar içeren iki
dosya oluşturmak istiyorum. Kolayca oluşturmak için daha önce
öğrendiğimiz süslü parantez genişletmesini kullanabiliriz. a'dan z'ye
kadar olan karakterleri `echo -e "\n"{a..z} > harf.txt` komutu ile
"***harf.txt***" dosyasına kaydedebiliriz.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "\n"{a..z} > harf.txt
```

Buradaki `echo` komutu ile kullandığımız `-e` seçeneği tırnak içinde
yazdığımız "yeni satıra geçme" yani "`\n`" ifadesinin çalışmasını
sağlıyor. Bu sayede a'dan z'ye kadar her satıra bir karakter basılıyor.
Merak etmeyin `echo` komutunu kullanırken bu konudan tekrar
bahsedeceğiz. Şimdilik ihtiyacımız olan dosyayı oluşturmak için
kullanabiliriz. Benzer şekilde 1'den 30'a kadar olan sayıları satır
satır sıralamak için de komutumuzu `echo -e "\n"{1..30} > sayi.txt`
şeklinde düzenleyip girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "\n"{1..30} > sayi.txt
```

Evet neticede içinde istediğimiz türde veriler bulunan iki dosyamızı
kolayca oluşturabildik. İçeriklerini görüntülemek için aynı anda iki
dosyayı da `cat` komutu ile açabiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "\n"{1..30} > sayi.txt

┌──(taylan@linuxdersleri)-[~]
└─$ cat harf.txt sayi.txt 

a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r 
s 
t 
u 
v 
w 
x 
y 
z

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30
```

Bakın, verdiğim dosya sırlamasına uygun şekilde tek seferde dosya
içerikleri sıralı şekilde bastırıldı. Aynı dosyaları `tac` komutu ile de
bastırabiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ tac harf.txt sayi.txt                
z
y 
x 
w 
v 
u 
t 
s 
r 
q 
p 
o 
n 
m 
l 
k 
j 
i 
h 
g 
f 
e 
d 
c 
b 
a 

30
29 
28 
27 
26 
25 
24 
23 
22 
21 
20 
19 
18 
17 
16 
15 
14 
13 
12 
11 
10 
9 
8 
7 
6 
5 
4 
3 
2 
1
```

Bakın yine verdiğim dosya sırlamasına uygun ancak bu kez dosya
içerikleri tersten sıralanmış şekilde bastırıldı.

`tac` komutu `cat` komutu kadar kolay hatırlanabilir basit bir komut.
`cat` komutunun tersten yazılmış hali olması zaten işlevi hakkında
unutulmaz bir hatırlatıcı.

`rev` Komutu
------------

Eğer mevcut satırların sırlanmasını değil de doğrudan satırdaki
karakterleri tersine çevirmek istersek `rev` aracını kullanabiliyoruz.
`rev` aracının ismi İngilizce "**rev**erse" yani "ters" ifadesinin
kısaltmasından geliyor. Kullanımı son derece kolay, `rev` komutunun
ardından satırlarındaki karakterlerini tersine çevirmek istediğiniz
dosyayı yazmanız yeterli oluyor.

Nasıl bir etkisi olduğunu test etmek için hemen basit bir metin dosyası
oluşturmayı deneyebiliriz. Ben bunun için `cat > metin.txt` komutunu
girip dosyamın içine birkaç satır veri ekliyorum.

``` {.bash}
cat > metin.txt 
bu basit

bir metin

dosyasıdır
```

Veri girişini sonlandırıp dosyaya kaydetmek için Ctrl + d tuşlamasını
yapmamız yeterli.

Aradaki farkı net gözlemleyebilmek için oluşturduğumuz dosyayı hem `cat`
hem de `rev` araçları ile okumayı deneyebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ cat metin
bu basit

bir metin

dosyasıdır

┌──(taylan@linuxdersleri)-[~]
└─$ rev metin                            
tisab ub

nitem rib

rıdısaysod
```

Görebildiğiniz gibi `rev` aracı tüm satırlardaki karakterler tersine
çeviriyor. Yani tek tek tüm satırlarda yer alan sondaki karakter başa,
baştaki de sona gidecek şekilde bir terslik elde edebildik.

`touch` Komutu
--------------

Eğer hatırlıyorsanız, daha önce yeni boş dosyalar oluşturmak üzere
`touch` aracını kullanmıştık. Bu işlevinin yanında aslında `touch` aracı
var olan dosyaların tarih bilgilerini değiştirmek için kullanılan bir
araç.

Daha önce `ls` komutunun ayrıntılı çıktılarında ve bu çıktıları
tarihlere göre sıralarken zaten dosya ve klasörlerin tarih bilgisinin
tutulduğunu söylemiştik.

Şimdi özellikle bu konu üstünde duracak olursak sistem üzerinde
oluşturulan tüm dosyaların oluşturulma, değiştirilme ve güncellenme
tarihleri olmak üzere temelde üç zaman etiketi bulunuyor. Biz istersek
`touch` aracı sayesinde bu tarihleri değiştirebiliyoruz.

Fakat öncelikle bu bilgileri görmek için `stat` komutunu kullanalım.
`stat` komutu sayesinde dosya ve dizinler hakkında çeşitli öznitelik
bilgilerini görüntüleyebiliyoruz. Ben test edebilmek için daha önce
oluşturduğum "***liste***" isimli dosyanın özelliklerine bakmak
istiyorum.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ stat liste
  File: liste
  Size: 208             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 05:24:30.303662486 -0400
Modify: 2023-06-11 05:22:23.199246609 -0400
Change: 2023-06-11 05:22:23.199246609 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Buradaki erişim(access) tarihi, bu dosyanın en son açıldığı, okunduğu
yani erişildiği tarihi veriyor. Fakat bir dosya pek çok kullanıcı
tarafından defaatle açılabileceği ve özellikle sunucularda dosya okunma
sayısının yüksek olması dolayısıyla bu erişim tarihi her erişimde
değişmiyor. Her erişimde değişecek şekilde konfigüre edebiliriz fakat
disk üzerindeki okuma yazma yükünü yüksek oranda artıracağımız için pek
de makul bir yaklaşım sayılmaz. Bu sebeple bir dosyayı açıp okuduğunuzda
erişim tarihi muhtemelen hemen değişmeyecektir. Değişiyorsa, o sistem
bunun için özellikle konfigüre edilmiştir.

Diğer tarih bilgisine bakacak olursak, düzenleme tarihi, dosya
içeriğinin değiştirilmiş olduğu tarihi veriyor. Örneğin yeni bir veri
eklediyseniz veya var olan verileri sildiyseniz dosyanızın düzenlenme
tarihi değişiyor. Ben denemek için `echo “yeni veri” >> liste` komutu
ile dosyama yeni bir veri ekleyip, `stat liste` komutu ile tarih
bilgisine tekrar bakmak istiyorum.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "yeni veri" >> liste

┌──(taylan@linuxdersleri)-[~]
└─$ stat liste                                                  
  File: liste
  Size: 218             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 05:24:30.303662486 -0400
Modify: 2023-06-11 10:15:07.265088731 -0400
Change: 2023-06-11 10:15:07.265088731 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın düzenleme(modify) tarihi düzenlemeyi yaptığımız tam tarih olarak
değişmiş. Ayrıca bakın burada değişim(change) tarihinin de aynı şekilde
değiştiğini görebiliyoruz.

Değişim tarihi de değişti çünkü buradaki değişim tarihi bilgisi,
dosyanın ismi, yetkisi, boyutu gibi çeşitli öznitelikleri değiştiğinde
güncelleniyor. Biz dosyanın içine yeni veri ekleyip dosyanın boyutunu
değiştirdiğimiz için bu "değişim" tarihi de güncellenmiş oldu.

Dolayısıyla bir dosyanın içeriğini değiştirirseniz hem düzenleme hem de
değişme tarihi değişiyor. Fakat yalnızca dosyanın ismi, konumu veya
yetkileri gibi özniteliklerini değiştirdiğinizde sadece değişme tarihi
güncelleniyor. Bu durumu teyit etmek için dosyamızı `mv` komutu ile aynı
dizinde yeni bir isimle kaydedebiliriz. Yani dosyamızın ismini
değiştirmeyi deneyebiliriz. Bunun için `mv liste yeni-liste` şeklinde
komutumuzu girebiliriz. Burada `mv` komutundan sonra girdiğim ilk
argüman taşınacak dosyayı ikincisi ise hangi dizine taşınacağını
belirtiyor. Ben harici olarak ekstra bir dizin adresi belirtmediğim için
göreli yol gereği mevcut dizinde burada belirttiğim isimde kaydedilecek.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ mv liste yeni-liste

┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 05:24:30.303662486 -0400
Modify: 2023-06-11 10:29:21.455971533 -0400
Change: 2023-06-11 10:36:40.927598070 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın dosyayı taşıyarak ismini değiştirdiğimiz için yalnızca
değişme(change) tarihi güncellenmiş. Dosya içeriğinde düzenleme
yapmadığımız için düzenleme tarihinde bir değişiklik yok.

Temel tarih bilgileri ve bunların değişme koşulları bizzat burada
örnekler üzerinden teyit ettiğimiz şekilde çalışıyor. Ayrıca çıktılara
dikkat edecek olursanız burada dosyanın oluşturulma tarihi de mevcut. Bu
bilgi tüm dosya sistemlerinde desteklenmediği için tüm sistemlerde
göremeyebilirsiniz. Yine de güncel mimariye sahip bir sistemde
çalışıyorsanız yeni dosya sistemleri dolayısıyla dosyanın oluşturulma
tarihi de tutuluyordur mutlaka.

Neticede bakın benim sürekli öznitelik olarak bahsetmiş olduğum bu meta
veriler üzerinden dosya hakkında çeşitli tarih bilgilerini
öğrenebiliyoruz. Sistem yönetimi sırasında özellikle sırlama ve
denetleme gibi işlevleri yerine getirirken bu bilgilerden
faydalanabiliyoruz.

`touch` komutu da erişim ve düzenleme tarihlerinin doğrudan
değiştirilmesi konusunda bize yardımcı oluyor.

Örneğin ben dosyanın erişim tarihini güncellemek istersem "**a**ccess"
yani "erişim" ifadesinin kısaltmasından gelen `a` seçeneği ile
`touch -a dosya ismi` şeklinde dosyanın erişim tarihini şimdiki tarih
ile değiştirebilirim.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 05:24:30.303662486 -0400
Modify: 2023-06-11 10:29:21.455971533 -0400
Change: 2023-06-11 10:36:40.927598070 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400

┌──(taylan@linuxdersleri)-[~]
└─$ touch -a yeni-liste                                                        

┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 10:41:09.213674288 -0400
Modify: 2023-06-11 10:29:21.455971533 -0400
Change: 2023-06-11 10:41:09.213674288 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın erişim tarihi bu komutu girdiğim zaman olarak değişmiş.

Benzer şekilde yalnızca düzenlenme tarihini değiştirmek istiyorsam
"modify" ifadesinin kısaltmasından gelen `m` seçeneğini de
kullanabilirim.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 10:41:09.213674288 -0400
Modify: 2023-06-11 10:29:21.455971533 -0400
Change: 2023-06-11 10:41:09.213674288 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400

┌──(taylan@linuxdersleri)-[~]
└─$ touch -m yeni-liste                                                        

┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste                                                        
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2023-06-11 10:41:09.213674288 -0400
Modify: 2023-06-11 10:56:52.024845155 -0400
Change: 2023-06-11 10:56:52.024845155 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın düzenlenme tarihi de tam olarak komutu girdiğim tarih ile
değişmiş.

Eğer biz komutu girdiğimiz sıradaki mevcut tarih yerine spesifik bir
tarih belirtmek istersek "date" ifadesinin kısaltmasından gelen `-d`
seçeneğini kullanarak tam tarih bilgisini yazmamız gerekiyor.

Ben denemek için 2015 yılının 1 haziran gününde saat tam 12:33'te hem
erişim hem de düzenleme tarihi olarak tanımlamak istediğim için komutumu
`touch -d "2015-06-01 12:33:00" yeni-liste` şeklinde giriyorum.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ touch -d "2015-06-01 12:33:00" yeni-liste 

┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2015-06-01 12:33:00.000000000 -0400
Modify: 2015-06-01 12:33:00.000000000 -0400
Change: 2023-06-11 11:02:12.749127535 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın hem erişim hem de düzenlenme tarihi değişmiş.

Eğer ikisini birden değiştirmek istemezsek bunu özellikle ilgili seçenek
sayesinde belirtebiliriz. Ben yalnızca düzenlenme saatini değiştirmek
istediğim için `-d` seçeneğinden önce "`m`" seçeneğini de ekliyorum.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ touch -md "2016-06-01 12:33:00" yeni-liste                              

┌──(taylan@linuxdersleri)-[~]
└─$ stat yeni-liste                                 
  File: yeni-liste
  Size: 228             Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 2893400     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/    taylan)   Gid: ( 1000/    taylan)
Access: 2015-06-01 12:33:00.000000000 -0400
Modify: 2016-06-01 12:33:00.000000000 -0400
Change: 2023-06-11 11:05:39.816609760 -0400
 Birth: 2023-06-11 05:22:23.195248608 -0400
```

Bakın bu kez de yalnızca düzenlenme tarihi tam olarak benim belirtmiş
olduğum tarih olarak değişmiş oldu.

İşte `touch` aracının en temel kullanımı bu şekilde. Yani artık `touch`
aracının yalnızca boş dosya oluşturmak için değil, aslında tarih
bilgilerini düzenlemek için kullanıldığını biliyoruz. Tarih değişimine
pek ihtiyaç duymasanız da ihtiyaç duyduğunuzda bu aracın kullanımını
anımsıyor olacaksınız. Zaten kullanımı çok basit olduğu için seçenekleri
unutmuş olsanız bile `touch —help` komutuyla kontrol edebilirsiniz.

`echo` Komutu
-------------

Daha önce örneklerimizde `echo` komutunu sıklıkla kullandık. "echo"
"eko" ifadesi sizin de bildiğiniz gibi Türkçe olarak "yankılanmak,
yansıtmak" anlamına geliyor. Zaten komutun işlevi de tam olarak bu.
Kendisine argüman olarak verilenleri konsola veya yönlendirildiği yere
yansıtıyor. En basit haliyle `echo` komutundan sonra yazacağımız tüm
ifadeler, `echo` tarafından konsola bastırılıyor. Ben örnek olarak
`echo merhabalar` yazıyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo merhabalar
merhabalar

┌──(taylan@linuxdersleri)-[~]
└─$
```

Gördüğünüz gibi "merhabalar" çıktısı konsola basıldı. Dilersek konsola
bastırmak yerine herhangi bir dosyaya da yönlendirebiliriz. Örneğin
`echo "hello" > hello.txt` komutunu girersem, hello ifadesi hello.txt
dosyasına yazılmış olacak. Zaten daha önce de `echo` komutunu bu şekilde
yönlendirmelerle birlikte kullanmıştık.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "hello" > hello.txt

┌──(taylan@linuxdersleri)-[~]
└─$ cat hello.txt 
hello
```

Bakın dosyamız oluşturulmuş ve içerisine "hello" verisi de eklenmiş.

Ayrıca `echo` komutunu yalnızca tek satırlık veriler için kullanmak
zorunda da değiliz. Eğer yazacaklarımız birden fazla satır tutacaksa,
tırnak işaretini kapatmadan satır satır, yazmak istediklerimizi
yazabiliyoruz. Ben denemek için açtığım tırnağı kapatmadan birden fazla
satırda veriler ekleyip, en son gireceklerim bittiğinde açtığım tırnağı
kapatıp enter ile komutumu onaylıyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "bu ilk
> bu ikinci
> bu uc
> bu ise son satır"
bu ilk
bu ikinci
bu uc
bu ise son satır

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın tırnağı kapatana kadar girmiş olduğum tüm veriler, aynen girdiğim
şekilde konsola bastırılmış oldu.

Eğer konsola bastırmak yerine bu yazdıklarımı bir dosyaya yönlendirmek
istersem tırnağı kapattıktan sonra yönlendirme operatörü ile ilgili
dosyayı belirtip enter ile işlemi onaylayabiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "bu ilk
bu ikinci
bu uc
bu ise son satır" > satırlar

┌──(taylan@linuxdersleri)-[~]                                                             
└─$ cat satırlar 
bu ilk
bu ikinci
bu uc
bu ise son satır
```

Gördüğünüz gibi `>` yönlendirme operatörü sayesinde `echo` komutuna
birden fazla satırda girmiş olduğum verileri "***satırlar***" isimli
dosyaya sorunuzca aktarmış oldum.

`echo` komutunun çıktılarını bir dosyaya sorunsuzca yönlendirebildik
ancak daha önce de bizzat deneyimlediğimiz gibi `echo` komutunun
standart girdiden veri okumadığına tekrar dikkatinizi çekmek istiyorum.
Bu durumu tekrar teyit etmek istersek, örneğin biraz önce `echo` komutu
ile içine satırlar eklediğimiz "***satırlar***" dosyasını `echo` komutu
aracılığı ile konsola bastırmak üzere `echo < sonuclar` şeklinde
komutumuzu girebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo < satırlar                                                            

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın, gördüğünüz gibi konsola herhangi bir çıktı basılmadı. Çünkü
`echo` komutu standart girdiden veri okumuyor. Biz göndersek de `echo`
komutu standart girdiden veri kabul etmediği için `echo` komutuna
aslında yankılayabileceği hiç bir argüman vermiş olmuyoruz. Dolayısıyla
konsola hiç bir veri bastırılamıyor. `echo` komutu çalışma yapısı gereği
yalnızca kendisine argüman olarak verilmiş olan ifadeleri konsola
yankılıyor yani bastırıyor.

Zaten `help echo` komutu ile yardım sayfasına göz atacak olursanız,
yardım bilgisinin en üstünde `echo` komutunun argümanları standart
çıktıya yazdırdığı açıkça yazıyor.

![8.webp](https://www.linuxdersleri.net/egitim/temel-linux/metin/8.webp)

Ayrıca gördüğünüz gibi standart girdiden veri kabul ettiğine dair
herhangi bir açıklama da bulunmuyor. Burada kast edilen argüman
yapısının ne olduğunu zaten biliyorsunuz.

Özetle `echo` yalnızca kendisine argüman olarak aktarılanları standart
çıktı aracılığı ile konsola veya özellikle belirtildiyse başka bir
hedefe yönlendirmekle mükellef bir araç. Eğer hatırlıyorsanız, ben
yönlendirmelerden bahsederken kimi araçların standart girdiden veri
almayabileceğinden de bahsetmiştim. İşte `echo` aracı da bahsi geçen bu
araçlardan biri. Kimi araçlar yalnızca argümanları işlemek için
tasarlandıklarından, standart girdiden veri kabul etmiyorlar.

Hatta `echo` komutunun yalnızca argümanları yankıladığına dair basit bir
örnek vermek gerekirse `echo *` komutunu kullanabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]                                                                                      
└─$ echo *
ada calısma Desktop Documents dosya.txt Downloads harf.txt hatalı.txt hatasız2.txt hatasız.txt hello.txt klasor liste2 liste3 liste.txt metin metin1.txt metin2.txt Music nihai-liste Pictures Public satırlar sayi.txt sonuc Templates test.sh Videos yeni yeni klasor yeni-liste yepyenidosya
```

Biliyorsunuz buradaki yıldız `*` işareti kabuk için tüm dosya ve dizin
isimleriyle eşleşen bir genişletme karakteri. Dolayısıyla bu karakterin
olduğu yere kabuk tarafından mevcut dosya ve dizin isimlerinden uygun
olan tüm karakterler getirilebiliyor. Kabuk `echo` komutunu gördüğünde
bu aracı çalıştırması gerektiğini anlıyor, daha sonra yıldız simgesini
görüyor. Yıldız işareti bash kabuğu için dosya ismi genişletmesi
anlamına geldiği için kabuğumuz bu genişletmeyi uyguluyor. Yani yıldız
işretinin yerini, mevcut dizindeki dosya ve klasörlerin isimleri alıyor.
Dolayısıyla `echo` komutuna da argüman olarak dosya ve dizinlerin
isimleri verilmiş oluyor. `echo` komutu da argümanlarını konsola çıktı
olarak yansıtıyor yani standart çıktılarını konsola yönlendiriyor.

İşte sizlerin de görebildiği gibi, kabuğun çalışma yapısını ve temel
özelliklerini bildiğimizde, bu örnekte olduğu gibi komut verme konusunda
inanılmaz esnekliğe sahip olabiliyoruz. Ben sadece dikkat çekici bir
örnek olması için tekrar bu örneği ele aldım.

Tıpkı bu örnekte olduğu gibi `echo` komutu da dahil tüm komutların pek
çok esnek kullanım imkanları var. Yeter ki biz temelde nasıl
çalıştıklarını bilelim.

Ayrıca şu ana kadar ele aldığımız kullanımlar dışında `echo` komutun pek
çok ek seçeneği bulunuyor. Bunları görmek için tekrar `help echo`
komutunu kullanabiliriz.

``` {.vbnet}
┌──(taylan@linuxdersleri)-[~]
└─$ help echo
echo: echo [-neE] [arg ...]
    Write arguments to the standard output.
    
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.
    
    Options:
      -n        do not append a newline
      -e        enable interpretation of the following backslash escapes
      -E        explicitly suppress interpretation of backslash escapes
    
    `echo' interprets the following backslash-escaped characters:
      \a        alert (bell)
      \b        backspace
      \c        suppress further output
      \e        escape character
      \E        escape character
      \f        form feed
      \n        new line
      \r        carriage return
      \t        horizontal tab
      \v        vertical tab
      \\        backslash
      \0nnn     the character whose ASCII code is NNN (octal).  NNN can be
                0 to 3 octal digits
      \xHH      the eight-bit character whose value is HH (hexadecimal).  HH
                can be one or two hex digits
      \uHHHH    the Unicode character whose value is the hexadecimal value HHHH.
                HHHH can be one to four hex digits.
      \UHHHHHHHH the Unicode character whose value is the hexadecimal value
                HHHHHHHH. HHHHHHHH can be one to eight hex digits.
    
    Exit Status:
    Returns success unless a write error occurs.
```

Bakın burada pek çok özel karakter bulunuyor. Hepsine tek tek
değinmemize gerek yok. Ama kısaca bir göz atalım.

Normalde `echo` komutunun ardından yazdığımız ifade konsola doğrudan
bastırılıyor.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo merhaba                                                                                                 
merhaba

┌──(taylan@linuxdersleri)-[~]
└─$ echo merhaba                                                                                                 
merhaba

┌──(taylan@linuxdersleri)-[~]
```

Burada dikkat etmemiz gereken detay, aslında bizim girdiğimiz ifadeden
sonra `echo` komutunun otomatik olarak yeni satıra geçme karakteri
gizlice kullanıyor olması. Bu durumu teyit etmek için otomatik olarak
yeni satıra geçme özelliğini kapatmak üzere `-n` seçeneğini
kullanabiliriz. `n` seçeneği "**n**ewline" yani "yeni satır" ifadesinin
kısaltmasından geliyor. Bu şekilde aklınızda daha kolay kalabilir.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -n merhaba                                                                                              
merhaba
┌──(taylan@linuxdersleri)-[~]
└─$
```

Önceki çıktı ile kıyaslayacak olursanız bir alt satıra geçilmediğini
teyit edebilirsiniz. Böylelikle `echo` komutunun aslında, gizli "yeni
satır" eklediğini öğrenmiş olduk. Elbette yardım sayfası üzerinde de
görebildiğimiz gibi `echo` aracının pek çok biçimlendirme özelliği
bulunuyor.

Kısaca bu biçimlendirme özelliklerinden de bahsedecek olursak. `echo`
aracı, ters slash `\` ile başlayan ifadeleri gördüğünde onların özel
anlamlarına göre çıktıyı biçimlendiriyor. Fakat bu ifadeleri doğrudan
kullanamıyoruz. Bu biçimlendirme ifadelerini kullanırken `echo`
komutunun `-e` seçeneğini kullanarak, `echo` komutuna bu karakterlere
özel anlamlarına göre dikkate alaması gerektiğini özellikle belirtmemiz
şart. Aksi halde buradaki ifadeleri kullansak bile bunlar `echo` komutu
için sıradan karakterlerden ibaret olacak. Hemen deneyelim. Ben yeni
satıra geçmeyi sağlayan `\n` ifadesini kullanacağım. Komutumu
`echo "merhaba \n dünya"` şeklinde giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo "merhaba \n dünya"
merhaba \n dünya

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın çıktılarda `\n` ifadesi de yazdığımız şekilde duruyor ve yeni bir
satıra da geçilmemiş. Aynı örneğini bu kez `-e` seçeneği varken tekrar
deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "merhaba \n dünya"                                                                                   
merhaba 
 dünya

┌──(taylan@linuxdersleri)-[~]
└─$
```

Bakın bu kez `\n` ifadesi `echo` komutu tarafından dikkate alındı ve
ikinci kelimemiz bir alt satırda bastırıldı. Dikkat ettiyseniz tırnak
içinde yazdım. Çünkü biçimlendirme özelliklerinin doğru şekilde
çalışması için tırnak içinde yazmamız gerekiyor. Daha önce tek ve çift
tırnak kullanımı arasındaki farklardan bahsetmiştik. Bu doğrultuda tek
veya çift tırnak kullanma seçimi size ait.

Ayrıca hatırlıyorsanız daha önce `echo` komutunu ve süslü parantez
genişletmelerini kullanarak sıralı karakterleri alt alta olacak şekilde
biçimlendirmiştik. Şimdi tekrar aynı komutu kullanıp sonuçlarına
bakabiliriz. Aynı örneği gerçekleştirmek için `echo -e "\n"{a..z}`
komutunu girelim.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "\n"{a..z}

a 
b 
c 
d 
e 
f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r 
s 
t 
u 
v 
w 
x 
y 
z
```

Bakın `echo` komutunun `-e` seçeneğinden ve `\n` şeklinde yazılan yeni
satır biçimlendirme özelliğinden faydalanmış olduk. Etkisini görmek için
aynı örneği `\n` olmadan da test edebiliriz.

``` {.css}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e {a..z}                                                                                           
a b c d e f g h i j k l m n o p q r s t u v w x y z
```

Bakın yeni satıra geçme karakteri olmayınca tüm veriler aynı satırda
bastırıldı. Bu örnek bu biçimlendirme karakterlerinin gerektiğinde
oldukça kullanışlı olabildiğini gösteren çok basit bir örnek.

İşte sizler de benim bu örnek üzerinden ele aldığım gibi, yardım
sayfasında yer alan diğer tüm biçimlendirme özelliklerini `-e` seçeneği
ile birlikte `echo` komutu üzerinden kullanabilirsiniz.

Buradaki seçeneklerin hepsini ezberlemek zorunda değilsiniz. Hatta hiç
birini ezberlemeyin. Çünkü ezberlemeniz gerekmiyor, kullandıkça bu
ifadeleri zaten hatırlıyor olacaksınız. Hatırlayamadığınız zaman yardım
sayfasından kısa sürede tekrar bakabilirsiniz. Zaten kısaltmaların,
temsil ettiği biçimlendirme özellikleri ile uyumlu olduğunu da göz
önünde bulundurduğumuzda, pratik yaptıkça sık kullandığınız seçeneklerin
hemen aklınıza geldiğini sizler de fark edeceksiniz. Ayrıca buradaki
biçimlendirme ifadeleri, çoğu araçta benzer şekilde olduğundan bir kez
öğrendiğinizde sistem üzerindeki metin biçimlendirme araçların pek
çoğunda aynı ifadeleri kullanabiliyor olacaksınız.

Yani özetle benim bahsetmediğim diğer seçeneklerin açıklamasına bakarak,
tam olarak nasıl bir biçimlendirme uyguladığını bizzat test etmeniz
yeterli. Hem bu sayede pratik yapmış olursunuz.

`paste` Komutu
--------------

İleride dosya içeriklerini değiştirip dosyaların değişimlerini
kıyaslamak için yan yana bastırmak istediğimiz örneklerle
karşılaşacağımız için ilk olarak `paste` aracından bahsetmek istedim.
Normalde `cat` komutu ile birden fazla dosyayı okurken dosyaların
içerikleri peşi sıra alt alta bastırılıyorken, `paste` aracı ile bu
çıktıların yan yana bastırılmasını sağlayabiliriz. Yani `cat` aracı
satırların birleştirilmiş çıktılarını üretirken, `paste` aracı
sütunların birleştirilmiş çıktılarını sunuyor.

Ben denemek için önceden oluşturduğum "***şehir" "harf"*** ve
"***rakam"*** isimli dosyaları yan yana bastırmak istiyorum. Ama bundan
önce `cat` komutu ile farkını daha rahat gözlemleyebilmek adına bu
dosyaları okumak üzere `cat harf sehir rakam` komutunu girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat harf sehir rakam
a
b
c
d
e
f
istanbul
Ankara
İzmir
bursa
antayla
Kocaeli
1
2
3
4
5
6
```

Bakın tam da beklediğimiz gibi tüm dosyalardaki satırlar alt alta
birleşik halde bastırıldı. Şimdi bunları yan yana bastırmak için
`paste harf sehir rakam` şeklinde komutumuz tekrar girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste harf sehir rakam                                                                                       
a       istanbul        1
b       Ankara  2
c       İzmir   3
d       bursa   4
e       antayla 5
f       Kocaeli 6
```

Bakın bu kez dosyalardaki satırlar üç farklı sütunda yan yana
bastırılmış oldu. `paste` aracının bize sunduğu kolaylık tam olarak bu.

Burada dosya içeriklerinin kolay ayırt edilebilmesi için sütunlar
arasında boşluklar yer alıyor. Fakat dilersek, bastırılan sütunlar
arasında boşluk yerine özel bir işaret yani özel bir sınırlayıcı
karakter de ekleyebiliriz. Örneğin ben her bir sütun arasına kısa dikey
çizgi eklemek istiyorum. `paste` aracına sütunları nasıl ayıracağını
belirtmek için de İngilizce "**d**elimiter" yani "sınırlayıcı"
ifadesinin kısalmasından gelen `-d` seçeneğinin ardından sınırlayıcı
karakteri yazabiliriz.

Ben sınırlayıcı olarak dikey çizgiyi kullanmak istediğim için komutumuz
`paste -d "|" harf sehir rakam` şeklinde giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste -d "|" harf sehir rakam                                                                                
a|istanbul|1
b|Ankara|2
c|İzmir|3
d|bursa|4
e|antayla|5
f|Kocaeli|6
```

Bakın, tüm sütunların arasında dikey çizgi yer alıyor, çünkü ben
sınırlayıcı karakter olarak buradaki dik çizgi karakterini
tanımlamıştım. Tabii ki sizler dilediğiniz bir karakteri sınırlayıcı
olarak kullanabilirsiniz. Hatta birden fazla sınırlayıcı karakter de
belirtebilirsiniz. Örneğin dikey çizgi ve kısa çizgi karakterlerini
sınırlayıcı olarak kullanırsak, sırasıyla iki sınırlayıcı da dosya
içeriklerini sınırlamak için kullanılıyor olacak. Bu durumu daha net
gözlemeyebilmek adına daha fazla dosyayı yan yana bastırsak daha iyi
olur. Ben aynı dosyaları tekrar tekrar yan yana bastırmak istiyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste -d "|-" harf sehir rakam sehir harf rakam
a|istanbul-1|istanbul-a|1
b|Ankara-2|Ankara-b|2
c|İzmir-3|İzmir-c|3
d|bursa-4|bursa-d|4
e|antayla-5|antayla-e|5
f|Kocaeli-6|Kocaeli-f|6
```

Bakın, gördüğünüz gibi sırasıyla hem dikey çizgi hem de kısa çizgi
karakterleri sütunlar arasındaki sınırlayıcı olarak kullanılmış. İşte
sizler de bu şekilde sütunları istediğiniz sınırlayıcı karakterle
birbirinden ayırabilirsiniz. Birden fazla sınırlayıcı belirttiğimizde
tıpkı burada aldığımız çıktıda da olduğu gibi bu karakterler sırasıyla
soldan sağa doğru tekrar eden bir örüntü gibi kullanılıyor olacak.
İhtiyacınız doğrultusunda tek ve birden fazla sınırlayıcı karakter
belirtebilirsiniz. Hatta sınırlayıcı olarak tırnak içinde hiç bir
karakter belirtmezseniz doğrudan boşluk olmadan dosyaların birbirine
yapıştırılmasını da sağlayabilirsiniz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste -d "" harf sehir rakam                                                              
aistanbul1
bAnkara2
cİzmir3
dbursa4
eantayla5
fKocaeli6
```

Bakın, dosyalardaki tüm satırlar aralarında boşluk olmadan sütunlarda
birleştirilmiş. Tıpkı bu örnekte olduğu gibi ihtiyacınıza yönelik
şekilde sınırlayıcı karakter belirtmekte özgürsünüz.

Ayrıca sınırlama işareti dışında eğer her bir satırı yan yana değil de
alt alta eşleşecek şekilde sıralamak istersek `-s` seçeneğini de
kullanabiliyoruz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste -s harf sehir rakam                                                                                 
a       b       c       d       e       f
istanbul        Ankara  İzmir   bursa   antayla Kocaeli
1       2       3       4       5       6
```

Görebildiğiniz gibi normalde satırlar yan yana basılırken şimdi
dosyalardaki her bir satır alt alta gelmiş şekilde basılmış oldu.

Sizler ihtiyacınıza göre `paste` aracını kullanarak istediğiniz sayıda
dosyanın satırlarını birebir yan yana ya da alt alta
birleştirebilirsiniz. Eğer birden fazla dosya içeriğinin yan yana
birleştirilmiş hali lazımsa komutunuzun sonuna yönlendirme işareti
ekleyip çıktıları yeni bir dosya olarak kaydedebilirsiniz. Ben en son
girdiğim komutun sonuna `> paste-sonucları` ekleyip çıktıları dosyaya
kaydediyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ paste -s harf sehir rakam > paste-sonucları                                                                  

┌──(taylan@linuxdersleri)-[~]
└─$ cat paste-sonucları                                                                                          
a       b       c       d       e       f
istanbul        Ankara  İzmir   bursa   antayla Kocaeli
1       2       3       4       5       6
```

Bakın çıktılar dosyama kaydolmuş. Neticede `paste` aracını kullanarak
mevcut dosyaları yan yana veya dikey olarak nasıl birleştirebileceğimizi
de ele almış olduk. Ayrıca ben yönlendirmek için tek büyüktür yine yeni
bir dosya oluşturmayı tercih ettim ama siz diğer yönlendirme
alternatiflerini biliyorsunuz.

Zaten artık hatırlatmama gerek yok. Sizler yönlendirmeler ile ilgili
bilmeniz gereken tüm temel altyapıya sahipsiniz. İhtiyaçlarınıza göre
sistem üzerinde tüm araçlarda kullanabilirsiniz. Özellikle veri bilimi
gibi alanlarda çalışırken, bu şekilde birden fazla kaynaktan alınan
verilerin istenildiği şekilde derlenebilmesi çok kullanışlı olabiliyor.
Tüm mesele elimizdeki verileri ihtiyaçlarımıza göre düzenleyip
kullanabilmek.

`sort` Komutu
-------------

Özellikle düzensiz haldeki büyük veriler üzerinde çalışıyorken `sort`
gibi araçlar yardımıyla bu verileri düzenlememiz gerekebiliyor. Tahmin
edebileceğiniz gibi zaten buradaki `sort` aracının ismi de Türkçe olarak
"sıralamak-sınıflandırmak" ifadelerine karşılık geliyor.

`sort` aracı sayesinde elimizdeki düzensiz verileri, belirli özelliklere
göre kolayca sınıflandırabiliyoruz.

sort aracının kullanılabilecek pek çok özelliği olmasına karşın, eğer
herhangi bir seçenek belirtmeden doğrudan karışık satırları `sort`
aracına iletirsek;

Öncelikle tüm satırlardaki ilk karakterlere bakıp sırasıyla sayılar,
daha sonra harfler ve son olarak eğer aynı harfler varsa küçük harfler
öncelikli olacak şekilde sıralanıyorlar. Ve bu sıralama işlemi tüm
satırlardaki tüm karakterler sıralanıncaya kadar tekrar tekrar devam
ediyor.

Yani ilk olarak tüm satırlardaki karakterlere bakılıp tüm satırlar
buradaki kural dahilinde sıralanıyor. Daha sonra ilk karakteri aynı olan
satırlar ikinci karaktere göre kendi içlerinde bir daha sıralanıyor ve
bu işlem satırlardaki tüm karakterler bitine kadar bu şekilde
gerçekleştiriliyor. Bu şekilde tüm satırlarda yer alan tüm karakterleri
baştan sonra kendi standart kuralı dahilinde sıralamış oluyor.

Uygulamalı olarak daha net anlaşılacağı için hemen bir dosya üzerinde
test edelim. Ben örnek olarak içerisinde küçük büyük harfler ve rakamlar
bulunan bir şablon kullanacağım. Bakın benim kullanacağım şablon bu.
İçerisinde düzensiz veriler bulunan bu şablonu kullanıyorum çünkü biraz
önce bahsetmiş olduğumuz tüm sıralama kurallarını net biçimde görmemiz
mümkün olacak.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat > sablon
b3
ba
B3
3B
a2
A1
a1
2a
1b
3b
```

Görebildiğiniz gibi kullanacağımız bu şablon, içerisinde küçük büyük
harfler ve rakamlar bulunan son derece düzensiz bir içeriğe sahip. Şimdi
bu dosyanın ismini `sort` komutundan sonra argüman olarak yapıp düzenli
bir listenin nasıl göründüğüne bakalım.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort sablon
1b
2a
3b
3B
a1
A1
a2
b3
B3
ba
```

Aldığımız çıktıyı inceleyecek olursak. Bakın öncelikle tüm satırlardaki
ilk karakterlere bakılmış ve bunlar sayısal olarak sıralanmış. Daha
sonra alfabetik olarak sıralanmış. **a** karakteri **b** den önce
geldiği için küçük büyük harf fark etmeksizin ilk harfinde **a** olan
tüm satırlar ilk karakterinde **b** olanlardan önce sıralanmış.
Alfabetik sıralamadan sonra da aynı karaktere sahip olan satırlarda
küçük karakterler büyüklerden önce sıralanmış. Bu sebeple küçük **a**
karakterleri büyüklerden önce geliyor. Fakat burada **A1** satırı,
başında küçük **a** olasına rağmen **a2** den önce gelmiş.

Bu durumun nedeni ikinci karakterdeki **2** rakamı aslında. `sort` aracı
sıralama işlemini tüm karakterleri tek tek sıralayıp tekrar tekrar
sıralama yaptığı için bu şekilde çıktı aldık. Yani aslında `sort` aracı
tıpkı bu örneğimizde olduğu gibi öncelikle sırasıyla tek tek
karakterlere bakarak sıralama yapıyor olsa da tüm karakterlerin
kendisine göre hesapladığı ağırlık değerlerine göre yeniden
sıralanmasını sağlıyor.

Yani aslında `sort` aracı ilk turda yalnızca buradaki ilk karaktere
bakarak listeyi şu şekilde sıralıyor.

    1b
    2a
    3b
    3B
    a1
    a2
    A1
    b3
    ba
    B3

Daha sonra sıra ikinci karaktere bakmaya geliyor. Bu durumda ilk
karakteri aynı olanları ikinci karaktere bakarak sıralıyor. Buradaki
**A1** satırındaki **1** rakamı, **a2** satırındaki **2** rakamından
küçük olduğu için daha fazla öncelik kazanıyor. Dolayısıyla baştaki
**a** karakterinin büyük küçük olması bu sıralamayı değiştirmiyor.

İlk örneğimizde tek bir dosyadaki satırları sıraladık ancak dilersek
birden fazla dosyayı da tek seferde `sort` komutu ile sıralayabiliriz.
Hem bu sayede birden fazla dosya içeriğini sıralı şekilde birleştirmiş
oluruz. Tıpkı `cat` komutun olduğu gibi ancak bu veriler sıralanmış
olacak.

Ben denemek için `cat > sayi` komutuyla yeni bir dosya açıp buna
düzensiz veriler giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat > sayi                    
10
4
6
2
21
95
3
3
75
8
1
01
40
```

Şimdi bir de düzensiz harfler oluşturmak üzere `cat > harf` komutunun
ardından rastgele karakterleri girelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat > harf
a
g
F
z
D
g
O
p
l
k
S
C
E
n
M
h
t
N
```

Şimdi her iki dosyamızın ismini de argüman olarak verip aynı anda
sıralamasını sağlayalım.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort sayi harf                       
01
1
10
2
21
3
3
4
40
6
75
8
95
a
C
D
E
F
g
g
h
k
l
M
n
N
O
p
S
t
z
```

Gördüğünüz gibi dosyalar birleştirilip ortak şekilde sıralanmış oldu.
Öncelikle rakamlar, daha sonra küçük karakter önce olacak şekilde
alfabetik sıralama gerçekleştirilmiş. Ama sanki aldığımız çıktı biraz
tuhaf gibi. Normalde sayıların sıralanması deyince çoğu kişinin aklına
iki basamaklıklar da dahil tüm hepsinin küçükten büyüğe doğru
sıralanması gerektiği geliyor. Ama önceki açıklamalarımıza dikkat
ettiyseniz `sort` komutu her bir satırın yalnızca tek bir karakterini
sıralıyor. Dolayısıyla sıralama yapılırken aslında sayılar değil 0 dan 9
a kadar olan rakamlar arasında sıralama yapılıyor. Buradaki ilk karakter
olan yani ilk basamakta yer alan tüm rakamlar zaten matematiksel olarak
küçükten büyüğe doğru sıralanmış. İlk karakterler sıralandıktan sonra da
ilk karakteri yani ilk basamağı aynı olan rakamların da ikinci
basamakları kendi içlerinde tekrar sıralanmış.

Yani aldığımız çıktıda herhangi bir problem yok. `sort` komutu buradaki
sayıların bütüncül matematiksel büyüklüğüne bakmıyor, tek tek her bir
satırdaki birer karakterlere bakıp ona göre sıralıyor.

Eğer dosya içeriğinin matematiksel büyüklüğü dikkate alınarak sıralansın
istersek bunu "**n**umerical" yani "sayısal" ifadesin kısaltması olan
`-n` seçeneği ile özellikle belirtmemiz gerekiyor. Şimdi "***sayi***"
dosyasını `-n` seçeneğini de kullanarak tekrar sıralayalım.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort -n sayi
01
1
2
3
3
4
6
8
10
21
40
75
95
```

Bakın bu kez dosya içeriğindeki veriler matematiksel büyüklüklerine göre
sıralandı. Yani eğer sayısal sıralama yapacaksınız `n` seçeneğini
kullanmanız gerektiğini unutmayın lütfen. Ya da unutun, tekrar yardım
sayfasına bakıp hatırlayabilirsiniz zaten. Sadece yeri gelmişken
bahsetmek istedim.

Sıralamayı Tersine Çevirmek
---------------------------

Eğer `sort` komutunun sıraladığı satırları tersine çevirmek istersek,
"**r**everse" yani "ters" ifadesinin kısaltması olan "`r`" seçeneğini
kullanabiliyoruz.

Rahatça kıyaslayabilmek için öncelikle seçenek olmadan `sort` komutunu
kullanalım.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort sayi
01
1
10
2
21
3
3
4
40
6
75
8
95
```

Şimdi de -r seçeneğini ekleyip tersten sıralayalım.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ sort -r sayi                         
95
8
75
6
40
4
3
3
21
2
10
1
01
```

Bakın iki çıktıyı kıyasladığımızda, satırların tam tersi şekilde
sıralandığını görebiliyoruz.

Elbette dilersek `n` seçeneğiyle de birlikte kullanabiliriz.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort -n sayi                        
01
1
2
3
3
4
6
8
10
21
40
75
95

┌──(taylan@linuxdersleri)-[~]
└─$ sort -nr sayi                        
95
75
40
21
10
8
6
4
3
3
2
1
01
```

Sizde bu seçenek sayesinde elinizdeki verileri ters alfabetik ya da ters
numerik şekilde sıralayabilirsiniz.

Sütunlar Özel Sıralama
----------------------

`sort` komutu en baştan başlayıp tüm satırlardaki karakterleri tek tek
sıralıyor. Fakat biz her zaman satırların en başındaki karaktere
bakılmasını istemeyebiliriz. Yalnızca her satırın en başındaki karaktere
göre sıralama yapmak yerine eğer mevcutsa, diğer sütunlara göre sıralama
yapılmasını da sağlayabiliriz.

Örnek olarak isimler ve yaşları içeren bir şablon kullanabiliriz.

    ahmet 21
    mehmet 44
    Ayse 24
    adnan 43
    Nil 20
    naz 29

Eğer seçenek kullanmadan yalnızca `sort` komutunu kullanırsak, en
baştaki karakterlere göre sıralanacak.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort veri                      
adnan 43
ahmet 21
Ayse 24
mehmet 44
naz 29
Nil 20
```

Bakın çıktılar ilk sütundaki ilk karakterlere göre sıralandı.

Şimdi `sort` komutuna yalnızca **2. sütuna** bakarak sıralama yapmasını
söyleyelim. Bunun için "`k`" seçeneğini kullanabiliyoruz. Hangi sütuna
göre sıralanacağını belirtmek için "`k`" seçeneğinden sonra sütun
sayısını girmemiz gerekiyor. Ben **2. sütuna** göre sıralanmasını ve
matematiksel büyüklüğe göre sıralanmasını istediğim için komutumu
`sort -nk 2 dosya adı` şeklinde giriyorum.

``` {.perl}
┌──(taylan@linuxdersleri)-[~]
└─$ sort -nk 2 veri                      
Nil 20
ahmet 21
Ayse 24
naz 29
adnan 43
mehmet 44
```

Gördüğünüz gibi girmiş olduğum "`k`" seçeneği sayesinde bu kez **2.
sütuna** yani yaş sayılarına göre sıralama yapıldı. İşte sizler de
içerisinde birden fazla sütun bulunan bu gibi dosyaların, hangi
sütunlarına göre sıralanması gerektiğini "`k`" seçeneği ile özellikle
belirtebilirsiniz.

Yalnızca Benzersiz Olanları Bastırmak
-------------------------------------

Eğer `sort` komutuna verilen girdide birbirini tekrar eden satırlar
varsa bunları teke indirebiliriz. `sort` komutunda bu filtrelemeyi
uygulamak için İngilizce "**u**nique" yani "benzersiz" ifadesinin
kısaltması olan "`u`" seçeneğini kullanabiliyoruz.

Ben denemek için basit bir isim soyisim listesi kullanacağım.

``` {.css}
Ahmet Yılmaz
Ayşe Demir
Cemal Özkan
Mustafa Öztürk
Fatma Kaya
Ali Can
Zeynep Aksoy
Hasan Şahin
Ahmet Şen
Emine Akgün
Mustafa Aydın
Hatice Türkmen
İbrahim Karaca
Esra Özdemir
Melek Akyüz
Murat Çelik
Seda Kaya
Cemal Özkan
Hatice Yıldız
Ahmet Şen
Leyla Koçak
Mustafa Yılmaz
Melek Akyüz
```

Bakın burada isim kısmı aynı olan satırlar ve isim soy isim aynı olan
satırlar var. sort -u komutunu çalıştırıp nasıl bir çıktı elde
edeceğimize bakalım.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ sort -u liste                        
Ahmet Şen
Ahmet Yılmaz
Ali Can
Ayşe Demir
Cemal Özkan
Emine Akgün
Esra Özdemir
Fatma Kaya
Hasan Şahin
Hatice Türkmen
Hatice Yıldız
İbrahim Karaca
Leyla Koçak
Melek Akyüz
Murat Çelik
Mustafa Aydın
Mustafa Öztürk
Mustafa Yılmaz
Seda Kaya
Zeynep Aksoy
```

Bakın isimler kısmı aynı olmasına rağmen satırlar basıldı. Fakat birebir
aynı olan satırlar yani isim ve soy isimin aynı olduğu satırlardan
yalnızca bir tanesi basıldı. Gördüğünüz gibi bu şekilde birebir tekrar
eden satırları `u` seçeneği ile tek bir satır basılacak şekilde
sıralayabiliyoruz.

`sort` komutunun tüm seçenekleri benim bahsettiklerimle sınırlı da
değil. Burada ele aldıklarımız dışında `sort` komutunun birkaç özelliği
daha bulunuyor. Ancak ben geri kalan özelliklerden, başka araçları
kullanarak da faydalanabileceğimizi bildiğim için `sort` komutunu için
bu kadarlık bilginin yeterli olduğunu düşünüyorum. Merak ediyorsanız
`sort —help` komutunun çıktılarına göz atabilirsiniz.

`shuf` Komutu
-------------

`shuf` aracının ismi İngilizce "**shuf**fle" yani "karıştırmak"
ifadesinden geliyor.

`shuf` aracı sayesinde mevcut satırların rastgele olacak şekilde
karıştırılmasını sağlayabiliyoruz. Ben örnek olması için
`echo -e “\n”{1..10} > liste1` komutu ile 1'den 10'a kadar alt alta
sayıları dosyaya kaydediyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ echo -e "\n"{1..10} > liste1

┌──(taylan@linuxdersleri)-[~]
└─$ cat liste1         
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
```

Eğer ben bu dosyamın satır sıralamalarını karıştırmak istersem `shuf`
komutunu kullanabilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ shuf liste1                          
6 
1 
7 
9 
3 
2 
8 
5 
4 
10
```

Bakın bu kez rastgele sıralanmış şekilde satırlar bastırıldı. Komutumuzu
her kullandığımızda, gördüğünüz gibi satırların sıralaması rastgele
olacak şekilde karıştırılıyor.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ shuf liste1                          
1 
8 
5 
6 
10
7 
4 
3 
2 
9
```

Tabii ki biz özellikle yönlendirme yapmadığımız sürece buradaki
karıştırma işlemi kaynak dosyayı etkilemiyor. `shuf` komutu kaynak
dosyadan okuyup karıştırdığı satırları konsolumuza bastırıyor. Yani
orijinal dosyada bir değişiklik olmuyor. Teyit etmek için tekrar cat
komutu ile "***liste1***" dosyamızı okuyabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ cat liste1         
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
```

Bakın dosyanın içeriğinde herhangi bir değişiklik olmamış. Çünkü dediğim
gibi `shuf` komutu yalnızca okuduğu satırları rastgele karıştırıp
standart çıktıya yönlendiriyor. Eğer biz bu karışık listeyi bir dosyaya
kaydetmek istersek, yönlendirme operatörü ile istediğimiz bir dosyaya
yönlendirebiliriz. Ben bunun için komutun sonuna `> karisik.txt`
şeklinde ekliyorum ve `paste` komutu ile de orijinal ile karışık
olanları yan yana bastırıyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ shuf liste1 > karisik.txt
┌──(taylan@linuxdersleri)-[~]
└─$ paste liste1 karisik.txt             
        3 
1       8 
2       5 
3       9 
4       10
5       6 
6       7 
7       2 
8 
9       4 
10      1
```

Bakın kaynak dosyada hiç bir değişiklik yok ve yönlendirme operatörü
sayesinde standart çıktıyı yönlendirdiğimiz "***karisik.txt***"
dosyasının içeriği de istediğimiz gibi karışık satırlardan oluşuyor.

Bu basit kullanım dışında eğer isterseniz tüm satırlar yerine belirli
sayıda satırların bastırılmasını da sağlayabilirsiniz. Örneğin ben 10
satırdan oluşan bu listenin karıştırılıp, yalnızca 3 satırın bana çıktı
olarak verilmesini istiyorum. Bunun için "`n`" seçeneğinin ardından
istediğim satır sayısını yazmam yeterli. Yani komutumuzu
`shuf -n 3 liste1` şeklinde girebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ shuf -n 3 liste1
8 
9 
2
```

Bakın rastgele 3 satır bastırıldı. Komutumu tekrar tekrar girdiğimizde,
yalnızca 3 satır olacak şekilde rastgele satırların bastırıldığını
görebiliyoruz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ shuf -n 3 liste1                     
5 
1 
10
```

Neticede artık elinizdeki verileri karıştırmak istediğinizde `shuf`
aracını nasıl kullanabileceğinizi biliyorsunuz. `shuf` aracının diğer
seçeneklerini merak ediyorsanız `shuf —help` komutu ile yardım bilgisine
göz atıp, kendiniz keşfedebilirsiniz.

`nl` Komutu
-----------

Eğer satırların başına satır numaralarını eklemek istersek
"**n**umbering **l**ine" yani "satır numaralandırma" ifadesinin
kısalmasından gelen `nl` komutunu kullanabiliyoruz. Özellikle çok fazla
verinin tek bir satıra sığdırıldığı yoğun içerikli dosyalarda içeriği
daha rahat okuyabilmek için numaralandırma bize kolaylık sunabiliyor.

Ben denemek için daha önce oluşturmuş olduğum içerisinde isimler bulunan
"***liste***" isimli dosyasını kullanacağım. Satırları numaralamak için
`nl liste` şeklinde dosyamızın ismini argüman olarak verebiliriz.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ nl liste                             
     1  Ahmet Yılmaz
     2  Ayşe Demir
     3  Cemal Özkan
     4  Mustafa Öztürk
     5  Fatma Kaya
     6  Ali Can
     7  Zeynep Aksoy
     8  Hasan Şahin
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
```

Bakın sırasıyla tüm satırların başında numara bulunuyor.

Ayrıca mesela eğer birden fazla dosyayı argüman olarak girersek,
girdiğimiz argüman sıralamasına göre bu dosya içerikleri birleştirilip o
şekilde numaralandırılıyor. Ben denemek için `nl liste harf` şeklinde
iki tane dosya ismini giriyorum.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ nl liste harf                        
     1  Ahmet Yılmaz
     2  Ayşe Demir
     3  Cemal Özkan
     4  Mustafa Öztürk
     5  Fatma Kaya
     6  Ali Can
     7  Zeynep Aksoy
     8  Hasan Şahin
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
    26  a
    27  g
    28  F
    29  z
    30  D
    31  g
    32  O
    33  p
    34  l
    35  k
    36  S
    37  C
    38  E
    39  n
    40  M
    41  h
    42  t
    43  N
```

Bakın öncelikle "***liste***" dosyasının içeriği daha sonra "***harf***"
dosyasının içeriği birleştirilmiş ve birleşik şekilde bu satırlar
numaralandırılmış. İşte `nl` aracını kullanarak satırları
numaralandırmak bu kadar kolay.

`nl` komutunun da tıpkı diğer pek çok araç gibi elbette birden fazla ek
seçeneği bulunuyor. Eğer `nl —help` komutunu kullanırsak, seçenekleri
görebiliriz. Ancak açıkçası ben bu kadar seçenekle şu an ilgilenmiyorum.
İleride gerekirse tekrar dönüp bakabilirim, yardım sayfaları bunun için
var.

Ayrıca ben `nl` aracından özellikle bahsettim fakat aslında benim
ihtiyacımı `cat` komutunun "`n`" seçeneği de yeterince iyi görüyor.
Örneğin aynı dosyayı `cat -n` seçeneği ile de numaralandırabilirim.

``` {.scss}
┌──(taylan@linuxdersleri)-[~]
└─$ cat -n liste
     1  Ahmet Yılmaz                                             
     2  Ayşe Demir                                               
     3  Cemal Özkan                                              
     4  Mustafa Öztürk                                           
     5  Fatma Kaya                                               
     6  Ali Can                                                  
     7  Zeynep Aksoy                                             
     8  Hasan Şahin                                              
     9  Ahmet Şen                                                
    10  Emine Akgün                                              
    11  Mustafa Aydın                                                    
    12  Hatice Türkmen                                                   
    13  İbrahim Karaca                                                   
    14  Esra Özdemir                                                               
    15  Melek Akyüz                                                                
    16  Murat Çelik                                                                
    17  Seda Kaya                                                                        
    18  Cemal Özkan                                                                      
    19  Hatice Yıldız                                                                           
    20  Ahmet Şen                                                                               
    21  Leyla Koçak                                                                             
    22  Mustafa Yılmaz                                                                          
    23  Melek Akyüz                                                                                     
    24  MELEK AKYÜZ                                                                                              
    25  mustafa Yılmaz
```

``` {.scss}
┌──(taylan@linuxdersleri)-[~]                                                                                                           
└─$ cat -n liste harf
     1  Ahmet Yılmaz                                                                                                         
     2  Ayşe Demir                                                                                                           
     3  Cemal Özkan                                                                                                          
     4  Mustafa Öztürk                                                                                                       
     5  Fatma Kaya                                                                                                           
     6  Ali Can                                                                                                                           
     7  Zeynep Aksoy                                                                                                                      
     8  Hasan Şahin                                                                                                                       
     9  Ahmet Şen
    10  Emine Akgün
    11  Mustafa Aydın
    12  Hatice Türkmen
    13  İbrahim Karaca
    14  Esra Özdemir
    15  Melek Akyüz
    16  Murat Çelik
    17  Seda Kaya
    18  Cemal Özkan
    19  Hatice Yıldız
    20  Ahmet Şen
    21  Leyla Koçak
    22  Mustafa Yılmaz
    23  Melek Akyüz
    24  MELEK AKYÜZ
    25  mustafa Yılmaz
    26  a
    27  g
    28  F
    29  z
    30  D
    31  g
    32  O
    33  p
    34  l
    35  k
    36  S
    37  C
    38  E
    39  n
    40  M
    41  h
    42  t
    43  N
```

Peki madem `cat` komutu ile aynı işi yapabiliyoruz neden ek olarak `nl`
komutunu ele aldık?

`nl` komutunu ele aldım, çünkü kullanımı ile sık karşılaşabilirsiniz.
`nl` komutunu sunduğu ek özellikler için özellikle kabuk programlamada
sıklıkla tercih ediliyor. Ben sadece sık kullanıldığı için `nl`
komutundan da haberdar olmanızı istedim. Hangi iş için hangi komutu
kullanacağınız tamamen sizin alışkanlıklarınıza bağlı. Aklınıza ilk `nl`
komutu geliyorsa, bu aracı kullanabilirsiniz. Pek çok farklı aracın
benzer özellikler için farklı seçenek tanımları bulunduğu için aslında
`nl` gibi spesifik olarak tek bir işi yapan aracı bilmek bir avantaj.
Zaten `nl` aracının ismi ana işlevini çağrıştırdığı için hatırlaması çok
kolay. Bu sayede aynı özellik için farklı araçların farklı seçeneklerini
hatırlamak yerine tek bir aracı hatırlayıp o iş için bu aracı
kullanabiliyoruz. Elinizdeki verileri numaralandırmak mı istiyorsunuz,
`nl` aracını kullanabilirsiniz.

`wc` Komutu
-----------

`wc` aracı en temel haliyle kelimeleri saymamızı sağlayan işlevsel bir
araçtır. `wc` komutunun ismi de "**w**ord **c**ount" yani "kelime sayma"
ifadesinin kısaltmasından geliyor. Ben kelime dedim ama yalnızca
kelimeleri değil, karakterleri, satırları ve ayrıca baytları saymak için
de kullanabiliyoruz. Eğer ek bir seçenek olmadan `wc` aracına okuması
gereken dosyayı argüman olarak verirsek, sırasıyla kaç satır, kelime ve
karakter olduğunu ve okunan dosyanın ismini bastırıyor. Ben denemek
isimleri ve soyisimleri içeren dosyam üzerinde kullanıyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc liste
 25  50 333 liste
```

Buradaki ilk sayı dosya içeriğinin kaç satır olduğunu, ortadaki sayı
toplam kaç kelime olduğunu ve son sayı ise toplam kaç karakter olduğunu
bildiriyor.

İstersek bu çıktıların hepsini almak yerine yalnızca ihtiyacımız olan
çıktıları da bastırabiliriz. Örneğin ben yalnızca satırların basılmasını
istersem İngilizce "**l**ines" yani "satırlar" ifadesinin kısaltması
olan "`l`" seçeneğini kullanabilirim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -l liste                                                                                                                           
25 liste
```

Bakın bu kez yalnızca kaç satır olduğunu öğrendik. Bu arada dosya
içeriğinde boş satırlar olduğunda bu satırların da sayıldığını da
farkında olun.

Satır sayısı yerine kelime sayısını öğrenmek için de yine İngilizce
karşılığı "**w**ord" yani "kelime" olan "`w`" seçeneğini
kullanabiliyoruz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -w liste                                                                                                                          
50 liste
```

Bakın bu sefer de yalnızca kelime sayısı bastırıldı.

Yalnızca karakter sayısını öğrenmek istersek, c seçeneğini
kullanabiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -c liste                                                                                                                          
333 liste
```

Bakın yalnızca bayt sayısı da bastırmayı başardık.

Ayrıca tüm seçenekleri tek tek kullanabileceğimiz gibi elbette aynı anda
da kullanabiliriz. Ancak dikkat etmeniz gereken detay, alacağınız
çıktıların komutun en başında bahsettiğimiz standart sıralamasında
olacağıdır. Yani seçenekleri hangi sıralamada vermiş olursak olalım,
aldığımız çıktılar, soldan sağa doğru; satır, kelime, karakter sayısı ve
dosya adı şeklinde olacak. Denemek için ben `wc -wl liste` şeklinde yani
kelimelerin ve satırların hesaplanacağı şekilde komutumu giriyorum.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -wl liste                                                                                                                         
 25  50 liste
```

Şimdi birde seçeneklerin sıralamasını değiştirip tekrar girmeyi
deneyelim.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -lw liste                                                                                                                         
 25  50 liste
```

Bakın iki çıktıdaki sayıların sıralaması da aynı. Yani bizim verdiğimiz
seçenek sıralamasının `wc` komutu için bir önemi yok. Her koşulda,
çıktılar kendi standartlarında, varsa satır daha sonra kelime sayısı ve
son olarak karakter sayısını verecek şekilde oluyor oluyor.

Bu çıktı sıralamasını aklınızda tutamıyorsanız sorun yok. Çünkü `man wc`
komutunu kullanıp, komut açıklamasındaki sıralama tanımına
bakabilirsiniz. Ayrıca ben şimdiye kadar hep karakter uzunluğu dedim ama
aslında kast ettiğim karakterlerin bayt uzunluğuydu. Zaten manual
sayfalarında da bu sebeple "byte" şeklinde yazıyor. İyi ki yardım
sayfaları var, haksız mıyım ?

Ayrıca ben şimdiye kadar hep tekil dosyalar üzerinden örnek verim fakat
istersek birden fazla dosya ismi de belirtebiliriz.

``` {.ruby}
┌──(taylan@linuxdersleri)-[~]
└─$ wc -lw liste harf                                                                                                                     
 25  50 liste
 17  18 harf
 42  68 total
```

Bakın ayrı ayrı ve toplam şekilde tüm sonuçlar konsola bastırıldı. Bu
şekilde ister tek isterseniz de birden fazla dosyanın istatistiklerini
kontrol edebilirsiniz.

Ben şimdi daha fazla araçtan bahsetmeden önce pipe yapısından bahsedip,
araçlar arasında nasıl veri yönlendirmesi yapabileceğimizi ele almak
istiyorum.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 15. Ders 111 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Söz konusu Linux sistem yönetimi olduğunda en önemli konuların başında
paket yönetimi geliyor. Paket yönetimi dediğimiz yapı, sisteme yeni
yazılımların yüklenmesi ve gerektiğinde var olanların güncellenmesi,
yeniden konfigüre edilmesi veya silinmesi gibi işlemlere olanak tanır.
Kullanmakta olduğumuz Linux dağıtımına bir yazılım yüklemek
istediğimizde en kolay yöntem paket yönetim aracını kullanmaktır. Çünkü
yazılımlar ilgili dağıtıma kolayca kurulup yönetilebilsin diye
geliştiriciler tarafından yazılımın tüm dosyaları tek bir paket olarak
bize sunuluyor. Bizler de bu paketler üzerinden ilgili yazılımları
kolayca kurup yönetebiliyoruz. Burada bahsi geçen paket yönetimi kavramı
üzerinde ayrıca duracağız zaten. Eğer hatırlıyorsanız eğitimin başında
dağıtımlardan bahsederken, dağıtımların genel olarak birbirlerinden
ayrıştığı noktanın başta paket yönetim araçları olmak üzere dağıtımlarda
varsayılan olarak yüklü bulunan araçlar olduğuna değinmiştik. Çeşitli
araçların mevcut dağıtımda sorunsuzca çalıştırılabilir güvenli
paketlerini sunmak, dağıtımların en temel sorumluluklarının başında
geliyor. Çünkü bizler sistemi yönetirken aslında sisteme yüklediğimiz
araçları kullanıyoruz. Eğer aradığımız araçların güncel güvenilir ve
stabil sürümlerine kolay erişemiyorsak ilgili dağıtımı kullanmak için
bir sebep kalmıyor. Her bir kullanıcının bireysel olarak paket yönetimi
ile boğuşması verimlilik açısından kesinlikle sürdürülebilir ve mantıklı
değildir. Özellikle işletmeler güvenli ve güncel paket depolarına sahip
olmayan dağıtımları kullanmayı kesinlikle istemezler. Neticede paket
yönetimi oldukça kritik öneme sahip bir konu. Şimdi kısaca paket
yönetimi fikrinin nereden çıktığı ve temelde ne olduğuna değinelim.

Linux üzerinde araçların kurulumu, güncellenmesi ve silinmesi gibi tüm
işlemleri paket yöneticileri üzerinde kolayca gerçekleştirebiliyoruz.
Ancak bu her zaman böyle değildi.

Paket yönetimi yaklaşımı geliştirilmeden önce yazılımların
yüklenebilmesi için kaynak koddan derlenerek kurulmaları gerekiyordu.
Peki kaynak koddan kurulum ne denemek ?

Geliştiriciler yazmış oldukları yazılımların kaynak kodlarını ve elbette
bu kaynak kodlarının sisteme kurulmasını sağlayacak olan bazı
konfigürasyon betiklerini, kurulum dokümanlarını kullanıcılar ile
paylaşıyorlar. Sistemine bu yazılımı kurmak isteyen kişiler de kurulum
dokümanlarının da yardımıyla ilgili yazılımın nasıl kurulacağı ve bu
yazılımın kurulması için gerekli olan başka yazılımlar olup olmadığını
öğreniyorlar. Kurulum işlemi genellikle kaynak kodlarının
çalıştırılabilir ikili dosyalara dönüştürülmesi için geliştiricinin
sunduğu konfigürasyon betiğinin çalıştırılması ve daha sonra bu
dosyaların, sistemin uygun dizinlerine konumlandırılması işlemidir. Bir
yazılımın kaynak koddan ikili dosyalara dönüştürülme ve daha sonra doğru
şekilde çalışabilmesi için farklı yazılımlara da ihtiyacı olabilir. Bu
durumda ilgili yazılımların da aynı şekilde kaynak koddan derlenerek
kurulmaları gerekiyor. Elbette bu yazılımların da bağımlılıkları
olabileceği için onların da kurulması gerekiyor. Biraz kompleks bir
aracı bu şekilde kurmayı denediğinizi düşünsenize? Eğer çok fazla
bağımlılığı yani çalışması için gereken ek yazılım varsa bunları teker
teker kaynak koddan kurmak kesinlikle bir kabus olacaktır.

Eğer daha önce kaynak koddan kurulum yapmadıysanız yeni başlayan
kullanıcılar için pek de kullanışlı olmadığını ileride kaynak koddan
kurulumu ele alırken sizler de bizzat görmüş olacaksınız.

Elbette bu durum geliştiriciler tarafından fark edilmiş ve kaynak koddan
derleme yerine herkes için işleri kolaylaştırmak adına paket yaklaşımı
geliştirilmiştir.

Paket dediğimiz yapı, ilgili aracın kurulacağı sisteme tam olarak uyumlu
şekilde önceden hazırlanmış dosyalarının paket haline getirilip
kullanıcılara sunulmasıdır. Bu paket içinde aracın çalıştırılabilir
dosyaları, kütüphane dosyaları veya dokümantasyon dosyaları gibi ilgili
aracın tüm dosyaları önceden derlenmiş yani hazırlanmış şekilde geliyor.
Dolayısıyla bizlerin kaynak koddan derlemeyle uğraşmamız gerekmiyor.
Derlenmiş yani çalıştırılabilir hale getirilmiş dosyalar zaten paketin
içinde bulunuyor. Tek yapmamız gereken bu paketi temin edip, paketi
kurabilecek aracı kullanmaktır. Paketlerin herkes tarafından güvenli
şekilde temin edilebilmesi için de bu paketler sunucular üzerinden
herkesin erişimine açık şekilde paylaşılıyor. Geliştiricilerin kendi
yazılım paketlerini sunduğu kendilerine ait sunucuları olmakla birlikte
bir de dağıtımların çeşitli paketleri bir araya toparlayıp tek bir
sunucu üzerinden sunduğu "repository" yani "repo" yaklaşımı da
bulunuyor. Zaten buradaki "repository" ifadesi "depo" ya da "ambar"
anlamına geliyor ve kısaca "repo" olarak ifade ediliyor. Bir çok farklı
paket tek bir sunucuda tutulduğu için bu sunucu depo görevi görüyor buna
da İngilizce olarak repo deniyor. Örneğin ben Kali dağıtımını
kullandığım için kali'nin resmi repo adresi üzerinden Kali tarafından
denetlenip sunucuya eklenmiş olan stabil yazılım paketlerine kolayca
ulaşıp bunları indirebilirim. Zaten bir aracın kurulabilmesi için
gereken ek bağımlılıklar dağıtım geliştiricileri tarafından bilindiği
için bu bağımlılıkların paketleri de mutlaka repoda bulunuyor. Yani bir
yazılımın kurulması için gereken tüm ek bileşenler de repolar üzerinde
paketler halinde kullanıcılara sunuluyor. Dağıtımların en önemli
sorumluluklarından biri de kullanıcılarına yazılımların tüm
bağımlılıklarıyla birlikte güvenilir ve güncel paketlerin bulunduğu bir
repo sunmaktır. Bu sayede bizler ekstra çaba sarf etmeden istediğimiz
yazılımı mevcut sistemimize güvenli şekilde kurabiliyoruz.

Yani uzun lafın kısası, Linux'a yeni bir program yüklemek ilk günlerine
oranla şimdilerde inanılmaz derecede kolay.

Repodaki paketlerin mevcut sisteme kurulması ve daha sonra bu paketlerin
silinmesi veya güncellenmesi gibi yönetimsel işlemlerin yapılabilmesi
için de "paket yöneticileri" vardır. Paket yöneticisi sayesinde ilgili
paketi sistemimize kurup yönetebiliyoruz.

Ana dağıtımlar birbirinden farklı paket sistemleri kullandığı için
kullanılan dağıtıma göre paketlerin kurulumu ve yönetimi için kullanılan
farklı türde çeşitli araçlar bulunuyor. Örneğin **Debian** tabanlı
dağıtımlar **apt** ve **dpkg** araçlarını kullanırken, **Red Hat**
tabanlı dağıtımlar, **yum** ve **rpm** araçları kullanılır. Elbette
diğer ana dağıtımlarda da kendilerine özgü paket yöneticileri bulunuyor.
Çünkü yazılımlar ilgili dağıtımda çalışmaya uygun şekilde derlenip
paketlendiği için, bu paketleri açmak için de uygun paket
yöneticilerinin kullanılması gerekiyor. Örneğin **Debian** tabanlı
dağıtımlarda kullanılacak olan paketler "***.deb***" uzantılı ile
sunulurken, **Red Hat** tabanlı dağıtımların paketleri "***.rpm***"
uzantılıdır. Benzeri şekilde pek çok ana dağıtımın paket yapısı ve paket
yönetim aracı da doğal olarak farklı oluyor.

Ancak ben anlatım sırasında özellikle söz konusu sunucu yönetimi
olduğunda en çok karşılaştığımız dağıtımlar gereği Debian ve Red Hat
için geçerli olan paket yöneticilerinden bahsediyor olacağım. Yine de
merak etmeyin, temelde tüm paket yöneticilerinin çalışma şekilleri
birbirine benzediği için tek yapmanız gereken kullandığınız paket
yöneticisine özgü olan komutları öğrenmek.

Biz öncelikle Debian tabanlı dağıtımlar için geçerli olan paket
yönetiminden bahsederek başlayalım.

Debian Tabanlı Sistemlerde Paket Yönetimi
-----------------------------------------

Debian dağıtımları için özel olarak hazırlanmış olan paketlerin
"***.deb***" uzantısı ile dağıtıldığından bahsettik. Debian tabanlı bir
sisteme "***.deb***" uzantılı paketi kurmak için tek yapmamız gereken bu
paketi işleyebilen `dpkg` aracını kullanmaktır.

`dpkg`
------

`dpkg` aracı Debian'a özel olan "***.deb***" paketlerinin kurulması,
konfigüre edilmesi, ve silinmesi gibi temel paket yönetiminden sorumlu
araçtır. "**dpkg**" kısaltması "**D**ebian **p**ac**k**a**g**e" yani
"Debian paketi" ifadesinden geliyor.

`apt`
-----

Bir de `apt` isimli bir araç mevcut. `apt` aracının ismi de,
"**a**dvanced **p**ackage **t**ool" yani "gelişmiş paket aracı"
ifadesinin kısaltmasından geliyor. Bu araç `dpkg` aracına oranla,
kullanıcının işlerini daha da kolaylaştırmak üzere geliştirilmiştir.
`apt` aracı paketlerin uzak sunucundan bağımlılıkları ile birlikte
indirip kurulmasını sağlıyor. Ve diğer paket yönetim işlerini de bu araç
üzerinden gerçekleştirebiliyoruz. `apt` aracı aslında kurulum ve
kaldırma gibi paket yönetimi işleri için arka planda `dpkg` aracını
kullanıyor. `apt` aracının avantajı, kurmak istediğimiz aracın paketini
**repo** üzerinden otomatik bulması ve bu aracın ihtiyaç duyduğu diğer
ek paketleri yani bağımlılıklarını da çözümleyip bunları da bulup
kurmasıdır. Bu sayede biz bağlandığımız uzak sunucu depolarında olduğu
sürece istediğimiz aracı kolayca kurabiliyoruz. Zaten repolar da bir
aracın kurulması için gereken tüm bağımlılıkları içerecek şekilde
düzenlendiği için `apt` aracı bütüncül olarak bizlere oldukça kolay bir
paket yönetim imkanı sunuyor.

Normalde `dpkg` aracını kullanarak yalnızca indirmiş olduğumuz yani
lokal olarak bilgisayarımızda mevcut olan tek bir paketi kurabiliyoruz.
Bu paketin, daha doğrusu kurduğumuz aracın çalışması için gereken harici
paketler `dpkg` tarafından bulunup indirilmiyor. Bunu yapan `apt`
aracıdır. Bizler `dpkg` aracını lokal paket yönetimi için kullanıyoruz.
Yani bu durumda `dpkg` aracını kullanarak kurulum yapacaksak kurduğumuz
paketin ihtiyaç duyduğu ek paketleri de tek tek bulup indirmemiz ve
onları da `dpkg` aracını kullanarak kurmamız gerekiyor. Bahsetmiş
olduğum bu durumu pratik yaparken yani uygulamalar üzerinden çok daha
net görmüş olacağız zaten. Her ne kadar `apt` aracı daha kullanışlı olsa
da öncelikle `dpkg` aracından bahsedip bu aracın temel kullanımını da
öğrenmemiz gerekiyor.

`dpkg` Kullanımı
----------------

`dpkg` aracının kullanımını örneklemek için öncelikle kurmak istediğimiz
bir yazılımın Debian için uygun paketini edinmemiz gerekiyor. Eğer
kurmak istediğimiz araç, Debian dağıtımlarında kullanıma uygun olarak
geliştirildiyse zaten geliştiricisi tarafından mutlaka websitesindeki
indirme seçeneklerin ***.deb*** uzantılı paket dosyası sunulmuştur. Ben
örnek olarak "zoom" aracını kurmak istiyorum.

Aracın Linux için indirme kaynağını kısa bir internet araştırması ile
bulabilirsiniz.

![zoom-for-linux.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/zoom-for-linux.webp)

Bakın indirmeden önce hangi Linux dağıtımını kullandığımı seçmem gereken
bir listeyle karşılaştım. Özellikle farklı ana dağıtımlar farklı paket
yönetim sistemi kullandıkları için buradan kullanmakta olduğunuz
dağıtıma uygun olan paketi seçmeniz önemli. Görebildiğiniz gibi buradaki
seçeneklerde doğrudan Ubuntu, Mint gibi Debian tabanlı olan dağıtımlar
da var ancak Kali, Debian tabanlı olduğu için doğrudan Debian dağıtımını
seçmem daha doğru olacaktır. İndirme butonuna basarak da Debian
dağıtımlarına uygun olan ***.deb*** uzantılı paketi indirebiliriz.

![zoom-for-linux2.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/zoom-for-linux2.webp)

Paket Kurulumu
--------------

Sistemimize uygun paketi temin ettikten sonra ilgili paketi kurmak için
tek yapmamız gereken `dpkg` komutunun "**i**nstall" yani "kurma"
anlamına gelen `i` seçeneğinin ardından kurmak istediğimiz paketin
ismini girmek. Paket indirilenler konumunda olduğu için öncelikle bu
konuma geçiş yapalım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cd ~/Downloads/                                                                                                                                         

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls                                                                                                                                                      
zoom_amd64.deb
```

Şimdi kurulum yapmak üzere `sudo dpkg -i paketin-adı` şeklinde
komutumuzu girebiliriz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg -i zoom_amd64.deb 
[sudo] password for taylan:
```

Kurma işlemi yetki gerektirdiği için komutumuzun başına `sudo` ekledik.
Bu doğrultuda bizden mevcut hesabımızın parolasını girmemiz bekleniyor.
Hesabımızın parolasını girip enter ile kurulumu onaylayalım.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg -i zoom_amd64.deb 
[sudo] password for taylan: 
Selecting previously unselected package zoom.
(Reading database ... 291494 files and directories currently installed.)
Preparing to unpack zoom_amd64.deb ...
Unpacking zoom (5.15.2.4260) ...
dpkg: dependency problems prevent configuration of zoom:
 zoom depends on libgl1-mesa-glx; however:
  Package libgl1-mesa-glx is not installed.
 zoom depends on libegl1-mesa; however:
  Package libegl1-mesa is not installed.
 zoom depends on libxcb-xtest0; however:
  Package libxcb-xtest0 is not installed.
 zoom depends on ibus; however:
  Package ibus is not installed.
 zoom depends on libxcb-cursor0; however:
  Package libxcb-cursor0 is not installed.

dpkg: error processing package zoom (--install):
 dependency problems - leaving unconfigured
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for mailcap (3.70+nmu1) ...
Processing triggers for shared-mime-info (2.1-2) ...
Errors were encountered while processing:
 zoom
```

Bakın paket çıkarılıp kuruldu ancak aracın doğru şekilde çalışması için
gereken ek paketler yani bağımlılıklar olduğu `dpkg` aracı tarafından
bize bildirildi. Çoğu durumda eksik paketler olduğu için mevcut paket
bile kurulmaz aslında. Ama **zoom** paketi eksik de olsa kuruldu. Yani
eksik paketler olmadan çalışmayacak ama sistemde kurulu gözüküyor.
Bizzat emin olmak için `zoom` komutu ile aracı çalıştırmayı
deneyebiliriz.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zoom                                                                                                                                                    
ZoomLauncher started.
Zoom path is: /opt/zoom
cmd line: 
Start subprocess: /opt/zoom/zoom sucessfully,  process pid: 28449 
Can't load/home/taylan/.config/zoomus.conf
/opt/zoom/zoom: error while loading shared libraries: libxcb-xtest.so.0: cannot open shared object file: No such file or directory
Something went wrong while running zoom, exit code is 127.
ZoomLauncher exit.
```

Bakın araç yüklenmiş olmasına rağmen eksik kütüphane dosyaları gibi
bağımlılık sorunları olduğu için çalıştırılamadı. Zaten `dpkg`
çıktılarında da bu eksik paketler açıkça belirtilmişti. `dpkg` aracı
mevcut paketteki aracın ihtiyaç duyduğu ek paketleri bize söyleyebilir
ancak bunları otomatik olarak bulup yükleyemez. Bizim bu çıktılara
bakarak gidip bu paketleri edinip aynı şekilde kurmamız gerekiyor.
Ayrıca elbette bu bağımlılıkları kurarken bu paketlerin de başka
paketlere bağımlılığı olabilir. Gerekirse bunları da bulup kurmamız
gerekiyor. Bu şekilde aracın çalışması için gereken tüm ek paketleri
yani bağımlılıkları tek tek elle kurmamız gerekiyor. Eğer kuracağınız
aracın çok fazla bağımlılığı varsa bu iş gerçekten çok uğraştırıcı
olabilir. Ben örnek olarak basit bir araç seçtiğim için çok fazla
bağımlılığı yok ama bu bile çok uğraştırıcı. Merak etmeyin anlatımın
devamında bağımlılıkları otomatik olarak bulup gerekli paketleri kuran
`apt` aracından zaten bahsedeceğiz. Ancak şimdilik `dpkg` aracı ile
gerektiğinde paketlerimizi nasıl kurabileceğimizi öğrenmemiz gerekiyor.

Paketleri bulmak için Google gibi bir arama motoru üzerinden araştırma
yapabilirsiniz. Ancak yine de en sağlıklısı Debian'ın resmi paket
kaynağı olan [packages.Debian.org](http://packages.debian.org/) adresini
kullanmak. Ben de aldığım hata çıktısına bakarak gerekli olan tüm
bağımlılıkları bu adres üzerinden bulup indireceğim.

![dpkg-download.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/dpkg-download.webp)

Ayrıca kurulacak olan paketlerin de kendi bağımlılıkları olacağı için
bunları da kurmamız gerekecek. Hatta varsa o indirdiğimiz paketlerin
bağımlı olduğu paketleri de indirmemiz gerekiyor. Bağımlılıkları
[packages.Debian.org](https://packages.debian.org/search?keywords=search)
adresi üzerinden görebilirsiniz.

![dpkg-dependency.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/dpkg-dependency.webp)

İşte görebildiğiniz gibi hepsini tek elle indirmek zorundayız ve bu
gerçekten çok verimsiz bir yöntem. Ben tek tek tüm paketlerin kurulumuna
değinmek istemiyorum. Eğer siz ***.deb*** uzantılı bir paketi kurmak
istiyorsanız tek yapmanız gereken burada ele aldığımız şekilde tüm
bağımlıkları için gereken paketleri indirip `dpkg -i paket-adı` komutu
ile tek tek kurmaktır. Lokal paketlerin yani internet bağlantısının
olmadığı durumlarda disk üzerindeki paketlerin kurulumu için `dpkg`
aracını kullanıyoruz. Ancak internet bağlantımız varken `dpkg` aracı ile
kurulum için uğraşmak pek mantıklı değil. Yine de ihtiyaç duyduğumuzda
kullanabilmemiz için `dpkg` aracını da öğrenmemiz gerekiyor. Gelin yüklü
bulunan paketleri nasıl kaldırabileceğimizle devam edelim.

Kurulu Paketin Kaldırılması
---------------------------

Sistemimize kurmuş olduğumuz paketi silmek istersek `dpkg` aracının
"**r**emove" yani "silmek- kaldırmak" ifadesinin kısaltmasından gelen
`r` seçeneğini kullanabiliyoruz. Örneğin ben **zoom** paketini kurduğum
için `sudo dpkg -r zoom` komutu ile kurduğum paketin kaldırılmasını
sağlayabilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg -r zoom
[sudo] password for taylan: 
(Reading database ... 294386 files and directories currently installed.)
Removing zoom (5.15.2.4260) ...
run post uninstall script, action is remove ...
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for shared-mime-info (2.1-2) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for mailcap (3.70+nmu1) ...
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ zoom
Command 'zoom' not found, did you mean:
  command 'zoem' from deb zoem
  command 'xzoom' from deb xzoom
Try: sudo apt install <deb name>
```

Gördüğünüz gibi **zoom** paketi sorunsuzca kaldırıldı. Eğer kaldırdığım
bu paket başka araçların çalışması için gerekli olan bir paket olsaydı
yani herhangi bir aracın bu pakete bağımlılığı olsaydı, bu aracı
kaldırırken hata alacaktım. Örnek olması için ben `apt` aracını silmek
üzere `sudo dpkg -r apt` komutunu giriyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg -r apt                                                                                                                                        
dpkg: dependency problems prevent removal of apt:
 tasksel depends on apt.
 apt-utils depends on apt (= 2.3.14+kali1).
 apt-file depends on apt (>= 1.3~exp1~).

dpkg: error processing package apt (--remove):
 dependency problems - not removing
Errors were encountered while processing:
 apt
```

Bakın bana bu paketin silinemeyeceğini çünkü bu paketi kullanan başka
araçlar olduğunu yani bu pakete başka araçların bağımlılığı olduğu
çıktılarda belirtiliyor. Bu yaklaşım sayesinde, bir paketi kaldırırken
başka araçların bozulması önlenmiş oluyor. Yine de araçların bozulması
pahasına paketi kaldırmak istiyorsanız `—force-all` yani zorlama
seçeneğini kullanarak ilgili paketi kaldırmaya zorlayabilirsiniz.
**Ancak ne yaptığınızın farkında değilseniz bu seçeneği kullanmanızı
kesinlikle ama kesinlikle önermiyorum.** Çünkü araçların
bağımlılıklarını bozup çalışmalarına ve dolaylı olarak da sistemin
işleyişine engel olabilirsiniz.

Kalıntıların Kaldırılması
-------------------------

Ayrıca `dpkg` aracının "remove" seçeneği dışında bir de "purge" seçeneği
bulunuyor. Normalde "**r**emove" yani `r` seçeneğini kullanarak bir
paketi kaldırdığımızda, konfigürasyon dosyaları hariç araçla ilişkili
olan tüm dosyalar silinir. Bu sayede ileride aracı tekrar yüklediğimizde
tekrar konfigüre edilmesi gerekmez çünkü zaten konfigürasyon dosyaları
silinmemiştir. Eğer aracın konfigürasyon dosyaları da dahil olmak üzere
tüm dosyalarının kaldırılmasını istersek "purge" yani "arındırmak"
anlamındaki `P` seçeneğini kullanabiliyoruz. Ben örnek olması için daha
önce `r` seçeneği ile kaldırdığım **zoom** aracının konfigürasyon
dosyalarını da silmek için bu kez `sudo dpkg -P zoom` yazıp onaylıyorum.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg -P zoom
(Reading database ... 291494 files and directories currently installed.)
Purging configuration files for zoom (5.15.2.4260) ...
run post uninstall script, action is purge ...
```

Bakın konfigürasyon dosyalarının silindiğine dair çıktılar da konsola
basıldı. Ben daha önce kaldırdığım `zoom` aracının konfigürasyon
dosyalarını temizlemek için kullandım ancak doğrudan "purge" seçeneği
ile aracın her şeyinin silinmesi de mümkündür. Yani `zoom` aracını
silmeden önce `dpkg -P zoom` komutunu girseydim konfigürasyon dosyaları
da dahil her şey silinmiş olacaktı.

Paket yönetimindeki en temel işlevler olan kurma ve kaldırmadan
bahsettiğimize göre şimdi biraz da bilgi alma seçeneklerinden
bahsedelim.

Paket Hakkında Bilgi Almak
--------------------------

Henüz paketi kurmadan önce paketin içeriği hakkında bilgi almak istersek
"**i**nfo" ifadesinin kısaltmasından gelen büyük `I` karakterini
kullanabiliriz. Ben daha önce indirmiş olduğum **zoom** aracının paket
dosyası hakkında bilgi almak için `dpkg -I paket-adı` şeklinde komutumu
giriyorum.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ dpkg -I zoom_amd64.deb 
 new Debian package, version 2.0.
 size 177915954 bytes: control archive=55064 bytes.
    1293 bytes,    17 lines      control              
  245135 bytes,  2773 lines      md5sums              
     593 bytes,    18 lines   *  postinst             #!/bin/bash
     226 bytes,    11 lines   *  postrm               #!/bin/bash
 Package: zoom
 Version: 5.15.2.4260
 License: see https://www.zoom.us/
 Vendor: Zoom Video Communications, Inc.
 Architecture: amd64
 Maintainer: Zoom Linux Team <https://support.zoom.us>
 Installed-Size: 656507
 Depends: libglib2.0-0, libxcb-keysyms1, libxcb-xinerama0, libdbus-1-3, libxcb-shape0, libxcb-shm0, libxcb-xfixes0, libxcb-randr0, libxcb-image0, libfontconfig1, libgl1-mesa-glx, libegl1-mesa, libxi6, libsm6, libxrender1, libpulse0, libxcomposite1, libxslt1.1, libsqlite3-0, libxcb-xtest0, libxtst6, ibus, libxkbcommon-x11-0, desktop-file-utils, libgbm1, libdrm2, libxcb-cursor0, libxcb-icccm4, libfreetype6 (>= 2.6)
 Section: default
 Priority: optional
 Homepage: https://www.zoom.us
 Description: Zoom Cloud Meetings 
  Zoom brings people together to connect and get more done in a frictionless, secure video environment. Our easy, reliable, and innovative video-first solutions provide video meetings and chat, with additional options for webinars and phone service. 
  .
  Zoom is the leading unified communications platform and helps individuals, schools, healthcare professionals and enterprises stay connected. Visit blog.zoom.us and follow @zoom_us. 
  .
  By installing this app, you agree to our Terms of Service (https://zoom.us/terms) and Privacy Statement (https://zoom.us/privacy).
```

Bakın adlığım çıktıda paketin ismi, sürümü, üreticisi kurulu boyutu ve
bağımlılıkları gibi pek çok bilgiyi görebiliyorum. Ayrıca bu paketin
işleviyle ve amacıyla ilgili açıklamalar da bulunuyor. İşte bu bilgi
alma seçeneğini bir paketin özellikleri hakkında bilgi almak ve paketi
tanımak için kullanabiliyoruz. Zaten bilgi alma seçeneği yani "`I`"
"**i**nfo" ifadesinin kısaltmasından geldiği için kolay akılda kalan bir
seçenek.

Ayrıca tek bir paket yerine istersek sistemde kurulu olan tüm paketler
hakkında da bilgi alabiliriz. Yani mevcut sistemdeki paketleri
listeleyebiliriz.

Paketlerin Listelenmesi
-----------------------

Sistemde yüklü bulunan tüm paketleri listelemek için "**l**ist" yani
"listelemek" ifadesinin kısalmasından gelen `l` seçeneğini kullanıyoruz.
Bakın paketlerin isimleri sürümleri ve açıklamaları tek tek konsolumuza
bastırıldı.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                   Version                              Architecture Description
+++-======================================-====================================-============-==============================================================>
ii  acl                                    2.3.1-1                              amd64        access control list - utilities
ii  adduser                                3.118                                all          add and remove users and groups
ii  adwaita-icon-theme                     41.0-1                               all          default icon theme of GNOME
ii  aircrack-ng                            1:1.6+git20210130.91820bc-2          amd64        wireless WEP/WPA cracking utilities
ii  alsa-topology-conf                     1.2.5.1-2                            all          ALSA topology configuration files
ii  alsa-ucm-conf                          1.2.6.3-1                            all          ALSA Use Case Manager configuration files
ii  amass                                  3.16.0-0kali1                        amd64        In-depth DNS Enumeration and Network Mapping
ii  amass-common                           3.16.0-0kali1                        all          In-depth DNS Enumeration and Network Mapping
ii  amd64-microcode                        3.20191218.1                         amd64        Processor microcode firmware for AMD CPUs
ii  apache2                                2.4.52-1                             amd64        Apache HTTP Server
ii  apache2-bin                            2.4.52-1                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                           2.4.52-1                             all          Apache HTTP Server (common files)
ii  apache2-utils                          2.4.52-1                             amd64        Apache HTTP Server (utility programs for web servers)
ii  apparmor                               3.0.3-6                              amd64        user-space parser utility for AppArmor
ri  apt                                    2.3.14+kali1                         amd64        commandline package manager
ii  apt-file                               3.2.2                                all          search for files within Debian packages (command-line interfac>
ii  apt-utils                              2.3.14+kali1                         amd64        package management related utility programs
ii  arj                                    3.10.22-25                           amd64        archiver for .arj files
ii  arp-scan                               1.9.7-2                              amd64        arp scanning and fingerprinting tool
ii  arping                                 2.22-1                               amd64        sends IP and/or ARP pings (to the MAC address)
ii  aspell                                 0.60.8-4                             amd64        GNU Aspell spell-checker
ii  aspell-en                              2018.04.16-0-1                       all          English dictionary for GNU Aspell
ii  aspnetcore-runtime-3.1                 3.1.14-1                             amd64        
ii  aspnetcore-targeting-pack-3.1          3.1.10-1                             amd64        
ii  at-spi2-core                           2.42.0-2                             amd64        Assistive Technology Service Provider Interface (dbus core)
ii  atftpd                                 0.7.git20210915-3                    amd64        advanced TFTP server
ii  atril                                  1.26.0-1                             amd64        MATE document viewer
ii  atril-common                           1.26.0-1                             all          MATE document viewer (common files)
ii  attr                                   1:2.5.1-1                            amd64        utilities for manipulating filesystem extended attributes
ii  autopsy                                2.24-5                               all          graphical interface to SleuthKit
ii  avahi-daemon                           0.8-5                                amd64        Avahi mDNS/DNS-SD daemon
ii  axel                                   2.17.11-1                            amd64        light command line download accelerator
ii  base-files                             1:2022.1.0                           amd64        Debian base system miscellaneous files
ii  base-passwd                            3.5.52                               amd64        Debian base system master password and group files
ii  base58                                 1.0.3-1.1                            all          base58 encode/decode: command-line interface
ii  bash                                   5.1-6                                amd64        GNU Bourne Again SHell
ii  bash-completion                        1:2.11-5                             all          programmable completion for the bash shell
ii  bind9-dnsutils                         1:9.18.0-2                           amd64        Clients provided with BIND 9
ii  bind9-host                             1:9.18.0-2                           amd64        DNS Lookup Utility
ii  bind9-libs:amd64                       1:9.18.0-2                           amd64        Shared Libraries used by BIND 9
ii  binutils                               2.40-2                               amd64        GNU assembler, linker and binary utilities
ii  binutils-common:amd64                  2.40-2                               amd64        Common files for the GNU assembler, linker and binary utilities
ii  binutils-x86-64-linux-gnu              2.40-2                               amd64        GNU binary utilities, for x86-64-linux-gnu target
ii  binwalk                                2.3.2+dfsg1-1                        all          tool library for analyzing binary blobs and executable code
ii  blt                                    2.5.3+dfsg-4.1                       amd64        graphics extension library for Tcl/Tk - run-time
ii  blueman                                2.2.3-1                              amd64        Graphical bluetooth manager
ii  bluez                                  5.62-2+kali1                         amd64        Bluetooth tools and daemons
```

Çok fazla paket kurulu olduğu için elbette hepsi konsol ekranına
sığmıyor. Dolayısıyla space tuşuna basarak kurulu araçların listesi
üzerinde sayfa sayfa gezinebilirsiniz.

Tüm liste yerine tek bir aracın yüklü olup olmadığını sorgulamak için
`dpkg -l paket-adı` şeklinde de araştırma yapabiliyoruz. Örneğin ben
**apt** paketinin kurulu olup olmadığını araştırmak istiyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ dpkg -l apt
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name           Version      Architecture Description
+++-==============-============-============-=================================
ri  apt            2.3.14+kali1 amd64        commandline package manager
```

Bakın **apt** paketi kuruluymuş. İşte sizler de bu şekilde isterseniz
tüm paketlerin listesini ya da tek bir paketin adını vererek tek bir
paketin bilgisini alabilirsiniz.

Ayrıca bunlar dışında aslında pek çok ek seçenek var fakat diğerlerine
nadiren ihtiyaç duyacağınız için değinmeyi mantıklı bulmuyorum. Eğer
merak ediyorsanız `dpkg` aracının yardım sayfasına göz atıp bizzat
deneyimleyebilirsiniz. Ben son olarak kurulu paketleri nasıl yeniden
konfigüre edebileceğimize de değinerek `dpkg` aracının anlatımını
noktalamak istiyorum.

Kurulu Paketleri Yeniden Yapılandırma
-------------------------------------

Paketler kurulurken ilgili aracın mevcut sistemde sorunsuzca
çalışabilmesi için konfigüre edilmesi sağlanıyor. Bu konfigürasyonlar
çoğu zaman paket kurulurken arka planda bize herhangi bir soru sorumadan
veya konfigürasyona dair çıktı üretmeden gerçekleşiyor. Çok sık
karşılaşmasak da kimi paketleri yüklerken konfigürasyon aşamasında
araçla ilgili bazı ayarları özelleştirmemiz için bize sorular da
sorulabiliyor. Ve neticede yaptığımız seçimlere göre veya otomatik
olarak uygulanan konfigürasyonlara göre ilgili araç mevcut sisteme
adapte ediliyor. Özetle konfigürasyonlar, araçların doğru şekilde
çalışabilmesi için çok önemli.

İşte bizler bir aracı kurduktan sonra konfigürasyonları hatalı veya
eksik uygulandıysa tekrar ilgili aracı baştan kurmadan yalnızca
konfigürasyonların tekrar yapılmasını sağlamak isteyebiliriz.
Konfigürasyonları yeniden yapılandırmak için de `dpkg-reconfigure`
aracını kullanıyoruz. Bu genellikle konfigürasyon dosyaları bozulmuş
veya konfigürasyonu için sorulan sorulara yeniden farklı şekilde yanıt
vermek istediğimizde kullandığımız bir seçenektir.

Bir paketi yeniden konfigüre etmek için `dpkg-reconfigure paketin-adı`
şeklinde komut girmemiz yeterli. Örneğin ben `firefox` aracının
konfigürasyonlarını bozduysam ve aracım açılmıyorsa yeniden konfigüre
etmeyi deneyebilirim. Bunun için `sudo dpkg-reconfigure firefox-esr`
komutunu girmem yeterli.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg-reconfigure firefox-esr
```

Bakın konfigürasyona dair bir çıktı almadım. Tıpkı daha önce söylediğim
gibi pek çok araçta konfigürasyonlar sessizce gerçekleşiyor. Yine de
bizden konfigürasyon için seçim yapmamızın istendiği araçlar da var. Bu
duruma basit bir örnek olarak sistemdeki yerelleştirmeden sorumlu
`locales` aracını ele alabiliriz. Ben `locales` aracını tekrar konfigüre
etmek için `sudo dpkg-reconfigure locales` şeklinde komutumu giriyorum.

![dpkg-reconfigure-locales.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/dpkg-reconfigure-locales.webp)

Bakın etkileşimli konfigürasyon penceresi açıldı ve benden seçim yapmam
isteniyor. Klavyemdeki yön tuşlarını kullanarak istediğimi seçin üzerine
gelip enter ile onaylayabilirim. Örneğin benim sistem dilim İngilizce
ama ben Türkçe yapmak istersem buradan Türkçeyi bulup space ile seçerek
ilgili konfigürasyonların geçerli olmasını sağlayabilirim.

![locales-tr.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/locales-tr.webp)

space ile seçtikten sonra tab tuşuna basıp **Ok** seçeneğinin üzerine
gelip enter ile bu değişimi onaylayabilirim. Daha sonra bana sistem
genelinde hangi dil ayarının geçerli olması gerektiğini soran bir
seçenek getiriliyor. Ben buradan da Türkçe'nin üzerine gelip tab ile
**Ok** seçeneğinin üzerine gelip değişimi onaylıyorum.

![locales-tr-set.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/locales-tr-set.webp)

**ℹ️ Not:** Eğer burada Türkçe seçeneği çıkmazsa mevcut seçeneklerden
birini seçip tekrar bu konfigürasyon menüsüne girmek için
`sudo dpkg-reconfigure locales` şeklinde yazın ve yine Türkçe dilini
bulup seçin. İkinci sefer denediğinizde mutlaka eklediğiniz ek dil
seçeneği gelecektir.

Bu konfigürasyon değişiminin ardından konsolda değişime dair bilgiler
bastırılıp değişim gerçekleştiriliyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ sudo dpkg-reconfigure locales                                                                                                                       
Generating locales (this might take a while)...
  en_US.UTF-8... done
  tr_TR.UTF-8... done
Generation complete.
```

Bu işlemin ardından oturumumu kapatıp tekrar oturum açtığımda, oturum
ekranında Türkçe desteğinin gelmiş olduğunu görebiliyorum.

![locale-change.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/locale-change.webp)

Oturum açtıktan sonra da klasör isimlerinin dile göre güncellenmesi için
seçenek sunulduğunu görebiliyoruz. Yani dil değişimi tamamdır.

![locales-reboot.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/locales-reboot.webp)

Eğer yaptığınız değişikliği geri almak isterseniz de yine
`dpkg-reconfigure locales` komutu ile dil konfigürasyonlarınızı eski
haline getirebilirsiniz. Türkçe dilini seçtiyseniz, yine Türkçeyi bulun
ve üzerine gelip space tuşu ile dil paketini kaldırın ve seçim
menüsünden de İngilizce paketi seçip onaylayın. Ben İngilizce kullanımı
tercih ettiğim için tekrar eski haline çevireceğim. Size de İngilizce
şekilde kullanmanızı tavsiye ederim.

Yani bizzat bu örneğimiz üzerinden teyit ettiğimiz gibi,
`dpkg-reconfigure` sayesinde bize sorulan konfigürasyon ayarlarını
kolayca tamamlayabiliyoruz.

Bu noktada dikkatinizi çekmek istediğim asıl nokta tüm
konfigürasyonların benim verdiğim örnekteki gibi bir arayüz üzerinden
gerçekleşmeyebileceği. Yani yalnızca komut satırından yazılı şekilde
soru cevap biçiminde de konfigürasyonlara onay vermeniz gerekebilir. Bu
konfigürasyon tanımlamaların nasıl düzenleneceği ilgili aracın yapısına
bağlıdır.

Yeniden konfigüre etme işlemine pek ihtiyaç duymasak da ihtiyacımız
olduğunda böyle bir seçeneğin varlığından haberdar olmamız bizim
yararımıza.

Evet bence temel düzeyde `dpkg` aracı için bu kadarlık bilgi yeterli.
Zaten bu seçenekler dışında paketlerin kurulumu veya konfigürasyonu
noktasında problem yaşandığında `dpkg` aracı, hangi komutları
kullanmanız gerektiği konusunda ayrıca yönlendirme yapıyor. Ve bizler
çoğunlukla araçlarımızı çok daha işlevsel olan `apt` aracı üzerinden
yönetiyor olacağız. Gelin anlatımlarımıza `apt` aracı ile devam edelim.

`apt`
-----

`apt` aracı repolarda paket arama ve otomatik bağımlılık çözümleme gibi
özellikleri ile paket yönetimini bizler için oldukça kolay hale getiren
gelişmiş paket yönetim aracıdır. Zaten `apt` ile `dpkg` arasındaki farkı
anlatımın başında kısaca ele almıştık.

Mevcut sisteme kurulabilecek araçları `apt`, tanımlanmış olan repolar
üzerinden çekip alır ve yükler. Yani bizlerin gerekli olan tüm paketleri
tek tek arayıp indirmemiz gerekmez. Dağıtıma uygun olan tüm paketler ve
bağımlılıkları **repo** olarak isimlendirilen paket depolarında tutulur.
Bu sayede paketlerin aranıp bulunması ve yüklenmesi hem güvenli hem de
tutarlı hale gelir. Repo dediğimiz paket deposunu yalnızca uzak sunucuda
bulunan internete açık olan depo olarak da düşünmeyin. Bu depolar
internete açık uzak sunucularda barındırılabileceği gibi lokal depolar
oluşturmak da mümkündür. Yani örneğin internete bağlı olmayan lokal ağda
bir diski "repo" olarak tanımlayıp içine istediğimiz paketleri
yerleştirebiliriz. Bu sayede lokal ağdaki tüm cihazların bu diskte
bulunan paketleri `apt` aracı üzerinden yüklemesi mümkün olur.

Sizlerin de tahmin edebileceği gibi özellikle paketlerin bağımlılıkları
da hesaba katıldığında repoların oluşturulması yani sürekli güncel ve
güvenilir paketlerin kullanıcılar için barındırılması kesinlikle çok
önemli ve meşakkatli bir iştir. Bizler de bu sebeple genellikle
kullandığımız dağıtımın resmi repolarını kullanarak güvenli ve güncel
paketlere ulaşabiliyoruz. Elbette bazı durumlarda internete açık olmayan
ağlarda lokal repolarımızı oluşturmamız veya resmi repolarda bulunmayan
paketleri indirmek için alternatif repoları kullanmamız da
gerekebiliyor. Neticede `apt` aracını kullanacaksak repolar bizler için
olmazsa olmazdır. Repo ifadesi de Türkçe olarak daha önce de
söylediğimiz gibi "depo ambar" gibi anlamlara gelen "repository"
kelimesinden geliyor.

Ben hep `apt` aracı olarak ifade ettim ancak `apt` tek bir komuttan
ibaret değil. `apt` yönetimi için birden fazla yardımcı araç bulunuyor,
örneğin bu araçlardan başlıcaları; `apt-get` `apt-cache` ve `apt-file`
araçlarıdır. Kısaca açıklamamız gerekirse;

`apt-get`: aracını, paketleri indirmek, kurmak, güncellemek ve silmek
için kullanıyoruz.

`apt-cache`: aracını, repolarda paket araştırması yapmak için
kullanıyoruz.

`apt-file`: aracını ise paketlerin içindeki dosyaları aramak için
kullanıyoruz.

Ayrıca sık kullanılan `apt-get` ve `apt-cache` araçlarını tek bir araçta
birleştiren `apt` adlı kullanıcı dostu bir yardımcı araç da bulunuyor.
Yani `apt-get` ve `apt-cache` komutları ile uzun uzadıya komut girmek
yerine yalnızca `apt` komutu ile aynı işlevleri de yerine
getirebiliyoruz.

Ben `apt` aracını çok daha kolay ve kullanışlı bulduğum için sıklıkla
kullanıyorum. Ancak bazı eski sistemlerde `apt` aracıyla
karşılaşmayabilirsiniz. Bu sebeple en azından bahsetmiş olduğum üç temel
yardımcı araçtan haberdar olmanız kesinlikle yararınıza olacaktır.
Ayrıca zaten geçmişten beri çok uzun süredir `apt-get` ve `apt-cache`
araçları kullanıldığı için araştırma yaptığınızda bu komutların yer
aldığı bir çok kaynakla karşılamanız da kaçınılmaz olacak. Yani aktif
olarak kullanmak istemeseniz bile bilmeniz gerekiyor.

Tamamdır **apt** ile ilgili bilmemiz gereken temel kavramlardan
bahsettiğimize göre gelin anlatımlara paket indekslerini güncelleme ile
başlayalım.

Paket Listesinin Güncellenmesi
------------------------------

apt'nin repolar üzerinden paketleri çekip yüklediğinden bahsettik. `apt`
aracının doğru şekilde çalışabilmesi için de kullanılan repoların en
güncel durumundan `apt` aracının haberi olması gerekiyor. Zira hangi
paketlerin en son hangi sürümlerinin repolara eklendiği ve bu paketlere
tam olarak hangi dizinden ulaşabileceğini `apt` aracı bilmezse ilgili
paketleri bulup kuramaz.

Yani repolar sürekli güncellendiği için paketler kurulmadan evvel
paketlerin isimleri ve dizinleri hakkında en güncel repo bilgisinin
alınması gerekiyor. Bu işleme de "index güncelleneme" deniyor. Yani
güncelleme yapıyorum dediğimde aslında repolardaki en son durum hakkında
en yeni bilginin `apt` aracı tarafından öğrenilmesini sağlıyorum. Bir
nevi paket listesinin en güncel halini alıyoruz.

`apt` aracıyla repolardaki paketlerin en güncel index bilgisini almak
için de `sudo apt-get update` komutunu kullanıyoruz. Zaten girdiğimiz
komut son derece açık. İşlemi `sudo` komutu ile yetkili şekilde
yapıyoruz ve `apt-get` aracının `update` yani "güncelleme" yapması
gerektiğini belirtiyoruz aslında.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt-get update
[sudo] password for taylan: 
Get:1 http://kali.download/kali kali-rolling InRelease [41.2 kB]
Get:2 http://kali.download/kali kali-rolling/main amd64 Packages [19.4 MB]
Get:3 http://kali.download/kali kali-rolling/main amd64 Contents (deb) [45.2 MB]               
Fetched 64.7 MB in 33s (1,973 kB/s)                                                            
Reading package lists... Done
```

Bakın burada mevcut dağıtımda varsayılan olarak kullanılan repo
adresleri üzerinden güncel index bilgilerinin alındığını görebiliyoruz.
Burada belirtilen adresler benim kullanmakta olduğum sistemde tanımlı
olan repo adresleridir. Sizde bulunan repo adresleri, kullandığınız
dağıtıma ve sürüme göre değişiklik gösterebilir.

Paket listesi güncellendikten sonra, artık repolar üzerinden yeni
paketleri alıp sorunsuzca kurulmalarını sağlayabileceğiz. Ben burada
`sudo apt-get update` komutunu kullandım ancak bunun yerine yalnızca
`sudo apt update` komutunu da kullanabilirdim.

``` {.perl}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt update
Hit:1 http://kali.download/kali kali-rolling InRelease
Reading package lists... Done   
Building dependency tree... Done
Reading state information... Done
1844 packages can be upgraded. Run 'apt list --upgradable' to see them.
```

Bakın aynı şekilde güncel repo indexleri `apt` komutu ile de alınmış
oldu. Yani `apt update` komutu ile de aynı şekilde güncelleme
yapabiliyoruz. Eğer iki komutun çıktılarının farklı olmasına
takıldıysanız `apt update` komutundan önce `apt-get update` komutu ile
güncelleme yaptığımız için tekrar güncel index bilgisi alınmadı. Kontrol
edildi ama daha yeni güncellendiği için alınacak yeni bir index listesi
bulunamadı. Yani aslında her iki komutta aynı işi yapıyor. Tamam, her
iki komutun da aynı olduğunu kabul ettik. Şimdi bunu bir kenara bırakıp
aldığımız çıktılara göz atacak olursak;

Bakın `apt update` komutunun çıktılarında, güncel index bilgisine
dayanarak sistemde yüklü bulunan bazı paketlerin yükseltilebileceği
hakkında not da bulunuyor. Sistemimizdeki sürümleri ile repolardaki
sürümler uyuşmadığında yani sistemimizdeki sürümler repolardakilerden
eski olduğunda bu şekilde yükseltme yapabileceğimize dair çıktılar
alıyoruz. Yani yalnızca güncelleme yapılmıyor, aynı zamanda olası
yükseltmeler için de bilgilendiriliyoruz. Yükseltme işlemine daha sonra
değineceğiz.

Şimdi, aradığımız paketleri nasıl bulabileceğimizden bahsedelim. Yalnız
unutmayın, araştırmaya geçmeden önce mutlaka repolardaki güncel paket
bilgilerinin alınabilmesi için `apt update` ya da `apt-get update`
komutu ile repolarınızı güncelleyin. Aksi halde aradığınız pek çok araç
repolarda bulunamaz. Yani güncel olmayan bir listede araştırma yapmış
olursunuz.

Paketlerin Araştırılması \| `apt search` \| `apt-cache search`
--------------------------------------------------------------

Bir paketi kurmadan önce ilgili paketin repoda hangi isimde tutulduğunu
öğrenmeniz gerek. Bu öğrenme işini de `apt search` veya
`apt-cache search` komutu ile konsol üzerinden gerçekleştirebilirsiniz.
Ben denemek için "leafpad" isimli bir aracı araştırmak istiyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ apt-cache search leafpad
l3afpad - Simple text editor forked from Leafpad
leafpad - GTK+ based simple text editor
libmousepad-dev - development files for libmousepad
libmousepad0 - mousepad plugins library
mousepad - simple Xfce oriented text editor

┌──(taylan㉿linuxdersleri)-[~]
└─$ apt search leafpad                                                              
Sorting... Done
Full Text Search... Done
l3afpad/kali-rolling 0.8.18.1.11-4 amd64
  Simple text editor forked from Leafpad

leafpad/kali-rolling 0.8.18.1-5 amd64
  GTK+ based simple text editor

libmousepad-dev/kali-rolling 0.6.1-1 amd64
  development files for libmousepad

libmousepad0/kali-rolling 0.6.1-1 amd64 [upgradable from: 0.5.8-1+b1]
  mousepad plugins library

mousepad/kali-rolling 0.6.1-1 amd64 [upgradable from: 0.5.8-1+b1]
  simple Xfce oriented text editor
```

Gördüğünüz gibi her iki komutta "**leafpad**" ismiyle ilişkili olan
paketlerin bilgilerini karşımıza getirildi. Artık paket isminden veya
kısa paket açıklamasından hangi paketi kurmak istediğime karar
verebilirim.

Paketlerin Kurulumu
-------------------

Bir paketi kurmak için `sudo apt-get install` veya `sudo apt install`
komutundan sonra kurmak istediğimiz paketin adını girmemiz yeterli.

APT aracı, kurulacak olan paketin doğru şekilde kurulabilmesi için
gereken tüm ek bağımlılıkları yani ek paketleri de otomatik olarak
yüklediği için tek yapmanız gereken kurulum aşamasında sizden istenen
kurulum onayını vermektir. Ben kuruluma örnek olması için metin editörü
olan `leafpad` aracını kurmak istiyorum. Öncelikle sistemimde `leafpad`
aracının yüklü olmadığını teyit etmek için `leafpad` komutunu
kullanabilirim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ leafpad                                                                         
Command 'leafpad' not found, but can be installed with:
sudo apt install leafpad
Do you want to install it? (N/y)
```

Bakın bu isimde bir komut olmadığı ve eğer istersem aşağıdaki komutlar
ile bu ismin geçtiği paketi yükleyebileceğim belirtilmiş. Buradaki
soruya "**y**" yani **yes** ile olumlu yanıt verirsem
`sudo apt install leafpad` komutu çalışıp bu araç kurulacak. Ben "**n**"
yani **no** ile reddedip komutu kendim elle girmek istiyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt install leafpad
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  evince-gtk
The following NEW packages will be installed:
  leafpad
0 upgraded, 1 newly installed, 0 to remove and 1844 not upgraded.
Need to get 0 B/90.9 kB of archives.
After this operation, 465 kB of additional disk space will be used.
Selecting previously unselected package leafpad.
(Reading database ... 291441 files and directories currently installed.)
Preparing to unpack .../leafpad_0.8.18.1-5_amd64.deb ...
Unpacking leafpad (0.8.18.1-5) ...
Setting up leafpad (0.8.18.1-5) ...
update-alternatives: using /usr/bin/leafpad to provide /usr/bin/gnome-text-editor (gnome-text-editor) in auto mode
Processing triggers for kali-menu (2021.4.2) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for hicolor-icon-theme (0.17-2) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for mailcap (3.70+nmu1) ...
```

Bakın girmiş olduğumuz komut neticesinde gerekli olan kurulum
gerçekleşti. Bu arada eğer istersek `apt install` komutu yerine
`apt-get install` komutunu da girebilirdik. Benim tercihim kısa olandan
yana.

Eğer siz bu kurulum komutundan önce `apt-get update` ya da `apt update`
komutu ile repo indexlerini güncellemediyseniz, muhtemelen **leafpad**
aracının bulunamadığına dair bir hata almışsınızdır. İşte ben de
özellikle bu sebeple sizlere kurulumdan önce mutlaka güncelleme yapmanız
gerektiğini belirtmiştim.

Şimdi `leafpad` komutunu girip kurduğumuz aracın çalışma durumunu
kontrol edelim.

![leafpad.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/leafpad.webp)

Araç sorunsuzca açıldı. İşte `apt` ile, paketlerin kurulumu bu kadar
kolay.

Paketlerin Kaldırılması
-----------------------

Bir aracı kaldırmak için `apt-get remove` ya da `apt remove` komutlarını
kullanabiliyoruz. Ben biraz önce kurmuş olduğum **leafpad** aracını
silmek için `sudo apt remove leafpad` şeklinde komutumu giriyorum.

``` {.kotlin}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt remove leafpad
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  leafpad
0 upgraded, 0 newly installed, 1 to remove and 1844 not upgraded.
After this operation, 465 kB disk space will be freed.
Do you want to continue? [Y/n]
```

Bakın burada silinecek olan paketler belirtiliyor. Şu an yalnızca
"leafpad" paketinin silineceği belirtiliyor.

`remove` komutu ile yalnızca spesifik olarak belirttiğimiz paket veya
birden fazla paket ismini yan yana yazdıysak o paketler siliniyor. Bu
paketlerin bağımlı olduğu ve başka araçlar tarafından kullanılmayan
paketler silinmiyor. Silinmeyen gereksiz paketler de zamanla sistem
kaynaklarını olumsuz etkilemeye başlıyor. Bu sebeple özel bir neden
olmadığı sürece `autoremove` komutu ile bir paketin artık kullanılmayan
bağımlılıklarının da kaldırılmasını sağlamak en mantıklısı. Ben de bu
silme işlemini "**n**" ile iptal ediyorum.

Şimdi komutumu `autoremove` şeklinde tekrar giriyorum.

``` {.kotlin}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt autoremove leafpad
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  leafpad
0 upgraded, 0 newly installed, 1 to remove and 1844 not upgraded.
After this operation, 465 kB disk space will be freed.
Do you want to continue? [Y/n]
```

Başka bir araç tarafından kullanılmayan, "**leafpad**" aracının bağımlı
olduğu bir paket olmadığı için burada ekstra bir paket görmüyoruz. Fakat
sizin sileceğiniz diğer araçlarda harici olarak artık gerekli olmayan
pek çok bağımlılık olabileceği için `autoremove` komutunu kullanmanız
çok daha mantıklıdır. Silmek istiyorsam **y** yazıp onaylamam yeterli.

``` {.rust}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt autoremove leafpad
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  leafpad
0 upgraded, 0 newly installed, 1 to remove and 1844 not upgraded.
After this operation, 465 kB disk space will be freed.
Do you want to continue? [Y/n] y
(Reading database ... 291494 files and directories currently installed.)
Removing leafpad (0.8.18.1-5) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for hicolor-icon-theme (0.17-2) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for mailcap (3.70+nmu1) ...
Processing triggers for kali-menu (2021.4.2) ...
```

Hazır yeri gelmişken belirteyim, eğer bu komutun sonuna `-y` argümanını
eklemiş olsaydım bana sorulmadan leafpad paketi ve leafpad ile ilişkili
artık gerekli olmayan paketler de silinmiş olacaktı.

Yani komutumu `sudo apt remove leafpad -y` şeklinde girip harici olarak
benden onay alınmadan gereksiz tüm paketlerin silinmesini de
sağlayabilirdim.

Neticede `apt` aracı ile kurmuş olduğumuz `leafpad` aracının kaldırma
işlemi de başarıyla sonuçlandı. Hatta `leafpad` komutunu kullanarak
aracın kaldırıldığını bizzat teyit edebiliriz.

``` {.python}
┌──(taylan㉿linuxdersleri)-[~]
└─$ leafpad
bash: /usr/bin/leafpad: No such file or directory
```

Bakın leafpad aracının çalıştırılabilir dosyası "***/usr/bin/leafpad***"
konumundaymış ama silindiği için "böyle bir dosya veya dizin yok"
şeklinde hata aldık. Yani aracımızın kaldırıldığınız bizzat teyit ettik.
Fakat burada dikkatimizi çekene detay, araç kaldırılmış olmasına rağmen
araçla ilgili konfigürasyonların hala duruyor olması. Aksi halde
buradaki bu çıktıyı almamız gerekirdi. Bu durumda araçlardan geriye
kalan tüm konfigürasyonları temizlememiz gerek.

Konfigürasyonların Temizlenmesi
-------------------------------

Tıpkı `dpkg` aracında olduğu gibi `apt` aracı da `remove` ya da
`autoremove` seçenekleri kullanıldığında ilgili aracın konfigürasyon
dosyaları silinmiyor. Konfigürasyon dosyalarının da silinmesi için
`remove` yerine `purge` seçeneğinin kullanılması gerekiyor.

`purge` seçeneğinin kullanımında dikkat etmemiz gereken detay eğer
`apt-get` aracıyla birlikte kullanacaksak
`sudo apt-get autoremove —purge leafpad` şeklinde komut girmemiz
gerektiğidir. Eğer `autoremove` seçeneğini kullanmazsak, yalnızca
**leafpad** paketinin konfigürasyon dosyaları silinir. İlişkili ama
kullanılmayan tüm paketlerin de konfigürasyon dosyalarının silinmesi
için tekrar `autoremove` ifadesini eklememiz gerekiyor. Burada otomatik
olarak tüm gereksiz paketlerin konfigürasyon dosyaları ile birlikte
silinmesi mümkündür. Ayrıca bunun yerine `sudo apt autopurge leafpad`
komutu ile en başında konfigürasyon dosyaları ve kullanılmayan
bağımlılık paketleri de dahil her şeyin silinmesi mümkündür.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt autopurge leafpad
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Package 'leafpad' is not installed, so not removed
0 upgraded, 0 newly installed, 0 to remove and 1844 not upgraded.
```

Bu komutumuzun ardından konfigürasyonların temizlendiğini teyit etmek
için tekrar `leafpad` komutunu girebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ leafpad
Command 'leafpad' not found, but can be installed with:
sudo apt install leafpad
Do you want to install it? (N/y)
```

Bakın tıpkı hiç kurmadan önce olduğu gibi "leafpad" aracının
kurulabileceğine dair çıktı aldık. Yani artık bu aracın
"***/usr/bin/leafpad***" konumunda olduğuna dair eski konfigürasyonlar
silinmiş bulunuyor.

Kaldırma işlemiyle ilgili son bir detaydan bahsetmek istiyorum.

Ben kurduğum aracı, `apt autoremove` komutu ile sildikten sonra
`apt autopurge` seçeneğini kullandım ancak `autopurge` seçeneği tek
başına kullanıldığında paketler de dahil tüm dosyaları silebiliyor. Yani
önce `remove` ya da `autoremove` sonra `autopurge` seçeneğini kullanmak
zorunda değilsiniz. Her şeyi silmek istiyorsanız `apt autopurge`
seçeneğini kullanabilirsiniz.

Ben yalnızca daha önce silmiş olduğunu ama hala konfigürasyonları
dosyaları bulunanları nasıl temizleyeceğinizi göstermek için ayrı ayrı
ele aldım.

Kaldırma işlemini de netleştirdiğimize göre şimdi bir diğer önemli konu
olan paket bağımlılıkların düzeltilmesinden bahsederek devam edelim.

Bozuk Bağımlılıkların Düzeltilmesi
----------------------------------

Bağımlılık kavramını defalarca dile getirdik. Bir aracın çalışması için
çoğunlukla birden fazla ek pakete ihtiyacı vardır. Yani araçların
bağımlılıkları vardır. Ve bu bağımlılıklar hatalı işlemler sonucu
bozulabilir.

Hatalı işlemeler sonucu sistem üzerindeki araçların bağımlılıklarının
olduğu paketleri sildiysek veya zarar verdiysek bu bağımlılık
sorunlarını çözülmesi gerekiyor. `apt` aracı da bu durum için bizlere
"**f**ix" yani "düzeltme" ifadesinin kısalmasından gelen `f` seçeneğini
sunuyor.

Örneğin benim sistemimde vim aracı kurulu. Ve bu aracın çalışabilmesi
için de vim-runtime isimli bir pakete ihtiyacı var, yani vim aracının
bağımlılığı. Dolayısıyla ben `vim` aracıyla birlikte yüklenmiş olan
`vim-runtime` paketini yani `vim` aracının bağımlılığı olan bir paketi
silersem `vim` aracı düzgün çalışmayabilir.

Ben örnek olması için `vim` aracının bağımlılığı olan `vim-runtime`
paketini silmek istiyorum. Normalde bu paketi silmek için `apt` aracın
kullanırsak otomatik olarak `vim` aracının kendisi de silinmek
istenecektir.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt remove vim-runtime 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  kali-linux-default kali-linux-headless vim vim-runtime
0 upgraded, 0 newly installed, 4 to remove and 1842 not upgraded.
After this operation, 41.1 MB disk space will be freed.
Do you want to continue? [Y/n]
```

Bakın "**will be REMOVED**" yani "**silinecek**" başlığı altında vim
aracı da silinecek şekilde işaretlenmiş. Ama ben yalnızca
"**vim-runtime**" paketini silmek istiyorum. Eğer `dpkg` aracını
kullanırsam bakın bu kez de bu paket başka bir paketin bağımlılığı
olduğu için silinmesinin sorun oluşturacağı belirtilerek `dpkg` aracı bu
paketi silmeyi reddediyor.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo dpkg -r vim-runtime
dpkg: dependency problems prevent removal of vim-runtime:
 vim depends on vim-runtime (= 2:9.0.1378-2).

dpkg: error processing package vim-runtime (--remove):
 dependency problems - not removing
Errors were encountered while processing:
 vim-runtime
```

Ancak biz bağımlılık sorunlarının nasıl çözüldüğünü örnekleyebilmek için
zorlama yoluyla bu bağımlılık paketini silebiliriz. Eğer hatırlıyorsanız
`dpkg` aracının `—force-all` seçeneği kullanılarak paketlerin
silinmesine zorlayabileceğimizden çok kısaca bahsetmiştik. Ben şimdi bu
bağımlılık paketini zorla silmek için `dpkg —force-all -r vim-runtime`
şeklinde komutumu giriyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo dpkg --force-all -r vim-runtime
dpkg: vim-runtime: dependency problems, but removing anyway as you requested:
 vim depends on vim-runtime (= 2:9.0.1378-2).

(Reading database ... 291441 files and directories currently installed.)
Removing vim-runtime (2:9.0.1378-2) ...
Removing 'diversion of /usr/share/vim/vim90/doc/help.txt to /usr/share/vim/vim90/doc/help.txt.vim-tiny by vim-runtime'
Removing 'diversion of /usr/share/vim/vim90/doc/tags to /usr/share/vim/vim90/doc/tags.vim-tiny by vim-runtime'
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for kali-menu (2021.4.2) ...
```

Bakın burada yalnızca **vim-runtime** paketinin silinmesi sağlandı.
Tamamdır artık bir bağımlılık sorunumuz var. Ben gözlemlemek için
konsola `vim` komutunu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ vim                                                                                                                                                      
E1187: Failed to source defaults.vim
Press ENTER or type command to continue
```

Bakın `vim` aracı hata verdi. Yine de çıktıda belirtildiği üzere, eğer
enter'a tıklarsam aracım açılacak ancak hangi işlevlerin kaybolduğunu
bilemiyorum.

![vim.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/vim.webp)

**vim-runtime** paketi olmadığı için `vim` aracım eskisi gibi stabil
çalışmayacak. esc tuşuna basıp `:q` komutu ile araçtan çıkıp konsola
dönüyorum. Ben kendim oluşturduğum için tam olarak bağımlılık sorununu
biliyorum. Ancak normalde bizim farkında olmadan bozduğumuz ya da
sildiğimiz paketler olabileceği için en ideal yol `apt` aracının **fix**
seçeneğini kullanmak. Bunun için aşağıdaki her iki komuttan birini
girebiliriz.

``` {.bash}
sudo apt —fix-broken install
```

ya da

Her iki komutta, sistemde yüklü bulunan paketlerin bağımlılıklarını
kontrol edip eksik olanların yüklenmesini sağlayacaktır.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt --fix-broken install                                                                    
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Correcting dependencies... Done
The following additional packages will be installed:
  vim-runtime
The following NEW packages will be installed:
  vim-runtime
0 upgraded, 1 newly installed, 0 to remove and 1844 not upgraded.
Need to get 7,025 kB of archives.
After this operation, 37.3 MB of additional disk space will be used.
Do you want to continue? [Y/n]
```

Tüm sistemdeki paketler ve bağımlılıkları çok kısa sürede tarandı ve
benim biraz önce silmiş olduğum paketin eksik olduğu burada açıkça
belirtiliyor. Ben yüklenmesine "y" ile onay veriyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt --fix-broken install                                                                    
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Correcting dependencies... Done
The following additional packages will be installed:
  vim-runtime
The following NEW packages will be installed:
  vim-runtime
0 upgraded, 1 newly installed, 0 to remove and 1844 not upgraded.
Need to get 7,025 kB of archives.
After this operation, 37.3 MB of additional disk space will be used.
Do you want to continue? [Y/n] y
Get:1 http://kali.download/kali kali-rolling/main amd64 vim-runtime all 2:9.0.1378-2 [7,025 kB]
Fetched 7,025 kB in 12s (580 kB/s)       
Selecting previously unselected package vim-runtime.
(Reading database ... 289384 files and directories currently installed.)
Preparing to unpack .../vim-runtime_2%3a9.0.1378-2_all.deb ...
Adding 'diversion of /usr/share/vim/vim90/doc/help.txt to /usr/share/vim/vim90/doc/help.txt.vim-tiny by vim-runtime'
Adding 'diversion of /usr/share/vim/vim90/doc/tags to /usr/share/vim/vim90/doc/tags.vim-tiny by vim-runtime'
Unpacking vim-runtime (2:9.0.1378-2) ...
Setting up vim-runtime (2:9.0.1378-2) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for kali-menu (2021.4.2) ...
```

Evet gerekli paket de kuruldu. Artık bağımlılık sorunun kalmadığını
teyit etmek için tekrar aynı komutu da girebiliriz.

``` {.lua}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt --fix-broken install
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
0 upgraded, 0 newly installed, 0 to remove and 1844 not upgraded.

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt-get install -f
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
0 upgraded, 0 newly installed, 0 to remove and 1844 not upgraded.
```

Bakın herhangi bir bağımlılık sorunu bulunamadı. Ayrıca `vim` komutunu
da tekrar girebiliriz.

![vim.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/vim.webp)

Gördüğünüz gibi `vim` aracı herhangi bir hata vermeden anında açıldı.
Netice `apt` aracının düzeltme seçeneği sayesinde bağımlılık sorunlarını
çözebileceğimizi de öğrenmiş olduk. Eğer bazı araçları kullanırken hata
alıyorsanız veya araçlar açılmıyorsa öncelikle burada ele aldığımız
şekilde bağımlılık sorunlarının kontrol edilip çözülmesini
deneyebilirsiniz. Ayrıca bağımlılık sorunlarını kontrol etmeden evvel
tabii ki repodaki güncel paket bilgilerini almak için `sudo apt update`
komutunu da girin mutlaka. Özellikle uzun süredir paket kurma veya
güncelleme gibi faaliyetler yapmadıysanız repo listeniz eskide kalmış
olabilir. Bu da bağımlılık sorunlarının bulunamamasına neden olabilir.

Bağımlılık sorunlarının çözümünü de ele aldığımıza göre artık
sistemimizde yüklü bulunan paketleri nasıl yeni sürümlerine
yükseltebileceğimizi ele alalım.

Paketlerin Güncellenmesi
------------------------

Repo index bilgilerinin nasıl güncelleneceğinden ve nasıl araç kurup
kaldırabileceğimizden bahsettik. Şimdi de mevcut araçları nasıl güncel
sürümlerine yükseltebileceğimizi ele alalım. Elbette mevcut paketlerin
sürümlerini yükseltmek için öncelikle repo indexlerinin güncel olması
gerekiyor. Yani yükseltme işleminden önce mutlaka, `sudo apt-get update`
ya da `sudo apt update` komutları ile index bilgilerini güncellememiz
gerekiyor. Zaten bu repo index bilgisini güncelledikten sonra komut
çıktısının sonunda kaç tane aracın yükseltilebilir durumda olduğu da
belirtiliyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt update                                                                                  
[sudo] password for taylan: 
Get:1 http://kali.download/kali kali-rolling InRelease [41.2 kB]
Get:2 http://kali.download/kali kali-rolling/main amd64 Packages [19.4 MB]
Get:3 http://kali.download/kali kali-rolling/main amd64 Contents (deb) [45.3 MB]                    
Get:4 http://kali.download/kali kali-rolling/contrib amd64 Packages [119 kB]                        
Fetched 64.8 MB in 32s (2,013 kB/s)                                                                 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
1844 packages can be upgraded. Run 'apt list --upgradable' to see them.
```

Eğer tüm yükseltilebilir olan paketleri güncel sürümlerine yükseltmek
istiyorsanız `sudo apt-get upgrade` ya da `sudo apt upgrade`
komutlarından birini girmeniz yeterli. Bu sayede sistem üzerinde yüklü
bulunan tüm paketler repolarda bulunan en güncel sürümüne yükseltilir.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt upgrade                                                                                 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Calculating upgrade... Done
The following packages were automatically installed and are no longer required:
  fonts-roboto-slab libatk1.0-data libavfilter7 libavformat58 libev4 libexporter-tiny-perl libflac8
  libfmt8 libgeos3.10.2 libgssdp-1.2-0 libgupnp-1.2-1 libhttp-server-simple-perl libilmbase25
  liblist-moreutils-perl liblist-moreutils-xs-perl libllvm12 liblttng-ust-ctl4 liblttng-ust0
  libmms0 libnginx-mod-http-geoip libnginx-mod-http-image-filter libnginx-mod-http-xslt-filter
  libnginx-mod-mail libnginx-mod-stream libnginx-mod-stream-geoip libofa0 libopenexr25 libperl5.32
  libpostproc55 libsrt1.4-gnutls libswscale5 libwebsockets16 libwireshark15 libwiretap12
  libwmf-0.2-7 libwmf0.2-7 libwsutil13 nginx-core openjdk-11-jre perl-modules-5.32 php8.1-mysql
  python-pastedeploy-tpl python3-commonmark python3-dataclasses-json python3-ipaddr
  python3-jaraco.classes python3-limiter python3-marshmallow-enum python3-mistune
  python3-mypy-extensions python3-responses python3-singledispatch python3-speaklater python3-spyse
  python3-texttable python3-token-bucket python3-toml python3-twisted-bin python3-typing-inspect
  ruby2.7 ruby2.7-dev
Use 'sudo apt autoremove' to remove them.
The following NEW packages will be installed:
  at-spi2-common binutils-mingw-w64-i686 binutils-mingw-w64-x86-64 clang-14 clang-15 coreboot-utils
  coreboot-utils-doc cron-daemon-common docbook-xml firmware-ath9k-htc flashrom fonts-dejavu
  fonts-freefont-ttf fonts-liberation2 fonts-lmodern fonts-texgyre fonts-texgyre-math
  gcc-mingw-w64-base gcc-mingw-w64-i686-win32 gcc-mingw-w64-i686-win32-runtime
  gcc-mingw-w64-x86-64-win32 gcc-mingw-w64-x86-64-win32-runtime gnome-icon-theme gnutls-bin
  inetutils-telnet isympy-common isympy3 kali-system-cli kali-system-core kali-system-gui
  kali-wallpapers-2023 libabsl20220623 libapache2-mod-php8.2 libavcodec59 libavfilter8
postgresql-15 postgresql-client-15 proj-bin python-tinycss2-common python3-aesedb
  python3-argcomplete python3-asttokens python3-asyauth python3-async-generator python3-autocommand
  python3-dsinternals python3-exceptiongroup python3-executing python3-httpcore python3-httpx
  python3-inflect python3-jaraco.context python3-json-pointer python3-markdown-it python3-mdurl
  python3-mistune0 python3-mitmproxy-wireguard python3-multipart python3-oscrypto python3-outcome
  python3-pastedeploy-tpl python3-psycopg python3-pure-eval python3-rfc3986 python3-rfc3987
  python3-stack-data python3-tinycss2 python3-tomli python3-trio python3-trio-websocket
  python3-unicrypto python3-uritemplate python3-webcolors racc redis-server redis-tools ree
  rpm-common rpm2cpio ruby-levenshtein ruby-mini-portile2 ruby-sdbm ruby-webrick ruby3.1
  ruby3.1-dev ruby3.1-doc sane-airscan sgml-base sgml-data tk8.6 tree usrmerge util-linux-extra
  xcvt xml-core xml-twig-tools yelp yelp-xsl zstd
The following packages have been kept back:
  blueman crackmapexec cython3 default-mysql-server faraday gir1.2-freedesktop gir1.2-glib-2.0
  gir1.2-nm-1.0 gobject-introspection kali-desktop-xfce kali-linux-headless libgirepository-1.0-1
  libgs9-common libinput-bin libinput10 libldb2 libnewt0.52 libnm0 libnss-systemd libpam-systemd
  aphviz python3-pymssql python3-pyproj python3-pyqt5 python3-pyqt5.sip
  python3-pyqtgraph python3-pyrsistent python3-redis python3-ruamel.yaml.clib python3-samba
  python3-scipy python3-setproctitle python3-simplejson python3-snappy python3-sqlalchemy
  python3-sqlalchemy-ext python3-tables python3-tables-lib python3-talloc python3-tdb python3-tk
  python3-ubjson python3-ufolib2 python3-ujson python3-urwid python3-uvloop python3-wsaccel
  python3-yaml python3-yara python3-yarl python3-zope.interface qt5-gtk-platformtheme qt5ct
  qtbase5-dev-tools qterminal qtermwidget5-data samba samba-common samba-common-bin
  samba-dsdb-modules samba-libs samba-vfs-modules smbclient systemd systemd-timesyncd whiptail
  winexe wpasupplicant
The following packages will be upgraded:
  acl adduser adwaita-icon-theme aircrack-ng alsa-ucm-conf amass amass-common amd64-microcode
  apache2 apache2-bin apache2-data apache2-utils apparmor apt apt-file apt-utils arj arp-scan
  arping aspell aspell-en at-spi2-core atftpd atril atril-common attr avahi-daemon axel base-files
  base-passwd base58 bash bash-completion bind9-dnsutils bind9-host bind9-libs binwalk bluez
  bluez-firmware bluez-hcidump bluez-obexd bsdextrautils bsdutils bubblewrap bulk-extractor bully
  xfce4-cpugraph-plugin xfce4-datetime-plugin xfce4-diskperf-plugin xfce4-helpers
  xfce4-netload-plugin xfce4-notifyd xfce4-panel xfce4-places-plugin xfce4-power-manager
  xfce4-power-manager-data xfce4-power-manager-plugins xfce4-pulseaudio-plugin xfce4-screenshooter
  xfce4-sensors-plugin xfce4-session xfce4-settings xfce4-systemload-plugin xfce4-taskmanager
  xfce4-timer-plugin xfce4-wavelan-plugin xfce4-whiskermenu-plugin xfce4-xkb-plugin xfconf
  xfdesktop4 xfdesktop4-data xfonts-100dpi xfonts-75dpi xfonts-base xfonts-encodings
  xfonts-scalable xfwm4 xiccd xkb-data xkbset xl2tpd xserver-common xserver-xorg-core
  xserver-xorg-input-libinput xserver-xorg-legacy xserver-xorg-video-amdgpu xserver-xorg-video-ati
  xserver-xorg-video-fbdev xserver-xorg-video-nouveau xserver-xorg-video-radeon
  xserver-xorg-video-vesa xserver-xorg-video-vmware xsltproc xterm xtightvncviewer xvfb xxd
  xz-utils zenity zenity-common zip zlib1g zlib1g-dev zsh zsh-common
1677 upgraded, 241 newly installed, 0 to remove and 167 not upgraded.
Need to get 2,297 MB of archives.
After this operation, 3,571 MB of additional disk space will be used.
Do you want to continue? [Y/n]
```

Bakın burada güncel sürümüne yükseltilebilir olan paketlerin hepsi
belirtilmiş. Üstelik kaç paketin yükseltileceği ve ne kadarlık disk
alanına gerek olacağı gibi detaylar da burada yer alıyor. Eğer "y" ile
onay verecek olursam buradaki tüm yükseltmeler gerçekleştirilecek. Ancak
her zaman tüm paketlerin sürümlerini yükseltmek istemeyebilirsiniz.

### Spesifik Paketleri Güncellemek

Eğer amacınız tüm paketleri değil de spesifik olarak bazı paketleri
güncellemek ise, güncellemek istediğiniz paketi tekrar kurmak üzere
`sudo apt install paket-adı` şeklinde komutunuzu girebilirsiniz. Bu
sayede ilgili aracın en son sürümüne güncelleme yapılacaktır. Zaten
`apt` aracı sistemde aynı isimli paket olduğunu fark edeceği için
yalnızca ilgili paketi üst sürüme yükseltmeyi teklif ediyor.

Ben denemek için daha önce `sudo apt upgrade` komutunun neticesinde
yükseltilebilecek olan paketler içerisinde gördüğüm herhangi bir paketi
güncellemek istiyorum. Örneğin ben çıktılarda **python3-git** isimli
paketin güncellenebileceğini görmüştüm. Bu paketi tek başına güncellemek
için `sudo apt install python3-git` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt install python3-git                                                   
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  python-git-doc
The following packages will be upgraded:
  python3-git
1 upgraded, 0 newly installed, 0 to remove and 1843 not upgraded.
Need to get 135 kB of archives.
After this operation, 20.5 kB of additional disk space will be used.
Get:1 http://kali.download/kali kali-rolling/main amd64 python3-git all 3.1.30-1 [135 kB]
Fetched 135 kB in 11s (12.7 kB/s)
(Reading database ... 291441 files and directories currently installed.)
Preparing to unpack .../python3-git_3.1.30-1_all.deb ...
Unpacking python3-git (3.1.30-1) over (3.1.24-1) ...
Setting up python3-git (3.1.30-1) ...
```

Bakın mevcut sistemde **python3-git** paketi olduğu için yalnızca
güncelleme olduğu belirtildi ve bu güncel paket kuruldu. Bu sayede
spesifik bir paketi `apt install` komutu ile güncelleyebileceğimizi
görmüş olduk.

Burada dikkat etmeniz gereken detay; **`apt`** aracı, mevcut paketin
güncel bir sürümünü indirip kurarak güncelleme yapar. Bu, paketin
yapılandırma dosyalarına dokunmaz veya önceki yapılandırmaları
etkilemez. Bu nedenle, paketin yapılandırması hakkında herhangi bir
değişiklik yapmadan sadece güncel bir sürümünü yüklersiniz.

Bununla birlikte, bazı durumlarda güncellenen bir paketin yeni bir
sürümü, yapılandırma dosyalarını etkileyebilir. Bu durumda, **`apt`**
aracı güncelleme işlemi sırasında size yapılandırma dosyaları hakkında
seçenekler sunabilir. Örneğin, mevcut yapılandırmayı korumak veya
güncellenmiş yapılandırmayı kullanmak gibi seçenekler sunulabilir. Bu
sebeple kurulum işlemi sırasında ve sonrasında size sorulan soruları
doğru şekilde okuyup anladığınızdan ve doğru onayı verdiğinizden emin
olun mutlaka.

### Kapsamlı Güncelleme

Normalde biz `sudo apt upgrade` komutunu kullandığımızda yalnızca
sistemde yüklü bulunan paketler repodaki güncel sürümlerine
yükseltiliyor. Ancak sistemde yüklü bulunan bir paketin bağımlılıkları
arttıysa veya azaldıysa tek başına `upgrade` komutu ile herhangi bir
kurma veya kaldırma işlemi yapılmıyor. `dist-upgrade` seçeneği ile
güncelleme yapılırken aynı zamanda varsa yeni paketlerin kurulması ve
ayrıca artık gerekli olmayan paketlerin de kaldırılması mümkün oluyor.
Bu sebeple genellikle bütüncül bir güncelleme için `sudo apt-get update`
komutunun ardından `sudo apt-get dist-upgrade` komutu da kullanılır.

Ayrıca yalnızca `apt` komutunu kullanırken, `dist-upgrade` değil
`apt full-upgrade` komutunu girmemiz gerekiyor. `dist-upgrade` ve
`full-upgrade` sayesinde güncelleme esnasında bağımlılık sorunlarının da
ilgili paket için otomatik olarak çözülmesi sağlanıyor. Paketleri
güncelleme ile ilgili bilmemiz gerekenler bunlar.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt full-upgrade 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Calculating upgrade... Done
The following packages were automatically installed and are no longer required:
  bluez-firmware faraday-client firmware-ath9k-htc firmware-atheros
  firmware-brcm80211 firmware-intel-sound firmware-iwlwifi firmware-libertas
  python3-limiter python3-marshmallow-enum python3-mistune python3-mypy-extensions
  python3-pyproj python3-pyshp python3-responses python3-singledispatch
  python3-speaklater python3-spyse python3-texttable python3-token-bucket
  python3-toml python3-typing-inspect python3.10 python3.10-minimal python3.9
  python3.9-dev python3.9-minimal ruby2.7 ruby2.7-dev
Use 'sudo apt autoremove' to remove them.
The following packages will be REMOVED:
  faraday-angular-frontend libapache2-mod-php8.1 libgs9 libnfsidmap2
  libqtermwidget5-0 libwacom2 mariadb-client-10.5 mariadb-client-core-10.5
  mariadb-server-core-10.5 php8.1 php8.1-cli php8.1-common php8.1-mysql
  php8.1-opcache php8.1-readline python3-mpltoolkits.basemap python3-twisted-bin
  tftp
The following NEW packages will be installed:
  aspnetcore-runtime-6.0 aspnetcore-targeting-pack-6.0 at-spi2-common
  binutils-mingw-w64-i686 binutils-mingw-w64-x86-64 certipy-ad clang-14 clang-15
  coreboot-utils coreboot-utils-doc cron-daemon-common debugedit doc-base
  ruby3.1-dev ruby3.1-doc samba-ad-provision sane-airscan sgml-base sgml-data
  starkiller t1utils tcl tex-common tex-gyre texlive-base texlive-binaries
  texlive-fonts-recommended texlive-latex-base texlive-latex-extra
  texlive-latex-recommended texlive-pictures texlive-plain-generic tftp-hpa tipa
  tk tk8.6 tree usrmerge util-linux-extra xcvt xml-core xml-twig-tools yelp
  yelp-xsl zstd
The following packages have been kept back:
  kali-desktop-xfce
The following packages will be upgraded:
  acl adduser adwaita-icon-theme aircrack-ng alsa-ucm-conf amass amass-common
  amd64-microcode apache2 apache2-bin apache2-data apache2-utils apparmor apt
  apt-file apt-utils arj arp-scan arping aspell aspell-en at-spi2-core atftpd
  atril atril-common attr avahi-daemon axel base-files base-passwd base58 bash
  bash-completion bind9-dnsutils bind9-host bind9-libs binwalk blueman bluez
  bluez-firmware bluez-hcidump bluez-obexd bsdextrautils bsdutils bubblewrap
  xserver-xorg-core xserver-xorg-input-libinput xserver-xorg-legacy
  xserver-xorg-video-amdgpu xserver-xorg-video-ati xserver-xorg-video-fbdev
  xserver-xorg-video-nouveau xserver-xorg-video-radeon xserver-xorg-video-vesa
  xserver-xorg-video-vmware xsltproc xterm xtightvncviewer xvfb xxd xz-utils
  zenity zenity-common zip zlib1g zlib1g-dev zsh zsh-common
1842 upgraded, 461 newly installed, 18 to remove and 1 not upgraded.
Need to get 2,869 MB of archives.
After this operation, 5,034 MB of additional disk space will be used.
Do you want to continue? [Y/n]
```

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt-get dist-upgrade
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Calculating upgrade... Done
The following packages were automatically installed and are no longer required:
  bluez-firmware faraday-client firmware-ath9k-htc firmware-atheros
  firmware-brcm80211 firmware-intel-sound firmware-iwlwifi firmware-libertas
  python3-limiter python3-marshmallow-enum python3-mistune python3-mypy-extensions
  python3-pyproj python3-pyshp python3-responses python3-singledispatch
  python3-speaklater python3-spyse python3-texttable python3-token-bucket
  python3-toml python3-typing-inspect python3.10 python3.10-minimal python3.9
  python3.9-dev python3.9-minimal ruby2.7 ruby2.7-dev
Use 'sudo apt autoremove' to remove them.
The following packages will be REMOVED:
  faraday-angular-frontend libapache2-mod-php8.1 libgs9 libnfsidmap2
  libqtermwidget5-0 libwacom2 mariadb-client-10.5 mariadb-client-core-10.5
  mariadb-server-core-10.5 php8.1 php8.1-cli php8.1-common php8.1-mysql
  php8.1-opcache php8.1-readline python3-mpltoolkits.basemap python3-twisted-bin
  tftp
The following NEW packages will be installed:
  aspnetcore-runtime-6.0 aspnetcore-targeting-pack-6.0 at-spi2-common
  binutils-mingw-w64-i686 binutils-mingw-w64-x86-64 certipy-ad clang-14 clang-15
  coreboot-utils coreboot-utils-doc cron-daemon-common debugedit doc-base
  ruby3.1-dev ruby3.1-doc samba-ad-provision sane-airscan sgml-base sgml-data
  starkiller t1utils tcl tex-common tex-gyre texlive-base texlive-binaries
  texlive-fonts-recommended texlive-latex-base texlive-latex-extra
  texlive-latex-recommended texlive-pictures texlive-plain-generic tftp-hpa tipa
  tk tk8.6 tree usrmerge util-linux-extra xcvt xml-core xml-twig-tools yelp
  yelp-xsl zstd
The following packages have been kept back:
  kali-desktop-xfce
The following packages will be upgraded:
  acl adduser adwaita-icon-theme aircrack-ng alsa-ucm-conf amass amass-common
  amd64-microcode apache2 apache2-bin apache2-data apache2-utils apparmor apt
  apt-file apt-utils arj arp-scan arping aspell aspell-en at-spi2-core atftpd
  atril atril-common attr avahi-daemon axel base-files base-passwd base58 bash
  bash-completion bind9-dnsutils bind9-host bind9-libs binwalk blueman bluez
  bluez-firmware bluez-hcidump bluez-obexd bsdextrautils bsdutils bubblewrap
  xserver-xorg-core xserver-xorg-input-libinput xserver-xorg-legacy
  xserver-xorg-video-amdgpu xserver-xorg-video-ati xserver-xorg-video-fbdev
  xserver-xorg-video-nouveau xserver-xorg-video-radeon xserver-xorg-video-vesa
  xserver-xorg-video-vmware xsltproc xterm xtightvncviewer xvfb xxd xz-utils
  zenity zenity-common zip zlib1g zlib1g-dev zsh zsh-common
1842 upgraded, 461 newly installed, 18 to remove and 1 not upgraded.
Need to get 2,869 MB of archives.
After this operation, 5,034 MB of additional disk space will be used.
Do you want to continue? [Y/n]
```

Bu çıktılar ile daha önce girmiş olduğumuz `apt upgrade` veya
`apt-get upgrade` komutlarının çıktılarını kıyaslayacak olursanız,
`dist-upgrade` veya `full-upgrade` komutlarının daha fazla güncelleme
istediğini kendiniz de görebilirsiniz.

**ℹ️ Not:** Dağıtım geliştiricileri aksini belirten bir konfigürasyon
eklemediği sürece, işletim sisteminin bir üst sürüme yükseltilmesi de
`dist-upgrade` veya `full-upgrade` komutları sayesinde
gerçekleştiriliyor. Yine de tabii ki sürüm yükseltme için öncelikli
olarak ilgili dağıtımın size sunduğu yükseltme rehberini kullanmanız en
doğrusu. Çünkü gerçekleştirilmesi gereken ek konfigürasyonlar ve
atılması gereken farklı adımlar olabilir.

Gereksiz Paketlerin Silinmesi
-----------------------------

Neticede sorunsuzca istediğimiz paketleri yüklemeyi, yükseltmeyi ve
silmeyi öğrendik. Bu harika ancak, indirilen paketler daha sonra tekrar
kullanılma ihtimaline karşı diskte tutuluyorlar. Yani biz bir aracı
kurmak için komut girdiğimizde o aracın paketi tekrar kullanılmak üzere
diskte tutuluyor. Bu paketler "***/var/cache/apt/archives***" dizini
altında tutuluyor. `ls` komutu ile listeleyerek kayıtlı tüm paket
dosyalarını görebiliyoruz.

``` {.csharp}
┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /var/cache/apt/archives/
leafpad_0.8.18.1-5_amd64.deb  lock  partial
```

Ben yakın zamanda yalnızca **leafpad** aracını kurduğum için bu aracın
paketi var. Ancak daha fazla kurulum gerçekleştirilen bir sistemde bu
paket sayısı çok daha fazla olabiliyor. Bu klasördeki paketleri
silmezsek zaman için yeni araçların kurulumu ve güncellenmesi ile bu
klasörün içeriği diskte gereksiz alan işgaline neden olacaktır. Eğer
internetten izole bir ortamda çalışmanız gerekmeyecekse bu paketleri
lokal olarak bulundurmanız pek mantıklı değil. Bunları silmek için de
yine `apt` aracını kullanabiliriz. Eğer `apt-get clean` ya da
`apt clean` komutlarını kullanırsak bu paketlerin hepsi silinmiş olacak.
Ben diskte kayıtlı paket dosyalarını silmek üzere komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt clean                                                                  

┌──(taylan㉿linuxdersleri)-[~]
└─$ ls /var/cache/apt/archives/                                                
lock  partial
```

Bakın artık dizin gereksiz paketlerden temizlenmiş oldu. Eğer
sisteminizi internetten izole olarak kullanmayacaksanız ve bu paketlere
lokal olarak tekrar erişmeyi gerektirecek özel bir durumla
karşılaşmıyorsanız ara sıra bu paketleri temizlemeniz iyi olur.

***.deb*** Uzantılı Paketleri `apt` ile Kurmak
----------------------------------------------

Hazır lokal paketlerin tekrar `apt` aracı üzerinden kurulabildiğinden
bahsetmişken, ***.deb*** uzantılı paketleri kurmak için doğrudan `dpkg`
aracını kullanmak zorunda olmadığımızı da belirtmek istiyorum. Örneğin
ben anlatımın başında `dpkg` aracı ile **zoom'**un ***.deb*** uzantılı
paketini kurmayı denemiştim ancak bağımlılıklarını tek tek bulup
yüklemekle uğraşmak istemediğim için kurmaktan vazgeçmiştim. Eğer
indirmiş olduğumuz ***.deb*** uzantılı paketi `apt` aracı ile kurarsak,
internet bağlantımız da olduğu için `apt` aracı bu paketin
bağımlılıklarını da otomatik çözümleyip kuracak. Yani lokal olarak
bulunan paketleri dahi `apt` aracı ile kurabiliyoruz. Zaten `apt`
aracının arkaplanda `dpkg` aracını kullandığını ancak `dpkg` aracına ek
olarak bağımlılık gibi sorunları çözerek bizlerin işlerini
kolaylaştırdığını daha önce de söylemiştik hatırlarsanız. Ben şimdi
indirmiş olduğum **zoom** paketini bu kez de `apt` aracı ile kurmayı
denemek istiyorum. Bunun için
`sudo apt-get install ~/Downloads/paket-adı.deb` şeklinde komutumu
girebilirim.

``` {.kotlin}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo apt install ~/Downloads/zoom_amd64.deb 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Note, selecting 'zoom' instead of '/home/taylan/Downloads/zoom_amd64.deb'
The following additional packages will be installed:
  dconf-cli dconf-gsettings-backend dconf-service gir1.2-ibus-1.0 ibus ibus-data
  ibus-gtk ibus-gtk3 ibus-gtk4 im-config libcairo-gobject2
  libcairo-script-interpreter2 libcairo2 libcloudproviders0 libdconf1 libegl1-mesa
  libgl1-mesa-glx libglib2.0-0 libglib2.0-bin libgtk-4-1 libgtk-4-bin
  libgtk-4-common libgtk-4-media-gstreamer libharfbuzz0b libibus-1.0-5 liblerc4
  libtiff6 libwayland-client0 libwayland-egl1 libwebp7 libxcb-cursor0
  libxcb-xtest0 libxfixes3 python3-ibus-1.0
Suggested packages:
  ibus-clutter ibus-doc low-memory-monitor
The following NEW packages will be installed:
  dconf-cli gir1.2-ibus-1.0 ibus ibus-data ibus-gtk ibus-gtk3 ibus-gtk4 im-config
  libcairo-script-interpreter2 libcloudproviders0 libegl1-mesa libgl1-mesa-glx
  libgtk-4-1 libgtk-4-bin libgtk-4-common libgtk-4-media-gstreamer libibus-1.0-5
  liblerc4 libtiff6 libwebp7 libxcb-cursor0 libxcb-xtest0 python3-ibus-1.0 zoom
The following packages will be upgraded:
  dconf-gsettings-backend dconf-service libcairo-gobject2 libcairo2 libdconf1
  libglib2.0-0 libglib2.0-bin libharfbuzz0b libwayland-client0 libwayland-egl1
  libxfixes3
11 upgraded, 24 newly installed, 0 to remove and 1832 not upgraded.
Need to get 23.9 MB/202 MB of archives.
After this operation, 814 MB of additional disk space will be used.
Do you want to continue? [Y/n]
```

Bakın bana bu paketin bağımlı olduğu diğer paketler olduğunu ve bunları
kurmak isteyip istemediğimi soruyor. Eğer "**y**" tuşuna basıp onay
verirsem tek tek tüm gerekli paketler ve daha sonra **zoom** aracı
kurulacak. Zaten daha önce de `apt` aracının lokal veya uzak sunucudaki
paketleri yükleyebildiğinden bahsettiğimiz için aslında bu örnek çok da
şaşırtıcı değil. Aracın bağımlı olduğu paketler repolarda varsa `apt`
aracı ile kurmak son derece kolay. Yine de bu kullanım metoduna da
dikkatinizi çekmek istedim.

Kaynak Listesi
--------------

Repoların ne olduğundan bahsettik, yani artık paketleri repo olarak
isimlendirilen depolar üzerinden edindiğimizi biliyoruz. Daha önce de
bahsettiğimiz gibi söz konusu repo olduğunda da ihtiyaca yönelik çözüm
sunan pek çok farklı repo adresi bulunuyor. Örneğin bireysel olarak
geliştiricilerin paketleri yayınladıkları repolardan, dağıtım
geliştiricilerinin resmi olarak sundukları repolara kadar pek çok farklı
repo adresi bulunuyor. Neticede tek bir repo adresi olmadığı için de APT
aracının doğru paketleri bulabilmesi için, APT aracının ilgili repo
adreslerini biliyor olması lazım. İşte bizler bu repo adreslerini sistem
üzerindeki "**sources.list**" yani "kaynak listesi" dosyasında
belirtiliyoruz. APT aracı bu kaynak listesine bakıp sorgulama yapacağı
repo adreslerini öğreniyor.

Debian tabanlı dağıtımlarda kaynak listesi "***/etc/apt***" dizini
altındaki "***sources.list***" isimli dosyadır. Bu dosyada `apt`
aracının paketleri edinmek için hangi adreslere bakması gerektiğini
belirten bağlantılar vardır. Yani repoların adresi bu
"***sources.list***" dosyası içinde tanımlanmıştır. Hemen `nano` aracı
ile dosyamızı açalım.

``` {.less}
GNU nano 6.0                    /etc/apt/sources.list *                           
# See https://www.kali.org/docs/general-use/kali-linux-sources-list-repositories/
deb http://http.kali.org/kali kali-rolling main contrib non-free

# Additional line for source packages
# deb-src http://http.kali.org/kali kali-rolling main contrib non-free

^G Help       ^O Write Out  ^W Where Is   ^K Cut        ^T Execute    ^C Location
^X Exit       ^R Read File  ^\ Replace    ^U Paste      ^J Justify    ^/ Go To Line
```

Bakın burada repo bağlantıları bulunuyor. Zaten tıpkı Kali'de olduğu
gibi pek çok dağıtımda, dağıtımın resmi repoları varsayılan olarak
kaynak dosyasında eklenmiş şekilde geliyor. Yani spesifik paketleri
yüklemek istemediğimiz sürece bu kaynak dosyasını değiştirmeye pek
ihtiyacımız olmuyor. Elbette bizler ihtiyaç duyduğumuzda kullanabilmemiz
için kaynak listesindeki işleyişten de kısaca bahsedelim.

### Yeni Repo Adresi Eklemek

Tanımlı olan repoları anlamak veya doğru şekilde yeni repo tanımlaması
yapabilmek için kullanmakta olduğunuz dağıtımın repolar ile ilgili olan
yardım sayfalarına göz atarak daha fazla bilgi alabilirsiniz. Zaten her
zaman en güncel ve doğru bilgi için mutlaka kullanmakta olduğunuz
dağıtımın yardım sayfalarını takip etmeniz gerekiyor. Özellikle güncel
repo bilgilerini almak için öncelikle resmi websitesi üzerindeki
kaynaklardan yararlanmalısınız. Çünkü dağıtımların izlediği repo
adresleme biçimi ve kategorizasyon türleri değişiklik gösterebilir. Ben
burada Kali üzerinden genel işleyişe değiniyorum yalnızca. Örneğin
Ubuntu kullanıyorsanız, Ubuntu'nun repolar ile ilgili resmi sayfalarını
okuyarak en güncel bilgiyi ulaşabilirsiniz. Benzer yaklaşımı
kulandığınız herhangi bir dağıtım için de aynen takip edebilirsiniz.

Ben örnek olarak "**kali linux repositroy**" yazıp araştırdığımda,
aşağıdaki gibi resmi yardım sayfasına ulaşabildim.

![kali-repo.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/kali-repo.webp)

Bu rehberde Kali Linux'un resmi reposunun nasıl tanımlanması gerektiği
belirtilmiş.

Örneğin ek bir repo adresi eklemek için aşağıdaki komutu
kullanabileceğim bu rehbede belirtiliyor.

``` {.bash}
echo "deb-src http://http.kali.org/kali kali-rolling main contrib non-free non-free-firmware" | sudo tee -a /etc/apt/sources.list
```

Bu rehberi takip edip gerekli repo adresini ***sources.list*** dosyasına
ekleyip dosyayı kaydetmeniz yeterli. Daha sonra bu repo adresinin
kullanılabilmesi için `sudo apt update` komutu ile paket listesinin
güncellenmesini sağlamanız gerek. Repo adresi güncellendikten sonra
ilgili adresteki paketlere ulaşabiliyor olacaksınız.

Ayrıca örneğin kullandığınız dağıtımın resmi repolarında sizin kurmak
istediğiniz araç bulunmuyorsa, bu aracın sunulduğu repo adresini de
benzer şekilde ilgili aracın dokümanı yardımıyla ***source.list***
dosyasına ekleyip kolayca bu repoyu da kullanabilirsiniz. Tabii ki
güvenliğinden emin olmadığınız herhangi bir repoyu da kesinlikle
eklememelisiniz.

Grafiksel Arayüzde Paket Yönetimi
---------------------------------

Ben komut satırı üzerinden kullandığımız `dpkg` ve `apt` araçlarına
odaklandım ancak elbette paket yüklemek için bunlar ile sınırlı değiliz.
Kullandığınız dağıtımda mutlaka grafiksel arayüzle paket yönetim imkanı
tanıyan araç vardır. Bu konuda birden fazla araç olduğu ve grafiksel
arayüzlü oldukları için özellikle değinmemizi gerektirecek bir yanları
olduğunu düşünmüyorum. Kullanmakta olduğunuz dağıtımı kurcalayıp market
uygulamasını bulabilirsiniz. Ayrıca kısa bir internet araştırması ile de
rahatlıkla grafiksel arayüzlü paket yönetim araçları hakkında bilgi
edinebilirsiniz.

Biliyorum doğrudan anlatmayıp keşfetme işini sizlere bırakmış olmam pek
çok kişinin hoşuna gitmedi ancak grafiksel arayüzler keşfedemeyeceğiniz
zorlukta değil ve ayrıca her zaman size rehberlik edecek birileri
olmayacak. Kendi kendinize keşfedip öğrenme yaklaşımına alışmanız çok
önemli. Hem kendini kendinize öğrendiğiniz bilgiler çok daha kalıcı
olacak. Bu sebeple bahsetmiş olduğum paket yönetimi araçlarını
keşfetmeyi, merakınızın rehberliğinde sizlere bırakıyorum.

Debian tabanlı dağıtımların paket yönetimini temel olarak ele aldığımıza
göre anlatımlara Red Hat tabanlı dağıtımların paket yönetiminden
bahsederek devam edebiliriz.

Red Hat Tabanlı Dağıtımlarda Paket Yönetimi
-------------------------------------------

Debian tabanlı dağıtımlarda kullandığımız `dpkg` ve `apt` araçlarının
Red Hat tabanlı dağıtımlardaki karşılığı sırasıyla `rpm` ve `yum`
araçlarıdır. Debian tabanlı dağıtımlar için hazırlanmış olan paketler
***.deb*** uzantılı iken, Red Hat tabanlı dağıtımlar için hazırlanmış
olan paketler ***.rpm*** uzantılıdır. ***.rpm*** uzantılı paketleri
yönetmek için de `rpm` aracını kullanıyoruz. `rpm` aracı tıpkı `dpkg`
aracı gibi paketlerin lokal olarak yönetilebilmesini sağlıyor. `yum`
aracı ise tıpkı `apt` aracı gibi repolar üzerinden paketlerin ve
bağımlılıkların kolayca yönetilebilmesini sağlıyor. `yum` aracı da
aslında arkaplanda `rpm` aracını kullanarak repolardan paketlerin
bulunması bağımlılıkların otomatik olarak çözümlenmesi gibi pek çok
faydalı işlevi sunan üst seviyeli bir paket yönetim aracıdır. Zaten
Debian üzerinden paket yönetimini ele aldığımız için temel kavramları
biliyorsunuz. Tek fark burada benzer paket yönetimi işlemleri için
farklı komutlar giriyor olmanızdır. Neticede farklı araçları
kullanacağımız için gireceğimiz komutlar da doğal olarak farklı olacak.

Elbette bu araçları kullanabilmek için öncelikle Red Hat tabanlı bir
dağıtıma sahip olmanız gerekiyor. Red Hat tabanlı olduğu sürece
dilediğiniz bir dağıtımı kullanabilirsiniz. Ben Rocky Linux dağıtımını
kullanıyor olacağım ancak sizler isterseniz Fedora, Alma Linux, CentOS
ya da doğrudan Red Hat Linux da kullanabilirsiniz.

Ben Red Hat tabanlı bir dağıtım üzerinden bu dersleri takip ettiğinizi
varsayarak anlatıma devam ediyor olacağım.

RPM
---

`rpm`, Red Hat tabanlı dağıtımlardaki paketleri yönetmek için
geliştirilmiş olan temel bir araçtır. Debian dağıtımlarındaki `dpkg`
aracının Red Hat dağıtımlarındaki karşılığı olduğundan zaten bahsettik.
Şimdi lafı daha fazla uzatmandan paket kurulumlarının nasıl
yapılabileceğiyle başlayabiliriz.

`rpm` ile Paket Kurulumu
------------------------

rpm uzantılı bir paketi kurmak için tek yapmamız gereken `rpm -i`
komutunun ardından kurmak istediğimiz paketin adını girmektir. Buradaki
-`i` seçeneği "**i**nstall" yani "kurmak" ifadesinin kısaltmasından
geliyor.

Ben tıpkı Debian üzerinde uyguladığım gibi "zoom" aracının Red Hat
dağıtımlarına uygun olan "***.rpm***" paketini indirip kurmak istiyorum.
Bunun için öncelikle zoom aracının rpm uzantılı paketini indirmem lazım.
Zaten indirme sayfasını açmıştım. Buradan ben Rocky Linux kullanıyorum
ancak zaten Red Hat tabanlı olduğu için buradan Red Hat seçeneğini
seçebilirim.

![Red
Hat-zoom.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/redhat-zoom.webp)

Şimdi paketi kurmak için konsoldan indirilenler konumuna geçiş yapalım
ve `ls` komutu ile dizin içeriğini listeleyelim.

``` {.ruby}
[taylan@linuxdersleri ~]$ cd ~/Downloads/
[taylan@linuxdersleri Downloads]$ ls
zoom_x86_64.rpm
```

Bakın ***.rpm*** paketi burada bulunuyor.

Kurmak için `rpm -i` komutunun ardından paketin tam ismini girmemiz
yeterli.

``` {.vbnet}
[taylan@linuxdersleri Downloads]$ rpm -i zoom_x86_64.rpm 
warning: zoom_x86_64.rpm: Header V4 RSA/SHA512 Signature, key ID dd79b481: NOKEY
error: Failed dependencies:
ibus-m17n is needed by zoom-5.15.2.4260-1.x86_64
libXss.so.1()(64bit) is needed by zoom-5.15.2.4260-1.x86_64
libxcb-icccm.so.4()(64bit) is needed by zoom-5.15.2.4260-1.x86_64
libxcb-image.so.0()(64bit) is needed by zoom-5.15.2.4260-1.x86_64
libxcb-keysyms.so.1()(64bit) is needed by zoom-5.15.2.4260-1.x86_64
libxcb-render-util.so.0()(64bit) is needed by zoom-5.15.2.4260-1.x86_64
```

Komutu doğru girdim ama tıpkı Debian üzerinde de olduğu şekilde paketin
bağımlılıkları bulunduğu için paketi yükleyemedim. Bu paketi `rpm` aracı
ile yüklemek için buradaki bağımlılık olarak gözüken paketleri ve
elbette varsa bu paketlerin de bağımlı olduğu diğer paketleri indirip
kurmam gerekiyor. Bu paketleri bulmak için yine internet üzerinden
araştırma yapabilirim. Ancak ben bu işle uğraşmak istemiyorum. Bunun
yerine zaten `yum` aracını kullanarak tüm bağımlılıkların çözülerek
paketlerin yüklenmesi mümkün. `yum` aracı da aslında `rpm` aracını
kullanıyor ama bağımlılık sorunları çözme ve paketleri otomatik olarak
bulup indirme gibi işlevler sunduğu için bizler lokal paketler dışında
`rpm` aracını pek kullanmıyoruz. Ben yine de tanımamız ve gerektiğinde
kullanabilmemiz için bahsetmek istedim. Her ne kadar henüz yeni bir
paket kurmamış olsam da kurulu paketlerin nasıl kaldırılacağından da
bahsedelim.

`rpm` ile Paket Kaldırma
------------------------

Sistemde kurulu olan bir paketi kaldırmak için `rpm` komutunun -`e`
seçeneğinden sonra ilgili paketin ismini girmemiz yeterli. Buradaki `e`
seçeneği "**e**rase" yani "silmek" ifadesinin kısaltmasından geliyor.

Ben örnek olması için halihazırda sistemimde yüklü olan `wget` aracını
silmek istiyorum. Bunun için `sudo rpm -e wget` komutunu girebilirim.
Ancak bu komutu bu şekilde girersek herhangi bir çıktı alamayacağız.
Araç silinecek ancak silinme işlemine dair bir çıktı bastırılmayacak.
Eğer işlemler hakkında detaylıca çıktı almak istersek "**v**erbose"
ifadesinin kısaltması olan `v` seçeneğini kullanabiliriz. Eğer bu
seçeneği eklemezseniz araç silinir ancak herhangi bir çıktı olmazsınız.

``` {.ruby}
[taylan@linuxdersleri Downloads]$ sudo rpm -ve wget
Preparing packages...
wget-1.21.1-7.el9.x86_64
```

Bakın kısa da olsa işleme dair bir çıktı aldım, yani `wget` aracı
silindi. Hatta doğrudan `wget` komutunu girerek de teyit edebiliriz.

``` {.bash}
[taylan@linuxdersleri Downloads]$ wget
bash: wget: command not found...
Install package 'wget' to provide command 'wget'? [N/y]
```

Bakın böyle bir komut olmadığına dair hata aldık yani `wget` aracı
silinmiş. Hatta "**y**" ile onay verirsem bu paketin kurulabileceği
belirtiliyor. Ben daha sonra ayrıca kuracağım için "n" ile reddediyorum.

Esasen `rpm` aracının çok fazla ek seçeneği bulunuyor ancak bu kadarlık
temel bilgi bizim için yeterli. Zaten paket yönetiminde `rpm` aracından
ziyade daha fonksiyonel olan `yum` aracını daha sık kullanıyor olacağız.
Şimdi `yum` aracından bahsederek devam edelim.

YUM ve DNF
----------

`yum` aracı tıpkı `apt` aracı gibi paketlerin bulunması, kurulması,
bağımlılıklarının otomatik olarak çözümlenmesi, güncellenmesi,
kaldırılması gibi paket yönetimi işlerini bizler için kolay hale getiren
Red Hat tabanlı dağıtımlarda kullanılan kararlı yapıdaki paket yönetim
aracıdır. Fakat bu aracın daha gelişmiş versiyonu olan `dnf` aracını
öğrenmek daha makul bir yaklaşım olacaktır.

Öncelikle repolardan bir paketin nasıl bulunabileceğinden bahsederek
başlayabiliriz.

`dnf` ile Paketlerin Araştırılması
----------------------------------

Repolardaki paketlerde araştırma yapmak için `dnf search paket-adı`
komutunu kullanabiliyoruz. Ben denemek için `wget` aracını araştırmak
üzere `dnf search wget` şeklinde yazıyorum.

``` {.yaml}
[taylan@linuxdersleri Downloads]$ dnf search wget
Extra Packages for Enterprise Linux 9 - x86_64  826 kB/s |  18 MB     00:22    
Rocky Linux 9 - BaseOS                          117 kB/s | 1.9 MB     00:16    
Rocky Linux 9 - AppStream                       416 kB/s | 7.1 MB     00:17    
Rocky Linux 9 - Extras                          650  B/s |  10 kB     00:15
Last metadata expiration check: 0:21:41 ago on Thu 06 Jul 2023 02:55:55 PM +03.
========================================= Name Exactly Matched: wget ==========================================
wget.x86_64 : A utility for retrieving files using the HTTP or FTP protocols
======================================== Name & Summary Matched: wget =========================================
perl-HTTP-Tinyish-Wget.noarch : HTTP::Tinyish wget backend
```

Bakın repolarda araştırma işleminden önce repo bilgileri güncelleniyor.
Bu sayede en güncel paket bilgileri repolardan alınabiliyor. Bu repo
bilgilerinin güncellenmesi işlemi belirli aralıklarla biz paket yönetim
aracını kullandıkça otomatik olarak gerçekleştiriliyor olacak. Bu sayede
hep en güncel repo index bilgisine sahip olabiliyoruz. Yani `apt`
aracında olduğu gibi bizim özellikle index bilgilerini güncellemek için
harici bir komut girmemiz gerekmiyor. Repo indexleri güncellendikten
sonra gördüğünüz gibi `wget` isminin geçtiği bir paket bulunmuş ve
paketin işlevi de kısaca burada yazıyor. Eğer yüklemek istersem bu
paketin ismini girmem yeterli. `wget` örneğinde paketin ismi kolay
tahmin edilebilirdir ancak her paket için aynı durum geçerli değil. Tüm
paketlerin isimleri benzersiz olmak zorunda olduğu için paketlerin
repolardaki isimleri farklı biçimlerde olabiliyor. Bu sebeple eğer
indirmek istediğiniz paketin tam isminden emin değilseniz `search`
seçeneğini kullanarak repolarda araştırma yapmaktan çekinmeyin lütfen.
Paket ismini nasıl öğrenebileceğimizden de bahsettiğimize göre paketleri
nasıl kurabileceğimizi ele alarak devam edelim.

`dnf` ile Paket Kurulumu
------------------------

Paket kurmak için `dnf install paket-adı` şeklinde komut girebiliyoruz.
Ben denemek için **wget** aracını kurmak üzere `dnf install wget`
komutunu giriyorum.

``` {.markdown}
[taylan@linuxdersleri Downloads]$ sudo dnf install wget
Last metadata expiration check: 0:30:29 ago on Thu 06 Jul 2023 03:05:03 PM +03.
Dependencies resolved.
===============================================================================================================
 Package               Architecture            Version                        Repository                  Size
===============================================================================================================
Installing:
 wget                  x86_64                  1.21.1-7.el9                   appstream                  769 k

Transaction Summary
===============================================================================================================
Install  1 Package

Total download size: 769 k
Installed size: 3.1 M
Is this ok [y/N]: y
```

Bakın kurulacak paketin ismi, paket boyutu ve kurulduğunda kaplayacağı
boyut gibi çeşitli özellikleri burada belirtiliyor. Eğer kurmak
istediğimiz paket buysa "**y**" ile onaylayabiliriz.

``` {.sql}
Downloading Packages:
wget-1.21.1-7.el9.x86_64.rpm                                                   142 kB/s | 769 kB     00:05    
---------------------------------------------------------------------------------------------------------------
Total                                                                           71 kB/s | 769 kB     00:10     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                                                       1/1 
  Installing       : wget-1.21.1-7.el9.x86_64                                                              1/1 
  Running scriptlet: wget-1.21.1-7.el9.x86_64                                                              1/1 
  Verifying        : wget-1.21.1-7.el9.x86_64                                                              1/1 

Installed:
  wget-1.21.1-7.el9.x86_64                                                                                     

Complete!
```

`wget` aracı çok küçük olduğu için hemen kuruluyor. Kurulum işleminin
ardından `wget` komutunu girerek de yüklendiğini teyit edebiliriz.

``` {.vbnet}
[taylan@linuxdersleri Downloads]$ wget
wget: missing URL
Usage: wget [OPTION]... [URL]...

Try `wget --help' for more options.
```

Yükleme işlemi işte bu kadar kolay.

Ayrıca yükleme işlemi sırasında benden onay alınmasını istedim ancak
istemezsem tıpkı daha önce uyguladığım şekilde komutun sonuna `-y`
argümanını eklemem yani `dnf install paket-adı -y` şeklinde girmem
yeterli. Bu sayede gerekli onayı peşinen komutla birlikte vermiş
oluyorum.

Nasıl paket kurabileceğimizi ele aldık, şimdi de mevcut paketleri nasıl
yükseltebileceğimizden bahsedebiliriz.

`dnf` ile Güncelleme
--------------------

Güncelleme yaparken birkaç farklı yaklaşıma sahibiz.

### Güncellemeleri Kontrol Etmek

Sistemde kurulu paketlerin güncellemelerini kontrol etmek için
`dnf check-update` komutunu girebiliyoruz.

``` {.sql}
taylan@linuxdersleri Downloads]$ sudo dnf check-update
[sudo] password for taylan: 
Sorry, try again.
[sudo] password for taylan: 
Last metadata expiration check: 1:07:13 ago on Thu 06 Jul 2023 03:05:03 PM +03.

ModemManager.x86_64                                        1.20.2-1.el9                              baseos    
ModemManager-glib.x86_64                                   1.20.2-1.el9                              baseos    
NetworkManager.x86_64                                      1:1.42.2-3.el9_2                          baseos    
NetworkManager-adsl.x86_64                                 1:1.42.2-3.el9_2                          baseos    
NetworkManager-bluetooth.x86_64                            1:1.42.2-3.el9_2
...
..
.
```

Gördüğünüz gibi güncellenebilir olanlar listelenmiş oldu. Tüm paketleri
kontrol etmek yerine dilersek `check-update` komutundan sonra paket ismi
girip spesifik paket güncellemesini de kontrol edebiliriz.

``` {.sql}
[taylan@linuxdersleri Downloads]$ dnf check-update ModemManager
Last metadata expiration check: 1:18:53 ago on Thu 06 Jul 2023 02:55:55 PM +03.

ModemManager.x86_64                                     1.20.2-1.el9                                     baseos
```

### Güncellemeleri Yüklemek

Eğer yalnızca kontrol etmek yerine güncellemelerin yüklenmesini de
istiyorsak `dnf update` komutunu kullanabiliyoruz.

``` {.markdown}
[taylan@linuxdersleri Downloads]$ sudo dnf update
Last metadata expiration check: 1:12:02 ago on Thu 06 Jul 2023 03:05:03 PM +03.
Dependencies resolved.
===============================================================================================================
 Package                                      Arch      Version                             Repository    Size
===============================================================================================================
Upgrading:
 ModemManager                                 x86_64    1.20.2-1.el9                        baseos       1.2 M
 ModemManager-glib                            x86_64    1.20.2-1.el9                        baseos       334 k
 NetworkManager                               x86_64    1:1.42.2-3.el9_2                    baseos       2.2 M
 python3-file-magic                           noarch    5.39-12.el9                         appstream     16 k

Transaction Summary
===============================================================================================================
Install    6 Packages
Upgrade  510 Packages

Total download size: 784 M
Is this ok [y/N]:
```

Gördüğünüz gibi gerçekleştirilebilecek güncellemeler hakkında bize bilgi
sunuluyor. Eğer "y" ile onaylarsam tüm güncelleme ve kurulum işlemleri
gerçekleştirilecek.

### Spesifik Paketlerin Güncellenmesi

Spesifik olarak tek bir paketi güncellemek istersek
`sudo dnf install paket-adı` komutu ile varsa ilgili aracın
güncelleştirilmesini sağlayabiliriz.

``` {.csharp}
[taylan@linuxdersleri Downloads]$ sudo dnf install ModemManager
Last metadata expiration check: 1:14:29 ago on Thu 06 Jul 2023 03:05:03 PM +03.
Package ModemManager-1.18.2-3.el9.x86_64 is already installed.
Dependencies resolved.
===============================================================================================================
 Package                         Architecture         Version                       Repository            Size
===============================================================================================================
Upgrading:
 ModemManager                    x86_64               1.20.2-1.el9                  baseos               1.2 M
 ModemManager-glib               x86_64               1.20.2-1.el9                  baseos               334 k
 libmbim                         x86_64               1.28.2-2.el9                  baseos               258 k
 libmbim-utils                   x86_64               1.28.2-2.el9                  baseos               106 k
 libqmi                          x86_64               1.32.2-1.el9                  baseos               1.0 M
 libqmi-utils                    x86_64               1.32.2-1.el9                  baseos               231 k

Transaction Summary
===============================================================================================================
Upgrade  6 Packages

Total download size: 3.1 M
Is this ok [y/N]:
```

Eğer onay verirsem spesifik olarak belirtiğim "**ModemManager**" aracı
ve bu aracın bağımlı olduğu paketler güncellenmiş olacak. Gördüğünüz
gibi spesifik olarak güncelleme yapmak için aslında tıpkı aracı yeniden
kurarmışçasına `install` komutunu kullanıyoruz.

`dnf` ile Paketleri Kaldırmak
-----------------------------

Silme işlemi için `dnf remove paket-adı` komutunu kullanıyoruz.

``` {.markdown}
[taylan@linuxdersleri Downloads]$ sudo dnf remove wget
[sudo] password for taylan: 
Dependencies resolved.
===============================================================================================================
 Package               Architecture            Version                       Repository                   Size
===============================================================================================================
Removing:
 wget                  x86_64                  1.21.1-7.el9                  @appstream                  3.1 M

Transaction Summary
===============================================================================================================
Remove  1 Package

Freed space: 3.1 M
Is this ok [y/N]:
```

Eğer "**y**" ile onay verirsem `wget` aracı silinecek. Ben onaylıyorum.

``` {.sql}
Is this ok [y/N]: y
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                                                       1/1 
  Erasing          : wget-1.21.1-7.el9.x86_64                                                              1/1 
  Running scriptlet: wget-1.21.1-7.el9.x86_64                                                              1/1 
  Verifying        : wget-1.21.1-7.el9.x86_64                                                              1/1 

Removed:
  wget-1.21.1-7.el9.x86_64                                                                                     

Complete!
[taylan@linuxdersleri Downloads]$ wget
bash: wget: command not found...
```

Gördüğünüz gibi **wget** aracı silinmiş oldu. Tekrar yüklemek isterseniz
nasıl yapacağınızı biliyorsunuz.

### Gereksiz Paketlerin Silinmesi

Kurulmak üzere indirilen ve artık ihtiyaç duyulamayan paketlerin
silinmesi için `sudo dnf clean all` komutunu kullanabiliyoruz.

``` {.ruby}
[taylan@linuxdersleri Downloads]$ sudo dnf clean all
36 files removed
[taylan@linuxdersleri Downloads]$
```

Burada açıkladıklarım temel yaklaşımlar. Bunlar dışında `dnf` aracının
ihtiyaç duydukça kısa bir araştırma ile öğrenebileceğiniz pek çok ek
seçeneği bulunuyor. Bunları özellikle ele almıyorum çünkü sık
kullanılmadıkları için unutulacaklardır. Gerektiğinde manual sayfaları
ya da internet araştırması ile kısa sürede kendi kendinize
keşfedebilirsiniz. Ben son olarak `dnf` ile `yum` aracı arasındaki farka
kısaca değinmek istiyorum.

`dnf` ile `yum` Arasındaki Fark
-------------------------------

`dnf` aracı `yum` aracının çatallanması ile oluşturulmuş alternatif bir
paket yöneticisidir. Yani `yum` aracından tamamen bağımsız değildir
doğrudan `yum` aracının değiştirilerek yeni bir paket yöneticisi
oluşturulmasıyla ortaya çıkmıştır. Bu nedenle `yum` ile `dnf` aracının
seçenekleri ve parametreleri benzerdir. `dnf` aracını
kullanabiliyorsanız `yum` aracını da rahatlıkla kullanabilirsiniz. `dnf`
aracı çok daha verimli bulunduğu için ben de anlatımlar sırasında
yalnızca `dnf` aracını ele aldım. Fakat siz dilediğiniz paket
yöneticisini kullanabilecek bilgiye artık sahipsiniz. Temel paket
yönetimi için özellikle ele almamız gereken ek bir detay bulunmuyor.

Kaynak Koddan Derleyerek Kurulum
--------------------------------

Şimdiye kadarki anlatımlarımızla, yeni nesil paket kavramından ve paket
yönetiminin temellerinden bahsettik. Paketler, bir aracın ilgili
dağıtıma göre önceden derlenip hazırlanması ve paketlenerek
kullanıcılara sunulmasıdır. Bu sayede kullanıcılar tekrar kaynak koddan
derlemeyle uğraşmadan mevcut sistemlerine uyumlu paketleri indirip
kolayca kurabiliyor. Ancak her zaman mevcut sistem için hazırlanmış olan
paket dosyası bulunmayabiliyor. Bu durumda bizlerin, ilgili aracın
kaynak kodlarını kullanarak aracı mevcut sistemde çalışabilir şekilde
derlememiz gerekiyor. Yani kaynak koddan derlemeye çok sık ihtiyaç
duymuyoruz ancak ihtiyaç duyduğumuzda ne yapmamız gerektiğini bilmemiz
önemli. Zaten kaynak koddan derlenerek kurulan araçlarda, geliştiriciler
dokümanlar ve araçlar ile birlikte gelen metin belgelerinde kurulumun
nasıl yapılması gerektiğini adım adım açıklıyorlar. Çünkü araçların
birbirinden farklı ihtiyaçları dolayısıyla, uygulanması gereken çeşitli
konfigürasyonları olabilir. Yani benim burada ele alacağım kaynak koddan
kurulum ayrıntıları genel anlatımdır. Yine en doğru kurulum adımı için
kurulmak istenen aracın yardım sayfalarına ve kurulum açıklamalarına göz
atmanız gerekiyor. Hadi şimdi uygulamalı olarak bu durumu gözlemleyelim.

Ben örnek olarak `wget` aracının en güncel sürümünü derleyerek kurmak
istiyorum. Aslında `wget` aracı mevcut sistemimde yüklü ancak ben henüz
paket depolarında bulunmayan sürümünü kaynak koddan derleyerek yüklemek
istiyorum. Öncelikle mevcut `wget` aracının sürümünü kontrol etmek için
`wget —version` komutunu kullanabilirim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ wget --version
GNU Wget 1.21.2 built on linux-gnu.
```

Bakın varsayılan olarak yüklü gelen `wget` aracının sürümü bu. Bir de
repolardaki sürümüne bakalım.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ apt search wget                                                                
Sorting... Done
Full Text Search... Done

wget/kali-rolling 1.21.2-2+b1 amd64
  retrieves files from the web

wget2/kali-rolling 1.99.1-2.2 amd64
  file and recursive website downloader

wget2-dev/kali-rolling 1.99.1-2.2 amd64
  development file for libwget2

wgetpaste/kali-rolling 2.30-0kali1 all
  Command-line interface to various online pastebin services

wput/kali-rolling 0.6.2+git20130413-11 amd64
  tiny wget-like ftp-client for uploading files
```

Bakın mevcut dağıtım için depolarda daha güncel bir sürüm sunulmamış.
Zaten ben de depolarda bulunmadığı için kaynak koddan derleyerek kurmak
istiyorum. Elbette her zaman depolarda her istediğimiz aracın her
sürümünü bulamayabiliriz. Bu çok doğal. Çünkü en nihayetinde repoları da
insanlar oluşturuyor ve denetleyip yönetiyor. Bu sebeple repoları
sınırsız bir kaynak olarak görme hatasına düşmeyin lütfen. Repolarda
önemli olan stabil ve güvenli sürümlerin sunulmasıdır.

Şimdi `wget` aracının kaynak kodunu araştırmak üzere arama motorunu
kullanabiliriz. Kaynak kodlara ulaşmak için "**wget source code**"
şeklinde araştırmamız yeterli. `wget` aracı GNU altında geliştirilen bir
araç olduğu için GNU'nun websitesi üzerinden kaynak kodlarına
ulaşabiliyoruz.

![wget.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/wget.webp)

Ancak kaynak kodları bulma konusunda çok dikkatli olmanız gerekiyor.
Benim örneğimde GNU güvenilir kaynak olduğu için sorun yok. Ancak sizin
kurmak istediğiniz aracın kaynak kodu geliştiricinin websitesinde ya da
Github gibi açık kaynaklı projelerin paylaşıldığı platformlarda
olabilir. Eğer kaynak kodu websitesi üzerinden indiriyorsanız bu sitenin
geliştiriciye ait olduğuna ya da güvenilir bir kaynak olduğuna emin
olmadığınız sürece sakın bu aracı kurmayın. Websitesini doğrulamak için
internet üzerinde ek araştırma yapabilir ya da çeşitli forumlar ve
yardım sayfalarında bu sitenin ve aracın güvenilir olup olmadığına ve
ilgili aracın kaynak kodlarına ulaşmak için hangi adresi kullanmanız
gerektiğini sorgulayabilirsiniz.

Yani aslında Github gibi platformlarda açık kaynaklı ve resmi repolarda
bulunmayan inanılmaz çeşitlilikte aracın kaynak kodlarına kolayca
erişebilirsiniz. **Ancak bunların hepsinin iyi niyetli olduğunu
yanılgısına sakın düşmeyin.** Açık kaynaklı olmasına rağmen pek çok
zararlı yazılım da yer alıyor. Kısacası kaynak koddan kurulum, sunduğu
esneklik dolayısıyla iyidir hoştur ama riskleri de beraberinde getirir.
Emin değilseniz kişisel veya profesyonel amaçla kullandığınız makinenize
sakın bu araçları kurmayın.

Evet neticede kaynak koda erişim noktasında nerelere dikkat etmeniz
gerektiğine de kısaca vurgu yaptığımıza göre aracın kaynak kodunu
indirelim.

`wget` aracının kaynak kodlarının sürümlere göre listelendiği bu FTP
sunucusuna, resmi GNU sitesi üzerinden ulaştım.

![wget-download.webp](https://www.linuxdersleri.net/egitim/temel-linux/paket/wget-download.webp)

Ben en güncel sürümü istediğim için buradan en son sürümü içeren arşiv
dosyasının üzerine tıklayıp indiriyorum. ***Downloads*** dizinine
geçiyorum ve `tar -xf` komutu ile arşiv dosyasını buraya çıkarıyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cd Downloads/

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ ls                                                                             
wget-1.21.4.tar.gz  zoom_amd64.deb

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ tar -xf wget-1.21.4.tar.gz
```

Şimdi kurulum yapmak için dizine geçiş yapıp, dosyaları listeleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ cd wget-1.21.4/                                                                

┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ ls                                                                             
ABOUT-NLS   ChangeLog     doc          INSTALL       maint.mk     NEWS    testenv
aclocal.m4  configure     fuzz         lib           Makefile.am  po      tests
AUTHORS     configure.ac  gnulib_po    m4            Makefile.in  README  util
build-aux   COPYING       GNUmakefile  MAILING-LIST  msdos        src
```

Burada "**README**" ve "**INSTALL**" gibi isimlerde metin dosyaları
bulunuyor. İstisnalar hariç neredeyse tüm araçların kaynak kodlarında,
aracın kurulumu ve konfigürasyonları ile ilgili bilgi sunan bu tür
dosyalar zaten geliyor. Ben genel olarak kurulumu ele alıyorum ancak
daha önce de söylediğim şekilde en doğru bilgiyi geliştiricinin sunduğu
doküman ve "***install***" veya "***readme***" gibi dosyalardan
öğrenebilirsiniz. Ben kurulum yapacağım için **INSTALL** isimli dosya
içeriğini `cat` komutu ile konsola bastırmak istiyorum.

``` {.vbnet}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ cat INSTALL 
Installation Instructions
*************************

   Copyright (C) 1994-1996, 1999-2002, 2004-2017, 2020-2021 Free
Software Foundation, Inc.

   Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.  This file is offered as-is,
without warranty of any kind.

Basic Installation
==================

   Briefly, the shell command './configure && make && make install'
should configure, build, and install this package.  The following
...
The simplest way to compile this package is:

  1. 'cd' to the directory containing the package's source code and type
     './configure' to configure the package for your system.

     Running 'configure' might take a while.  While running, it prints
     some messages telling which features it is checking for.

  2. Type 'make' to compile the package.

  3. Optionally, type 'make check' to run any self-tests that come with
     the package, generally using the just-built uninstalled binaries.

  4. Type 'make install' to install the programs and any data files and
     documentation.  When installing into a prefix owned by root, it is
     recommended that the package be configured and built as a regular
     user, and only the 'make install' phase executed with root
     privileges.

  5. Optionally, type 'make installcheck' to repeat any self-tests, but
     this time using the binaries in their final installed location.
     This target does not install anything.  Running this target as a
     regular user, particularly if the prior 'make install' required
     root privileges, verifies that the installation completed
     correctly.

  6. You can remove the program binaries and object files from the
     source code directory by typing 'make clean'.  To also remove the
     files that 'configure' created (so you can compile the package for
     a different kind of computer), type 'make distclean'.  There is
     also a 'make maintainer-clean' target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.

  7. Often, you can also type 'make uninstall' to remove the installed
     files again.  In practice, not all packages have tested that
     uninstallation works correctly, even though it is required by the
     GNU Coding Standards.

  8. Some packages, particularly those that use Automake, provide 'make
     distcheck', which can by used by developers to test that all other
     targets like 'make install' and 'make uninstall' work correctly.
     This target is generally not run by end users.
..
.
```

**ℹ️ Not:** Çıktılar çok uzun olduğu için buraya kısaltarak ekledim.

Bakın burada araç hakkında çeşitli bilgilerin yanında kaynak
dosyalarının nasıl derleneceği de adım adım açıklanmış. Örneğin benim
kuracağım araç için kullanmam gereken komutlar bakın burada belirtilmiş.
Ben zaten arşiv dosyası olarak indirmiştim ve arşiv dosyasından da
çıkarmıştım. Yani şimdi aracı kurmak için buradaki komutları sırasıyla
kullanmam yeterli olacak. Burada listelenen dosyalar elbette ilgili
yazılıma göre değişiklik gösterir. Ancak genel olarak bilgi içeren metin
dosyalarının yanında kurulum için ön ayarlamaları yapan ***configure***
dosyası ve kurulum işlemini kolaylaştıran genellikle ***install.sh***
isminde kurulum betiği ile karşılaşırsınız. Örneğin bu araç için
***install.sh*** gibi bir betik yok ama konfigürasyonlar için
***configure*** dosyası var. Ayrıca buradaki ***makefile*** dosyaları da
gerekli konfigürasyon ayarlamaları yapıldıktan sonra ilgili aracın
derlenip kurulması için kullanıyor. Şimdi adım adım ilerleyelim.

**Ancak tekrar belirtiyorum bu adımlar pek çok araç için aşağı yukarı
benzer olsa da her zaman birebir aynı olmayacaktır. Çünkü pek çok farklı
yazılımın pek çok farklı bağımlılıkları ve yapılandırma ayarları
vardır.**

Ben **wget** aracının kaynak kodlarında belirtilen kurulum adımları
üzerinden genel işleyişe değiniyorum sadece. Yani kurulum yaparken
sizler mutlaka geliştiricinin sunduğu rehberi takip edin. Nitekim ben de
şu an öyle yapıyorum.

Hatırlamayı da yaptığımıza göre kurulum rehberinde de belirtildiği
şekilde `./configure` komutu ile ***configure*** dosyasının
çalıştırılmasını sağlayabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ ./configure 
configure: configuring for GNU Wget 1.21.4
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a race-free mkdir -p... /usr/bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking whether make supports the include directive... yes (GNU style)
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for compress in -lz... yes
checking for GNUTLS... no
configure: error: in `/home/taylan/Downloads/wget-1.21.4':
configure: error: The pkg-config script could not be found or is too old.  Make sure it
is in your PATH or set the PKG_CONFIG environment variable to the full
path to pkg-config.

Alternatively, you may set the environment variables GNUTLS_CFLAGS
and GNUTLS_LIBS to avoid the need to call pkg-config.
See the pkg-config man page for more details.

To get pkg-config, see <http://pkg-config.freedesktop.org/>.
See `config.log' for more details
```

Bakın çeşitli kontroller yapıldı ancak sonunda bir hata aldık. Bu
hatanın nedeni de çıktılardan anlayabildiğimiz kadarıyla `pkg-config`
scriptinin sistemde yüklü olmamasından kaynaklanıyor.

Hemen `sudo apt install pkg-config` komutu ile yükleyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ sudo apt install pkg-config
[sudo] password for taylan: 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  libpkgconf3 pkgconf pkgconf-bin
The following NEW packages will be installed:
  libpkgconf3 pkg-config pkgconf pkgconf-bin
0 upgraded, 4 newly installed, 0 to remove and 1843 not upgraded.
Need to get 105 kB of archives.
After this operation, 283 kB of additional disk space will be used.
Do you want to continue? [Y/n] y
Get:1 http://kali.download/kali kali-rolling/main amd64 libpkgconf3 amd64 1.8.1-1 [36.1 kB]
Get:2 http://kali.download/kali kali-rolling/main amd64 pkgconf-bin amd64 1.8.1-1 [29.5 kB]
Get:3 http://kali.download/kali kali-rolling/main amd64 pkgconf amd64 1.8.1-1 [25.9 kB]
Get:4 http://kali.download/kali kali-rolling/main amd64 pkg-config amd64 1.8.1-1 [13.7 kB]
Fetched 105 kB in 11s (9,934 B/s)
Selecting previously unselected package libpkgconf3:amd64.
(Reading database ... 291440 files and directories currently installed.)
Preparing to unpack .../libpkgconf3_1.8.1-1_amd64.deb ...
Unpacking libpkgconf3:amd64 (1.8.1-1) ...
Selecting previously unselected package pkgconf-bin.
Preparing to unpack .../pkgconf-bin_1.8.1-1_amd64.deb ...
Unpacking pkgconf-bin (1.8.1-1) ...
Selecting previously unselected package pkgconf:amd64.
Preparing to unpack .../pkgconf_1.8.1-1_amd64.deb ...
Unpacking pkgconf:amd64 (1.8.1-1) ...
Selecting previously unselected package pkg-config:amd64.
Preparing to unpack .../pkg-config_1.8.1-1_amd64.deb ...
Unpacking pkg-config:amd64 (1.8.1-1) ...
Setting up libpkgconf3:amd64 (1.8.1-1) ...
Setting up pkgconf-bin (1.8.1-1) ...
Setting up pkgconf:amd64 (1.8.1-1) ...
Setting up pkg-config:amd64 (1.8.1-1) ...
Processing triggers for libc-bin (2.36-9) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for kali-menu (2021.4.2) ...
```

**ℹ️ Not:** Siz hiç hata almayabilir ya da farklı bir hata
alabilirsiniz. İlk olarak konfigürasyon dosyasını çalıştırdığımız için
mevcut sistemin derleme işlemine uygun olup olmadığı kontrol ediliyor.
Dolayısıyla uyumlu değilse hata çıktısında belirtilen uyarıları
araştırıp çözdükten sonra derleme adımlarına devam etmelisiniz.

Ben hatadaki eksikliği giderdikten sonra `./configure` komutu ile
konfigürasyonu tekrar çalıştırıyorum.

Bu kez de "***Package 'gnutls', required by 'virtual:world', not
found***" hatasını aldım. Eksikliği gidermek için gerekli paketi de
kuruyorum.

**ℹ️ Not:** Hataları gidermek için kurmanız gereken paketleri repolarda
araştırabilir veya internet üzerinde bu hata ile araştırma yapıp
eksiklik hakkında bilgi alabilirsiniz. Sizden önce mutlaka birileri bu
konu hakkında soru sorup yanıt almıştır. Tek yapmanız gereken aldığınız
hataları biraz araştırmak. Yeterince araştırmış olmanıza rağmen yanıt
bulamadığınız durumda, forumlar aracılığı ile soru sorup yardım
alabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ sudo apt install libgnutls28-dev 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  libgnutls-openssl27 libgnutlsxx30 libhogweed6 libidn2-0 libidn2-dev libnettle8
  libp11-kit-dev libp11-kit0 libtasn1-6 libtasn1-6-dev libtasn1-doc nettle-dev
  p11-kit-modules
Suggested packages:
  gnutls-doc p11-kit-doc
The following NEW packages will be installed:
  libgnutls-openssl27 libgnutls28-dev libgnutlsxx30 libidn2-dev libp11-kit-dev
  libtasn1-6-dev libtasn1-doc nettle-dev
The following packages will be upgraded:
  libhogweed6 libidn2-0 libnettle8 libp11-kit0 libtasn1-6 p11-kit-modules
6 upgraded, 8 newly installed, 0 to remove and 1833 not upgraded.
Need to get 5,121 kB of archives.
After this operation, 10.6 MB of additional disk space will be used.
Do you want to continue? [Y/n] y
Get:1 http://kali.download/kali kali-rolling/main amd64 libnettle8 amd64 3.8.1-2 [288 kB]
Get:2 http://kali.download/kali kali-rolling/main amd64 libhogweed6 amd64 3.8.1-2 [328 kB]
Get:3 http://http.kali.org/kali kali-rolling/main amd64 libidn2-0 amd64 2.3.3-1+b1 [124 kB]
Get:4 http://kali.download/kali kali-rolling/main amd64 libtasn1-6 amd64 4.19.0-2 [56.6 kB]
Get:5 http://kali.download/kali kali-rolling/main amd64 p11-kit-modules amd64 0.24.1-2 [233 kB]
Get:6 http://kali.download/kali kali-rolling/main amd64 libp11-kit0 amd64 0.24.1-2 [345 kB]
Get:7 http://kali.download/kali kali-rolling/main amd64 libgnutls-openssl27 amd64 3.7.9-2 [406 kB]
Get:8 http://kali.download/kali kali-rolling/main amd64 libgnutlsxx30 amd64 3.7.9-2 [14.3 kB]
Get:9 http://http.kali.org/kali kali-rolling/main amd64 libidn2-dev amd64 2.3.3-1+b1 [122 kB]
Get:10 http://kali.download/kali kali-rolling/main amd64 libp11-kit-dev amd64 0.24.1-2 [172 kB]
Get:11 http://kali.download/kali kali-rolling/main amd64 libtasn1-6-dev amd64 4.19.0-2 [106 kB]
Get:12 http://kali.download/kali kali-rolling/main amd64 nettle-dev amd64 3.8.1-2 [1,239 kB]
Get:13 http://kali.download/kali kali-rolling/main amd64 libgnutls28-dev amd64 3.7.9-2 [1,351 kB]
Get:14 http://kali.download/kali kali-rolling/main amd64 libtasn1-doc all 4.19.0-2 [337 kB]
Fetched 5,121 kB in 13s (400 kB/s)                                                
(Reading database ... 291515 files and directories currently installed.)
Preparing to unpack .../libnettle8_3.8.1-2_amd64.deb ...
Unpacking libnettle8:amd64 (3.8.1-2) over (3.7.3-1) ...
Setting up libnettle8:amd64 (3.8.1-2) ...
(Reading database ... 291515 files and directories currently installed.)
Setting up libgnutls28-dev:amd64 (3.7.9-2) ...
Processing triggers for man-db (2.9.4-4) ...
Processing triggers for install-info (6.8-4+b1) ...
Processing triggers for libc-bin (2.36-9) ...
```

Bu şekilde hata kalmayıncaya kadar devam etmem gerek.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ ./configure 
configure: configuring for GNU Wget 1.21.4
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a race-free mkdir -p... /usr/bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking whether make supports the include directive... yes (GNU style)
checking for gcc... gcc
..
..
.
config.status: creating gnulib_po/POTFILES
config.status: creating gnulib_po/Makefile
configure: Summary of build options:

  Version:           1.21.4
  Host OS:           linux-gnu
  Install prefix:    /usr/local
  Compiler:          gcc
  CFlags:              -I/usr/include/p11-kit-1  -DHAVE_LIBGNUTLS  -DNDEBUG -g -O2   
  LDFlags:           
  Libs:              -lidn2  -lnettle  -lgnutls  -lz  
  SSL:               gnutls
  Zlib:              yes
  PSL:               no
  PCRE:              no
  Digest:            yes
  NTLM:              yes
  OPIE:              yes
  POSIX xattr:       yes
  Debugging:         yes
  Assertions:        no
  Valgrind:          Valgrind testing not enabled
  Metalink:          no
  Resolver:          libc, --bind-dns-address and --dns-servers not available
  GPGME:             no
  IRI:               yes
  Fuzzing build:     no,
```

Nihayet konfigürasyon aşaması tamamlandı. Şimdi sıradaki adım olan,
`make` komutu ile derleme işlemini gerçekleştireceğiz.

``` {.go}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ make                                                                           
make  all-recursive
make[1]: Entering directory '/home/taylan/Downloads/wget-1.21.4'
Making all in lib
make[2]: Entering directory '/home/taylan/Downloads/wget-1.21.4/lib'
  GEN      alloca.h
  GEN      arpa/inet.h
  GEN      ctype.h
  GEN      dirent.h
  GEN      fcntl.h
  GEN      malloc/dynarray.gl.h
  GEN      malloc/dynarray-skeleton.gl.h
..
..
make[2]: Leaving directory '/home/taylan/Downloads/wget-1.21.4'
make[1]: Leaving directory '/home/taylan/Downloads/wget-1.21.4'
```

Derleme aşaması da tamam. Şimdi derlenmiş olanları kurmak için
`sudo make install` komutunu girmeliyiz.

``` {.go}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ sudo make install                                                              
[sudo] password for taylan: 
make  install-recursive
make[1]: Entering directory '/home/taylan/Downloads/wget-1.21.4'
Making install in lib
make[2]: Entering directory '/home/taylan/Downloads/wget-1.21.4/lib'
make  install-am
make[3]: Entering directory '/home/taylan/Downloads/wget-1.21.4/lib'
make[4]: Entering directory '/home/taylan/Downloads/wget-1.21.4/lib'
make[4]: Nothing to be done for 'install-exec-am'.
make[4]: Nothing to be done for 'install-data-am'.
...
..
```

Böylelikle **INSTALL** dosyasında yazan kurulum adımlarını tamamlamış
olduk. Şimdi teyit etmek için konsola `wget —version` şeklinde
komutumuzu girelim.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ wget --version                                                                                                                                          
GNU Wget 1.21.4 built on linux-gnu.
```

Bakın derlemiş olduğum wget versiyonu karşıma gelmiş oldu. Yani kaynak
koddan derleme işlemini geliştiricilerin verdiği rehberi takip ederek
tamamlamış oldum.

Hatta kurulum için derlenmiş ama artık ihtiyaç duymadığımız dosyaları
`make clean` komutu ile temizleyebiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~/Downloads/wget-1.21.4]
└─$ make clean                                                                     
Making clean in lib
make[1]: Entering directory '/home/taylan/Downloads/wget-1.21.4/lib'
test -z "" || rm -f 
test -z "libgnu.a" || rm -f libgnu.a
test -z "" || rm -f 
rm -f *.o
rm -f glthread/*.o
rm -f malloc/*.o
rm -f unicase/*.o
```

Buna ek olarak tabii ki indirmiş olduğunuz bu dosyayı da artık
silebilirsiniz çünkü aracın gerekli dosyaları artık sisteme kuruldu.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cd Downloads/

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ rm -r wget-1.21.4*                                                                                                                                      

┌──(taylan㉿linuxdersleri)-[~/Downloads]
└─$ wget --version
GNU Wget 1.21.4 built on linux-gnu.
```

En nihayetinde derleme işlemini tamamlamış olduk.

Elbette ben bağımlılık sorunları ile boğuşmak istemediğim için çok fazla
ek bağımlılığı olmayan `wget` aracının kurulumunu ele aldım. Sizler de
geliştiricilerin sunduğu kurulum rehberlerinin ya da daha önce
öğrendiğiniz paket yükleme araçlarının ve internetin yardımıyla
bağımlılık sorunlarını çözerek istediğiniz aracı kaynak koddan
derleyerek kurabilirsiniz. Önemli olan geliştiricilerin sunduğu adımları
dikkatlice takip etmenizdir.

Zaten depolarda bulunmayan özel sürümler veya bağımsız harici araçlara
ihtiyaç duymadığınız sürece, kaynak koddan derlemeye neredeyse hiç
ihtiyaç duymayacaksınız. Kaynak koddan derleme işlemini genellikle Wi-Fi
kartları gibi harici sürücülerin kurulumu noktasında kullanıyoruz.

Genel olarak kaynak koddan derleme işlemini de öğrendiğimize göre bu
bölümü de sonlandırabiliriz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.

###### Temel Linux Eğitimi

------------------------------------------------------------------------

###### 19. Ders 32 dk. [Taylan Özgür Bildik](https://www.linuxdersleri.net/yazar/taylan-%C3%B6zg%C3%BCr-bildik/)

Servis Yönetimi
---------------

Servisler, sürekli olarak çalışan, çeşitli görevleri yerine getiren ve
sisteme işlevsellik sağlayan arka plan işlemleridir. Genellikle sistem
başlangıcında otomatik olarak başlatılır ve sistem çalıştığı süre
boyunca aksini gerektiren bir durum olmadığı sürece çalışırlar.

Sistem üzerindeki servisleri yönetmek için de birden fazla alternatif
servis yöneticisi vardır. Fakat biz bu bölümde yalnızca en güncel ve
yaygın kullanıma sahip olan "**systemd**" servis yöneticisini ele alıyor
olacağız. Dilerseniz alternatif servis yöneticilerini ve bunların
farklarını araştırıp öğrenebilirsiniz.

systemd
-------

**systemd** yönetimi çok detaylı bir konu olmakla birlikte çoğunlukla en
temel işlevlerine ihtiyacımız olduğu için öğrenmek oldukça kolay. Temel
işleyişi bildiğimizde spesifik ihtiyaçlara yönelik konfigürasyonları
araştırıp uygulamamız zaten mümkün. Bu sebeple biz yalnızca en temel
kullanıma odaklanıyor olacağız.

**systemd** aracı, kontrolü altındaki tüm yapıları "**birim**" yani
"**unit**" olarak görüyor. Yazıyı hazırladığım sırada araç
dokümanlarında yer alan birimlerin tablosu aşağıdaki şekildeydi:

  Unit Type        File Extension
  ---------------- ----------------
  Service unit     .service
  Target unit      .target
  Automount unit   .automount
  Device unit      .device
  Mount unit       .mount
  Path unit        .path
  Scope unit       .scope
  Slice unit       .slice
  Snapshot unit    .snapshot
  Socket unit      .socket
  Swap unit        .swap
  Timer unit       .timer

Örneğin systemd üzerinden **servisleri** yönetmek istediğimizde
"**service unit**" üzerinde işlem yapmamız gerekiyor. Biz bu bölümde
yalnızca servisler özelinde anlatımlar gerçekleştireceğiz. Daha fazlası
için ek araştırma yapmanız yeterli. Bu açıklama şu an için pek anlamlı
gelmemiş olabilir fakat bölüm sonunda netleşecek.

**systemd** aracını yönetirken `systemctl` komutunu kullanıyor olacağız.
Anlatımlarımıza birimleri listeleyerek başlayalım.

Birimleri Listelemek
--------------------

Sistemimizde aktif olan tüm birimleri listelemek için
`systemctl list-units` komutunu kullanıyoruz.

``` {.php}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl list-units
  UNIT                                                                                     LOAD   ACTIVE SUB       DESCRIPTION                                                   >
  proc-sys-fs-binfmt_misc.automount                                                        loaded active waiting   Arbitrary Executable File Formats File System Automount Point >
  sys-devices-pci0000:00-0000:00:01.1-ata2-host3-target3:0:0-3:0:0:0-block-sr0.device      loaded active plugged   VBOX_CD-ROM
  sys-devices-pci0000:00-0000:00:03.0-net-eth0.device                                      loaded active plugged   82540EM Gigabit Ethernet Controller (PRO/1000 MT Desktop Adapt>
  sys-devices-pci0000:00-0000:00:05.0-sound-card0-controlC0.device                         loaded active plugged   /sys/devices/pci0000:00/0000:00:05.0/sound/card0/controlC0
  sys-devices-pci0000:00-0000:00:0d.0-ata3-host0-target0:0:0-0:0:0:0-block-sdd-sdd1.device loaded active plugged   VBOX_HARDDISK 1
  sys-devices-pci0000:00-0000:00:0d.0-ata3-host0-target0:0:0-0:0:0:0-block-sdd-sdd2.device loaded active plugged   VBOX_HARDDISK 2
  sys-devices-pci0000:00-0000:00:0d.0-ata3-host0-target0:0:0-0:0:0:0-block-sdd-sdd5.device loaded active plugged   VBOX_HARDDISK 5
  sys-devices-pci0000:00-0000:00:0d.0-ata3-host0-target0:0:0-0:0:0:0-block-sdd.device      loaded active plugged   VBOX_HARDDISK
  sys-devices-pci0000:00-0000:00:0d.0-ata4-host2-target2:0:0-2:0:0:0-block-sda-sda1.device loaded active plugged   VBOX_HARDDISK 1
  sys-devices-pci0000:00-0000:00:0d.0-ata4-host2-target2:0:0-2:0:0:0-block-sda.device      loaded active plugged   VBOX_HARDDISK
  sys-devices-pci0000:00-0000:00:0d.0-ata5-host4-target4:0:0-4:0:0:0-block-sdb.device      loaded active plugged   VBOX_HARDDISK
  sys-devices-pci0000:00-0000:00:0d.0-ata6-host5-target5:0:0-5:0:0:0-block-sdc.device      loaded active plugged   VBOX_HARDDISK
  sys-devices-pci0000:00-0000:00:0e.0-nvme-nvme0-nvme0n1.device                            loaded active plugged   ORCL-VBOX-NVME-VER12
  sys-devices-pci0000:00-0000:00:0e.0-nvme-nvme0-nvme0n2.device                            loaded active plugged   ORCL-VBOX-NVME-VER12
  sys-devices-platform-serial8250-tty-ttyS0.device                                         loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS0
  sys-devices-platform-serial8250-tty-ttyS1.device                                         loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS1
  sys-devices-platform-serial8250-tty-ttyS2.device                                         loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS2
  sys-devices-platform-serial8250-tty-ttyS3.device                                         loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS3
  sys-devices-virtual-misc-rfkill.device                                                   loaded active plugged   /sys/devices/virtual/misc/rfkill
  sys-module-configfs.device                                                               loaded active plugged   /sys/module/configfs
  sys-module-fuse.device                                                                   loaded active plugged   /sys/module/fuse
```

Ben çıktıları kısaltarak ekledim, fakat siz kendi konsolunuz üzerinde
pek çok farklı türde "**unit**" yani "**birim**" olduğunu bizzat
görebilirsiniz. Zaten birimler, "**.automount"**, "**.device"**,
"**.service"** şeklinde isminin sonunda nokta ve birim ismiyle açıkça
belirtiliyor.

Buradaki çıktılarda yalnızca aktif olan yani halihazırda çalışmakta olan
birimler listelenmiş oldu. Eğer sistemdeki tüm birimleri listelemek
istersek `systemctl list-units —all` komutunu kullanabiliriz.

``` {.lua}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl list-units --all
  UNIT                                                                                                   LOAD      ACTIVE   SUB       DESCRIPTION                                >
  proc-sys-fs-binfmt_misc.automount                                                                      loaded    active   waiting   Arbitrary Executable File Formats File Syst>
  dev-cdrom.device                                                                                       loaded    active   plugged   VBOX_CD-ROM
  dev-disk-by\x2did-ata\x2dVBOX_CD\x2dROM_VB2\x2d01700376.device                                         loaded    active   plugged   VBOX_CD-ROM
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VB3ccf8e6f\x2da9e91513.device                                   loaded    active   plugged   VBOX_HARDDISK
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VB45786de4\x2d3738de63.device                                   loaded    active   plugged   VBOX_HARDDISK
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VB45786de4\x2d3738de63\x2dpart1.device                          loaded    active   plugged   VBOX_HARDDISK 1
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VB45786de4\x2d3738de63\x2dpart2.device                          loaded    active   plugged   VBOX_HARDDISK 2
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VB45786de4\x2d3738de63\x2dpart5.device                          loaded    active   plugged   VBOX_HARDDISK 5
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VBda1e68a2\x2d30c6e453.device                                   loaded    active   plugged   VBOX_HARDDISK
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VBe669bbe4\x2d6b8b9ee2.device                                   loaded    active   plugged   VBOX_HARDDISK
  dev-disk-by\x2did-ata\x2dVBOX_HARDDISK_VBe669bbe4\x2d6b8b9ee2\x2dpart1.device                          loaded    active   plugged   VBOX_HARDDISK 1
  dev-disk-by\x2did-lvm\x2dpv\x2duuid\x2d5JMH8c\x2dE6sH\x2dCU8Q\x2dffxQ\x2dM2Qf\x2dibd9\x2diwfl4z.device loaded    active   plugged   ORCL-VBOX-NVME-VER12
  dev-disk-by\x2did-lvm\x2dpv\x2duuid\x2dx0PYst\x2d25V2\x2drYcj\x2dxXIC\x2dEAvQ\x2dKFun\x2d11WCWu.device loaded    active   plugged   VBOX_HARDDISK 1
```

Ben çıktıları kısalttığım için inaktif olanlar buraya eklediğim
çıktılarda gözükmüyor ancak `—state=inactive` seçeneği ile inaktif
olanları da özellikle filtreleyebiliriz.

``` {.lua}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl list-units --all --state=inactive                                                                                                                             
  UNIT                                                                                 LOAD      ACTIVE   SUB  DESCRIPTION                                                       >
● home.mount                                                                           not-found inactive dead home.mount
  proc-sys-fs-binfmt_misc.mount                                                        loaded    inactive dead Arbitrary Executable File Formats File System
● tmp.mount                                                                            not-found inactive dead tmp.mount                                                         >
  systemd-ask-password-console.path                                                    loaded    inactive dead Dispatch Password Requests to Console Directory Watch             >
  apparmor.service                                                                     loaded    inactive dead Load AppArmor profiles
● auditd.service                                                                       not-found inactive dead auditd.service
  auth-rpcgss-module.service                                                           loaded    inactive dead Kernel Module supporting RPCSEC_GSS
● console-screen.service                                                               not-found inactive dead console-screen.service
  dm-event.service                                                                     loaded    inactive dead Device-mapper event daemon
  dpkg-db-backup.service                                                               loaded    inactive dead Daily dpkg database backup service
  e2scrub_all.service                                                                  loaded    inactive dead Online ext4 Metadata Check for All Filesystems
  e2scrub_reap.service                                                                 loaded    inactive dead Remove Stale Online ext4 Metadata Check Snapshots
  emergency.service                                                                    loaded    inactive dead Emergency Shell
```

Gördüğünüz gibi yalnızca inaktif olanları da filtrelemiş olduk.

Eğer spesifik olarak bir servisin durumunu sorgulamak istersek `status`
seçeneğini kullanabiliyoruz. Ben denemek için **apache2** servisini
sorguluyorum.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2
○ apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: inactive (dead)
       Docs: https://httpd.apache.org/docs/2.4/
```

**ℹ️ Not:** Sizin kullanmakta olduğunuz sistemde **apache** servisi
farklı bir kısayol ismi ile tanımlı olabilir. Örneğin Apache servisi,
Red Hat üzerinde **httpd** olarak geçiyor. Birimleri listelediğiniz
çıktılardan, sizin sisteminizdeki ismini öğrenebilirsiniz. Ayrıca apache
için sizin sisteminizde tanımlı bir servis mevcut olmayabilir. Ben
yalnızca kendi sistemimden örnek vermek için **apache** ismi üzerinden
apache servisinde uygulamalar gerçekleştiriyorum. Buradaki anlatımları
takip etmek için siz dilediğiniz bir servisi kullanabilirsiniz.

Unit(Birim) Yönetimi
--------------------

Başlatmak \| `start`
--------------------

İnaktif durumdaki bir birimi başlatmak için
`sudo systemctl start birim-adı` şeklinde komutumuzu girebiliyoruz. Ben
denemek için kapalı olan **apache2.service** isimli servisi başlatmak
istiyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl start apache2.service 
[sudo] password for taylan: 

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2.service 
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-07-24 10:08:06 EDT; 6s ago
       Docs: https://httpd.apache.org/docs/2.4/
    Process: 15355 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
   Main PID: 15390 (apache2)
      Tasks: 6 (limit: 12719)
     Memory: 19.2M
        CPU: 110ms
     CGroup: /system.slice/apache2.service
             ├─15390 /usr/sbin/apache2 -k start
             ├─15391 /usr/sbin/apache2 -k start
             ├─15392 /usr/sbin/apache2 -k start
             ├─15393 /usr/sbin/apache2 -k start
             ├─15394 /usr/sbin/apache2 -k start
             └─15395 /usr/sbin/apache2 -k start

Jul 24 10:08:01 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:08:06 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
```

Ben **apache2.service** şeklinde birimin türünü(**.service**) açıkça
belirttim fakat **apache2** isminde başka bir birim türü yoksa
**apache2.service** yerine doğrudan **apache2** şeklinde de
girebilirdim.

Durdurmak \| `stop`
-------------------

Çalışmakta olan birimi durdurmak için `sudo systemctl stop birim-adı`
komutunu kullanabiliyoruz. Ben başlattığım apache2 servis birimini
durduracağım.

``` {.ruby}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl stop apache2

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2
○ apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: inactive (dead)
       Docs: https://httpd.apache.org/docs/2.4/

Jul 24 10:08:01 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:08:06 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
Jul 24 10:08:33 linuxdersleri.net systemd[1]: Stopping The Apache HTTP Server...
Jul 24 10:08:38 linuxdersleri.net systemd[1]: apache2.service: Deactivated successfully.
Jul 24 10:08:38 linuxdersleri.net systemd[1]: Stopped The Apache HTTP Server.
```

İlgili birimin durdurulduğunu `status` seçeneği ile teyit etmiş olduk.
En alttaki log kayıtlarında hangi işlemin hangi sırada
gerçekleştirildiği de açıkça belirtiliyor zaten.

Yeniden Başlatmak \| `restart` `reload`
---------------------------------------

Birimi yeniden başlatmak için `restart` seçeneğini kullanabiliyoruz.
Örneğin birim dosyası üzerinde konfigürasyon değişikliği yaptığınızda,
ilgili birimde bu değişikliğin geçerli olması için o birimi yeniden
başlatabilirsiniz. Bu seçenek, hem kapalı hem de halihazırda çalışmakta
olan birimin yeniden başlatılmasını sağlıyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl restart apache2.service 

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2.service 
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-07-24 10:09:17 EDT; 23s ago
       Docs: https://httpd.apache.org/docs/2.4/
    Process: 15683 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
   Main PID: 15749 (apache2)
      Tasks: 6 (limit: 12719)
     Memory: 12.1M
        CPU: 60ms
     CGroup: /system.slice/apache2.service
             ├─15749 /usr/sbin/apache2 -k start
             ├─15754 /usr/sbin/apache2 -k start
             ├─15755 /usr/sbin/apache2 -k start
             ├─15756 /usr/sbin/apache2 -k start
             ├─15757 /usr/sbin/apache2 -k start
             └─15758 /usr/sbin/apache2 -k start

Jul 24 10:09:12 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:09:17 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
```

Eğer servisi kesintiye uğratmadan yalnızca konfigürasyon
değişikliklerinin geçerli olmasını isterseniz `restart` yerine `reload`
seçeneğini kullanabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl reload apache2.service                                                                                                                  

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2.service                                                                                                                   
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-07-24 10:09:17 EDT; 56s ago
       Docs: https://httpd.apache.org/docs/2.4/
    Process: 15683 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
    Process: 15939 ExecReload=/usr/sbin/apachectl graceful (code=exited, status=0/SUCCESS)
   Main PID: 15749 (apache2)
      Tasks: 6 (limit: 12719)
     Memory: 12.3M
        CPU: 149ms
     CGroup: /system.slice/apache2.service
             ├─15749 /usr/sbin/apache2 -k start
             ├─15983 /usr/sbin/apache2 -k start
             ├─15984 /usr/sbin/apache2 -k start
             ├─15985 /usr/sbin/apache2 -k start
             ├─15986 /usr/sbin/apache2 -k start
             └─15987 /usr/sbin/apache2 -k start

Jul 24 10:09:12 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:09:17 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
Jul 24 10:10:01 linuxdersleri.net systemd[1]: Reloading The Apache HTTP Server...
Jul 24 10:10:11 linuxdersleri.net systemd[1]: Reloaded The Apache HTTP Server.
```

Birimlerin Aktif Pasif Hale Getirilmesi
---------------------------------------

Birimleri yalnızca manuel olarak başlatıp, durdurmamız gerekmiyor.
Sistem başlangıcında otomatik olarak başlatılmasını istediğimiz
birimleri **systemd** üzerinden "**enabled**" yani "aktif" şekilde
tanımlamamız yeterli.

### Aktifleştirmek \| `enable`

Ben denemek için apache2 servisini aktifleştirmek üzere
`sudo systemctl enable apache2` şeklinde komutumu giriyorum.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl enable apache2
Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable apache2
Created symlink /etc/systemd/system/multi-user.target.wants/apache2.service → /lib/systemd/system/apache2.service.

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-07-24 10:09:17 EDT; 19min ago
       Docs: https://httpd.apache.org/docs/2.4/
   Main PID: 15749 (apache2)
      Tasks: 6 (limit: 12719)
     Memory: 12.3M
        CPU: 220ms
     CGroup: /system.slice/apache2.service
             ├─15749 /usr/sbin/apache2 -k start
             ├─15983 /usr/sbin/apache2 -k start
             ├─15984 /usr/sbin/apache2 -k start
             ├─15985 /usr/sbin/apache2 -k start
             ├─15986 /usr/sbin/apache2 -k start
             └─15987 /usr/sbin/apache2 -k start

Jul 24 10:09:12 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:09:17 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
Jul 24 10:10:01 linuxdersleri.net systemd[1]: Reloading The Apache HTTP Server...
Jul 24 10:10:11 linuxdersleri.net systemd[1]: Reloaded The Apache HTTP Server.
```

**apache2** servisi "**enable**" yani "aktif" hale gelmiş oldu. Yani
sistem başlangıcında otomatik olarak başlatılıyor olacak.

### Devre Dışı Bırakmak \| `disable`

Eğer aktifleştirilmiş bir birimi pasif konuma getirmek istersek
`disable` yani "devre dışı bırakma" seçeneğini kullanabiliriz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl disable apache2                                                                                                                 
Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install disable apache2
Removed /etc/systemd/system/multi-user.target.wants/apache2.service.

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status apache2                                                                                                                          
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2023-07-24 10:09:17 EDT; 21min ago
       Docs: https://httpd.apache.org/docs/2.4/
   Main PID: 15749 (apache2)
      Tasks: 6 (limit: 12719)
     Memory: 12.3M
        CPU: 227ms
     CGroup: /system.slice/apache2.service
             ├─15749 /usr/sbin/apache2 -k start
             ├─15983 /usr/sbin/apache2 -k start
             ├─15984 /usr/sbin/apache2 -k start
             ├─15985 /usr/sbin/apache2 -k start
             ├─15986 /usr/sbin/apache2 -k start
             └─15987 /usr/sbin/apache2 -k start

Jul 24 10:09:12 linuxdersleri.net systemd[1]: Starting The Apache HTTP Server...
Jul 24 10:09:17 linuxdersleri.net systemd[1]: Started The Apache HTTP Server.
Jul 24 10:10:01 linuxdersleri.net systemd[1]: Reloading The Apache HTTP Server...
Jul 24 10:10:11 linuxdersleri.net systemd[1]: Reloaded The Apache HTTP Server.
```

Gördüğünüz gibi `enable` seçeneği ile aktifleştiriyorken, `disable`
seçeneği ile de pasif konuma getirebiliyoruz.

Birimleri Gruplamak \| Target
-----------------------------

Farklı durumlar için farklı birimlerin sistem açılışında otomatik olarak
aktifleştirilmesini isteyebiliriz. systemd bu durumlar için "**target**"
ismi verilen birimleri kullanıyor. target sayesinde sistem başlangıcında
başlatılmasını istediğimiz tüm birimleri gruplayabiliyoruz. Temel target
birimlerini listeleyecek olursak:

-   *poweroff*
-   *rescue*
-   *multi-user*
-   *graphical*
-   *reboot*

Bu target'lar, içerisinde amaçları doğrultusunda uygun olan birimleri
barındıran gruplardır. Örneğin poweroff.target aslında systemd'nin tüm
birimleri sonlandırması sonucu sistemin kapanmasını sağlayan gruptur.

Kullanmakta olduğunuz sistemdeki varsayılan target bilgisini öğrenmek
için `systemctl get-default` komutunu girebilirsiniz.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl get-default 
graphical.target
```

Benim kullanmakta olduğum sistem **graphical.target** seviyesinde
başlatıldığı için otomatik olarak ağ destekleri grafiksel çok
kullanıcılı sistem için gerekli olan birimler de başlatılmış oluyor. Bu
sayede grafiksel arayüze sahip olan, ağa bağlanabilen, çok kullanıcılı
işletim sistemini yönetebiliyorum.

Eğer varsayılan target birimini değiştirmek istersek `set-default`
seçeneğinin ardından ilgili target biriminin tam ismini girebiliriz.
Fakat ben öncelikle mevcut sistemimde tanımlı olan tüm targetleri
öğrenmek üzere `systemctl list-units —type target —all` komutunu
giriyorum.

``` {.sql}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl list-units --type target --all                                                                                                                
  UNIT                                                                                 LOAD   ACTIVE   SUB    DESCRIPTION                                  >
  basic.target                                                                         loaded active   active Basic System
  blockdev@dev-disk-by\x2duuid-00253fba\x2dff78\x2d4f04\x2db189\x2dfbc974082345.target loaded inactive dead   Block Device Preparation for /dev/disk/by-uui>
  blockdev@dev-disk-by\x2duuid-491d3534\x2db3d9\x2d47af\x2dad63\x2d66b0e72fe8dd.target loaded inactive dead   Block Device Preparation for /dev/disk/by-uui>
  blockdev@dev-sda5.target                                                             loaded inactive dead   Block Device Preparation for /dev/sda5
  cryptsetup.target                                                                    loaded active   active Local Encrypted Volumes
  emergency.target                                                                     loaded inactive dead   Emergency Mode
  first-boot-complete.target                                                           loaded inactive dead   First Boot Complete
  getty-pre.target                                                                     loaded inactive dead   Preparation for Logins
  getty.target                                                                         loaded active   active Login Prompts
  graphical.target                                                                     loaded active   active Graphical Interface
  initrd-root-fs.target                                                                loaded inactive dead   Initrd Root File System
  initrd-usr-fs.target                                                                 loaded inactive dead   Initrd /usr File System
  integritysetup.target                                                                loaded active   active Local Integrity Protected Volumes
  local-fs-pre.target                                                                  loaded active   active Preparation for Local File Systems
  local-fs.target                                                                      loaded active   active Local File Systems
  multi-user.target                                                                    loaded active   active Multi-User System
  network-online.target                                                                loaded inactive dead   Network is Online
  network-pre.target                                                                   loaded inactive dead   Preparation for Network
  network.target                                                                       loaded active   active Network
  nfs-client.target                                                                    loaded active   active NFS client services
  nss-lookup.target                                                                    loaded inactive dead   Host and Network Name Lookups
  nss-user-lookup.target                                                               loaded inactive dead   User and Group Name Lookups
  paths.target                                                                         loaded active   active Path Units
  remote-fs-pre.target                                                                 loaded active   active Preparation for Remote File Systems
  remote-fs.target                                                                     loaded active   active Remote File Systems
  rescue.target                                                                        loaded inactive dead   Rescue Mode
  shutdown.target                                                                      loaded inactive dead   System Shutdown
  slices.target                                                                        loaded active   active Slice Units
  sockets.target                                                                       loaded active   active Socket Units
  sound.target                                                                         loaded active   active Sound Card
  stunnel.target                                                                       loaded active   active TLS tunnels for network services - per-config>
  swap.target                                                                          loaded active   active Swaps
  sysinit.target                                                                       loaded active   active System Initialization
  time-set.target                                                                      loaded active   active System Time Set
  time-sync.target                                                                     loaded inactive dead   System Time Synchronized
  timers.target                                                                        loaded active   active Timer Units
  umount.target                                                                        loaded inactive dead   Unmount All Filesystems
  veritysetup.target                                                                   loaded active   active Local Verity Protected Volumes

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.
38 loaded units listed.
To show all installed unit files use 'systemctl list-unit-files'.
```

Bakın benim sistemimde, başta vermiş olduğum standart tablodan çok daha
fazla target tanımlı gözüküyor. Dilersek biz de spesifik bir amaç için
bir target birimi oluşturup bu birimin başlatması gereken birimleri bu
birim altında gruplayabiliriz. Bu konuya değinmeyeceğiz fakat hazır yeri
gelmişken, ihtiyaca yönelik olarak tüm birimleri konfigüre
edebileceğimize vurgu yapmak istedim.

Ben varsayılan target seviyesini değiştirmeyi örneklemek için
**graphical.target** yerine **multi-user.target**'ı varsayılan olarak
tanımlamak istiyorum.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl get-default 
graphical.target

┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl set-default multi-user.target                                                                                                                 
Created symlink /etc/systemd/system/default.target → /lib/systemd/system/multi-user.target.

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl get-default                                                                                                                 
multi-user.target
```

Gördüğünüz gibi varsayılan target değişmiş oldu. Bu değişiklik sistem
başlangıcında geçerli olacak.

Eğer değişikliğin anında mevcut oturum için geçerli olmasını istersek
`sudo systemctl isolate isim.target` şeklinde komutumuzu girebiliriz.
Örneğin `sudo systemctl isolate reboot.target` komutunu girecek olursak,
**reboot.target** birimi konfigürasyonları sebebiyle sistemin yeniden
başlatılmasını sağlayacaktır. Bu komutu onayladığınız anda sisteminiz
yeniden başlatılacaktır. Çünkü **reboot.target** birimi bunun için özel
olarak konfigüre edilmiştir.

Ayrıca birimleri aktif ve pasif şekilde tanımlarken, komut çıktılarında
ilgili birimin multi-user.target ile ilişkili olan dosya konumuna
sembolik olarak bağlandığını da görmüştük. Bu sayede sistem
multi-user.target birimi ile başlatılırken, aktifleştirmiş olduğumuz
birim de bu grup dahilinde başlatılmış oluyor.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl enable apache2
Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable apache2
Created symlink /etc/systemd/system/multi-user.target.wants/apache2.service → /lib/systemd/system/apache2.service.
```

Bakın multi-user.target birimi altına bu servis sembolik olan bağlanmış
oldu. Bu sayede sistem multi-user.target birimi ile başlatılırken bu
servis de otomatik olarak başlatılıyor olacak.

Eğer bu birimi devredışı bırakırsak da bu sembolik link silinecek. Hemen
deneyelim.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl disable apache2.service                             
Synchronizing state of apache2.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install disable apache2                 
Removed /etc/systemd/system/multi-user.target.wants/apache2.service.
```

İlgili sembolik linkin silinmesiyle bu servis de pasif konumuna geçerek,
mult-user.target birimi ile ilişkisi kesilmiş oldu. Bu sebeple sistem
başlangıcında bu servis birimi otomatik olarak başlatılmayacak.

Ayrıca ben örnek olarak **graphical.target** yerine
**multi-user.target** birimini varsayılan target birimi olarak ayarladım
ama aslında **graphical.target** birimi de arkaplanda
**multi-user.target** birimini kullanıyor. Tek fark grafiksel kullanıcı
arayüzü için gerekli olan ek birimleri de dahil etmiş olması. Bu durumu
teyit etmek için `cat /lib/systemd/system/graphical.target` komutu ile
**graphical.target** birim dosyasını inceleyebiliriz.

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /lib/systemd/system/graphical.target                                                                                         
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target
Wants=display-manager.service
Conflicts=rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
AllowIsolate=yes
```

Şimdi buradaki konfigürasyonları açıklayacak olursak:

**`Requires=multi-user.target`**: Bu satır, **kesin bağımlılığı**
belirtiyor. Yani, mevcut birim çalıştırılmadan önce
**multi-user.target** birimi de çalıştırılmalıdır. Eğer
**multi-user.target** çalıştırılamazsa, bu birim yani
**graphical.target** birimi de çalıştırılmayacaktır.

**`Wants=display-manager.service`**: Bu satır, birim dosyanın
**display-manager.service** birimini bağımlılık olarak **istediğini**
belirtir. **`Requires`**'dan farklı olarak, **`Wants`** bağımlılığı
zorunlu kılmaz. Eğer display-manager.service mevcut değilse, bu birim
hala çalıştırılabilir. Ancak eğer varsa, display-manager.service ile
birlikte çalışacaktır.

**`Conflicts=rescue.service rescue.target`**: Bu satır, birim dosyanın
**rescue.service** veya **rescue.target** ile **çakışmaması**
gerektiğini belirtir. Yani, eğer rescue.service veya rescue.target
çalışıyorsa, bu birim çalıştırılmaz.

**`After=multi-user.target rescue.service rescue.target display-manager.service`**:
Bu satır, birimin çalıştırılması gereken **sıralamayı** belirtir. Yani
mevcut graphical.target birimi, multi-user.target, rescue.service,
rescue.target ve display-manager.service birimlerinden **sonra**
çalıştırılmalıdır. Bu, belirli bir sıra sağlamak için kullanılır.

**`AllowIsolate=yes`**: Bu satır, bu birimin "`isolate`" komutunu
destekleyeceğini belirtir. `isolete` komutu ile **anında target
birimlerinde geçiş** yapabileceğinizi biliyorsunuz, işte bu tanımlama
buna izin veriyor.

Gördüğünüz gibi grafiksel arayüz için gereken
**display-manager.service** ve çok kullanıcılı standart sistem yönetimi
için gerekli olan **multi-user.target** kullanılarak
**graphical.target** birimi meydana getirilimiş. Bu sayede grafiksel
arayüzlü çok kullanıcılı bir sistem için gereken tüm birimler
başlatılabiliyor.

Buradaki kısa açıklamayla, birimlerin nasıl aktif ve pasif olarak
tanımlandığı ve target birimlerinin bu konudaki işlevi biraz daha net
anlaşılmıştır diye umuyorum.

Yeni Servis Tanımlaması
-----------------------

Basit bir örnek olarak kendimize yeni bir servis tanımlamayı
deneyebiliriz. Ben servis olarak arka planda çalıştırılması için bir
betik hazırlamak istiyorum.

Örnek olarak; çalıştığı her dakika boyunca
***/home/taylan/Desktop/zaman.log*** isimli dosyaya çalışma saatlerini
bastıran bir betik kullanacağım.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat > zaman.sh
#! /usr/bin/bash

while true; do
    date >> /home/taylan/Desktop/zaman.log
    sleep 60 
done

┌──(taylan㉿linuxdersleri)-[~]
└─$ chmod +x zaman.sh 

┌──(taylan㉿linuxdersleri)-[~]
└─$ ./zaman.sh

┌──(taylan㉿linuxdersleri)-[~]
└─$ cat ~/Desktop/zaman.log 
Wed Jul 26 10:05:24 AM EDT 2023
```

Betik dosyamı hazırladım ve sorunsuzca çalıştığını da teyit ettim. Şimdi
bu betik dosyasının servis olarak arka planda çalışması için tanımlama
yapalım.

Servis dosyasını `/etc/systemd/system/` dizini altında
***servis-ismi.service*** ismiyle oluşturmamız gerekiyor. Dosya isminde
Türkçe karakter kullanmayın. Yeni servis dosyası oluşturmak için `nano`
aracından faydalanabilirsiniz.

``` {.bash}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo nano /etc/systemd/system/zaman.service
[sudo] password for taylan:
```

Öncelikle tanımlamayı yapıp dosyamızı kaydedelim.

``` {.ini}
[Unit]
Description=zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır.

[Service]                                                                    
ExecStart=/home/taylan/zaman.sh                                              
                                                                             
[Install]                                                                    
WantedBy=multi-user.target
```

**`[Unit]`**, birim hakkında bilgi girdiğimiz bölümdür. `Description`
seçeneğinin ardından, mevcut birim hakkında **açıklama** ekliyoruz.

**`[Service]`** servisle ilgili konfigürasyonları tanımlayabileceğimiz
başlıktır. Bu başlık altında servisin çalışma şekli hakkında
ihtiyacımıza yönelik tanımlamalarda bulunabiliyoruz. Ben yalnızca
***/home/taylan/zaman.sh*** konumundaki betik dosyasını çalıştırmak
istediğim için "`ExecStart=`" tanımından sonra bu betik dosyasının tam
konumunu girdim. Siz çalıştırmak istediğiniz dosyanın tam konumunu
belirtebilirsiniz.

**`[Install]`** başlığı ise, bu birimin ne zaman yani hangi target ile
başlatılacağını belirtmemizi sağlıyor. Ben standart olan çok kullanıcılı
**multi-user.target** grubunu belirttim. Bu sayede sistem başlangıcında
multi-user.target başlatılacağı için, eğer aktifleştirirsem otomatik
olarak benim tanımladığım bu servis de başlatılıp, betik dosyası
çalıştırılıyor olacak.

Bu değişikliğin geçerli olması için **systemd** aracının konfigürasyon
değişikliklerini tanıması üzere `sudo systemctl daemon-reload` komutunu
girmemiz gerek.

``` {.scss}
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ sudo systemctl daemon-reload
                                                                             
┌──(taylan㉿linuxdersleri)-[~]                                               
└─$ systemctl status zaman
○ zaman.service - zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır.
     Loaded: loaded (/etc/systemd/system/zaman.service; disabled; vendor preset: disabled)
     Active: inactive (dead)
```

Çıktıdaki "loaded" ifadesine bakarak, servisin **systemd** tarafından
tanındığını(bu konfigürasyon dosyasının yüklendiğini) görebiliyoruz.
Fakat **status** çıktısından bizzat teyit edebildiğimiz gibi bu servis
şu anda çalışmıyor ve ayrıca aktif durumda da değil. Yani sistem
başlangıcında otomatik olarak başlatılmayacak çünkü "**pasif**" yani
"**disabled**" olarak tanımlı gözüküyor.

Servisi başlatmak için `sudo systemctl start zaman.service` şeklinde
komutumuzu girebiliriz.

``` {.yaml}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl start zaman                                                                                                                          

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status zaman.service 
● zaman.service - zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır.
     Loaded: loaded (/etc/systemd/system/zaman.service; disabled; vendor preset: disabled)
     Active: active (running) since Wed 2023-07-26 10:45:43 EDT; 9s ago
   Main PID: 11958 (zaman.sh)
      Tasks: 2 (limit: 12719)
     Memory: 584.0K
        CPU: 9ms
     CGroup: /system.slice/zaman.service
             ├─11958 /usr/bin/bash /home/taylan/zaman.sh
             └─11960 sleep 60

Jul 26 10:45:43 linuxdersleri.net systemd[1]: Started zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır..
```

Servisimiz şu anda çalışıyor fakat sistem başlangıcında otomatik olarak
başlatılmayacak. Eğer başlatılmasını istiyorsak
`sudo systemctl enable zaman.service` komutu ile aktifleştirebiliriz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ sudo systemctl enable zaman.service 
Created symlink /etc/systemd/system/multi-user.target.wants/zaman.service → /etc/systemd/system/zaman.service.

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status zaman.service 
● zaman.service - zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır.
     Loaded: loaded (/etc/systemd/system/zaman.service; enabled; vendor preset: disabled)
     Active: active (running) since Wed 2023-07-26 10:45:43 EDT; 2min 36s ago
   Main PID: 11958 (zaman.sh)
      Tasks: 2 (limit: 12719)
     Memory: 596.0K
        CPU: 21ms
     CGroup: /system.slice/zaman.service
             ├─11958 /usr/bin/bash /home/taylan/zaman.sh
             └─12459 sleep 60

Jul 26 10:45:43 linuxdersleri.net systemd[1]: Started zaman.sh isimli betik dosyasını çalıştıran servisin açıklamasıdır..
```

Servis, multi-user.target ile ilişkili olan dizine sembolik linkle
bağlanmış oldu. Yani artık böylelikle sistemimiz multi-user.target ile
başlatıldığında "**zaman.service**" birimi de otomatik olarak
başlatılacak. Teyit etmek isterseniz sisteminizi yeniden başlatıp
deneyebilirsiniz.

Elbette servisi nasıl sonlandırabileceğinizi ve pasif hale
getirebileceğinizi de biliyorsunuz. Eğer servisi kalıcı olarak silmek
isterseniz de, oluşturduğunuz servis birimi dosyasını silmeniz yeterli.

Biz burada yalnızca çok basit düzeyde servis tanımlamayı ele aldık.
Fakat servisin yerine getireceği görevlere göre tanımlanması gereken
konfigürasyonalar çok çeşitli olabilir.

Örneğin apache2 servisini incelemek için
`cat /lib/systemd/system/apache2.service` komutunu girelim.

``` {.makefile}
┌──(taylan㉿linuxdersleri)-[~]
└─$ cat /lib/systemd/system/apache2.service
[Unit]
Description=The Apache HTTP Server
After=network.target remote-fs.target nss-lookup.target
Documentation=https://httpd.apache.org/docs/2.4/

[Service]
Type=forking
Environment=APACHE_STARTED_BY_SYSTEMD=true
ExecStart=/usr/sbin/apachectl start
ExecStop=/usr/sbin/apachectl graceful-stop
ExecReload=/usr/sbin/apachectl graceful
KillMode=mixed
PrivateTmp=true
Restart=on-abort

[Install]
WantedBy=multi-user.target
```

Gördüğünüz gibi bizim tanımladığımıza ek olarak daha farklı
konfigürasyonlar da mevcut. Tüm konfigürasyonlardan bahsetmemiz mümkün
değil. Çünkü hepsi ihtiyaca yönelik olarak tanımlanıyor. Yani sık
kullanılmayanların akılda kalması veya tüm konfigürasyonların bilinmesi
gibi bir durum mümkün değil. İhtiyaç duyduğunuz konfigürasyonları
öğrenmek için systemd aracının manual sayfalarını ve interneti
kullanabilirsiniz.

Ayrıca dikkat ettiyseniz, araçlarla birlikte gelen servisler,
***/lib/systemd/system/*** dizini altında tutuluyor. Gerekirse buradan
ilgili servis birimlerinin konfigürasyonlarına göz atıp
düzenleyebilirsiniz.

Zamanlanmış Görevler : cron \| systemd timer
--------------------------------------------

Belirli görevlerin tanımlandıkları zaman aralıklarında otomatik olarak
çalıştırılması için **cron** ile zamanlanmış görevler
tanımlayabiliyoruz. Fakat ben **cron** yapısına değinmekten ziyade daha
güncel olan systemd aracının benzer amaçla sunduğu **timer** birimini
ele almak istiyorum. Daha önce nasıl yeni bir servis
tanımlayabileceğimize değindiğimiz için aslında bizim için çok kolay
olacak.

Ben denemek için daha önce oluşturduğum servisi kullanarak, betik
dosyasının spesifik bir aralıkta çalıştırılması için tanımlamada
bulunacağım. Bunun için `nano /lib/systemd/system/zaman.timer` komutu
ile zamanlanmış görev için **timer** birim dosyası oluşturalım.

``` {.ini}
[Unit]
Description=zaman.service için zamanlanmış görev tanımı

[Timer]
OnBootSec=1min
OnCalendar=*:*:0/30
Unit=zaman.service

[Install]
WantedBy=multi-user.target
```

**`[Timer]`** başlığı altında hangi servisin hangi sıklıkla
çalıştırılması gerektiğini tanımlayabiliyoruz.

`OnBootSec` seçeneği, **1min** tanımlamasıyla systemd aracının bu
zamanlanmış görevi sistem başlatıldıktan **1 dakika sonra** tetiklemesi
gerektiği belirtiyor. Eğer anında geçerli olması gerekiyorsa **0min**
şeklinde de tanımlanabilir.

Tanımlamak için **`YYYY-MM-DD HH:MM:SS`** modeli kullanıyor.

Yani: `Yıl-Ay-Gün Saat:Dakika:Saniye` şeklinde tanımlayabiliyoruz.

Ben örnek olarak 30 saniyede bir çalıştırılacak şekilde zamanladım.
Fakat daha net anlaşılması için birkaç farklı tanımlamayı örnekleyecek
olursak:

Spesifik bir tarih için, örneğin 2023 yılının 12. ayının 1. gününde
23.59 da çalışması için:

``` {.ini}
OnCalendar=2023-12-01 23:59:00
```

Her gün saat 9.30 da çalışması için:

``` {.ini}
OnCalendar=*-*-* 09:30:00
```

Her gün sabah 12 ve akşam 12 de çalışması için:

``` {.ini}
OnCalendar=*-*-* 12:00:00
OnCalendar=*-*-* 00:00:00
```

Her saat çalışması için:

İki saatte bir çalışması için

``` {.ini}
OnCalendar=*-*-* 00/2:00:00
```

Buradaki taksim işaretinden sonraki sayı, tekrar edecek olan sayının
katlarını belirtiyor. Bu sayede 00'dan başlayıp 2'şer şer artarak 2
saatte bir çalıştırılmış olacak.

Her dakika çalıştırmak için:

5 dakikadaki bir çalıştırmak için:

``` {.ini}
OnCalendar=*-*-* *:00/5:00
```

20 saniyede bir çalıştırmak için:

``` {.ini}
OnCalendar=*-*-* *:*:00/20
```

Pazartesiden cumaya her saat çalıştırmak için:

``` {.ini}
OnCalendar=Mon..Fri *-*-* *:00:00
```

Yalnızca hafta sonları 6 saatte bir çalıştırmak için:

``` {.ini}
OnCalendar=Sat,Sun *-*-* 00/6:00:00
```

Yalnızca pazartesi çarşamba ve cuma günleri her saat başında çalıştırmak
için:

``` {.ini}
OnCalendar=Mon,Wed,Fri *-*-* *:00:00
```

Yılın ilk altı ayında 10 günde bir kez çalıştırmak için:

``` {.ini}
OnCalendar=Jan..Jun/10 00:00:00
```

Liste bu şekilde uzar gider. Tanımlama aşamasında emin olamazsanız,
interneti kullanabilirsiniz. Zaten sıklıkla zamanlanmış görevler
tanımlamayacağınız için hatırlamamanız veya karıştırmanız olağan.

Zamanlanmış görevi timer birimi olarak tanımladıktan sonra, çalışması
için aktifleştirmemiz gerek. Bunun için de
`systemctl enable zaman.timer` komutunu kullanıyoruz.

``` {.swift}
┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl enable zaman.timer 
Created symlink /etc/systemd/system/multi-user.target.wants/zaman.timer → /lib/systemd/system/zaman.timer.

┌──(taylan㉿linuxdersleri)-[~]
└─$ systemctl status zaman.timer                                                                                                                            
○ zaman.timer - zaman.service için zamanlanmış görev tanımı
     Loaded: loaded (/lib/systemd/system/zaman.timer; enabled; vendor preset: enabled)
     Active: inactive (dead)
    Trigger: n/a
   Triggers: ● zaman.service
```

zaman.timer birimi de multi-user.target birimine sembolik linkle dahil
edildiği için biz devredışı bırakana kadar sistem başlangıcında otomatik
olarak başlatılıyor olacak. Ayrıca `status` komutunun çıktısında
gördüğünüz gibi tanımladığım "zaman.timer" zamanlanmış görevi
"zaman.service" servisini tetikleyecek şekilde aktif olarak çalışıyor.
Ve sistem başlangıcından 1 dakika sonra da her 30 saniyede bir çalışmaya
devam edecek.

İşte zamanlanmış görev tanımlamak da bu kadar kolay.

Anlatım boyunca tekrar tekrar dile getirdiğim üzere, elbette systemd
aracının tüm özellikleri ve kullanım detayları bu bölümde bahsetmiş
olduklarımdan ibaret değil. Fakat temel sistem yönetimi kapsamında
servis yönetimi için bu kadarlık bilgi yeterli. Özellikle
konfigürasyonlar söz konusu olduğunda sıklıkla yardım sayfalarından ve
internetteki kaynaklardan yardım almamız da son derece doğal, en azından
ben öyle yapıyorum :) Yardım sayfalarını biraz kurcalayacak olursanız,
ne kadar geniş çaplı bilgi birikimi olduğunu bizzat görebilirsiniz.

Okundu Olarak İşaretle

##### 📮 Hata, eksik ve öneri bildirimlerinizi [buradan](https://www.linuxdersleri.net/bildirim.html) iletebilirsiniz.
